/*
 *  tonnetz.c
 *
 * Copyright (C) 2010-2022 Andrea Agostini and Daniele Ghisi
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License
 * as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 *
 */

/**
	@file
	tonnetz.c
	
	@name 
	bach.tonnetz
	
	@realname 
	bach.tonnetz

	@type
	object
	
	@module
	bach

	@author
	bachproject
	
	@digest 
	Pitch space lattice
	
	@description
	Lattice diagram representing the (diatonic or chromatic) space of pitches,
	generated by two intervals or via an equation.
	Each point can also have a velocity, and points can be
	selected to form chords.
	
	@discussion
	<o>bach.tonnetz</o> implement the Tonnetz, which is a concept
	originally developed by Leonard Euler, and then subsequentely
	used by Riemannian music theory. 	
	
	@category
	bach, bach objects, bach set theory, bach interface, U/I

	@keywords
	tonnetz, interval, lattice, hexagone, triad, generator, just intonation, 
	rotate, shift, pitch-class, set, coordinate, modulo, microtone, select
	
	@palette
	YES
	
	@palette category
	bach, bach objects, bach set theory, bach interface

	@seealso
	bach.circle
	
	@owner
	Daniele Ghisi
*/


#include "math/llll_settheory.h"
#include "notation/notation.h"
#include "graphics/bach_graphics.h"
#include "ext.h"
#include "ext_obex.h"
#include "jpatcher_api.h"
#include "jgraphics.h"
#include "ext_globalsymbol.h"
#include "ext_systhread.h"
#include "ext_common.h"
#include "ext_critical.h"
#include <stdio.h>
#include <locale.h>
#include "ext_strings.h"
#include "ext_boxstyle.h"

#define CONST_MAX_POINTS 1000
#define CONST_PIXEL_TOLERANCE_CLICK 4
#define CONST_DRAGGING_MODULO 20.
#define CONST_DRAGGING_VELOCITY 1.
#define CONST_DEFAULT_VELOCITY 100
#define CONST_MIN_VELOCITY 1
#define CONST_MAX_VELOCITY 127
#define CONST_MAX_POINT_NAMES 1000

#define TONNETZ_MAX_ZOOM 1000
#define TONNETZ_MIN_ZOOM 20

#define SQRT_3 1.732050808

// velocities array
#define CONST_MAX_VELOCITY_POINTS_PER_DIMENSION 100
#define CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET 50

#define ARE_COORD_IN_VEL_MATRIX(coord1, coord2)  (CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET + (coord1) > 0 && CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET + (coord1) < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION - 1 && \
													CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET + (coord2) > 0 && CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET + (coord2) < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION - 1)
#define TONNETZ_VEL_OFFSET(coord)	(CLAMP(CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET + (coord), 0, CONST_MAX_VELOCITY_POINTS_PER_DIMENSION - 1))



#define TONNETZ_COMPUTE_FREQ_RATIOS true	///< Do we also compute frequency ratios? This makes creation of static tonnetz slower



typedef struct _tonnetz_pt_coord
{
	long		coord1; // horizontal coordinate
	long		coord2; // 60° ccw coordinate
} t_tonnetz_pt_coord;

typedef struct _tonnetz_pt_cubic_coord
{
	long		coord1; // horizontal coordinate
	long		coord2; // 60° ccw coordinate
	long		coord3; // 120° ccw coordinate
} t_tonnetz_pt_cubic_coord;
// seealso: http://www.redblobgames.com/grids/hexagons/#rotation


typedef enum _tonnetz_label_styles
{
	k_TONNETZ_LABEL_NOTE_NAMES = 0,
	k_TONNETZ_LABEL_NOTE_NAMES_WITH_OCTAVE = 1,
	k_TONNETZ_LABEL_CENTS = 2,
	k_TONNETZ_LABEL_DIATONIC_INTERVALS = 3,
	k_TONNETZ_LABEL_FREQUENCY_RATIOS = 4,
	k_TONNETZ_LABEL_COORDINATES = 5
} e_tonnetz_label_styles;

typedef enum _tonnetz_modes
{
	k_TONNETZ_MODE_JUST_INTONATION_INFINITE_LATTICE = 0,
	k_TONNETZ_MODE_EQUALLY_TEMPERED_INFINITE_LATTICE = 1,
	k_TONNETZ_MODE_EQUALLY_TEMPERED_WRAPPED_LATTICE = 2,
	k_TONNETZ_MODE_PITCH_SURFACE = 3,
} e_tonnetz_modes;

typedef enum _tonnetz_add_point_modes
{
	k_TONNETZ_MATCH_MODE_ALL_MATCHES = 0,
	k_TONNETZ_MATCH_MODE_MOST_CENTRAL_MATCH = 1,
	k_TONNETZ_MATCH_MODE_NEAREST_MELODICAL_MATCH = 2,
	k_TONNETZ_MATCH_MODE_SMART = 3,
} e_tonnetz_add_point_modes;


typedef struct _tonnetz // [bach.tonnetz] structure
{
	t_llllobj_jbox			j_box; // root object

	t_jrgba					j_textcolor;
	t_jrgba					j_bgcolor;
	t_jrgba					j_bordercolor;
	t_jrgba					j_pointbordercolor;
	t_jrgba					j_pointinnercolor;
	t_jrgba					j_selectedpointbordercolor;
	t_jrgba					j_selectedpointinnercolor;
	t_jrgba					j_selectedtriangleinnercolor;
	t_jrgba					j_tonnetzcolor;
	t_jrgba					j_tonnetzinnercolor;
	t_jrgba					j_linecolor;
	double					lattice_step;
	
	char					j_has_focus;
	char					show_focus;

	// changed from e_note_names_styles or vc++ complains
	e_note_names_styles		note_names_style;
	long					middleC_octave;

	char					need_refresh_tonnetz_coordinates;

	char					mode;
	char					match_mode;
	char					label_style;
	char					output_note_names;
	
	// surface mode
	t_symbol				*surface_eq_as_sym;
	t_lexpr					*surface_lexpr;
	
	char					save_data_with_patcher;
	char					autoclear;
	char					echo;
	
	t_tonnetz_diatonic_interval diatonic_center;
    t_pitch                     pitch_center;
	t_llll                      *diatonic_center_as_llll;
//	t_tonnetz_diatonic_interval         generators[2];
    t_tonnetz_diatonic_interval generators[2];
	t_llll                      *generators_as_llll;
	
	char					purely_diatonic;
	t_llll					*purely_diatonic_scale_intervals;
	t_llll					*purely_diatonic_scale_freq_ratios;
	double					purely_diatonic_scale_modulo;

	t_llll					*tonnetz_data;
	char					*velocities[CONST_MAX_VELOCITY_POINTS_PER_DIMENSION];
	t_llllelem				**tonnetz_elems[CONST_MAX_VELOCITY_POINTS_PER_DIMENSION];
	
	char					only_return_inscreen_coordinates;
	
	long					num_selected_points;
	long					modulo;
	
	double					zoom_percentage; // zoom as a percentage (default = 100)
	double					zoom; // zoom as factor (default = 1.)
	char					velocity_handling;
	char					auto_reduce;
	double					point_radius;
	double					inset;
	double					tonnetz_line_width;
	double					point_line_width;
	double					selected_line_width;
	
	t_pt					mouseover_pt;
	t_pt					mousedrag_pt;
	t_tonnetz_pt_coord		mousedown_tonnetz_pt;
	char					mouse_is_down;
	int						j_mouse_cursor;					///< The active mouse cursor, one of the #e_mouse_cursors
	
	long					is_velocity_dragging; // keeps track of the index of the mousedown point (-1 if none)
	double					dragging_velocity;

	t_tonnetz_pt_coord		last_selected_pt;
	t_pt					center;			  // point corresponding to the actual center of the tonnetz
	double					center_offset[2];
	t_pt					graphical_center; // graphical center of the tonnetz (i.e. width/2, height/2)
	
	char					rebuild; 
	char					creating_new_obj;

	void					*n_proxy[6];
	long					n_in;

	// preset attributes
	t_atom		*preset_av;		
	long		preset_ac;		
	
	
	t_systhread_mutex		c_mutex;

	long					circle_layer_side;

} t_tonnetz;


// global class pointer variable
t_class	*s_tonnetz_class = NULL;


DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_tonnetz, generators_as_llll, tonnetz_getattr_generators)
DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_tonnetz, purely_diatonic_scale_intervals, tonnetz_getattr_scaleintervals);
DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_tonnetz, purely_diatonic_scale_freq_ratios, tonnetz_getattr_scalefreqratios);

// functions
void tonnetz_inletinfo(t_tonnetz *x, void *b, long a, char *t);
void tonnetz_assist(t_tonnetz *x, void *b, long m, long a, char *s);

void tonnetz_free(t_tonnetz *x);


void tonnetz_focusgained(t_tonnetz *x, t_object *patcherview);
void tonnetz_focuslost(t_tonnetz *x, t_object *patcherview);
void tonnetz_mousedown(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers);
void tonnetz_mousemove(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers);
void tonnetz_mousewheel(t_tonnetz *x, t_object *view, t_pt pt, long modifiers, double x_inc, double y_inc);
void tonnetz_mouseup(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers);
void tonnetz_mousedrag(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers);
long tonnetz_key(t_tonnetz *x, t_object *patcherview, long keycode, long modifiers, long textcharacter);
long tonnetz_oksize(t_tonnetz *x, t_rect *newrect);

t_tonnetz* tonnetz_new(t_symbol *s, long argc, t_atom *argv);

void invalidate_static_layers_and_repaint(t_tonnetz *x);
void tonnetz_paint(t_tonnetz *x, t_object *view);

void tonnetz_anything(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv);
void tonnetz_dump(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv);
void tonnetz_int(t_tonnetz *x, t_atom_long num);
void tonnetz_float(t_tonnetz *x, double num);
void tonnetz_bang(t_tonnetz *x);

void calculate_static_tonnetz(t_tonnetz *x);

void get_radius_and_center(t_tonnetz *x, t_object *patcherview, double *radius, double *center_x, double *center_y);

void rotate_tonnetz_selected_points(t_tonnetz *x, char clockwise);
void translate_tonnetz_selected_points(t_tonnetz *x, long delta_coord1, long delta_coord2);

t_max_err tonnetz_setattr_diatonic_center(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_generators(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_modulo(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_side(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_mode(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_zoom(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_purelydiatonic(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_scaleintervals(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_scalefreqratios(t_tonnetz *x, t_object *attr, long ac, t_atom *av);
t_max_err tonnetz_setattr_surface(t_tonnetz *x, t_object *attr, long ac, t_atom *av);

void diatonic_interval_to_notename(t_tonnetz *x, t_tonnetz_diatonic_interval interval, char also_put_octave, char **buf);
t_llll *tonnetz_node_as_llllelem_to_point_info_for_output(t_tonnetz *x, t_llllelem *node, t_symbol *router);

t_tonnetz_pt_cubic_coord to_cubic_coord(t_tonnetz_pt_coord coord);
t_tonnetz_pt_coord from_cubic_coord(t_tonnetz_pt_cubic_coord coord);
long manhattan_distance(t_tonnetz_pt_coord coord1, t_tonnetz_pt_coord coord2);

void tonnetz_preset(t_tonnetz *x);
void tonnetz_begin_preset(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv);
void tonnetz_restore_preset(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv);
void tonnetz_end_preset(t_tonnetz *x);
void get_selected_points_data_as_llll(t_tonnetz *x, t_llll **midicents, t_llll **pitchclasses, 
									  t_llll **diatonic_intervals, t_llll **nodes_coordinates, t_llll **velocities, char note_get_names);
t_llllelem *coordinates_to_node_lattice_llllelem(t_tonnetz *x, t_llll *coordinates);

double purely_diatonic_interval_to_midicents(t_tonnetz *x, t_tonnetz_diatonic_interval purely_diatonic_interval);
void purely_diatonic_interval_to_notename(t_tonnetz *x, t_tonnetz_diatonic_interval interval, char also_put_octave, char **buf);
t_rational purely_diatonic_interval_to_freqratio(t_tonnetz *x, t_tonnetz_diatonic_interval purely_diatonic_interval);

void tonnetz_jsave(t_tonnetz *x, t_dictionary *d);

DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_tonnetz, diatonic_center_as_llll, tonnetz_getattr_diatonic_center);




char is_tonnetz_data_elem_in_screen(t_tonnetz *x, t_llllelem *elem)
{
	if (hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_tail->l_hatom) > 0)
		return 1;
	return 0;
}


t_pitch tonnetz_get_pitch_from_diatonic_and_chromatic_steps(t_tonnetz *x, long diat, long chro, char steps_wr_to_middle_C)
{
    if (steps_wr_to_middle_C) {
        diat += 7 * 5;
        chro += x->modulo * 5;
    }
    
    t_rational mc = chro * genrat(1200,x->modulo);
    t_pitch temp = t_pitch(positive_mod(diat, 7), long2rat(0), integer_div_round_down(diat, 7));
    t_rational temp_mc = temp.toMC();
    return t_pitch(positive_mod(diat, 7), genrat(mc - temp_mc, 200), integer_div_round_down(diat, 7));
}

t_tonnetz_diatonic_interval tonnetz_get_diatonic_interval_from_pitch(t_tonnetz *x, t_pitch pitch)
{
    t_tonnetz_diatonic_interval dinterval;
    dinterval.diatonic_steps = pitch.toSteps();
    dinterval.chromatic_steps = round((double)(pitch.toMC()/genrat(1200, x->modulo)));
    dinterval.frequency_ratio = long2rat(1);
    dinterval.user_defined_ratio = 0;
    return dinterval;
}

t_max_err tonnetz_setattr_diatonic_center(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
    t_llll *args = llllobj_parse_llll((t_object *)x, LLLL_OBJ_UI, NULL, ac, av, LLLL_PARSE_RETAIN);
	if (args) {
		if (args->l_size == 1) {
			// single element
            if (hatom_gettype(&args->l_head->l_hatom) == H_PITCH) {
                x->pitch_center = hatom_getpitch(&args->l_head->l_hatom);
            } else if (is_hatom_number(&args->l_head->l_hatom)) {
                x->pitch_center = t_pitch::fromMC(hatom_getdouble(&args->l_head->l_hatom), x->modulo/6, k_ACC_AUTO);
                
/*				long screen_mc;
				t_rational screen_acc;
				mc_to_screen_approximations_do(x->modulo/6, k_ACCIDENTALS_AUTO, atom_getlong(av), &screen_mc, &screen_acc, NULL, NULL);
				x->diatonic_center = screen_midicents_and_accidental_to_diatonic_interval(screen_mc, screen_acc, x->modulo);
				x->diatonic_center_as_long_array[0] = x->diatonic_center.diatonic_steps;
				x->diatonic_center_as_long_array[1] = x->diatonic_center.chromatic_steps;
			} else if (atom_gettype(av) == A_SYM) {
				// note name
				x->diatonic_center = notename_to_diatonic_interval(x->middleC_octave, atom_getsym(av)->s_name, x->modulo);
				x->diatonic_center_as_long_array[0] = x->diatonic_center.diatonic_steps;
				x->diatonic_center_as_long_array[1] = x->diatonic_center.chromatic_steps; */
			}
		} else if (args->l_size == 2) {
            // backward compatibility!!!
			if (hatom_gettype(&args->l_head->l_hatom) == H_LONG && hatom_gettype(&args->l_head->l_next->l_hatom) == H_LONG) {
                long a[2];
                a[0] = hatom_getlong(&args->l_head->l_hatom);
                a[1] = hatom_getlong(&args->l_head->l_next->l_hatom);
                x->pitch_center = tonnetz_get_pitch_from_diatonic_and_chromatic_steps(x, a[0], a[1], true);
			}
		}
        
        x->diatonic_center = tonnetz_get_diatonic_interval_from_pitch(x, x->pitch_center - t_pitch::middleC);
        
        llll_clear(x->diatonic_center_as_llll);
        llll_appendpitch(x->diatonic_center_as_llll, x->pitch_center);
	}
    llll_free(args);
    
	if (!x->creating_new_obj)
		calculate_static_tonnetz(x);
	
    invalidate_static_layers_and_repaint(x);
	return MAX_ERR_NONE;
}

t_rational diatonic_interval_to_frequency_ratio(t_tonnetz *x, t_tonnetz_diatonic_interval interval)
{
	long dia = interval.diatonic_steps;
	long chr = interval.chromatic_steps;
	
	// retrieving the octave
	long octave = (long)floor(dia/7.);
	dia -= 7 * octave;
	chr -= x->modulo * octave;
	
	chr = round((double)chr / (x->modulo / 12.));
	
	t_rational rapp;
	const t_rational augmented_unison = genrat(2187, 2048); 
	switch (dia) {
		case 0:
			rapp = rat_long_pow(augmented_unison, chr);
			break;
		case 1:
			if (chr == 2)
				rapp = genrat(9, 8);
			else if (chr == 1)
				rapp = genrat(16, 15);
			else if (chr > 2)
				rapp = rat_rat_prod(genrat(9, 8), rat_long_pow(augmented_unison, chr - 2));
			else
				rapp = rat_rat_prod(genrat(16, 15), rat_long_pow(augmented_unison, chr - 1));
			break;
		case 2:
			if (chr == 4)
				rapp = genrat(5, 4);
			else if (chr == 3)
				rapp = genrat(6, 5);
			else if (chr > 4)
				rapp = rat_rat_prod(genrat(5, 4), rat_long_pow(augmented_unison, chr - 4));
			else
				rapp = rat_rat_prod(genrat(6, 5), rat_long_pow(augmented_unison, chr - 3));
			break;
		case 3:
			rapp = rat_rat_prod(genrat(4, 3), rat_long_pow(augmented_unison, chr - 5));
			break;
		case 4:
			rapp = rat_rat_prod(genrat(3, 2), rat_long_pow(augmented_unison, chr - 7));
			break;
		case 5:
			if (chr == 9)
				rapp = genrat(5, 3);
			else if (chr == 8)
				rapp = genrat(8, 5);
			else if (chr > 9)
				rapp = rat_rat_prod(genrat(5, 3), rat_long_pow(augmented_unison, chr - 9));
			else
				rapp = rat_rat_prod(genrat(8, 5), rat_long_pow(augmented_unison, chr - 8));
			break;
		case 6:
			if (chr == 11)
				rapp = genrat(15, 8);
			else if (chr == 10)
				rapp = genrat(9, 5);
			else if (chr > 2)
				rapp = rat_rat_prod(genrat(15, 8), rat_long_pow(augmented_unison, chr - 11));
			else
				rapp = rat_rat_prod(genrat(9, 5), rat_long_pow(augmented_unison, chr - 10));
			break;
		default:
			rapp = long2rat(1);
			break;
	}
	
	return rat_rat_prod(rapp, rat_long_pow(long2rat(2), octave));
}

t_max_err tonnetz_setattr_modulo(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		long old_modulo = x->modulo;
		x->modulo = atom_getlong(av);
		if (!x->generators[0].user_defined_ratio)
			x->generators[0].frequency_ratio = diatonic_interval_to_frequency_ratio(x, x->generators[0]);
		if (!x->generators[1].user_defined_ratio)
			x->generators[1].frequency_ratio = diatonic_interval_to_frequency_ratio(x, x->generators[1]);

		if (!x->creating_new_obj)
			calculate_static_tonnetz(x);
		
        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}

t_max_err tonnetz_setattr_side(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		x->lattice_step = atom_getfloat(av);
		x->need_refresh_tonnetz_coordinates = true;
        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}


t_max_err tonnetz_setattr_purelydiatonic(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		long old_val = x->purely_diatonic;
		x->purely_diatonic = atom_getlong(av);
		if (true) { //!x->creating_new_obj) {
			long gen_ac;
			t_atom *gen_av = NULL;

			if (old_val && !x->purely_diatonic) {
				t_llll *ll = llll_get();
				llll_appendllll(ll, long_couple_to_llll(x->generators[0].diatonic_steps, x->generators[0].chromatic_steps), 0, WHITENULL_llll);
				llll_appendllll(ll, long_couple_to_llll(x->generators[1].diatonic_steps, x->generators[1].chromatic_steps), 0, WHITENULL_llll);
				gen_ac = llll_deparse(ll, &gen_av, 0, 0);
				llll_free(ll);
			} else {
				gen_ac = llll_deparse(x->generators_as_llll, &gen_av, 0, 0);
			}
			tonnetz_setattr_generators(x, NULL, gen_ac, gen_av);
			bach_freeptr(gen_av);
		}
		object_attr_setdisabled((t_object *)x, gensym("scaleintervals"), x->purely_diatonic == 0);
		object_attr_setdisabled((t_object *)x, gensym("scalefreqratios"), x->purely_diatonic == 0);

		if (!x->creating_new_obj)
			calculate_static_tonnetz(x);
		
        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}

void check_scale_llll_length(t_tonnetz *x)
{
	if (x->purely_diatonic_scale_freq_ratios->l_size > x->purely_diatonic_scale_intervals->l_size)
		llll_free(llll_slice(x->purely_diatonic_scale_freq_ratios, x->purely_diatonic_scale_intervals->l_size));
	else {
		long i;
		for (i = x->purely_diatonic_scale_freq_ratios->l_size; i < (long)x->purely_diatonic_scale_intervals->l_size; i++)
			llll_appendrat(x->purely_diatonic_scale_freq_ratios, long2rat(1), 0, WHITENULL_llll);
	}
}

t_max_err tonnetz_setattr_scaleintervals(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac == 0 || av) {
		t_llll *ll;
		if ((ll = llllobj_parse_llll((t_object *) x, LLLL_OBJ_VANILLA, NULL, ac, av, LLLL_PARSE_CLONE))) {
			if (ll->l_size > 0) {

				if (ll->l_size == 1 && ll->l_depth == 1 && hatom_gettype(&ll->l_head->l_hatom) == H_SYM) {
					t_symbol *sym = hatom_getsym(&ll->l_head->l_hatom);
					llll_free(ll);
					ll = llll_from_text_buf(sym->s_name);
				}
				
				llll_free(x->purely_diatonic_scale_intervals);
				x->purely_diatonic_scale_modulo = llll_sum_of_doubles_llll(ll);
				x->purely_diatonic_scale_intervals = ll;
				
				check_scale_llll_length(x);

                if (!x->creating_new_obj)
                    calculate_static_tonnetz(x);
                
                invalidate_static_layers_and_repaint(x);

            } else
				llll_free(ll);
		}
	}
	return MAX_ERR_NONE;
}

t_max_err tonnetz_setattr_scalefreqratios(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac == 0 || av) {
		t_llll *ll;
		if ((ll = llllobj_parse_llll((t_object *) x, LLLL_OBJ_VANILLA, NULL, ac, av, LLLL_PARSE_CLONE))) {

			if (ll->l_size == 1 && ll->l_depth == 1 && hatom_gettype(&ll->l_head->l_hatom) == H_SYM) {
				t_symbol *sym = hatom_getsym(&ll->l_head->l_hatom);
				llll_free(ll);
				ll = llll_from_text_buf(sym->s_name);
			}

			llll_free(x->purely_diatonic_scale_freq_ratios);
			x->purely_diatonic_scale_freq_ratios = ll;
			check_scale_llll_length(x);
            
            if (!x->creating_new_obj)
                calculate_static_tonnetz(x);
            
            invalidate_static_layers_and_repaint(x);
		}
	}
	return MAX_ERR_NONE;
}


t_max_err tonnetz_setattr_zoom(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		x->zoom_percentage = CLAMP(atom_getfloat(av), TONNETZ_MIN_ZOOM, TONNETZ_MAX_ZOOM);
		x->zoom = x->zoom_percentage / 100.;
		x->need_refresh_tonnetz_coordinates = true;
        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}

t_max_err tonnetz_setattr_offset(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		x->center_offset[0] = atom_getfloat(av);
		if (ac > 1 && is_atom_number(av+1)) 
			x->center_offset[1] = atom_getfloat(av+1);
		else
			x->center_offset[1] = 0.;
		x->need_refresh_tonnetz_coordinates = true;
        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}

t_max_err tonnetz_setattr_mode(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0 && is_atom_number(av)) {
		x->mode = atom_getlong(av);

		if (!x->creating_new_obj)
			calculate_static_tonnetz(x);

        invalidate_static_layers_and_repaint(x);
		object_attr_setdisabled((t_object *)x, gensym("surface"), x->mode != 3);
	}
	return MAX_ERR_NONE;
}

t_max_err tonnetz_setattr_surface(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	if (ac > 0) {
//		t_atom *av_temp = NULL;
//		long ac_temp;
		char *text = NULL;
		const char *subs[] = {"x","y"};		
		long size;
		
		atom_gettext_debug(ac, av, &size, &text, OBEX_UTIL_ATOM_GETTEXT_SYM_NO_QUOTE);
//		atom_setparse(&ac_temp, &av_temp, text);
		x->surface_eq_as_sym = gensym(text);

		lexpr_free(x->surface_lexpr);

		if (!(x->surface_lexpr = lexpr_new(ac, av, 2, subs, (t_object *) x)))
//		if (!(x->surface_lexpr = lexpr_new(ac_temp, av_temp, 2, subs)))
            if (text && text[0] != 0)
                object_error((t_object *)x, "Error: wrong surface expression introduced!");
		
		bach_freeptr(text);
//		bach_freeptr(av_temp);

		if (!x->creating_new_obj)
			calculate_static_tonnetz(x);

        invalidate_static_layers_and_repaint(x);
	}
	return MAX_ERR_NONE;
}


t_max_err tonnetz_setattr_generators(t_tonnetz *x, t_object *attr, long ac, t_atom *av)
{
	t_llll *ll;
	if (ac == 0 || av) {
		if ((ll = llllobj_parse_llll((t_object *) x, LLLL_OBJ_VANILLA, NULL, ac, av, LLLL_PARSE_RETAIN))) {
			t_llll *free_me;
			
			if (ll->l_size == 1 && ll->l_depth == 1 && hatom_gettype(&ll->l_head->l_hatom) == H_SYM) {
				t_symbol *sym = hatom_getsym(&ll->l_head->l_hatom);
				llll_free(ll);
				ll = llll_from_text_buf(sym->s_name);
			}
			
			
			char can_change_generators = true;
			if (ll && ll->l_head) {
				if (hatom_gettype(&ll->l_head->l_hatom) == H_LLLL) {
					t_llll *sub_ll = hatom_getllll(&ll->l_head->l_hatom);
					if (sub_ll->l_size < 2) {
						if ((!x->creating_new_obj && !x->purely_diatonic) || sub_ll->l_size < 1)
							can_change_generators = false;
					} else {
						if (!(hatom_gettype(&sub_ll->l_head->l_hatom) == H_LONG && 
							hatom_gettype(&sub_ll->l_head->l_next->l_hatom) == H_LONG))
							can_change_generators = false;
						else {
							if (sub_ll->l_size > 3)
								llll_free(llll_slice(sub_ll, 3));
						}
					}
				} else if (!is_hatom_number(&ll->l_head->l_hatom) && hatom_gettype(&ll->l_head->l_hatom) != H_PITCH){
					can_change_generators = false;
				}
				
				if (ll->l_head->l_next) {
					if (hatom_gettype(&ll->l_head->l_next->l_hatom) == H_LLLL) {
						t_llll *sub_ll = hatom_getllll(&ll->l_head->l_next->l_hatom);
						if (sub_ll->l_size < 2) {
							if ((!x->creating_new_obj && !x->purely_diatonic) || sub_ll->l_size < 1)
								can_change_generators = false;
						} else {
							if (!(hatom_gettype(&sub_ll->l_head->l_hatom) == H_LONG && 
								  hatom_gettype(&sub_ll->l_head->l_next->l_hatom) == H_LONG))
								can_change_generators = false;
							else {
								if (sub_ll->l_size > 3)
									llll_free(llll_slice(sub_ll, 3));
							}
						}
					} else if (!is_hatom_number(&ll->l_head->l_next->l_hatom) && hatom_gettype(&ll->l_head->l_next->l_hatom) != H_PITCH){
						can_change_generators = false;
					}
				} else {
					can_change_generators = false;
				}
			} else 
				can_change_generators = false;
			
			if (can_change_generators) {
				
				if (hatom_gettype(&ll->l_head->l_hatom) == H_LLLL) {
					x->generators[0].diatonic_steps = hatom_getlong(&hatom_getllll(&ll->l_head->l_hatom)->l_head->l_hatom);
					if (!x->purely_diatonic && hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next)
						x->generators[0].chromatic_steps = hatom_getlong(&hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next->l_hatom);
				} else {
                    if (hatom_gettype(&ll->l_head->l_hatom) == H_PITCH) {
                        x->generators[0] = tonnetz_get_diatonic_interval_from_pitch(x, hatom_getpitch(&ll->l_head->l_hatom));
                    } else {
                        long screen_mc;
                        t_rational screen_acc;
                        mc_to_screen_approximations_do(x->modulo / 6, k_ACCIDENTALS_AUTO, 6000 + hatom_getdouble(&ll->l_head->l_hatom), &screen_mc, &screen_acc, NULL, NULL);
                        x->generators[0] = screen_midicents_and_accidental_to_diatonic_interval(screen_mc, screen_acc, x->modulo);
                        
                    }
                }

				if (hatom_gettype(&ll->l_head->l_next->l_hatom) == H_LLLL) {
					x->generators[1].diatonic_steps = hatom_getlong(&hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_hatom);
					if (!x->purely_diatonic && hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next)
                        x->generators[1].chromatic_steps = hatom_getlong(&hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next->l_hatom);
                } else {
                    if (hatom_gettype(&ll->l_head->l_hatom) == H_PITCH) {
                        x->generators[1] = tonnetz_get_diatonic_interval_from_pitch(x, hatom_getpitch(&ll->l_head->l_next->l_hatom));
                    } else {
                        long screen_mc;
                        t_rational screen_acc;
                        mc_to_screen_approximations_do(x->modulo / 6, k_ACCIDENTALS_AUTO, 6000 + hatom_getdouble(&ll->l_head->l_next->l_hatom), &screen_mc, &screen_acc, NULL, NULL);
                        x->generators[1] = screen_midicents_and_accidental_to_diatonic_interval(screen_mc, screen_acc, x->modulo);
                    }
                }
				
				
                if (x->purely_diatonic) {
                    x->generators[0].frequency_ratio = x->generators[1].frequency_ratio = long2rat(1); // dummy
                    x->generators[0].user_defined_ratio = x->generators[1].user_defined_ratio = false;
                } else {
                    if (hatom_gettype(&ll->l_head->l_hatom) == H_LLLL &&
                        hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next && hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next->l_next &&
                        is_hatom_number(&hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next->l_next->l_hatom)) {
                        x->generators[0].frequency_ratio = hatom_getrational(&hatom_getllll(&ll->l_head->l_hatom)->l_head->l_next->l_next->l_hatom);
                        x->generators[0].user_defined_ratio = true;
                    } else {
                        x->generators[0].frequency_ratio = diatonic_interval_to_frequency_ratio(x, x->generators[0]);
                        x->generators[0].user_defined_ratio = false;
                    }
                    
                    if (hatom_gettype(&ll->l_head->l_next->l_hatom) == H_LLLL &&
                        hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next && hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next->l_next &&
                        is_hatom_number(&hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next->l_next->l_hatom)) {
                        x->generators[1].frequency_ratio = hatom_getrational(&hatom_getllll(&ll->l_head->l_next->l_hatom)->l_head->l_next->l_next->l_hatom);
                        x->generators[1].user_defined_ratio = true;
                    } else {
                        x->generators[1].frequency_ratio = diatonic_interval_to_frequency_ratio(x, x->generators[1]);
                        x->generators[1].user_defined_ratio = false; 
                    }				
                    
                }
				systhread_mutex_lock(x->c_mutex);
				free_me = x->generators_as_llll;
				llll_free(ll);
				
				x->generators_as_llll = llll_get();
/*				t_llll *firstgen = llll_get();
				t_llll *secondgen = llll_get();
				llll_appendlong(firstgen, x->generators[0].diatonic_steps, 0, WHITENULL_llll);
				if (!x->purely_diatonic) {
					llll_appendlong(firstgen, x->generators[0].chromatic_steps, 0, WHITENULL_llll);
					if (x->generators[0].user_defined_ratio)
						llll_appendrat(firstgen, x->generators[0].frequency_ratio, 0, WHITENULL_llll);
				}
				llll_appendlong(secondgen, x->generators[1].diatonic_steps, 0, WHITENULL_llll);
				if (!x->purely_diatonic) {
					llll_appendlong(secondgen, x->generators[1].chromatic_steps, 0, WHITENULL_llll);
					if (x->generators[1].user_defined_ratio)
						llll_appendrat(firstgen, x->generators[1].frequency_ratio, 0, WHITENULL_llll);
				}
				llll_appendllll(x->generators_as_llll, firstgen, 0, WHITENULL_llll);
				llll_appendllll(x->generators_as_llll, secondgen, 0, WHITENULL_llll); */
                
                if (x->purely_diatonic) {
                    t_llll *ll1 = llll_get();
                    t_llll *ll2 = llll_get();
                    llll_appendlong(ll1, x->generators[0].diatonic_steps);
                    llll_appendlong(ll2, x->generators[1].diatonic_steps);
                    llll_appendllll(x->generators_as_llll, ll1);
                    llll_appendllll(x->generators_as_llll, ll2);
                } else {
                    llll_appendpitch(x->generators_as_llll, tonnetz_get_pitch_from_diatonic_and_chromatic_steps(x, x->generators[0].diatonic_steps, x->generators[0].chromatic_steps, false));
                    llll_appendpitch(x->generators_as_llll, tonnetz_get_pitch_from_diatonic_and_chromatic_steps(x, x->generators[1].diatonic_steps, x->generators[1].chromatic_steps, false));
                }
				systhread_mutex_unlock(x->c_mutex);
				llll_free(free_me);
			} else {
				llll_free(ll);
			}

			if (!x->creating_new_obj)
				calculate_static_tonnetz(x);

            invalidate_static_layers_and_repaint(x);
		}
	}
	return MAX_ERR_NONE;
}

void tonnetz_bang(t_tonnetz *x)
{
	if (x->j_box.l_rebuild == 1 || proxy_getinlet((t_object *) x) != 0)
		tonnetz_anything(x, _sym_bang, 0, NULL);
}

void tonnetz_dumpselection(t_tonnetz *x)
{
	t_llll *lllls_to_output = llll_get();
	long i, j;
	t_llllelem *elem;
	
	systhread_mutex_lock(x->c_mutex);

	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
		for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
			if (x->velocities[i][j] > 0) {
				t_llll *coord = long_couple_to_llll(i - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET, j - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET);
				t_llllelem *getinfo = coordinates_to_node_lattice_llllelem(x, coord);
				t_llll *this_output = tonnetz_node_as_llllelem_to_point_info_for_output(x, getinfo, gensym("node"));
				llll_appendobj(lllls_to_output, this_output, 0, WHITENULL_llll);
				llll_free(coord);
			}
	
	systhread_mutex_unlock(x->c_mutex);
	
	for (elem = lllls_to_output->l_head; elem; elem = elem->l_next) {
		t_llll *this_output = (t_llll *)hatom_getobj(&elem->l_hatom);
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 6, this_output);
		llll_free(this_output);
	}
	
	llll_free(lllls_to_output);
	
}

void tonnetz_begin_preset(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv)
{
	x->preset_ac = atom_getlong(argv) ;
	x->preset_av = (t_atom *)bach_newptr(x->preset_ac * sizeof(t_atom));
	
	// could allocate memory here etc.
	//	post("begin_preset %ld values will be arriving",x->r_ob.preset_ac);
}


void tonnetz_restore_preset(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv)
{
	long start, size;
	
	start = atom_getlong(argv);
	size = atom_getlong(argv + 1);
	//	post("restore_preset start %ld size %ld", start,size);
	
	sysmem_copyptr(argv+2, x->preset_av+start, size*sizeof(t_atom));
}

void tonnetz_end_preset(t_tonnetz *x)
{
	//	post("end_preset received");
	tonnetz_anything(x, NULL, x->preset_ac,x->preset_av);
	bach_freeptr(x->preset_av);
}

void tonnetz_preset(t_tonnetz *x){
	t_atom temp[256];
	void *buf;
	long i, index, size;
	char wrote = false, begin = true, done = false;
	
	t_llll *selected_nodes_coordinates = NULL;
	get_selected_points_data_as_llll(x, NULL, NULL, NULL, &selected_nodes_coordinates, NULL, x->output_note_names);
	llll_prependsym(selected_nodes_coordinates, gensym("setfromcoordinates"), 0, WHITENULL_llll);
	
	// 1. we deparse the list
	t_atom *av = NULL, *this_av = NULL;
	long ac = llll_deparse(selected_nodes_coordinates, &av, 0, /* LLLL_D_FLOAT64 | */ LLLL_D_QUOTE); //offset 0
	this_av = av;
	
	// 2. We fill the binbuf
	buf = gensym("_preset")->s_thing; 
	if (!buf)	// no preset object
		return;
	
	index = 0;
	while (!done) {
		i = index;
		size = ac - index;
		if (size > 250)
			size = 250;
		else	// you are at the end
			done = true;
		
		sysmem_copyptr(this_av, temp+5, 250*sizeof(t_atom));
		
		if (size) {
			atom_setobj(temp, x);
			atom_setsym(temp + 1, ob_sym(x));
			if (begin) {
				atom_setsym(temp + 2, gensym("begin_preset"));
				atom_setlong(temp + 3, ac);
				binbuf_insert(buf, NULL, 4, temp);
				begin = false;
			}
			atom_setsym(temp + 2, gensym("restore_preset"));
			atom_setlong(temp + 3, index);
			atom_setlong(temp + 4, size);
			binbuf_insert(buf, NULL, size + 5, temp);
			wrote = true;
		}
		index += size;
		this_av += 250;
	}
	if (wrote) {
		atom_setobj(temp, x);
		atom_setsym(temp + 1, ob_sym(x));
		atom_setsym(temp + 2, gensym("end_preset"));
		binbuf_insert(buf, NULL, 3, temp);
	}
	
	if (av) bach_freeptr(av);
}

void tonnetz_jsave(t_tonnetz *x, t_dictionary *d)
{
	if (x->save_data_with_patcher){
		if (x->j_box.l_dictll) {
			llll_store_in_dictionary(x->j_box.l_dictll, d, "whole_tonnetz_data", NULL);
		} else {
			t_llll *selected_nodes_coordinates = NULL;
			get_selected_points_data_as_llll(x, NULL, NULL, NULL, &selected_nodes_coordinates, NULL, x->output_note_names);
			llll_prependsym(selected_nodes_coordinates, gensym("setfromcoordinates"), 0, WHITENULL_llll);

			llll_store_in_dictionary(selected_nodes_coordinates, d, "whole_tonnetz_data", NULL);
			llll_free(selected_nodes_coordinates);
		}
	} 
}




void C74_EXPORT ext_main(void *moduleRef){
	t_class *c;
	
	common_symbols_init();
	llllobj_common_symbols_init();

	if (llllobj_check_version(bach_get_current_llll_version()) || llllobj_test()) {
		error("bach: bad installation");
		return;
	}

    CLASS_NEW_CHECK_SIZE(c, "bach.tonnetz", 
						(method)tonnetz_new,
						(method)tonnetz_free,
						sizeof(t_tonnetz),
						(method)NULL,
						A_GIMME,
						0L);
	
	c->c_flags |= CLASS_FLAG_NEWDICTIONARY;

//	jbox_initclass(c, JBOX_COLOR | JBOX_FIXWIDTH | JBOX_FONTATTR);
	jbox_initclass(c, JBOX_TEXTFIELD | JBOX_FONTATTR);	// include textfield and Fonts attributes
//	jbox_initclass(c, 0);
	
	class_addmethod(c, (method) tonnetz_paint,			"paint", A_CANT, 0);

	
	// @method llll @digest Set points and/or velocities (depending on inlet)
	// @description
	// The first four (hot) inlets accepts llll determining which should be the selected points: user should
	// use either one of these inlets to insert data. <br />
	// The fifth inlet accepts a plain llll setting the velocities correspond to the list given in either one of
	// the hot inlets. <br />
	// The first inlet sets the selected points starting from their midicents values or from the note names. 
	// A plain llll with midicents or note names (or both) is thus expected. <br />
	// The second inlet sets the selected points starting from their pitch-class. A plain list of pitch-classes
	// is thus expected. <br />
	// The third inlet sets the selected points starting from their diatonic interval with respect to the 
	// tonnetz center (see <m>center</m> attribute). An llll of depth 2, each sublist containing a diatonic
	// interval, is thus expected (see below to know more about diatonic intervals syntax: only the list syntax
	// can be used, not the midicent one - use the first inlet if you need to set midicents). <br />
	// The fourth inlet sets the selected points starting from their coordinates inside the tonnetz (see below). <br />
	// If the <m>autoclear</m> attribute is active (default), the current selection is cleared before 
	// performing the new one. <br />
	// If the <m>echo</m> attribute is active, the newly selected or de-selected point information is also output 
	// from the "Queries and Notification" outlet (seventh outlet), in the complete point information syntax, having the <b>echo</b> symbol as router. <br />
	// @copy BACH_DOC_SETTHEORY_DIATONIC_INTERVALS_SYNTAX
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COORDINATES
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	class_addmethod(c, (method) tonnetz_anything, "anything", A_GIMME, 0);
	class_addmethod(c, (method) tonnetz_anything, "list", A_GIMME, 0);
	class_addmethod(c, (method) tonnetz_anything, "setfromcoordinates", A_GIMME, 0);
	
	
	// @method getnodeinfo @digest Output the information about one of the lattice nodes
	// @description The <m>getnodeinfo</m> message outputs the information about a given
	// tonnetz point from the "Queries and Notifications" outlet. 
	// Such point can be specified: from its midicents or note name, from its pitch-class,
	// from its diatonic interval with respect to the tonnetz center, or from its coordinates in the tonnetz.
	// To choose between these four different types of input syntax, just send the <m>getnodeinfo</m> message
	// in the dedicate inlet (one of the first four "hot" inlets: see the <m>llll</m> method). <br />
	// Depending on the <m>match</m> attribute, if more matches are found, the information about all of them is output.
	// The output syntax is the complete point information syntax,
	// with the router being the <m>nodeinfo</m> symbol. <br />
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	// @marg 0 @name point @optional 0 @type llll
    // @example getnodeinfo 6000 @caption in 1st inlet, outputs information about node(s) at 6000cents
    // @example getnodeinfo Bb2 @caption in 1st inlet, outputs information about node(s) with pitch Bb2
    // @example getnodeinfo 5 @caption in 2nd inlet, outputs information about node(s) with pitch class 5
    // @example getnodeinfo 2 4 @caption in 3rd inlet, outputs information about node(s) with interval 2 diatonic steps and 4 chromatic semitones
    // @example getnodeinfo 10 -4 @caption in 4th inlet, outputs information about node(s) with coordinates 10, -4
	class_addmethod(c, (method) tonnetz_anything, "getnodeinfo", A_GIMME, 0);

	
	// @method dump @digest Output all data
	// @description 
	// The <m>dump</m> message sends: <br />
	// - the modulo from the sixth outlet; <br />
	// - all the selected points' velocities from the fifth outlet, as a plain list of integers; <br />
	// - all the selected points' coordinates from the fourth outlet, as a list of depth 2 (each sublist being a couple of 
	// coordinates, see below); <br />
	// - all the selected points' diatonic interval with respect to the tonnetz center from the third outlet, as a list of depth 2 
	// (each sublist being a diatonic interval in list form, see below); <br />
	// - all the selected points' pitch-classes, as a plain list of integers; <br />
	// - all the selected points' midicents, as a plain list of floating point values. <br />
	// Moreover, if one needs to only dump specific elements, the <m>dump</m> message may also accept a list of symbols referring to them.
	// Allowed symbols are: "cents", "pitchclasses", "intervals", "coordinates", "velocities", "modulo".
	// For instance, <b>dump cents coordinates</b> will dump the coordinates and the midicents (always right-to-left, the order 
	// of the introduced arguments is irrelevant).
	// <br /> <br />
	// @copy BACH_DOC_SETTHEORY_DIATONIC_INTERVALS_SYNTAX
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COORDINATES
	// @marg 0 @name selective_dump_options @optional 1 @type list
    // @example dump @caption dump information from all outlets
    // @example dump cents @caption dump cents only
    // @example dump pitchclasses @caption dump pitch-classes only
    // @example dump coordinates @caption dump coordinates only
    // @example dump velocities @caption dump velocities only
    // @example dump intervals @caption dump intervals only
	class_addmethod(c, (method) tonnetz_dump, "dump", A_GIMME, 0);


	// @method int @digest Set the modulo (in sixth inlet)
	// @description 
	// In the sixth inlet, an <m>int</m> sets the modulo (number of points in the clock).
	// In first and second inlet, an <m>int</m> is converted into an <m>llll</m>.
	class_addmethod(c, (method) tonnetz_int, "int", A_LONG, 0);
	class_addmethod(c, (method) tonnetz_float, "float", A_FLOAT, 0);
	class_addmethod(c, (method) tonnetz_bang, "bang", 0);

	// @method clear @digest Clear the selection
	// @description Clear the selection on the tonnetz
    // @seealso replace
	class_addmethod(c, (method) tonnetz_anything, "clear", A_GIMME, 0);

	// @method add @digest Add points to the selection
	// @description Add some point to the diagram. This message is just like the standard <m>llll</m> formatted
	// message, except for the fact that it has the "add" symbol router. Exactly as the <m>llll</m> message,
	// it can be sent in any of the first four hot inlets, each one expecting its specific syntax (see <m>llll</m> to know more).
	// If the <m>echo</m> attribute is active, the newly selected point information is also output 
	// from the "Queries and Notification" outlet (seventh outlet), in the complete point information syntax, having the <b>echo</b> symbol as router. <br />
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	// @marg 0 @name points @optional 0 @type llll
    // @example add 7100 7300 @caption in 1st inlet, adds points with 7100 and 7300cents
    // @example add 5 2 @caption in 2nd inlet, adds points with pitch classes 5 or 2
    // @example add [2 4] @caption in 3rd inlet, adds a single point points with intervals 2 diatonic steps and 4 chromatic steps
    // @example add [-1 -0] [-3 1] @caption in 4th inlet, adds two points given their coordinates
    // @seealso delete, replace
	class_addmethod(c, (method) tonnetz_anything, "add", A_GIMME, 0);

    
	// @method delete @digest Remove points from the selection
	// @description Remove some points from the selection. This message is just like the standard <m>llll</m> formatted
	// message, except for the fact that it has the "remove" symbol router. Exactly as the <m>llll</m> message,
	// it can be sent in any of the first four hot inlets, each one expecting its specific syntax (see <m>llll</m> to know more).
	// If the <m>echo</m> attribute is active, the newly deselected point information is also output 
	// from the "Queries and Notification" outlet (seventh outlet), in the complete point information syntax, having the <b>echo</b> symbol as router. <br />
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	// @marg 0 @name points @optional 0 @type llll
    // @example delete 7100 7300 @caption in 1st inlet, deletes points with 7100 and 7300cents
    // @example delete 5 2 @caption in 2nd inlet, deletes points with pitch classes 5 or 2
    // @example delete [2 4] @caption in 3rd inlet, deletes a point points with intervals 2 diatonic steps and 4 chromatic steps
    // @example delete [-1 -0] [-3 1] @caption in 4th inlet, deletes two points given their coordinates
    // @seealso add, replace
	class_addmethod(c, (method) tonnetz_anything, "delete", A_GIMME, 0);

	// @method replace @digest Modify selection taking care of note-offs
	// @description An <m>llll</m> preceded by the <m>replace</m> symbol in any of the first four inlets
	// will work like a standard <m>llll</m> with a major difference: if the <m>echo</m> mode is on, 
	// the echoed (note-on) information will be only given for newly-selected nodes (and not for nodes
	// which were already selected), and note-off information for all deselected nodes will be also sent. <br />
	// The <m>replace</m> message with no further arguments, will act like a <m>clear</m> message, but 
	// will also send all echoed note-off information (if <m>echo</m> mode is on. <br />)
	// See <m>llll</m> method to know more.
	// @marg 0 @name points @optional 0 @type llll
    // @seealso clear, add, delete
    // @example replace @caption clear tonnetz and output note-offs
    // @example replace [0 0] [0 1] [0 2] [1 1] @caption in 4th inlet, set the new selected points from their coordinates, and output note-offs for previously selected ones
	class_addmethod(c, (method) tonnetz_anything, "replace", A_GIMME, 0);

    
	// @method dumpselection @digest Dump the selected points from the "Queries and Notifications" outlet
	// @description The <m>dumpselection</m> message will dump the selected point information from the 
	// "Queries and Notification" outlet in the complete point information syntax, having the <b>node</b> symbol as router. <br />
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	class_addmethod(c, (method) tonnetz_dumpselection, "dumpselection", 0);
	
	// @method rotate @digest Rotate selection
	// @description Rotate all the selected points in the lattice of a certain angle multiple of 60°. 
	// The expected argument is such multiplier (number of steps): with <b>rotate 1</b> the tonnetz is rotated counterclockwise by 60°, with
	// <b>rotate 2</b> it is rotated clockwise by 120°, and so on. Negative number rotate counterclockwise.
	// @marg 0 @name steps @optional 0 @type int
    // @example rotate 1 @caption rotate selection of 60° (1 step) clockwise
    // @example rotate -2 @caption rotate selection of 120° (2 steps) counterclockwise
    // @seealso translate
	class_addmethod(c, (method) tonnetz_anything, "rotate", A_GIMME, 0);

    
	// @method translate @digest Translate selection
	// @description Translate all the selected points in the lattice of a certain vector, specified in the lattice coordinates.
	// The expected arguments are thus the two integer coordinates for the translation.
	// @marg 0 @name coord1 @optional 0 @type int
	// @marg 1 @name coord2 @optional 0 @type int
    // @example translate 1 -2 @caption move selection of a vector (1, -2)
    // @seealso rotate
	class_addmethod(c, (method) tonnetz_anything, "translate", A_GIMME, 0);
	
    
	// @method (mouse) @digest Select/deselect points, or change their velocities
	// @description 
	// • <m>click</m>: Select a point, and output <br />
	//    ↪ Hold the mouse down and drag to select other points. <br />
	// • <m>Alt+click</m>: Output clicked point data from the "Queries and Notifications" output, without selecting the point.
	// See below to know more about the syntax. <br />
	// • <m>Cmd+click</m> (mac) or <m>Ctrl+click</m> (win): Deselect a point <br />
	//    ↪ Hold the mouse down and drag to deselect other points. <br />
	// • <m>Ctrl+click+drag</m> (mac) or <m>Shift+Ctrl+click+drag</m> (win): Change the velocity of a point (dragging up or down) <br /> 
	// • <m>Cmd+mousewheel</m> (mac) or <m>Ctrl+mousewheel</m> (win): drag up/down to increase or decrease the lattice side. <br />
	//    ↪ Add the <m>Shift</m> key to slow change. <br />
	// • <m>Alt+Ctrl+click+drag</m> (mac) or <m>Alt+Ctrl+Shift+click+drag</m> (win): move lattice center (change offset). <br />
	// When a point is clicked upon, selected or de-selected, its content is output from the "Queries and Notifications" outlet, 
	// having as router the <b>clicked</b> symbol, and as syntax the complete point information syntax. <br /> <br />
	// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	class_addmethod(c, (method) tonnetz_mousedown, "mousedown", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_mousedrag, "mousedrag", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_mouseup, "mouseup", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_mousemove, "mousemove", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_mousewheel, "mousewheel", A_CANT, 0);

	// @method (keyboard) @digest Modify points or dump
	// @description 
	// • <m>Cmd+T</m> (mac) or <m>Ctrl+T</m> (win): Rotate tonnetz selection of 60° clockwise <br />
	// • <m>Cmd+R</m> (mac) or <m>Ctrl+R</m> (win): Rotate tonnetz selection of 60° counterclockwise <br />
	// • <m>Cmd+Shift+D</m> (mac) or <m>Ctrl+Shift+D</m> (win): Dump all information (as for <m>dump</m> message). <br />
	// • <m>Cmd+→</m> (mac) or <m>Ctrl+→</m> (win): Transpose tonnetz selection on horizontal coordinate, at right. <br />
	// • <m>Cmd+←</m> (mac) or <m>Ctrl+←</m> (win): Transpose tonnetz selection on horizontal coordinate, at left. <br />
	// • <m>Cmd+↑</m> (mac) or <m>Ctrl+↑</m> (win): Transpose tonnetz selection on diagonal coordinate, up. <br />
	// • <m>Cmd+↓</m> (mac) or <m>Ctrl+↓</m> (win): Transpose tonnetz selection on diagonal coordinate, down. <br />
	// • <m>Esc</m>: Reset offset, setting the tonnetz center at the graphical center <br />
	// • <m>Spacebar</m>: Dump all information from the "Queries and Notifications" outlet (as for <m>dumpselection</m> message). <br />
  	class_addmethod(c, (method) tonnetz_key, "key", A_CANT, 0);

    class_addmethod(c, (method) tonnetz_preset, "preset", 0);
    class_addmethod(c, (method) tonnetz_begin_preset, "begin_preset", A_GIMME, 0);
    class_addmethod(c, (method) tonnetz_restore_preset, "restore_preset", A_GIMME, 0);
    class_addmethod(c, (method) tonnetz_end_preset, "end_preset", 0);
	CLASS_METHOD_ATTR_PARSE(c, "begin_preset", "undocumented", gensym("long"), 0L, "1");
	CLASS_METHOD_ATTR_PARSE(c, "restore_preset", "undocumented", gensym("long"), 0L, "1");
	CLASS_METHOD_ATTR_PARSE(c, "end_preset", "undocumented", gensym("long"), 0L, "1");
	class_addmethod(c, (method) tonnetz_jsave, "jsave", A_CANT, 0);
	
	class_addmethod(c, (method) tonnetz_focusgained, "focusgained", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_focuslost, "focuslost", A_CANT, 0); 

	class_addmethod(c, (method) tonnetz_inletinfo, "inletinfo", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_assist, "assist", A_CANT, 0);
	class_addmethod(c, (method) tonnetz_oksize, "oksize", A_CANT, 0);

	llllobj_class_add_default_bach_attrs_and_methods(c, LLLL_OBJ_UI);


	CLASS_ATTR_DEFAULT(c, "patching_rect", 0, "0 0 542. 316."); // new dimensions
	// @exclude bach.tonnetz

	CLASS_STICKY_ATTR(c,"category",0,"Color");

#ifdef BACH_MAX7_STYLES_COMPATIBILITY
        CLASS_ATTR_STYLE_RGBA_PREVIEW(c, "textcolor", 0, t_tonnetz, j_textcolor, "Text Color", "text_letter");
        CLASS_ATTR_LEGACYDEFAULT(c, "textcolor", "textcolor", 0, "0. 0. 0. 1.");
        CLASS_ATTR_BASIC(c, "textcolor", 0);
        // @description Color of the text in the diagram
#else
        CLASS_ATTR_RGBA(c, "textcolor", 0, t_tonnetz, j_textcolor);
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "textcolor", 0, "0. 0. 0. 1.");
        CLASS_ATTR_STYLE_LABEL(c, "textcolor", 0, "rgba", "Text Color");
        CLASS_ATTR_BASIC(c, "textcolor", 0);
#endif
		
#ifdef BACH_MAX7_STYLES_COMPATIBILITY
        CLASS_ATTR_STYLE_RGBA_PREVIEW(c, "bgcolor", 0, t_tonnetz, j_bgcolor, "Background Color", "rect_fill");
        CLASS_ATTR_LEGACYDEFAULT(c, "bgcolor", "bgcolor", 0, "1. 1. 1. 1.");
        CLASS_ATTR_BASIC(c, "bgcolor", 0);
        // @description Diagram external background color
#else
		CLASS_ATTR_RGBA(c, "bgcolor", 0, t_tonnetz, j_bgcolor);
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "bgcolor", 0, "1. 1. 1. 1.");
		CLASS_ATTR_STYLE_LABEL(c, "bgcolor", 0, "rgba", "Background Color");
		CLASS_ATTR_BASIC(c, "bgcolor",0);
#endif
    
		CLASS_ATTR_RGBA(c, "bordercolor", 0, t_tonnetz, j_bordercolor);
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "bordercolor", 0, "0.2 0.2 0.2 1.");
		CLASS_ATTR_STYLE_LABEL(c, "bordercolor", 0, "rgba", "Border Color");
		// @description Color of the diagram border

		CLASS_ATTR_RGBA(c, "pointbordercolor", 0, t_tonnetz, j_pointbordercolor);
#ifdef BACH_MAX7_STYLES_COMPATIBILITY
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "pointbordercolor", 0, "0. 0. 0. 0.");
#else
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "pointbordercolor", 0, "0. 0. 0. 1.");
#endif
		CLASS_ATTR_STYLE_LABEL(c, "pointbordercolor", 0, "rgba", "Point Border Color");
		// @description Color of each point's outline

#ifdef BACH_MAX7_STYLES_COMPATIBILITY
        CLASS_ATTR_STYLE_RGBA_PREVIEW(c, "pointinnercolor", 0, t_tonnetz, j_pointinnercolor, "Point Inner Color", "circle_fill");
        CLASS_ATTR_LEGACYDEFAULT(c, "pointinnercolor", "pointinnercolor", 0, "1. 1. 1. 1.");
    	class_attr_stylemap(c, (char *)"pointinnercolor", (char *)"accentcolor");
        // @description Color of the inner part of each point.
#else
        CLASS_ATTR_RGBA(c, "pointinnercolor", 0, t_tonnetz, j_pointinnercolor);
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "pointinnercolor", 0, "1. 1. 1. 1.");
		CLASS_ATTR_STYLE_LABEL(c, "pointinnercolor", 0, "rgba", "Point Inner Color");

        CLASS_ATTR_RGBA(c, "tonnetzcolor", 0, t_tonnetz, j_tonnetzcolor);
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "tonnetzcolor", 0, "0.5 0.5 0.5 1.");
        CLASS_ATTR_STYLE_LABEL(c, "tonnetzcolor", 0, "rgba", "Tonnetz Color");
        // @description Color of the tonnetz diagram
#endif

		CLASS_ATTR_RGBA(c, "selectedpointbordercolor", 0, t_tonnetz, j_selectedpointbordercolor);
#ifdef BACH_MAX7_STYLES_COMPATIBILITY
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "selectedpointbordercolor", 0, "0. 0. 0. 0.");
#else
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "selectedpointbordercolor", 0, "0.54 0.28 0.28 1.");
#endif
		CLASS_ATTR_STYLE_LABEL(c, "selectedpointbordercolor", 0, "rgba", "Selected Point Border Color");
		// @description Color of the selected point's outline

#ifdef BACH_MAX7_STYLES_COMPATIBILITY
        CLASS_ATTR_STYLE_RGBA_PREVIEW(c, "selectedpointinnercolor", 0, t_tonnetz, j_selectedpointinnercolor, "Selected Point Inner Color", "circle_fill");
        CLASS_ATTR_LEGACYDEFAULT(c, "selectedpointinnercolor", "selectedpointinnercolor", 0, "0.85 0.65 0.65 1.");
        class_attr_stylemap(c, (char *)"selectedpointinnercolor", (char *)"color");
		// @description Color of the inner part of a selected point.
#else
        CLASS_ATTR_RGBA(c, "selectedpointinnercolor", 0, t_tonnetz, j_selectedpointinnercolor);
        CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "selectedpointinnercolor", 0, "0.85 0.65 0.65 1.");
        CLASS_ATTR_STYLE_LABEL(c, "selectedpointinnercolor", 0, "rgba", "Selected Point Inner Color");
    
		CLASS_ATTR_RGBA(c, "selectedtriangleinnercolor", 0, t_tonnetz, j_selectedtriangleinnercolor);
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c, "selectedtriangleinnercolor", 0, "0.7 0.16 0.173 1.");
		CLASS_ATTR_STYLE_LABEL(c, "selectedtriangleinnercolor", 0, "rgba", "Selected Triangle Inner Color");
        // @description Color of the inner part of a selected triangle.
#endif
	
		
	CLASS_STICKY_ATTR_CLEAR(c, "category");


	CLASS_STICKY_ATTR(c,"category",0,"Behavior");

		CLASS_ATTR_CHAR(c,"embed",0, t_tonnetz, save_data_with_patcher);
		CLASS_ATTR_STYLE_LABEL(c,"embed",0,"onoff","Save Data With Patcher");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"embed",0,"1");
		CLASS_ATTR_BASIC(c,"embed",0);
		// @description Toggles the ability to embed the data as a part of the patch, when this latter is saved.
		// The default behaviour is 1 (content is saved).

		CLASS_ATTR_CHAR(c,"autoclear",0, t_tonnetz, autoclear);
		CLASS_ATTR_STYLE_LABEL(c,"autoclear",0,"onoff","Autoclear");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"autoclear",0,"1");
		CLASS_ATTR_BASIC(c,"autoclear",0);
		// @description Toggles the ability to automatically clear the content once new data arrives in the four hot inlets.

		CLASS_ATTR_CHAR(c,"echo",0, t_tonnetz, echo);
		CLASS_ATTR_STYLE_LABEL(c,"echo",0,"onoff","Echo Incoming Data");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"echo",0,"0");
		CLASS_ATTR_BASIC(c,"echo",0);
		// @description Toggles the ability to automatically reoutput incoming data from "Queries and Notifications" outlet
		// (seventh outlet) once it comes in from one of the hot inlets. The syntax used is the complete point information syntax,
		// having the <b>echo</b> symbol as router. <br />
		// @copy BACH_DOC_SETTHEORY_TONNETZ_COMPLETE_POINT_INFORMATION
	
	CLASS_STICKY_ATTR_CLEAR(c, "category");

	
	CLASS_STICKY_ATTR(c,"category",0,"Value");

		// max and min attributes
		CLASS_ATTR_LONG(c,"modulo",0, t_tonnetz, modulo);
		CLASS_ATTR_STYLE_LABEL(c,"modulo",0,"text","Modulo");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"modulo",0,"12");
		CLASS_ATTR_FILTER_MIN(c, "modulo", 1);
		CLASS_ATTR_ACCESSORS(c, "modulo", (method)NULL, (method)tonnetz_setattr_modulo);
		CLASS_ATTR_BASIC(c,"modulo",0);
		// @description Modulo of the diagram. <br />
		// @copy BACH_DOC_SETTHEORY_MODULO
	
	
	CLASS_STICKY_ATTR_CLEAR(c, "category");

	CLASS_STICKY_ATTR(c,"category",0,"Settings");

		CLASS_ATTR_CHAR_UNSAFE(c,"notenamesstyle",0, t_tonnetz, note_names_style);
		CLASS_ATTR_STYLE_LABEL(c,"notenamesstyle",0,"enumindex","Note Names Style");
		CLASS_ATTR_ENUMINDEX(c,"notenamesstyle", 0, "Latin Anglo-Saxon");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"notenamesstyle",0,"1");
        CLASS_ATTR_INVISIBLE(c, "notenamesstyle", ATTR_GET_OPAQUE | ATTR_SET_OPAQUE); // deprecated and unsupported
        // @exclude all
        // @description @copy BACH_DOC_NOTENAMESSTYLE

		CLASS_ATTR_CHAR(c,"label",0, t_tonnetz, label_style);
		CLASS_ATTR_STYLE_LABEL(c,"label",0,"enumindex","Label Type");
		CLASS_ATTR_ENUMINDEX(c,"label", 0, "Note Names Note Names And Octave Cents Diatonic Intervals Frequency Ratios Coordinates");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"label",0,"1");
		CLASS_ATTR_BASIC(c,"label",0);
		// @description Sets the displayed content in each tonnetz point:
		// <m>Note Names</m>: Just the note name; <br />
		// <m>Note Names And Octave</m>: As the previous one, but also with the octave number; <br />
		// <m>Cents</m>: The pitch in midicents; <br />
		// <m>Diatonic Intervals</m>: The diatonic interval with respect to the tonnetz center; <br />
		// <m>Frequency Ratios</m>: The frequency ratio with respect to the tonnetz center; <br />
		// <m>Coordinates</m>: The coordinates of the point in the tonnetz. <br /> <br />
		// @copy BACH_DOC_SETTHEORY_DIATONIC_INTERVALS_SYNTAX
		// @copy BACH_DOC_SETTHEORY_TONNETZ_COORDINATES
	
		CLASS_ATTR_CHAR(c,"outputnotenames",0, t_tonnetz, output_note_names);
		CLASS_ATTR_STYLE_LABEL(c,"outputnotenames",0,"onoff","Output Note Names On Dump");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"outputnotenames",0,"0");
		// @description Toggles the ability to output note names from first inlet, instead of midicents, when a <m>dump</m> message is sent.
		// (or a dump is required from keyboard combinations).
	
		CLASS_ATTR_LONG(c,"middlecoctave",0, t_tonnetz, middleC_octave);
		CLASS_ATTR_STYLE_LABEL(c,"middlecoctave",0,"text","Middle C Octave");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"middlecoctave", 0, "5");
        CLASS_ATTR_INVISIBLE(c, "middlecoctave", ATTR_GET_OPAQUE | ATTR_SET_OPAQUE); // deprecated and unsupported
        // @exclude all
		// @description Sets the octave number of the middle C. By default this is 5 (meaning that C5 = Do5 is the middle C);
		// values of 3 and 5 are also encountered. 
	
        CLASS_ATTR_LLLL(c, "center", 0, t_tonnetz, diatonic_center_as_llll, tonnetz_getattr_diatonic_center, tonnetz_setattr_diatonic_center);
		CLASS_ATTR_STYLE_LABEL(c,"center",0,"text","Diatonic Center");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"center",0,"C5");
//		CLASS_ATTR_ACCESSORS(c, "center", (method)NULL, (method)tonnetz_setattr_diatonic_center);
		// @description Sets the diatonic center pitch.
        // @copy BACH_DOC_PITCHES_ALSO_AS_NOTENAMES
    
		CLASS_ATTR_CHAR(c, "mode", 0, t_tonnetz, mode);
		CLASS_ATTR_STYLE_LABEL(c,"mode",0,"enumindex","Lattice Type");
		CLASS_ATTR_ENUMINDEX(c,"mode", 0, "Just Intonation Infinite Lattice Equally Tempered Infinite Lattice Equally Tempered Wrapped Lattice Pitch Surface"); 
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"mode",0,"2");
		CLASS_ATTR_ACCESSORS(c, "mode", (method)NULL, (method)tonnetz_setattr_mode);
		CLASS_ATTR_BASIC(c,"mode",0);
		// @description Sets the type of lattice: <br />
		// - <m>Just Intonation Infinite Lattice</m> (0): Infinite lattice generated by just intervals
		// (or by custom frequency ratios, if a third element is given in the generators); <br />
		// - <m>Equally Tempered Infinite Lattice</m> (1): Infinite lattice with dinstinct enharmonically equivalent notes, but with equally tempered midicents; <br />
		// - <m>Equally Tempered Wrapped Lattice</m> (2): All enharmonically equivalent notes are named in the same way. <br />
		// - <m>Pitch Surface</m> (3): The pitch of each node is defined via an equation (see <m>surface</m> attribute).

		CLASS_ATTR_SYM(c, "surface", 0, t_tonnetz, surface_eq_as_sym);
		CLASS_ATTR_STYLE_LABEL(c,"surface",0,"text","Surface Equation");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"surface",0,"\"6000 + 700 * x + 400 * y\"");
		CLASS_ATTR_ACCESSORS(c, "surface", (method)NULL, (method)tonnetz_setattr_surface);
		// @descriptions Sets the surface equation if <m>mode</m> is 3 ("Pitch Surface"). Use <m>x</m> and <m>y</m> as integer variables
		// for the two main directions.
	
		CLASS_ATTR_CHAR(c, "purelydiatonic", 0, t_tonnetz, purely_diatonic);
		CLASS_ATTR_STYLE_LABEL(c,"purelydiatonic",0,"onoff","Purely Diatonic");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"purelydiatonic",0,"0");
		CLASS_ATTR_ACCESSORS(c, "purelydiatonic", (method)NULL, (method)tonnetz_setattr_purelydiatonic);
		// @descriptions If set, forces the tonnetz generators to be purely diatonic: the chromatic steps of the <m>generators</m> are ignored, and instead a default interval sequence (scale)
		// is used (see <m>scaleintervals</m> and <m>scalefreqratios</m>).

		CLASS_ATTR_LLLL(c, "scaleintervals", 0, t_tonnetz, purely_diatonic_scale_intervals, tonnetz_getattr_scaleintervals, tonnetz_setattr_scaleintervals);
		CLASS_ATTR_STYLE_LABEL(c,"scaleintervals",0,"text","Diatonic Scale Intervals");
		CLASS_ATTR_SAVE(c, "scaleintervals", 0);
		CLASS_ATTR_PAINT(c, "scaleintervals", 0);
		// @descriptions If <m>purelydiatonic</m> is active, this specifies the current scale, as a sequence of intervals in midicents.
	
		CLASS_ATTR_LLLL(c, "scalefreqratios", 0, t_tonnetz, purely_diatonic_scale_freq_ratios, tonnetz_getattr_scalefreqratios, tonnetz_setattr_scalefreqratios);
		CLASS_ATTR_STYLE_LABEL(c,"scalefreqratios",0,"text","Diatonic Scale Frequency Ratios");
		CLASS_ATTR_SAVE(c, "scalefreqratios", 0);
		CLASS_ATTR_PAINT(c, "scalefreqratios", 0);
		// @descriptions If <m>purelydiatonic</m> is active, this specifies the frequency intervals related to the current scale steps.
	
		CLASS_ATTR_CHAR(c, "match", 0, t_tonnetz, match_mode);
		CLASS_ATTR_STYLE_LABEL(c,"match",0,"enumindex","When Adding Points Select");
		CLASS_ATTR_ENUMINDEX(c,"match", 0, "All Matches Most Central Match Nearest Melodical Match Smart"); 
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"match",0,"3");
		CLASS_ATTR_BASIC(c,"match",0);
		// @description When a point is selected by message, the request might be ambiguous - for instance, one might
		// ask to select a point having pitch-class 1, or midicents 6200, which can correspond to multiple points in the tonnets.
		// The <m>match</m> attribute tells which point should be selected in such occasion: <br />
		// - <m>All Matches</m>: Select all points matching the request; <br/>
		// - <m>Most Central Match</m>: Only select the match being nearest to the tonnetz center; <br/>
		// - <m>Nearest Melodical Match</m>: Only select the match being nearest to the last selected point; <br/>
		// - <m>Smart</m> (default): Only select the match being nearest to the last selected point, if it is displayed inside the screen,
		// otherwise choose the nearest one being inside the displayed portion of tonnetz.
	
		CLASS_ATTR_CHAR(c, "inscreenonly", 0, t_tonnetz, only_return_inscreen_coordinates);
		CLASS_ATTR_STYLE_LABEL(c,"inscreenonly",0,"onoff","Handle Displayed Points Only");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"inscreenonly",0,"1");
		// @description Toggles the ability to only select points displayed inside the screen.
	
		CLASS_ATTR_LLLL(c, "generators", 0, t_tonnetz, generators_as_llll, tonnetz_getattr_generators, tonnetz_setattr_generators);
		CLASS_ATTR_STYLE_LABEL(c,"generators",0,"text","Generators As Diatonic Intervals");
		CLASS_ATTR_SAVE(c, "generators", 0);
		CLASS_ATTR_PAINT(c, "generators", 0);
		CLASS_ATTR_BASIC(c,"generators",0);
		// @description Sets the generating diatonic intervals for the two main directions (the horizontal, and the 
		// one rotated by 60° counterclockwise). An additional third element in the diatonic list syntax will be considered as a custom frequency ratio
		// associated with the generator. <br />
		// @copy BACH_DOC_SETTHEORY_DIATONIC_INTERVALS_SYNTAX
	
	CLASS_STICKY_ATTR_CLEAR(c, "category");

	CLASS_STICKY_ATTR(c,"category",0,"Show");
	
		CLASS_ATTR_CHAR(c,"showfocus",0, t_tonnetz, show_focus);
		CLASS_ATTR_STYLE_LABEL(c,"showfocus",0,"onoff","Show Focus");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"showfocus",0,"1");
		// @description Show that the object has the focus by increasing the width of the border.
	
		CLASS_ATTR_CHAR(c, "showvelocity", 0, t_tonnetz, velocity_handling);
		CLASS_ATTR_STYLE_LABEL(c,"showvelocity",0,"enumindex","Show Velocity");
		CLASS_ATTR_ENUMINDEX(c,"showvelocity", 0, "None Colorscale Colorspectrum Circle Size");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"showvelocity",0,"0");
		// @description Attribute deciding how the velocity of a point must be shown:
		// <m>None</m>: velocity must be graphically ignored<br />
		// <m>Colorscale</m>: by changing the lightness of the point inner color<br />
		// <m>Colorspectrum</m>: by changing the point inner color over a spectrum of colors (red to blue) <br />
		// <m>Circle Size</m>: by changing the point point circle size
	
	CLASS_STICKY_ATTR_CLEAR(c, "category");
	
	CLASS_STICKY_ATTR(c, "category", 0, "Appearance"); 

		CLASS_ATTR_DOUBLE(c,"zoom",0, t_tonnetz, zoom_percentage);
		CLASS_ATTR_STYLE_LABEL(c,"zoom",0,"text","Zoom %");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"zoom",0,"100.");
		CLASS_ATTR_ACCESSORS(c, "zoom", (method)NULL, (method)tonnetz_setattr_zoom);
		CLASS_ATTR_BASIC(c,"zoom",0);
		// @description Sets the global zoom factor, as a percentage. This zoom also affects all other graphical parameters, such as circle size, text font size...

		CLASS_ATTR_DOUBLE_ARRAY(c,"offset",0, t_tonnetz, center_offset, 2);
		CLASS_ATTR_STYLE_LABEL(c,"offset",0,"text","Center Offset");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"offset",0,"0. 0.");
		CLASS_ATTR_ACCESSORS(c, "offset", (method)NULL, (method)tonnetz_setattr_offset);
		// @description Sets the center offset in lattice coordinates.
	
		CLASS_ATTR_DOUBLE(c,"side",0, t_tonnetz, lattice_step);
		CLASS_ATTR_STYLE_LABEL(c,"side",0,"text","Triangle Side");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"side",0,"50.");
		CLASS_ATTR_FILTER_MIN(c, "side", 0.);
		CLASS_ATTR_ACCESSORS(c, "side", (method)NULL, (method)tonnetz_setattr_side);
		// @description Side of each tonnetz triangle in pixels
	
		CLASS_ATTR_DOUBLE(c,"pointradius",0, t_tonnetz, point_radius);
		CLASS_ATTR_STYLE_LABEL(c,"pointradius",0,"text","Point Radius");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"pointradius",0,"16.");
		CLASS_ATTR_FILTER_MIN(c, "pointradius", 0.);
		// @description Radius of each tonnetz point in pixels

		CLASS_ATTR_DOUBLE(c,"tonnetzlinewidth",0, t_tonnetz, tonnetz_line_width);
		CLASS_ATTR_STYLE_LABEL(c,"tonnetzlinewidth",0,"text","Tonnetz Line Width");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"tonnetzlinewidth",0,"1.");
		CLASS_ATTR_FILTER_MIN(c, "tonnetzlinewidth", 0.);
		// @description Width of the line of the main tonnetz in the diagram, in pixels

		CLASS_ATTR_DOUBLE(c,"pointlinewidth",0, t_tonnetz, point_line_width);
		CLASS_ATTR_STYLE_LABEL(c,"pointlinewidth",0,"text","Point Line Width");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"pointlinewidth",0,"1.");
		CLASS_ATTR_FILTER_MIN(c, "pointlinewidth", 0.);
		// @description Width of the line of each point's tonnetz, in pixels

		CLASS_ATTR_DOUBLE(c,"selectedlinewidth",0, t_tonnetz, selected_line_width);
		CLASS_ATTR_STYLE_LABEL(c,"selectedlinewidth",0,"text","Selected Nodes Line Width");
		CLASS_ATTR_DEFAULT_SAVE_PAINT(c,"selectedlinewidth",0,"2.");
		CLASS_ATTR_FILTER_MIN(c, "selectedlinewidth", 0.);
		// @description Width of the line linking all selected points together, in pixels
	

	CLASS_STICKY_ATTR_CLEAR(c, "category"); 

	s_tonnetz_class = c;
	class_register(CLASS_BOX, s_tonnetz_class);
	
	dev_post("bach.tonnetz compiled %s %s", __DATE__, __TIME__);
	return;
}


void tonnetz_assist(t_tonnetz *x, void *b, long m, long a, char *s){
    if (m == ASSIST_INLET) {
		if (a == 0) // @in 0 @type llll @digest Midicents or Note Names, or a 2-depth list with interleaved Velocities
			sprintf(s, "llll: Midicents or Note Names"); 
		else if (a == 1) // @in 1 @type llll @digest Pitch-Classes, or a 2-depth list with interleaved Velocities
						 // @description @copy BACH_DOC_SETTHEORY_PC_AND_PCSET
			sprintf(s, "llll: Pitch-Classes"); 
		else if (a == 2)  // @in 2 @type llll @digest Diatonic Intervals, or a 3-depth list of interlaced Diatonic Intervals and Velocities
			sprintf(s, "llll: Diatonic Intervals");
		else if (a == 3)  // @in 3 @type llll @digest Node Coordinates, or a 3-depth list of interlaced Node Coordinates and Velocities
			sprintf(s, "llll: Node Coordinates");
		else if (a == 4)  // @in 4 @type llll @digest Velocities
			sprintf(s, "llll: Velocities");
		else // @in 5 @type int @digest Modulo
			sprintf(s, "int: Modulo");
	} else {
		char *type = NULL;
		llllobj_get_llll_outlet_type_as_string((t_object *) x, LLLL_OBJ_UI, a, &type);
		if (a == 0) // @out 0 @type llll @digest Selected nodes' midicents or note names
			sprintf(s, true ? "llll (%s): Midicents" : "llll (%s): Note Names", type);
		else if (a == 1) // @out 1 @type llll @digest Selected pitch-classes
			sprintf(s, "llll (%s): Pitch-Classes", type);
		else if (a == 2) // @out 2 @type llll @digest Selected nodes' diatonic representation
			sprintf(s, "llll (%s): Diatonic Intervals", type);
		else if (a == 3) // @out 3 @type llll @digest Selected nodes' coordinates
			sprintf(s, "llll (%s): Nodes Coordinates", type);
		else if (a == 4) // @out 4 @type llll @digest Selected nodes' velocities
			sprintf(s, "llll (%s): Velocities", type);
		else if (a == 5) // @out 5 @type llll @digest Modulo
			sprintf(s, "int: Modulo");
		else if (a == 6) // @out 6 @type llll @digest Queries and notifications
			sprintf(s, "llll (%s): Queries and Notifications", type);
		else // @out 7 @type bang @digest bang when changed via the interface 
			sprintf(s, "bang When Circle Changed"); // @description A bang is output whenever the user changes the diagram via mouse and keyboard
	}
}

void tonnetz_inletinfo(t_tonnetz *x, void *b, long a, char *t)
{
	if (a >= 4)
		*t = 1;
}

void tonnetz_int(t_tonnetz *x, t_atom_long num)
{
	t_atom argv[1]; atom_setlong(argv, num);
	tonnetz_anything(x, _llllobj_sym_list, 1, argv);
}

void tonnetz_float(t_tonnetz *x, double num){
	t_atom argv[1]; atom_setfloat(argv, num);
	tonnetz_anything(x, _llllobj_sym_list, 1, argv);
}

char get_tonnetz_element_velocity(t_tonnetz *x, t_llllelem *elem)
{
	t_llll *ll = hatom_getllll(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
	long coord1 = hatom_getlong(&ll->l_head->l_hatom);
	long coord2 = hatom_getlong(&ll->l_head->l_next->l_hatom);

	if (ARE_COORD_IN_VEL_MATRIX(coord1, coord2))
		return x->velocities[TONNETZ_VEL_OFFSET(coord1)][TONNETZ_VEL_OFFSET(coord2)];
	
	return 0;
}

void get_selected_points_data_as_llll(t_tonnetz *x, t_llll **midicents, t_llll **pitchclasses, 
									  t_llll **diatonic_intervals, t_llll **nodes_coordinates, t_llll **velocities, char note_get_names)
{

	systhread_mutex_lock(x->c_mutex);

	if (midicents) *midicents = llll_get();
	if (pitchclasses) *pitchclasses = llll_get();
	if (diatonic_intervals) *diatonic_intervals = llll_get();
	if (nodes_coordinates) *nodes_coordinates = llll_get();
	if (velocities) *velocities = llll_get();
	
	t_llllelem *elem;
	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		long this_vel = get_tonnetz_element_velocity(x, elem);
		if (this_vel > 0) {
			t_llll *ll = hatom_getllll(&elem->l_hatom);
			t_llllelem *elem = ll->l_head;
			t_llll *this_coord = hatom_getllll(&elem->l_hatom);
			elem = elem->l_next->l_next;
			double this_midicents = hatom_getdouble(&elem->l_hatom);
			elem = elem->l_next->l_next;
			long this_pc = hatom_getlong(&elem->l_hatom);
			elem = elem->l_next;
			t_llll *this_diatonic_interval = hatom_getllll(&elem->l_hatom);

			if (midicents) {
				if (note_get_names) {
					t_tonnetz_diatonic_interval dia;
					char *buf = NULL;
					dia.diatonic_steps = hatom_getlong(&this_diatonic_interval->l_head->l_hatom);
					if (x->purely_diatonic){
						purely_diatonic_interval_to_notename(x, dia, true, &buf);
					} else {
						dia.chromatic_steps = hatom_getlong(&this_diatonic_interval->l_head->l_next->l_hatom);
						diatonic_interval_to_notename(x, dia, true, &buf);
					}
					llll_appendsym(*midicents, gensym(buf), 0, WHITENULL_llll);
					bach_freeptr(buf);
				} else
					llll_appenddouble(*midicents, this_midicents, 0, WHITENULL_llll);
			}
			if (pitchclasses) 
				llll_appendlong(*pitchclasses, this_pc, 0, WHITENULL_llll);
			if (diatonic_intervals) 
				llll_appendllll_clone(*diatonic_intervals, this_diatonic_interval, 0, WHITENULL_llll, NULL);
			if (nodes_coordinates) 
				llll_appendllll_clone(*nodes_coordinates, this_coord, 0, WHITENULL_llll, NULL);
			if (velocities) 
				llll_appendlong(*velocities, this_vel, 0, WHITENULL_llll);
		}
	}

	systhread_mutex_unlock(x->c_mutex);
}

void send_values(t_tonnetz *x, char send_midicents, char send_pitchlasses, char send_diatonic_intervals, char send_coordinates, char send_velocities, char send_modulo) 
{
	t_llll *out0 = NULL, *out1 = NULL, *out2 = NULL, *out3 = NULL, *out4 = NULL;
	
	get_selected_points_data_as_llll(x, send_midicents ? &out0 : NULL, send_pitchlasses ? &out1 : NULL, send_diatonic_intervals ? &out2 : NULL, 
									 send_coordinates ? &out3 : NULL, send_velocities ? &out4 : NULL, x->output_note_names); 
	
	if (send_modulo)
		llllobj_outlet_int((t_object *) x, LLLL_OBJ_UI, 5, x->modulo);
	if (out4)
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 4, out4);
	if (out3)
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 3, out3);
	if (out2)
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 2, out2);
	if (out1)
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 1, out1);
	if (out0)
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 0, out0);
	
	llll_free(out0);
	llll_free(out1);
	llll_free(out2);
	llll_free(out3);
	llll_free(out4);
}

void tonnetz_dump(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv){
	t_llll *args = llllobj_parse_llll((t_object *)x, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_RETAIN);
	send_values(x,	!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, _llllobj_sym_cents), 
					!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, gensym("pitchclasses")),
					!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, gensym("intervals")),
					!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, gensym("coordinates")),
					!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, _llllobj_sym_velocities),
					!args || args->l_size == 0 || is_symbol_in_llll_first_level(args, gensym("modulo")));
	llll_free(args);
}

t_tonnetz_pt_coord build_tonnetz_pt_coord(long c1, long c2)
{
	t_tonnetz_pt_coord res;
	res.coord1 = c1;
	res.coord2 = c2;
	return res;
}


long llll_sort_by_distance_from_center(void *data, t_llllelem *a, t_llllelem *b) {
	t_llll *a_ll = hatom_getllll(&a->l_hatom);
	t_llll *b_ll = hatom_getllll(&b->l_hatom);
	long a1 = hatom_getdouble(&a_ll->l_head->l_hatom);
	long a2 = hatom_getdouble(&a_ll->l_head->l_next->l_hatom);
	long b1 = hatom_getdouble(&b_ll->l_head->l_hatom);
	long b2 = hatom_getdouble(&b_ll->l_head->l_next->l_hatom);
	
	t_tonnetz_pt_coord zero = build_tonnetz_pt_coord(0, 0);
	
	if (manhattan_distance(build_tonnetz_pt_coord(a1, a2),  zero) <=
		manhattan_distance(build_tonnetz_pt_coord(b1, b2),  zero))
		return 1;
	else
		return 0;
	
}

long llll_sort_by_distance_from_last_selected_point(void *data, t_llllelem *a, t_llllelem *b) {
	t_tonnetz *x = (t_tonnetz *)data;

	t_llll *a_ll = hatom_getllll(&a->l_hatom);
	t_llll *b_ll = hatom_getllll(&b->l_hatom);
	long a1 = hatom_getdouble(&a_ll->l_head->l_hatom);
	long a2 = hatom_getdouble(&a_ll->l_head->l_next->l_hatom);
	long b1 = hatom_getdouble(&b_ll->l_head->l_hatom);
	long b2 = hatom_getdouble(&b_ll->l_head->l_next->l_hatom);
	
	if (manhattan_distance(build_tonnetz_pt_coord(a1, a2),  x->last_selected_pt) <=
		manhattan_distance(build_tonnetz_pt_coord(b1, b2),  x->last_selected_pt))
		return 1;
	else
		return 0;
}

long llll_sort_by_distance_smart(void *data, t_llllelem *a, t_llllelem *b) {
	t_tonnetz *x = (t_tonnetz *)data;
	
	t_llll *a_ll = hatom_getllll(&a->l_hatom);
	t_llll *b_ll = hatom_getllll(&b->l_hatom);
	long a1 = hatom_getdouble(&a_ll->l_head->l_hatom);
	long a2 = hatom_getdouble(&a_ll->l_head->l_next->l_hatom);
	long b1 = hatom_getdouble(&b_ll->l_head->l_hatom);
	long b2 = hatom_getdouble(&b_ll->l_head->l_next->l_hatom);
	
	t_llllelem *elem_a = (t_llllelem *)hatom_getobj(&a_ll->l_head->l_next->l_next->l_hatom);
	t_llllelem *elem_b = (t_llllelem *)hatom_getobj(&b_ll->l_head->l_next->l_next->l_hatom);
	t_llll *a_center_coord = hatom_getllll(&hatom_getllll(&elem_a->l_hatom)->l_head->l_next->l_next->l_next->l_next->l_next->l_next->l_hatom);
	t_llll *b_center_coord = hatom_getllll(&hatom_getllll(&elem_b->l_hatom)->l_head->l_next->l_next->l_next->l_next->l_next->l_next->l_hatom);
	
//	if (!a_center_coord || !b_center_coord) 
//		return 1;
	
	double a_x = hatom_getdouble(&a_center_coord->l_head->l_hatom);
	double a_y = hatom_getdouble(&a_center_coord->l_head->l_next->l_hatom);
	double b_x = hatom_getdouble(&b_center_coord->l_head->l_hatom);
	double b_y = hatom_getdouble(&b_center_coord->l_head->l_next->l_hatom);
	
	double width = x->graphical_center.x * 2;
	double height = x->graphical_center.y * 2;
	
	char a_is_inscreen = (a_x > x->point_radius && a_x < width - x->point_radius) && (a_y > x->point_radius && a_y < height - x->point_radius);
	char b_is_inscreen = (b_x > x->point_radius && b_x < width - x->point_radius) && (b_y > x->point_radius && b_y < height - x->point_radius);

	char distance_is_better = (manhattan_distance(build_tonnetz_pt_coord(a1, a2),  x->last_selected_pt) <=
							   manhattan_distance(build_tonnetz_pt_coord(b1, b2),  x->last_selected_pt) ? 1 : 0);
	
	if ((distance_is_better && (a_is_inscreen || !b_is_inscreen)) || (!distance_is_better && a_is_inscreen && !b_is_inscreen))
		return 1;
	else
		return 0;
}

// also frees coord_llll
void set_velocities_from_intermediate_coordinates_llll(t_tonnetz *x, t_llll *coord_llll, long velocity_value)
{
	t_llllelem *elem; 
	for (elem = coord_llll->l_head; elem; elem = elem->l_next)
	{
		t_llllelem *llll_head = hatom_getllll(&elem->l_hatom)->l_head;
		long c1 = hatom_getlong(&llll_head->l_hatom);
		long c2 = hatom_getlong(&llll_head->l_next->l_hatom);
		if (ARE_COORD_IN_VEL_MATRIX(c1, c2)) { 
			x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] = velocity_value;
			
			if (velocity_value > 0 && elem == coord_llll->l_tail) {
				x->last_selected_pt.coord1 = c1;
				x->last_selected_pt.coord2 = c2;
			}
		}
	}
}

void handle_match_modes(t_tonnetz *x, t_llll **coord_llll)
{
	if (x->match_mode == k_TONNETZ_MATCH_MODE_MOST_CENTRAL_MATCH) {
		llll_mergesort_inplace(coord_llll, (sort_fn)llll_sort_by_distance_from_center, x);
		llll_free(llll_slice(*coord_llll, 1));
	} else if (x->match_mode == k_TONNETZ_MATCH_MODE_NEAREST_MELODICAL_MATCH) {
		llll_mergesort_inplace(coord_llll, (sort_fn)llll_sort_by_distance_from_last_selected_point, x);
		llll_free(llll_slice(*coord_llll, 1));
	} else if (x->match_mode == k_TONNETZ_MATCH_MODE_SMART) {
		llll_mergesort_inplace(coord_llll, (sort_fn)llll_sort_by_distance_smart, x);
		llll_free(llll_slice(*coord_llll, 1));
	}
}


void handle_found_coordinates(t_tonnetz *x, t_llll **coord_out, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion, 
							  char only_return_lattice_elems_with_nonnegative_velocity)
{
	t_llllelem *elem;
	if (!for_deletion)
		handle_match_modes(x, coord_out);
	
	if (found_lattice_elems && (*coord_out)->l_head) 
		for (elem = (*coord_out)->l_head; elem; elem = elem->l_next) {
			if (only_return_lattice_elems_with_nonnegative_velocity) {
				t_llll *this_ll = hatom_getllll(&elem->l_hatom);
				long c1 = hatom_getlong(&this_ll->l_head->l_hatom);
				long c2 = hatom_getlong(&this_ll->l_head->l_next->l_hatom);
				if (ARE_COORD_IN_VEL_MATRIX(c1, c2)) 
					if (x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] >= 0)
						llll_appendobj(found_lattice_elems, hatom_getobj(&hatom_getllll(&elem->l_hatom)->l_tail->l_hatom), 0, WHITENULL_llll);
			} else
				llll_appendobj(found_lattice_elems, hatom_getobj(&hatom_getllll(&elem->l_hatom)->l_tail->l_hatom), 0, WHITENULL_llll);
		}
	
	if (also_set_velocity) 
		set_velocities_from_intermediate_coordinates_llll(x, *coord_out, velocity_value);
	
	for (elem = (*coord_out)->l_head; elem; elem = elem->l_next)
		llll_free(llll_slice(hatom_getllll(&elem->l_hatom), 2));
}




// only_return_lattice_elements_with_nonnegative_velocity only returns in the found_lattice_elems only the elements whose velocity is nonnegative
// negative velocity is a tweak used to signal that a velocity has been zeroed out via a "replace" command. In such a way,
// when "replace" is called, we only put in the "found_lattice_elems" (for "echo" output) the elements which were NOT present in the previous state.
t_llll *get_coordinates_from_midicents(t_tonnetz *x, double midicents, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion,
									   char only_return_lattice_elems_with_nonnegative_velocity)
{
	t_llllelem *elem;
	t_llll *coord_out = llll_get();

	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		if (x->only_return_inscreen_coordinates && !is_tonnetz_data_elem_in_screen(x, elem))
			break;
		
		t_llll *ll = hatom_getllll(&elem->l_hatom);
		double this_midicents = hatom_getdouble(&ll->l_head->l_next->l_next->l_hatom);
		if (((long)round(this_midicents)) == ((long)round(midicents))) {
			t_llll *to_append;
			to_append = llll_clone(hatom_getllll(&ll->l_head->l_hatom));
			llll_appendobj(to_append, elem, 0, WHITENULL_llll);
			llll_appendllll(coord_out, to_append, 0, WHITENULL_llll);
		}
	}
	
	handle_found_coordinates(x, &coord_out, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
	
	return coord_out;
}

t_llll *get_coordinates_from_diatonic_interval(t_tonnetz *x, t_llll *interval, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion,
											   char only_return_lattice_elems_with_nonnegative_velocity)
{
	t_llllelem *elem;
	t_llll *coord_out = llll_get();

	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		if (x->only_return_inscreen_coordinates && !is_tonnetz_data_elem_in_screen(x, elem))
			break;

		t_llll *ll = hatom_getllll(&elem->l_hatom);
		t_llll *this_interval = hatom_getllll(&ll->l_head->l_next->l_next->l_next->l_next->l_next->l_hatom);
		if (llll_eq_ignoretype(this_interval, interval)) {
			t_llll *to_append;
			to_append = llll_clone(hatom_getllll(&ll->l_head->l_hatom));
			llll_appendobj(to_append, elem, 0, WHITENULL_llll);
			llll_appendllll(coord_out, to_append, 0, WHITENULL_llll);
		}
	}

	handle_found_coordinates(x, &coord_out, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
	
	return coord_out;
}


t_llll *get_coordinates_from_pitch(t_tonnetz *x, t_pitch pitch, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion,
                                      char only_return_lattice_elems_with_nonnegative_velocity)
{
    long screen_mc = pitch.toMC_wo_accidental();
    t_rational screen_acc = pitch.alter();
    
    t_llll *res;
    if (x->mode == 2) {
        // wrapped lattice, pitches are irrelevant
        res = get_coordinates_from_midicents(x, screen_mc + rat2double(screen_acc) * 200, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
    } else {
        t_tonnetz_diatonic_interval interval = tonnetz_get_diatonic_interval_from_pitch(x, pitch - x->pitch_center);
        t_llll *temp = llll_get();
        llll_appendlong(temp, interval.diatonic_steps, 0, WHITENULL_llll);
        if (!x->purely_diatonic)
            llll_appendlong(temp, interval.chromatic_steps, 0, WHITENULL_llll);
        res = get_coordinates_from_diatonic_interval(x, temp, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
        llll_free(temp);
    }
    return res;
}


t_llll *get_coordinates_from_notename(t_tonnetz *x, t_symbol *notename, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion,
									  char only_return_lattice_elems_with_nonnegative_velocity)
{
	long screen_mc;
	t_rational screen_acc;
	notename2midicents(x->middleC_octave, NULL, notename->s_name, &screen_mc, &screen_acc);
	
	t_llll *res;
	if (x->mode == 2) {
		res = get_coordinates_from_midicents(x, screen_mc + rat2double(screen_acc) * 200, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
	} else {
		t_tonnetz_diatonic_interval interval = screen_midicents_and_accidental_to_diatonic_interval(screen_mc, screen_acc, x->modulo);
		t_llll *temp = llll_get();
		llll_appendlong(temp, interval.diatonic_steps, 0, WHITENULL_llll);
		if (!x->purely_diatonic)
			llll_appendlong(temp, interval.chromatic_steps, 0, WHITENULL_llll);
		res = get_coordinates_from_diatonic_interval(x, temp, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
		llll_free(temp);
	}
	return res;
}

t_llll *get_coordinates_from_pitchclasses(t_tonnetz *x, long pc, long also_set_velocity, long velocity_value, t_llll *found_lattice_elems, char for_deletion,
										  char only_return_lattice_elems_with_nonnegative_velocity)
{
	t_llllelem *elem;
	t_llll *coord_out = llll_get();

	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		t_llll *ll = hatom_getllll(&elem->l_hatom);
		if (x->only_return_inscreen_coordinates && !is_tonnetz_data_elem_in_screen(x, elem))
			break;

		long this_pc = hatom_getlong(&ll->l_head->l_next->l_next->l_next->l_next->l_hatom);
		if (this_pc == pc) {
			t_llll *to_append;
			to_append = llll_clone(hatom_getllll(&ll->l_head->l_hatom));
			llll_appendobj(to_append, elem, 0, WHITENULL_llll);
			llll_appendllll(coord_out, to_append, 0, WHITENULL_llll);
		}
	}
	
	handle_found_coordinates(x, &coord_out, also_set_velocity, velocity_value, found_lattice_elems, for_deletion, only_return_lattice_elems_with_nonnegative_velocity);
	
	return coord_out;
}

t_llllelem *coordinates_to_node_lattice_llllelem(t_tonnetz *x, t_llll *coordinates)
{
    if (coordinates->l_size >= 2) {
        long c1 = hatom_getlong(&coordinates->l_head->l_hatom);
        long c2 = hatom_getlong(&coordinates->l_head->l_next->l_hatom);
        
        if (ARE_COORD_IN_VEL_MATRIX(c1, c2))
            return x->tonnetz_elems[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)];
    }
	return NULL;

}

void clear_velocities(t_tonnetz *x)
{
	long i, j;
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
		for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
			x->velocities[i][j] = 0;
}

void clear_velocities_but_put_nonzero_ones_to_minus_one(t_tonnetz *x)
{
	long i, j;
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
		for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
			x->velocities[i][j] = (x->velocities[i][j] > 0 ? -1 : 0);
}


void set_add_or_remove_selected_points(t_tonnetz *x, t_llll **inllll, long inlet)
{
	t_llllelem *elem, *elemv;
	t_llll *vels = NULL;
	char delete_selected = false;
	char echo = (x->echo && !x->creating_new_obj) ? true : false;
	char replace_mode = false;
	
	if (hatom_gettype(&(*inllll)->l_head->l_hatom) == H_SYM && hatom_getsym(&(*inllll)->l_head->l_hatom) == _sym_add) {
		llll_behead((*inllll));
		
	} else if (hatom_gettype(&(*inllll)->l_head->l_hatom) == H_SYM && hatom_getsym(&(*inllll)->l_head->l_hatom) == _sym_replace) {
		// replace mode clears the existing velocity but also (if "echo" is active) sends the note off of the note which have been turned off.
		// N.B.: Noteoff is not sent for ALL notes: only for those which are not re-added.
		replace_mode = true;
		clear_velocities_but_put_nonzero_ones_to_minus_one(x); // minus one is a hack we use to say: don't echo it, it was already there!!
		llll_behead(*inllll);

	} else if (hatom_gettype(&(*inllll)->l_head->l_hatom) == H_SYM && hatom_getsym(&(*inllll)->l_head->l_hatom) == _sym_delete) {
		llll_behead(*inllll);
		delete_selected = true;
	
	} else {
		if (x->autoclear)
			clear_velocities(x);
	}
	
	if ((*inllll)->l_head && hatom_gettype(&(*inllll)->l_head->l_hatom) == H_SYM && hatom_getsym(&(*inllll)->l_head->l_hatom) == gensym("setfromcoordinates")) { 
		llll_behead(*inllll);
		inlet = 3;
	}
	
	vels = llllobj_get_store_contents((t_object *) x, LLLL_OBJ_UI, 1, 1);
	
	systhread_mutex_lock(x->c_mutex);
	x->num_selected_points = 0;
	
	
	if (!delete_selected && ((inlet < 2 && (*inllll)->l_depth > 1) || (inlet >= 3 && (*inllll)->l_depth > 2))) { 
		// vels are interleaved with (pt vel) (pt vel)...
		t_llll *trans = llll_trans((*inllll), 2);
		if (trans->l_head && trans->l_head->l_next && hatom_gettype(&trans->l_head->l_next->l_hatom) == H_LLLL) {
			llll_clear(vels);
			vels = llll_clone(hatom_getllll(&trans->l_head->l_next->l_hatom));
			if (hatom_gettype(&trans->l_head->l_hatom) == H_LLLL)
				*inllll = llll_clone(hatom_getllll(&trans->l_head->l_hatom));
			else 
				*inllll = NULL;
		} else 
			*inllll = NULL;
		llll_free(trans);
	}
	
	if (!(*inllll)) { // wrong syntax
		object_error((t_object *)x, "Wrong input syntax!");	
		systhread_mutex_unlock(x->c_mutex);
		llll_free(vels);
		return;
	}
	
	
	t_llll *lllls_to_echo = llll_get();
	
	for (elem = (*inllll)->l_head, elemv = vels ? vels->l_head : NULL; elem && x->num_selected_points < CONST_MAX_POINTS - 1; elem = elem->l_next, elemv = elemv ? elemv->l_next : NULL) {
		// velocity
		long vel;
		if (delete_selected)
			vel = 0;
		else {
			vel = (elemv && is_hatom_number(&elemv->l_hatom)) ? hatom_getlong(&elemv->l_hatom) : CONST_DEFAULT_VELOCITY;
			vel = CLAMP(vel, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
		}
		
		t_llll *coordinates = NULL;
		t_llll *lattice_elems = NULL;
		
		if (echo)
			lattice_elems = llll_get();
		
		// node detection
		if (inlet == 0) { // midicents or note names or diatonic steps
			if (is_hatom_number(&elem->l_hatom)) {
				coordinates = get_coordinates_from_midicents(x, hatom_getdouble(&elem->l_hatom), true, vel, echo ? lattice_elems : NULL, delete_selected, replace_mode);
            } else if (hatom_gettype(&elem->l_hatom) == H_PITCH) {
                coordinates = get_coordinates_from_pitch(x, hatom_getpitch(&elem->l_hatom), true, vel, echo ? lattice_elems : NULL, delete_selected, replace_mode);
			} else if (hatom_gettype(&elem->l_hatom) == H_SYM) {
				coordinates = get_coordinates_from_notename(x, hatom_getsym(&elem->l_hatom), true, vel, echo ? lattice_elems : NULL, delete_selected, replace_mode);
			}
		} else if (inlet == 1) { // pitch-classes
			coordinates = get_coordinates_from_pitchclasses(x, hatom_getlong(&elem->l_hatom), true, vel, echo ? lattice_elems : NULL, delete_selected, replace_mode);
		} else if (inlet == 2) { // diatonic intervals
			coordinates = get_coordinates_from_diatonic_interval(x, hatom_getllll(&elem->l_hatom), true, vel, echo ? lattice_elems : NULL, delete_selected, replace_mode);
		} else if (inlet == 3) { // coordinates 
			if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
				t_llll *ll = hatom_getllll(&elem->l_hatom);
				if (echo) {
					coordinates = llll_clone(ll);
					t_llllelem *el = coordinates_to_node_lattice_llllelem(x, ll);
					if (el) {
						if (replace_mode) {
							long c1 = hatom_getlong(&ll->l_head->l_hatom);
							long c2 = hatom_getlong(&ll->l_head->l_next->l_hatom);
							if (ARE_COORD_IN_VEL_MATRIX(c1, c2) && x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] >= 0)					
								llll_appendobj(lattice_elems, el, 0, WHITENULL_llll);
						} else
							llll_appendobj(lattice_elems, el, 0, WHITENULL_llll);
					}
				}
				if (ll && ll->l_head && ll->l_head->l_next && is_hatom_number(&ll->l_head->l_hatom) && is_hatom_number(&ll->l_head->l_next->l_hatom)) {
					long c1 = hatom_getlong(&ll->l_head->l_hatom);
					long c2 = hatom_getlong(&ll->l_head->l_next->l_hatom);
					if (ARE_COORD_IN_VEL_MATRIX(c1, c2)) 
						x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] = vel;					
				}
			}
		}	
		
		// echo?
		if (echo) {
			if (lattice_elems) {
				t_llllelem *elem2;
				for (elem2 = lattice_elems->l_head; elem2; elem2 = elem2->l_next) {
					t_llllelem *getinfo = (t_llllelem *)hatom_getobj(&elem2->l_hatom);
					if (getinfo){
						t_llll *this_echo = tonnetz_node_as_llllelem_to_point_info_for_output(x, getinfo, gensym("echo"));
						llll_appendobj(lllls_to_echo, this_echo, 0, WHITENULL_llll);
					}
				}
				llll_free(lattice_elems);
			}
		}
			
		llll_free(coordinates);
		
	}
	
	if (replace_mode && echo) {
		// echoing note offs
		long i, j;
		for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
			for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
				if (x->velocities[i][j] < 0) {
					t_llll *coord = long_couple_to_llll(i - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET, j - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET);
					t_llllelem *getinfo = coordinates_to_node_lattice_llllelem(x, coord);
					x->velocities[i][j] = 0;
					if (getinfo){
						t_llll *this_echo = tonnetz_node_as_llllelem_to_point_info_for_output(x, getinfo, gensym("echo"));
						llll_appendobj(lllls_to_echo, this_echo, 0, WHITENULL_llll);
					}
					llll_free(coord);
				}
	}
	
	jbox_redraw((t_jbox *)x);
	systhread_mutex_unlock(x->c_mutex);

	for (elem = lllls_to_echo->l_head; elem; elem = elem->l_next) {
		t_llll *this_echo = (t_llll *)hatom_getobj(&elem->l_hatom);
		llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 6, this_echo);
		llll_free(this_echo);
	}
	
	llll_free(lllls_to_echo);
	
	if (vels) 
		llll_free(vels);
}

void tonnetz_anything(t_tonnetz *x, t_symbol *s, long argc, t_atom *argv){ //argv+1
	
	long inlet = proxy_getinlet((t_object *) x);
	
	if (inlet == 5 && argc) {
		// change modulo
		object_attr_setlong(x, gensym("modulo"), atom_getlong(argv));

	} else if (s == _sym_clear && inlet == 0) {
		// clear tonnetz
		clear_velocities(x);

	} else if (inlet == 4) {	
		// keep velocities
		llllobj_parse_and_store((t_object *) x, LLLL_OBJ_UI, s, argc, argv, 1);

	} else if (inlet <= 3) {
		// add points
		t_llll *inllll = llllobj_parse_llll((t_object *) x, LLLL_OBJ_UI, s, argc, argv, LLLL_PARSE_CLONE);
//		llll_check(inllll);
		if (inllll && inllll->l_head && hatom_gettype(&inllll->l_head->l_hatom) == H_SYM && hatom_getsym(&inllll->l_head->l_hatom) == gensym("rotate")) {
			if (inllll->l_head->l_next) {
				long howmuch = is_hatom_number(&inllll->l_head->l_next->l_hatom) ? hatom_getlong(&inllll->l_head->l_next->l_hatom) : 0;
				long i;
				for (i = 0; i < labs(howmuch); i++)
					rotate_tonnetz_selected_points(x, isign(howmuch) >= 0 ? true : false);
			}

		} else if (inllll && inllll->l_head && hatom_gettype(&inllll->l_head->l_hatom) == H_SYM && hatom_getsym(&inllll->l_head->l_hatom) == gensym("translate")) {
			if (inllll->l_head->l_next) {
				long coord1 = is_hatom_number(&inllll->l_head->l_next->l_hatom) ? hatom_getlong(&inllll->l_head->l_next->l_hatom) : 0;
				long coord2 = inllll->l_head->l_next->l_next && is_hatom_number(&inllll->l_head->l_next->l_next->l_hatom) ? hatom_getlong(&inllll->l_head->l_next->l_next->l_hatom) : 0;
				translate_tonnetz_selected_points(x, coord1, coord2);
			}
			
		} else if (inllll && inllll->l_head && inllll->l_head->l_next && hatom_gettype(&inllll->l_head->l_hatom) == H_SYM && hatom_getsym(&inllll->l_head->l_hatom) == gensym("getnodeinfo")) {
			t_llll *getinfo_llll = llll_get();
			t_llll *lllls_to_output = llll_get();
			t_llllelem *elem;
			

			llll_behead(inllll);
			
			systhread_mutex_lock(x->c_mutex);
			
			if (inlet == 0 && hatom_gettype(&inllll->l_head->l_hatom) == H_SYM) {
				llll_free(get_coordinates_from_notename(x, hatom_getsym(&inllll->l_head->l_hatom), false, 0, getinfo_llll, false, false));
			} else if (inlet == 0 && is_hatom_number(&inllll->l_head->l_hatom)) {
				llll_free(get_coordinates_from_midicents(x, hatom_getdouble(&inllll->l_head->l_hatom), false, 0, getinfo_llll, false, false));
			} else if (inlet == 1) {
				llll_free(get_coordinates_from_pitchclasses(x, hatom_getlong(&inllll->l_head->l_hatom), false, 0, getinfo_llll, false, false));
			} else if (inlet == 2) {
				llll_free(get_coordinates_from_diatonic_interval(x, inllll, false, 0, getinfo_llll, false, false));
			} else if (inlet == 3) {
				t_llllelem *getinfo_el = coordinates_to_node_lattice_llllelem(x, inllll);
				llll_appendobj(getinfo_llll, getinfo_el, 0, WHITENULL_llll);
			}
			
			for (elem = getinfo_llll->l_head; elem; elem = elem->l_next) {
				t_llllelem *getinfo = (t_llllelem *)hatom_getobj(&elem->l_hatom);
				if (getinfo){
					t_llll *this_output = tonnetz_node_as_llllelem_to_point_info_for_output(x, getinfo, gensym("nodeinfo"));
					llll_appendobj(lllls_to_output, this_output, 0, WHITENULL_llll);
				}
			}
			
			systhread_mutex_unlock(x->c_mutex);
			
			
			for (elem = lllls_to_output->l_head; elem; elem = elem->l_next) {
				t_llll *this_output = (t_llll *)hatom_getobj(&elem->l_hatom);
				llllobj_outlet_llll((t_object *) x, LLLL_OBJ_UI, 6, this_output);
				llll_free(this_output);
			}

			llll_free(getinfo_llll);
			llll_free(lllls_to_output);
				
		} else if (inllll && inllll->l_head) {
			set_add_or_remove_selected_points(x, &inllll, inlet);

		}
		llll_free(inllll);
	}
	jbox_redraw((t_jbox *) x);
}

t_tonnetz* tonnetz_new(t_symbol *s, long argc, t_atom *argv)
{
	t_tonnetz* x = NULL;
	t_max_err err = MAX_ERR_GENERIC;
	t_dictionary *d;
	long flags;
	t_object *textfield;

	if (!(d=object_dictionaryarg(argc,argv)))
		return NULL;

	x = (t_tonnetz*) object_alloc_debug(s_tonnetz_class);
	flags = 0 
			| JBOX_DRAWFIRSTIN 
			| JBOX_NODRAWBOX
			| JBOX_DRAWINLAST
	//		| JBOX_TRANSPARENT	
	//		| JBOX_NOGROW
	//		| JBOX_GROWY
			| JBOX_GROWBOTH
			| JBOX_HILITE
	//		| JBOX_BACKGROUND
			| JBOX_TEXTFIELD
	//		| JBOX_DRAWBACKGROUND
	//		| JBOX_DEFAULTNAMES
	//		| JBOX_MOUSEDRAGDELTA
			;
	

	err = jbox_new(&x->j_box.l_box, flags, argc, argv); 
	x->j_box.l_box.b_firstin = (t_object*) x;
	x->creating_new_obj = true;
	x->purely_diatonic_scale_intervals = llll_from_text_buf((char *) "200 200 100 200 200 200 100");
	x->purely_diatonic_scale_freq_ratios = llll_from_text_buf((char *) "9/8 5/4 4/3 3/2 5/3 15/8 2/1");

    x->diatonic_center_as_llll = llll_get();
    
	x->n_proxy[5] = proxy_new_debug((t_object *) x, 5, &x->n_in);
	x->n_proxy[4] = proxy_new_debug((t_object *) x, 4, &x->n_in);
	x->n_proxy[3] = proxy_new_debug((t_object *) x, 3, &x->n_in);
	x->n_proxy[2] = proxy_new_debug((t_object *) x, 2, &x->n_in);
	x->n_proxy[1] = proxy_new_debug((t_object *) x, 1, &x->n_in);

	x->last_selected_pt.coord1 = x->last_selected_pt.coord2 = 0;
	x->center = x->graphical_center = build_pt(0, 0);
	x->center_offset[0] = x->center_offset[1] = 0;
	x->j_mouse_cursor = BACH_CURSOR_DEFAULT;
	
	x->tonnetz_data = llll_get();
	x->num_selected_points = 0;
	x->show_focus = 1;
	x->velocity_handling = 1;
	x->is_velocity_dragging = -1;
	x->generators_as_llll = llll_from_text_buf((char *)"(4 7) (2 4)");
	x->generators[0].diatonic_steps = 4;
	x->generators[0].chromatic_steps = 7;
	x->generators[0].frequency_ratio = genrat(3, 2);
	x->generators[0].user_defined_ratio = false;
	x->generators[1].diatonic_steps = 2;
	x->generators[1].chromatic_steps = 4;
	x->generators[1].frequency_ratio = genrat(5, 4);
	x->generators[1].user_defined_ratio = false;
	x->modulo = 12;
	
	// allocating memory
	long i;
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++) {
		x->velocities[i] = (char *)bach_newptrclear(CONST_MAX_VELOCITY_POINTS_PER_DIMENSION * sizeof(char));
		x->tonnetz_elems[i] = (t_llllelem **)bach_newptrclear(CONST_MAX_VELOCITY_POINTS_PER_DIMENSION * sizeof(t_llllelem *));
	}
	
	
	// mutex
	systhread_mutex_new_debug(&x->c_mutex, 0);
	
	// retrieve saved attribute values
	attr_dictionary_process(x, d);
	
	textfield = jbox_get_textfield((t_object *) x);  // JUST TO HAVE A TEXT ATTRIBUTE READY
	if (textfield) {
		textfield_set_noactivate(textfield, 1);
		textfield_set_editonclick(textfield, 0);			// set it to 0 if you don't want user to edit it in lock mode
		textfield_set_textmargins(textfield, 3, 3, 3, 3);	// margin on each side
	}

	llllobj_jbox_setup((t_llllobj_jbox *) x, 6, "b4i44444");

	jbox_ready(&x->j_box.l_box);

	if (x) {
		t_llll *llll_for_rebuild = llll_retrieve_from_dictionary(d, "whole_tonnetz_data");
		
		if (llll_for_rebuild) { // new method
			llllobj_manage_dict_llll((t_object *)x, LLLL_OBJ_UI, llll_for_rebuild);
			set_add_or_remove_selected_points(x, &llll_for_rebuild, 3);
			llll_free(llll_for_rebuild);
		}

		calculate_static_tonnetz(x);

		x->creating_new_obj = false;
        llllobj_set_current_version_number_and_ss((t_object *) x, LLLL_OBJ_UI);
		return x;
	}

	object_free_debug(x);
	return NULL;
}

void tonnetz_free(t_tonnetz *x){
	long i;
	
	for (i = 1; i < 6; i++)
		object_free_debug(x->n_proxy[i]);
	
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++) {
		bach_freeptr(x->velocities[i]);
		bach_freeptr(x->tonnetz_elems[i]);
	}
    llll_free(x->diatonic_center_as_llll);
	llll_free(x->generators_as_llll);
	llll_free(x->tonnetz_data);
	llll_free(x->purely_diatonic_scale_intervals);
	llll_free(x->purely_diatonic_scale_freq_ratios);

	if (x->surface_lexpr)
		lexpr_free(x->surface_lexpr);
	
	jbox_free(&x->j_box.l_box);
	
	systhread_mutex_free_debug(x->c_mutex);
	llllobj_jbox_free((t_llllobj_jbox *) x);
}



double purely_diatonic_interval_to_midicents(t_tonnetz *x, t_tonnetz_diatonic_interval purely_diatonic_interval)
{
    long screen_midicents = x->pitch_center.toMC_wo_accidental();
    t_rational screen_acc = x->pitch_center.alter();
	double mc = screen_midicents + rat2double(rat_long_prod(screen_acc, 200));
	long interval_modulo = positive_mod(purely_diatonic_interval.diatonic_steps, (long)x->purely_diatonic_scale_intervals->l_size);
	long interval_base = (purely_diatonic_interval.diatonic_steps - interval_modulo) / ((long)x->purely_diatonic_scale_intervals->l_size);

	mc += interval_base * x->purely_diatonic_scale_modulo;
	t_llllelem *elem;
	long count;
	for (elem = x->purely_diatonic_scale_intervals->l_head, count = 0; elem && count < interval_modulo; elem = elem->l_next, count++)
		mc += hatom_getdouble(&elem->l_hatom);
	return mc;
}


t_rational purely_diatonic_interval_to_freqratio(t_tonnetz *x, t_tonnetz_diatonic_interval purely_diatonic_interval)
{
	t_rational res = long2rat(1);
	long interval_modulo = positive_mod(purely_diatonic_interval.diatonic_steps, x->purely_diatonic_scale_intervals->l_size);
	long interval_base = (purely_diatonic_interval.diatonic_steps - interval_modulo) / x->purely_diatonic_scale_intervals->l_size;
	
	t_llllelem *last_elem = llll_getindex(x->purely_diatonic_scale_freq_ratios, x->purely_diatonic_scale_intervals->l_size, I_STANDARD);
	t_llllelem *modulo_elem = llll_getindex(x->purely_diatonic_scale_freq_ratios, interval_modulo, I_STANDARD);
	
	if (last_elem && interval_base != 0) 
		res = rat_rat_prod(res, rat_long_pow(hatom_getrational(&last_elem->l_hatom), interval_base));
	if (modulo_elem && interval_modulo != 0)
		res = rat_rat_prod(res, hatom_getrational(&modulo_elem->l_hatom));
	return res;
}


void purely_diatonic_interval_to_notename(t_tonnetz *x, t_tonnetz_diatonic_interval interval, char also_put_octave, char **buf)
{
	double mc;
	long screen_mc;
	t_rational screen_acc;

	mc = purely_diatonic_interval_to_midicents(x, interval);	
	if (!also_put_octave)
		mc = 6000 + fmod(mc, 1200);

	mc_to_screen_approximations_do(x->modulo / 6, k_ACCIDENTALS_AUTO, mc, &screen_mc, &screen_acc, NULL, NULL);
	midicents2notename(x->middleC_octave, screen_mc, screen_acc, x->note_names_style, true, buf);

	if (!also_put_octave && strlen(*buf) > 1)
		(*buf)[strlen(*buf)-1] = 0;
}

void diatonic_interval_to_notename(t_tonnetz *x, t_tonnetz_diatonic_interval interval, char also_put_octave, char **buf)
{
	long screen_midicents = 6000;
	t_rational screen_acc = long2rat(0);
	if (x->purely_diatonic) {
		double mc = purely_diatonic_interval_to_midicents(x, interval);
		mc_to_screen_approximations_do(x->modulo / 6, k_ACCIDENTALS_AUTO, mc, &screen_midicents, &screen_acc, NULL, NULL);
	} else
		diatonic_interval_to_screen_midicents_and_accidental(interval, &screen_midicents, &screen_acc, x->modulo);
	
	if (x->mode == k_TONNETZ_MODE_EQUALLY_TEMPERED_WRAPPED_LATTICE) { // wrapped
		double mc = screen_midicents + rat2double(screen_acc)*200;

		if (!also_put_octave)
			mc = 6000 + fmod(mc, 1200);
		ezmidicents2notename(x->middleC_octave, mc, x->note_names_style, true, buf, x->modulo/6);
		if (!also_put_octave && strlen(*buf) > 1)
			(*buf)[strlen(*buf)-1] = 0;

	} else {
		
		if (!also_put_octave)
			screen_midicents = 6000 + (screen_midicents % 1200);
		midicents2notename(x->middleC_octave, screen_midicents, screen_acc, x->note_names_style, true, buf);
		if (!also_put_octave && strlen(*buf) > 1)
			(*buf)[strlen(*buf)-1] = 0;
	}
}

void tonnetz_ezmidicents_to_notename(t_tonnetz *x, double midicents, char also_put_octave, char **buf)
{
	if (!also_put_octave)
		midicents = 6000 + fmod(midicents, 1200.);
	ezmidicents2notename(x->middleC_octave, midicents, x->note_names_style, true, buf, x->modulo / 6);
	if (!also_put_octave && strlen(*buf) > 1)
		(*buf)[strlen(*buf)-1] = 0;
}


void build_tonnetz_point(t_tonnetz *x, double center_x, double center_y, t_tonnetz_diatonic_interval interval, t_tonnetz_pt_coord coord, char pt_is_in_screen)
{
	// =====================================
	// Storing point information
	// =====================================
	t_llll *this_point = llll_get();
	t_tonnetz_diatonic_interval interval_plus_center = diatonic_interval_sum_no_freqratio(interval, x->diatonic_center);
	
	// 1. coordinates
	t_llll *coords = llll_get();
	llll_appendlong(coords, coord.coord1, 0, WHITENULL_llll);
	llll_appendlong(coords, coord.coord2, 0, WHITENULL_llll);
	llll_appendllll(this_point, coords, 0, WHITENULL_llll);
	
	// 2. diatonic interval with respect to middle C
	t_llll *diatonic_int = llll_get();
	llll_appendlong(diatonic_int, interval_plus_center.diatonic_steps, 0, WHITENULL_llll);
	if (!x->purely_diatonic)
		llll_appendlong(diatonic_int, interval_plus_center.chromatic_steps, 0, WHITENULL_llll);
	llll_appendllll(this_point, diatonic_int, 0, WHITENULL_llll);
	
	// 3. midicents
	double midicents = 6000;
	switch (x->mode) {
		case k_TONNETZ_MODE_JUST_INTONATION_INFINITE_LATTICE: // just intonation or custom intonation
		{
			long center_mc;
			t_rational center_acc;
			t_rational freq_ratio = rat_rat_prod(rat_long_pow(x->generators[0].frequency_ratio, coord.coord1), rat_long_pow(x->generators[1].frequency_ratio, coord.coord2));
			diatonic_interval_to_screen_midicents_and_accidental(x->diatonic_center, &center_mc, &center_acc, x->modulo);
			center_mc += rat2double(center_acc) * 200;
			double mc = freqratio_to_mc(freq_ratio);
			midicents = round(center_mc + mc);
			break;
		} 

		case k_TONNETZ_MODE_PITCH_SURFACE: // surface equation
		{
			t_hatom vars[2];
			t_hatom *res = NULL;
			hatom_setlong(vars, coord.coord1);
			hatom_setlong(vars + 1, coord.coord2);
			if (x->surface_lexpr) {
				res = lexpr_eval(x->surface_lexpr, vars);
				midicents = hatom_getdouble(res);
			} 
			bach_freeptr(res);
			break;
		} 
			
		default:
		{
			long screen_midicents = 6000;
			t_rational screen_acc = long2rat(0);
			if (x->purely_diatonic) {
				double mc = purely_diatonic_interval_to_midicents(x, interval);
				mc_to_screen_approximations_do(x->modulo / 6, k_ACCIDENTALS_AUTO, mc, &screen_midicents, &screen_acc, NULL, NULL);
			} else
				diatonic_interval_to_screen_midicents_and_accidental(interval_plus_center, &screen_midicents, &screen_acc, x->modulo);
			midicents = screen_midicents + rat2double(screen_acc) * 200;
			break;
		}
	}
	llll_appenddouble(this_point, midicents, 0, WHITENULL_llll);
	
	// 4. freq ratio
	if (TONNETZ_COMPUTE_FREQ_RATIOS) {
		t_rational freq_ratio;
		if (x->purely_diatonic)
			freq_ratio = purely_diatonic_interval_to_freqratio(x, interval);
		else
			freq_ratio = interval.frequency_ratio; // rat_rat_prod(rat_long_pow(x->generators[0].frequency_ratio, coord.coord1), rat_long_pow(x->generators[1].frequency_ratio, coord.coord2));
		llll_appendrat(this_point, freq_ratio, 0, WHITENULL_llll);
	} else 
		llll_appendlong(this_point, 0, 0, WHITENULL_llll);
	
	// 5. pitch class
	llll_appendlong(this_point, mc_to_pitch_class(midicents, x->modulo), 0, WHITENULL_llll);
	
	// 6. diatonic interval with respect to the center
	t_llll *diatonic_int2 = llll_get();
	llll_appendlong(diatonic_int2, interval.diatonic_steps, 0, WHITENULL_llll);
	llll_appendlong(diatonic_int2, interval.chromatic_steps, 0, WHITENULL_llll);
	llll_appendllll(this_point, diatonic_int2, 0, WHITENULL_llll);	
	
	// 7. X Y center position
	t_llll *center = llll_get();
	llll_appendlong(center, center_x, 0, WHITENULL_llll);
	llll_appendlong(center, center_y, 0, WHITENULL_llll);
	llll_appendllll(this_point, center, 0, WHITENULL_llll);
	
	// 8. in-screen flag
	llll_appendlong(this_point, pt_is_in_screen, 0, WHITENULL_llll);	
	
	t_llllelem *appended_elem = llll_appendllll(x->tonnetz_data, this_point, 0, WHITENULL_llll);
	
	if (ARE_COORD_IN_VEL_MATRIX(coord.coord1, coord.coord2))
		x->tonnetz_elems[TONNETZ_VEL_OFFSET(coord.coord1)][TONNETZ_VEL_OFFSET(coord.coord2)] = appended_elem;
}


long llll_sort_by_inscreen_and_center_x(void *dummy, t_llllelem *a, t_llllelem *b) {
	double inscreen_a = hatom_getlong(&hatom_getllll(&a->l_hatom)->l_tail->l_hatom);
	double inscreen_b = hatom_getlong(&hatom_getllll(&b->l_hatom)->l_tail->l_hatom);
	
	if (inscreen_a > inscreen_b)
		return 1;
	if (inscreen_b > inscreen_a)
		return 0;
	if (inscreen_a == inscreen_b && inscreen_a == 0)
		return 1; // we don't care for points outside the screen
	
	double center_a = hatom_getdouble(&hatom_getllll(&hatom_getllll(&a->l_hatom)->l_tail->l_prev->l_hatom)->l_head->l_hatom);
	double center_b = hatom_getdouble(&hatom_getllll(&hatom_getllll(&b->l_hatom)->l_tail->l_prev->l_hatom)->l_head->l_hatom);
	if (center_a <= center_b)
		return 1;
	else
		return 0;
}

t_tonnetz_diatonic_interval coordinates_to_diatonic_interval(t_tonnetz *x, t_tonnetz_pt_coord coord)
{
	long i;
	t_tonnetz_diatonic_interval res;
	res.diatonic_steps = res.chromatic_steps = 0;
	res.user_defined_ratio = false;
	res.frequency_ratio = long2rat(1);
	
	long abs_coord1 = labs(coord.coord1), abs_coord2 = labs(coord.coord2);
	char sign_coord1 = isign(coord.coord1), sign_coord2 = isign(coord.coord2);
	
	for (i = 0; i < abs_coord1; i++) {
		res.diatonic_steps += x->generators[0].diatonic_steps * sign_coord1;
		res.chromatic_steps += x->generators[0].chromatic_steps * sign_coord1;
		res.frequency_ratio = (sign_coord1 > 0 ? rat_rat_prod(res.frequency_ratio, x->generators[0].frequency_ratio) : 
							   rat_rat_div(res.frequency_ratio, x->generators[0].frequency_ratio));
	}

	for (i = 0; i < abs_coord2; i++) {
		res.diatonic_steps += x->generators[1].diatonic_steps * sign_coord2;
		res.chromatic_steps += x->generators[1].chromatic_steps * sign_coord2;
		res.frequency_ratio = (sign_coord1 > 0 ? rat_rat_prod(res.frequency_ratio, x->generators[1].frequency_ratio) : 
							   rat_rat_div(res.frequency_ratio, x->generators[1].frequency_ratio));
	}
	return res;
}

void refresh_tonnetz_coordinates(t_tonnetz *x, t_rect rect)
{
	double center_x = rect.width / 2;
	double center_y = rect.height / 2;
	double lattice_step = x->lattice_step * x->zoom;
	double lattice_triangle_height = x->lattice_step * x->zoom * SQRT_3/2.;
	double point_radius = x->point_radius * x->zoom;

	center_y += lattice_triangle_height * x->center_offset[1];
	center_x -= lattice_step  * x->center_offset[0] + (lattice_step / 2.) * x->center_offset[1];

	t_llllelem *elem;
	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		t_llll *ll = hatom_getllll(&elem->l_hatom);
		t_llll *coord = hatom_getllll(&ll->l_head->l_hatom);
		long row = hatom_getlong(&coord->l_head->l_hatom); // - x->center_offset[0];
		long col = hatom_getlong(&coord->l_head->l_next->l_hatom); // - x->center_offset[1];
		t_llll *center = hatom_getllll(&ll->l_tail->l_prev->l_hatom);
		double y_coord = center_y - col * lattice_triangle_height;
		double x_coord = center_x + row * lattice_step + col * lattice_step/2.;
		llll_clear(center);
		llll_appenddouble(center, x_coord, 0, WHITENULL_llll);
		llll_appenddouble(center, y_coord, 0, WHITENULL_llll);
		
		// updating "inscreen" flag
		char inscreen = (x_coord + point_radius + lattice_step > 0 && x_coord - point_radius - lattice_step < rect.width &&
						 y_coord + point_radius + lattice_step > 0 && y_coord - point_radius - lattice_step < rect.height);
		llll_betail(ll);
		llll_appendlong(ll, inscreen, 0, WHITENULL_llll);
/*		if (inscreen == 0)
			dev_post("••• scr: %ld", inscreen);
		else
			dev_post("*** insscr: %ld", inscreen); */
	}

	llll_inplacesort(x->tonnetz_data, (sort_fn)llll_sort_by_inscreen_and_center_x); //< So that everything is painted correctly (one layer over the other
	
	x->need_refresh_tonnetz_coordinates = false;
}


void calculate_static_tonnetz(t_tonnetz *x)
{
	// points
	t_tonnetz_diatonic_interval interval;
	
	t_tonnetz_pt_coord coord = build_tonnetz_pt_coord(0, 0);
	
	systhread_mutex_lock(x->c_mutex);
	
	llll_clear(x->tonnetz_data);
	
	t_tonnetz_diatonic_interval local_interval;
	t_tonnetz_pt_coord temp_coord;
	
	for (interval = build_diatonic_interval(0, 0); 
		 coord.coord2 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; 
		 interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_sum(interval, x->generators[1]) : diatonic_interval_sum_no_freqratio(interval, x->generators[1]), coord.coord2 += 1){
		
		for (temp_coord = coord, local_interval = interval; 
			 temp_coord.coord1 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET > 0; 
			 local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_diff(local_interval, x->generators[0]) : diatonic_interval_diff_no_freqratio(local_interval, x->generators[0]), temp_coord.coord1 -= 1) 
			build_tonnetz_point(x, 0, 0, local_interval, temp_coord, 0);
		
		local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_sum(interval, x->generators[0]) : diatonic_interval_sum_no_freqratio(interval, x->generators[0]);
		temp_coord = coord;
		temp_coord.coord1 += 1;
		
		for (; 
			 temp_coord.coord1 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; 
			 local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_sum(local_interval, x->generators[0]) : diatonic_interval_sum_no_freqratio(local_interval, x->generators[0]), temp_coord.coord1 += 1) 
			build_tonnetz_point(x, 0, 0, local_interval, temp_coord, 0);
	}
	
    coord.coord2 = -1; 

	for (interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_diff(build_diatonic_interval(0, 0), x->generators[1]) : diatonic_interval_diff_no_freqratio(build_diatonic_interval(0, 0), x->generators[1]); 
		 coord.coord2 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET > 0; 
		 interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_diff(interval, x->generators[1]) : diatonic_interval_diff_no_freqratio(interval, x->generators[1]), coord.coord2 -= 1){
		
		for (local_interval = interval, temp_coord = coord; 
			 temp_coord.coord1 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET > 0; 
			 local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_diff(local_interval, x->generators[0]) : diatonic_interval_diff_no_freqratio(local_interval, x->generators[0]), temp_coord.coord1 -= 1) 
			build_tonnetz_point(x, 0, 0, local_interval, temp_coord, 0);
		
		local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_sum(interval, x->generators[0]) : diatonic_interval_sum_no_freqratio(interval, x->generators[0]);
		temp_coord = coord;
		temp_coord.coord1 += 1;
		
		for (; 
			 temp_coord.coord1 + CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; 
			 local_interval = TONNETZ_COMPUTE_FREQ_RATIOS ? diatonic_interval_sum(local_interval, x->generators[0]) : diatonic_interval_sum_no_freqratio(local_interval, x->generators[0]), temp_coord.coord1 += 1) 
			build_tonnetz_point(x, 0, 0, local_interval, temp_coord, 0);
	}	

	x->need_refresh_tonnetz_coordinates = true;
	
	systhread_mutex_unlock(x->c_mutex);
}



void paint_static_lines(t_tonnetz *x, t_object *view, t_rect rect, t_jrgba j_tonnetzcolor_r)
{
    
    t_jgraphics *g = jbox_start_layer((t_object *)x, view, gensym("static_lines"), rect.width, rect.height);
    
    if (g) {
        
        double offs_x = fmod(x->center_offset[0], 1.);
        double offs_y = fmod(x->center_offset[1], 1.);
        
        double center_x = rect.width / 2;
        double center_y = rect.height / 2;
        double temp_y, temp_x1, temp_x2;
        double lattice_step = x->lattice_step * x->zoom;
        double lattice_triangle_height = x->lattice_step * x->zoom * SQRT_3/2.;

        center_y = center_y + lattice_triangle_height * offs_y;
        center_x = center_x - lattice_step  * offs_x - (lattice_step / 2.) * offs_y;
        
        // horizontal lines
        for (temp_y = center_y; temp_y > 0; temp_y -= lattice_triangle_height)
            paint_line(g, j_tonnetzcolor_r, 0, temp_y, rect.width, temp_y, x->tonnetz_line_width);
        for (temp_y = center_y + lattice_triangle_height; temp_y < rect.width; temp_y += lattice_triangle_height)
            paint_line(g, j_tonnetzcolor_r, 0, temp_y, rect.width, temp_y, x->tonnetz_line_width);
        
        // direction / lines
        for (temp_x1 = center_x - (rect.height - center_y)/SQRT_3, temp_x2 = center_x + (center_y)/SQRT_3;
             temp_x1 > 0 || temp_x2 > 0; temp_x1 -= lattice_step, temp_x2 -= lattice_step)
            paint_line(g, j_tonnetzcolor_r, temp_x1, rect.height, temp_x2, 0, x->tonnetz_line_width);
        for (temp_x1 = center_x - (rect.height - center_y)/SQRT_3 + lattice_step, temp_x2 = center_x + (center_y)/SQRT_3 + lattice_step;
             temp_x1 < rect.width || temp_x2 < rect.width; temp_x1 += lattice_step, temp_x2 += lattice_step)
            paint_line(g, j_tonnetzcolor_r, temp_x1, rect.height, temp_x2, 0, x->tonnetz_line_width);
        
        
        // direction \ lines
        for (temp_x1 = center_x + (rect.height - center_y)/SQRT_3, temp_x2 = center_x - (center_y)/SQRT_3;
             temp_x1 > 0 || temp_x2 > 0; temp_x1 -= lattice_step, temp_x2 -= lattice_step)
            paint_line(g, j_tonnetzcolor_r, temp_x1, rect.height, temp_x2, 0, x->tonnetz_line_width);
        for (temp_x1 = center_x + (rect.height - center_y)/SQRT_3 + lattice_step, temp_x2 = center_x - (center_y)/SQRT_3 + lattice_step;
             temp_x1 < rect.width || temp_x2 < rect.width; temp_x1 += lattice_step, temp_x2 += lattice_step)
            paint_line(g, j_tonnetzcolor_r, temp_x1, rect.height, temp_x2, 0, x->tonnetz_line_width);
        
        jbox_end_layer((t_object *)x, view, gensym("static_lines"));
    }
    
    jbox_paint_layer((t_object *)x, view, gensym("static_lines"), 0., 0.);	// position of the layer
}



void build_circle_layer(t_tonnetz *x, t_object *view, t_rect rect, t_jrgba *j_pointinnercolor_r)
{
	
	long size = ceil(2 * x->point_radius * x->zoom + 2 * x->point_line_width + 1);
	
	if (size % 2 == 1)
		size += 1;
	
	long center = size /2;

	x->circle_layer_side = size;
	
	t_jgraphics *g = jbox_start_layer((t_object *)x, view, gensym("circle_layer"), size, size);
	
	if (g) {
		paint_circle(g, x->j_pointbordercolor, *j_pointinnercolor_r, center, center, x->point_radius * x->zoom, x->point_line_width);
		jbox_end_layer((t_object *)x, view, gensym("circle_layer"));
	}
}


void paint_tonnetz_point(t_tonnetz *x, t_object *view, t_jgraphics *g, t_llll *node_as_llll_data, t_jfont *font, t_jrgba *j_textcolor_r, t_jrgba *j_selectedpointinnercolor_r, t_jrgba *j_pointinnercolor_r, t_jrgba *j_selectedtriangleinnercolor_r)
{
	char *buf = NULL;
	
	// retrieving information
	t_llllelem *elem = node_as_llll_data->l_head;
	double midicents, x_coord, y_coord;
	t_rational freq_ratio;
	t_tonnetz_diatonic_interval interval, interval_with_center;
	t_tonnetz_pt_coord coord;
	long velocity = 0;
	double lattice_step = x->lattice_step * x->zoom;
	double lattice_triangle_height = x->lattice_step * x->zoom * SQRT_3/2.;

	coord.coord1 = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
	coord.coord2 = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
	elem = elem->l_next;

	interval.diatonic_steps = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
	if (!x->purely_diatonic && hatom_getllll(&elem->l_hatom)->l_head->l_next)
		interval.chromatic_steps = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
	else
		interval.chromatic_steps = 0;
	
	interval_with_center = interval;
	interval_with_center.diatonic_steps -= x->diatonic_center.diatonic_steps;
	if (!x->purely_diatonic)
		interval_with_center.chromatic_steps -= x->diatonic_center.chromatic_steps;

	elem = elem->l_next;
	
	midicents = hatom_getdouble(&elem->l_hatom);
	elem = elem->l_next;
	
	freq_ratio = hatom_getrational(&elem->l_hatom);
	elem = elem->l_next;

	
	elem = elem->l_next->l_next; // skipping pitch class and diatonic interval

	x_coord = hatom_getdouble(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
	y_coord = hatom_getdouble(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);

	
	long c1 = TONNETZ_VEL_OFFSET(coord.coord1);
	long c2 = TONNETZ_VEL_OFFSET(coord.coord2);
	
	if (ARE_COORD_IN_VEL_MATRIX(coord.coord1, coord.coord2))
		velocity = x->velocities[c1][c2];
	
	t_jrgba inner_color = velocity > 0 ? *j_selectedpointinnercolor_r : *j_pointinnercolor_r;
	double point_radius = x->point_radius * x->zoom;


	if (x->velocity_handling == 0){ // no handling
		// nothing to do
	} else if (x->velocity_handling == 1) { // building colorscale
		double temp = (1. - (((double)velocity - CONST_MIN_VELOCITY)/(CONST_MAX_VELOCITY - CONST_MIN_VELOCITY)));
		//rescaling the temp
		temp = temp * 0.8;
		inner_color.red = (1. - temp) * inner_color.red + temp * j_pointinnercolor_r->red;
		inner_color.blue = (1. - temp) * inner_color.blue + temp * j_pointinnercolor_r->blue;
		inner_color.green = (1. - temp) * inner_color.green + temp * j_pointinnercolor_r->green;
	} else if (x->velocity_handling == 2){ // colourspectrum
		double temp = 2. * (((double)velocity - CONST_MIN_VELOCITY)/(CONST_MAX_VELOCITY - CONST_MIN_VELOCITY));
		inner_color.red = (temp < 1.) ? (1. - temp) : 0.; 
		inner_color.green = (((temp >= 0.) && (temp < 1.)) ? temp : 0.) + (((temp >= 1.) && (temp < 2.)) ? (2. - temp) : 0.); 
		inner_color.blue = (temp >= 1.) ? (temp - 1.) : 0.; 
	} else if (x->velocity_handling == 3) { // changing circle size
        double factor = (((double)velocity)/CONST_MAX_VELOCITY);
        factor = 0.5 + 0.5 * factor;
		point_radius *= factor;
	}
	
	
	
	if (velocity > 0 && c1 > 2 && c1 < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION - 2 && c2 > 2 && c2 < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION - 2) {
		// selection triangles?
		if (x->velocities[c1 + 1][c2] > 0 && x->velocities[c1][c2 + 1] > 0)
			paint_triangle(g, *j_selectedtriangleinnercolor_r, change_luminosity(*j_selectedtriangleinnercolor_r, 1.2), x_coord, y_coord, x_coord + lattice_step/2., y_coord - lattice_triangle_height, x_coord + lattice_step, y_coord, 0);
		if (x->velocities[c1+1][c2-1] > 0 && x->velocities[c1 + 1][c2] > 0)
			paint_triangle(g, *j_selectedtriangleinnercolor_r, change_luminosity(*j_selectedtriangleinnercolor_r, 1.2), x_coord, y_coord, x_coord + lattice_step/2., y_coord + lattice_triangle_height, x_coord + lattice_step, y_coord, 0);

		// selection lines?
		if (x->velocities[c1 + 1][c2] > 0)
			paint_line(g, *j_selectedtriangleinnercolor_r, x_coord, y_coord, x_coord + lattice_step, y_coord, x->selected_line_width);
		if (x->velocities[c1][c2 + 1] > 0)
			paint_line(g, *j_selectedtriangleinnercolor_r, x_coord, y_coord, x_coord + lattice_step / 2., y_coord - lattice_triangle_height, x->selected_line_width);
		if (x->velocities[c1 + 1][c2 - 1] > 0)
			paint_line(g, *j_selectedtriangleinnercolor_r, x_coord, y_coord, x_coord + lattice_step / 2., y_coord + lattice_triangle_height, x->selected_line_width);
	}
	
	if (velocity == 0) {
		jgraphics_set_source_rgba(g, 0, 0, 0, 1); 
		jbox_paint_layer((t_object *)x, view, gensym("circle_layer"), x_coord - x->circle_layer_side / 2., y_coord - x->circle_layer_side / 2.);	// position of the layer
	} else {
		
		paint_circle(g, velocity > 0 ? x->j_selectedpointbordercolor : x->j_pointbordercolor, inner_color, x_coord, y_coord, point_radius, velocity > 0 ? x->selected_line_width : x->point_line_width);
		//	paint_rectangle(g, velocity > 0 ? x->j_selectedpointbordercolor : x->j_pointbordercolor, inner_color, x_coord - point_radius, y_coord - point_radius, 2 * point_radius, 2 * point_radius, velocity > 0 ? x->selected_line_width : x->point_line_width);
	}
	
	if (font) {
		switch (x->label_style) {
			case k_TONNETZ_LABEL_NOTE_NAMES:
				if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
					tonnetz_ezmidicents_to_notename(x, midicents, false, &buf);
				else if (x->purely_diatonic)
					purely_diatonic_interval_to_notename(x, interval_with_center, false, &buf);
				else
					diatonic_interval_to_notename(x, interval, false, &buf);
				break;
			case k_TONNETZ_LABEL_NOTE_NAMES_WITH_OCTAVE:
				if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
					tonnetz_ezmidicents_to_notename(x, midicents, true, &buf);
				else if (x->purely_diatonic)
					purely_diatonic_interval_to_notename(x, interval_with_center, true, &buf);
				else
					diatonic_interval_to_notename(x, interval, true, &buf);
				break;
			case k_TONNETZ_LABEL_CENTS: 
				buf = (char *)bach_newptr(60 * sizeof(char));
				snprintf_zero(buf, 60, "%ld", (long)midicents);
				break;
			case k_TONNETZ_LABEL_DIATONIC_INTERVALS: 
				buf = (char *)bach_newptr(60 * sizeof(char));
				if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
					snprintf_zero(buf, 60, "(none)");
				else if (x->purely_diatonic)
					snprintf_zero(buf, 60, "%d", interval_with_center.diatonic_steps);
				else
					snprintf_zero(buf, 60, "%d, %d", interval_with_center.diatonic_steps, interval_with_center.chromatic_steps);
				break;
			case k_TONNETZ_LABEL_FREQUENCY_RATIOS: 
				buf = (char *)bach_newptr(60 * sizeof(char));
				if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
					snprintf_zero(buf, 60, "(none)");
				else
					snprintf_zero(buf, 60, "%ld/%ld", freq_ratio.r_num, freq_ratio.r_den);
				break;
			case k_TONNETZ_LABEL_COORDINATES: 
			{
				buf = (char *)bach_newptr(60 * sizeof(char));
				snprintf_zero(buf, 60, "%ld, %ld", coord.coord1, coord.coord2);
				break;
			}
			default:
				buf = (char *)bach_newptr(2 * sizeof(char));
				buf[0] = 0;
				break;
		} 
		
		write_text(g, font, *j_textcolor_r, buf, x_coord - 300, y_coord - 100, 600, 200, JGRAPHICS_TEXT_JUSTIFICATION_CENTERED, true, false);

	}

//	dev_post("Painted %p: %ld, %ld", llllelem_getpos(node_as_llll_data->l_owner), (long)x_coord, (long)y_coord);

	bach_freeptr(buf);
}

void paint_tonnetz_text(t_tonnetz *x, t_object *view, t_jgraphics *g, t_llll *node_as_llll_data, t_jfont *font, t_jrgba *j_textcolor_r)
{
    char *buf = NULL;
    t_llllelem *elem = node_as_llll_data->l_head;
    double midicents, x_coord, y_coord;
    t_rational freq_ratio;
    t_tonnetz_diatonic_interval interval, interval_with_center;
    t_tonnetz_pt_coord coord;
    
    coord.coord1 = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
    coord.coord2 = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
    elem = elem->l_next;
    
    interval.diatonic_steps = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
    if (!x->purely_diatonic && hatom_getllll(&elem->l_hatom)->l_head->l_next)
        interval.chromatic_steps = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
    else
        interval.chromatic_steps = 0;
    
    interval_with_center = interval;
    interval_with_center.diatonic_steps -= x->diatonic_center.diatonic_steps;
    if (!x->purely_diatonic)
        interval_with_center.chromatic_steps -= x->diatonic_center.chromatic_steps;
    
    elem = elem->l_next;
    
    midicents = hatom_getdouble(&elem->l_hatom);
    elem = elem->l_next;
    
    freq_ratio = hatom_getrational(&elem->l_hatom);
    elem = elem->l_next;
    
    
    elem = elem->l_next->l_next; // skipping pitch class and diatonic interval
    
    x_coord = hatom_getdouble(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom);
    y_coord = hatom_getdouble(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
    
    if (font) {
        switch (x->label_style) {
            case k_TONNETZ_LABEL_NOTE_NAMES:
                if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
                    tonnetz_ezmidicents_to_notename(x, midicents, false, &buf);
                else if (x->purely_diatonic)
                    purely_diatonic_interval_to_notename(x, interval_with_center, false, &buf);
                else
                    diatonic_interval_to_notename(x, interval, false, &buf);
                break;
            case k_TONNETZ_LABEL_NOTE_NAMES_WITH_OCTAVE:
                if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
                    tonnetz_ezmidicents_to_notename(x, midicents, true, &buf);
                else if (x->purely_diatonic)
                    purely_diatonic_interval_to_notename(x, interval_with_center, true, &buf);
                else
                    diatonic_interval_to_notename(x, interval, true, &buf);
                break;
            case k_TONNETZ_LABEL_CENTS:
                buf = (char *)bach_newptr(60 * sizeof(char));
                snprintf_zero(buf, 60, "%ld", (long)midicents);
                break;
            case k_TONNETZ_LABEL_DIATONIC_INTERVALS:
                buf = (char *)bach_newptr(60 * sizeof(char));
                if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
                    snprintf_zero(buf, 60, "(none)");
                else if (x->purely_diatonic)
                    snprintf_zero(buf, 60, "%d", interval_with_center.diatonic_steps);
                else
                    snprintf_zero(buf, 60, "%d, %d", interval_with_center.diatonic_steps, interval_with_center.chromatic_steps);
                break;
            case k_TONNETZ_LABEL_FREQUENCY_RATIOS:
                buf = (char *)bach_newptr(60 * sizeof(char));
                if (x->mode == k_TONNETZ_MODE_PITCH_SURFACE)
                    snprintf_zero(buf, 60, "(none)");
                else
                    snprintf_zero(buf, 60, "%ld/%ld", freq_ratio.r_num, freq_ratio.r_den);
                break;
            case k_TONNETZ_LABEL_COORDINATES: 
            {
                buf = (char *)bach_newptr(60 * sizeof(char));
                snprintf_zero(buf, 60, "%ld, %ld", coord.coord1, coord.coord2);
                break;
            }
            default:
                buf = (char *)bach_newptr(2 * sizeof(char));
                buf[0] = 0;
                break;
        } 
        
        write_text(g, font, *j_textcolor_r, buf, x_coord - 300, y_coord - 100, 600, 200, JGRAPHICS_TEXT_JUSTIFICATION_CENTERED, true, false);
        
    }
    
    //	dev_post("Painted %p: %ld, %ld", llllelem_getpos(node_as_llll_data->l_owner), (long)x_coord, (long)y_coord);
    
    bach_freeptr(buf);
}

void paint_static_text(t_tonnetz *x, t_object *view, t_rect rect, double font_size, t_jfont *jf_smalltext, t_jrgba *j_textcolor_r)
{
    
    t_jgraphics *g = jbox_start_layer((t_object *)x, view, gensym("static_text"), rect.width, rect.height);
    
    if (g) {
        t_llllelem *elem;
        for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
            if (!is_tonnetz_data_elem_in_screen(x, elem))
                break;
            paint_tonnetz_text(x, view, g, hatom_getllll(&elem->l_hatom), font_size > 3 ? jf_smalltext : NULL, j_textcolor_r);
        }
        
        jbox_end_layer((t_object *)x, view, gensym("static_text"));
    }
    
    jbox_paint_layer((t_object *)x, view, gensym("static_text"), 0., 0.);	// position of the layer
}



void tonnetz_paint(t_tonnetz *x, t_object *view)
{

	t_jgraphics *g;
	t_rect rect;
	double center_x, center_y;
	double lattice_step = x->lattice_step * x->zoom;
	double lattice_triangle_height = x->lattice_step * x->zoom * SQRT_3/2.;
	t_symbol *font_name = jbox_get_fontname((t_object *) x);
    double font_size = jbox_get_fontsize((t_object *) x) * x->zoom;
	t_jfont *jf_smalltext = jfont_create_debug(font_name->s_name, (t_jgraphics_font_slant)jbox_get_font_slant((t_object *) x), (t_jgraphics_font_weight)jbox_get_font_weight((t_object *) x), font_size);
	
    t_jrgba j_bgcolor_r, j_pointinnercolor_r, j_selectedpointinnercolor_r, j_textcolor_r, j_tonnetzcolor_r, j_selectedtriangleinnercolor_r;
    object_attr_getjrgba((t_object *)x, gensym("bgcolor"), &j_bgcolor_r);
    object_attr_getjrgba((t_object *)x, gensym("textcolor"), &j_textcolor_r);
    object_attr_getjrgba((t_object *)x, gensym("pointinnercolor"), &j_pointinnercolor_r);
    object_attr_getjrgba((t_object *)x, gensym("selectedpointinnercolor"), &j_selectedpointinnercolor_r);
#ifdef BACH_MAX7_STYLES_COMPATIBILITY
    j_tonnetzcolor_r = j_pointinnercolor_r;
    j_selectedtriangleinnercolor_r = change_alpha(j_selectedpointinnercolor_r, j_selectedpointinnercolor_r.alpha * 0.5);
#else
    object_attr_getjrgba((t_object *)x, gensym("tonnetzcolor"), &j_tonnetzcolor_r);
    object_attr_getjrgba((t_object *)x, gensym("selectedtriangleinnercolor"), &j_selectedtriangleinnercolor_r);
#endif
    
	// getting rectangle dimensions
	g = (t_jgraphics*) patcherview_get_jgraphics(view); 
	jbox_get_rect_for_view(&x->j_box.l_box.b_ob, view, &rect);
	
	// background
    paint_background((t_object *)x, g, &rect, &j_bgcolor_r, 0.);
	
	jbox_invalidate_layer((t_object *)x, NULL, gensym("circle_layer"));
	build_circle_layer(x, view, rect, &j_pointinnercolor_r);

	center_x = rect.width / 2;
	center_y = rect.height / 2;
	
    systhread_mutex_lock(x->c_mutex);

    x->graphical_center = build_pt(center_x, center_y);

	x->center.x = x->graphical_center.x + x->center_offset[0] * lattice_step + x->center_offset[1] * lattice_step/2.;
	x->center.y = x->graphical_center.y + x->center_offset[1] * lattice_triangle_height;

    paint_static_lines(x, view, rect, j_tonnetzcolor_r);
	
	// points
	t_llllelem *elem;
	if (x->need_refresh_tonnetz_coordinates)
		refresh_tonnetz_coordinates(x, rect);
	
	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		if (!is_tonnetz_data_elem_in_screen(x, elem)) 
			break;
		paint_tonnetz_point(x, view, g, hatom_getllll(&elem->l_hatom), NULL /* we'll paint text labels later! */, &j_textcolor_r, &j_selectedpointinnercolor_r, &j_pointinnercolor_r, &j_selectedtriangleinnercolor_r);
	}
    
    paint_static_text(x, view, rect, font_size, jf_smalltext, &j_textcolor_r);
    
	systhread_mutex_unlock(x->c_mutex);
	
		
	// border
    paint_border((t_object *)x, g, &rect, &x->j_bordercolor, (x->show_focus && x->j_has_focus) ? 2.5 : 1., 0.);
	
	jfont_destroy_debug(jf_smalltext);
}

void invalidate_static_layers_and_repaint(t_tonnetz *x)
{
    jbox_invalidate_layer((t_object *)x, NULL, gensym("static_lines"));
    jbox_invalidate_layer((t_object *)x, NULL, gensym("static_text"));
    jbox_redraw((t_jbox *)x);
}



void tonnetz_focusgained(t_tonnetz *x, t_object *patcherview) {
//	object_post((t_object *)x, "focusgained"); 
	x->j_has_focus = true;
    invalidate_static_layers_and_repaint(x);
}

void tonnetz_focuslost(t_tonnetz *x, t_object *patcherview) {
//	object_post((t_object *)x, "focuslost"); 
	x->j_has_focus = false;
    invalidate_static_layers_and_repaint(x);
}

long tonnetz_oksize(t_tonnetz *x, t_rect *newrect)
{
	x->need_refresh_tonnetz_coordinates = true;
    invalidate_static_layers_and_repaint(x);
	return 1;
}

void tonnetz_mousemove(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers) {
	char dragging = false;
	
	llll_format_modifiers(&modifiers, NULL);

	dragging = (modifiers == eAltKey + eControlKey);

	if (dragging)
		bach_set_cursor((t_object *)x, &x->j_mouse_cursor , patcherview, BACH_CURSOR_DRAGGINGHAND);
	else
		bach_set_cursor((t_object *)x, &x->j_mouse_cursor, patcherview, BACH_CURSOR_DEFAULT);
}

// returns 0 if not found, 1 if found
char pixel_coordinates_to_point_coordinates(t_tonnetz *x, t_object *patcherview, t_pt pt, t_tonnetz_pt_coord *coord)
{
	t_rect rect;
	jbox_get_rect_for_view(&x->j_box.l_box.b_ob, patcherview, &rect);
	t_pt center = build_pt(rect.width / 2, rect.height / 2);
	double lattice_triangle_height = SQRT_3 * x->lattice_step/2. * x->zoom;
	double lattice_step = x->lattice_step * x->zoom;

	center.x -= x->center_offset[0] * lattice_step + x->center_offset[1] * lattice_triangle_height/2.;
	center.y += x->center_offset[1] * lattice_triangle_height;

	double row = -(pt.y - center.y) / lattice_triangle_height;
	long round_row = round(row);
	double supposed_pt_center_y = -round_row * lattice_triangle_height + center.y;
	
	double max_radius = x->point_radius * x->zoom;
	if (fabs(supposed_pt_center_y - pt.y) < max_radius) {
		
		double col = (pt.x - (center.x + round_row * lattice_step / 2.)) / lattice_step;
		long round_col = round(col);
		double supposed_pt_center_x = center.x + round_row * lattice_step / 2. + round_col * lattice_step;
		
		double radius = max_radius;
		
		if (x->velocity_handling == 3) { // circle size
			if (ARE_COORD_IN_VEL_MATRIX(round_row, round_row) &&
				x->velocities[TONNETZ_VEL_OFFSET(round_col)][TONNETZ_VEL_OFFSET(round_row)] > 0) {
				radius *= rescale(x->velocities[TONNETZ_VEL_OFFSET(round_col)][TONNETZ_VEL_OFFSET(round_row)], CONST_MIN_VELOCITY, CONST_MAX_VELOCITY, 0.5, 1.);
			}
		}
		
		double dx = pt.x - supposed_pt_center_x;
		double dy = pt.y - supposed_pt_center_y;
		
		if (dx * dx + dy * dy <= radius * radius)  {
			coord->coord1 = round_col; //+ x->center_offset[0];
			coord->coord2 = round_row; //+ x->center_offset[1];
			return 1;
		}
	}
	return 0;
}

t_llll *tonnetz_node_as_llllelem_to_point_info_for_output(t_tonnetz *x, t_llllelem *node, t_symbol *router)
{
	// output from clicked outlet
	t_llll *out_ll = llll_get();
	
	if (node) {
		t_llll *ll = hatom_getllll(&node->l_hatom);
		t_llllelem *elem = ll->l_head;
		t_llll *this_coord = hatom_getllll(&elem->l_hatom);
		elem = elem->l_next;
		t_llll *this_diatonic_interval = hatom_getllll(&elem->l_hatom);
		elem = elem->l_next;
		double this_midicents = hatom_getdouble(&elem->l_hatom);
		elem = elem->l_next->l_next;
		double this_pc = hatom_getlong(&elem->l_hatom);
		
		long first_coord = hatom_getlong(&this_coord->l_head->l_hatom);
		long second_coord = hatom_getlong(&this_coord->l_head->l_next->l_hatom);
		long velocity = 0;
		
		if (ARE_COORD_IN_VEL_MATRIX(first_coord, second_coord))
			velocity = x->velocities[TONNETZ_VEL_OFFSET(first_coord)][TONNETZ_VEL_OFFSET(second_coord)];
		
		if (x->output_note_names) {
			t_tonnetz_diatonic_interval dia;
			char *buf = NULL;
			dia.diatonic_steps = hatom_getlong(&this_diatonic_interval->l_head->l_hatom);
			if (x->purely_diatonic) {
				purely_diatonic_interval_to_notename(x, dia, true, &buf);
			} else  {
				dia.chromatic_steps = hatom_getlong(&this_diatonic_interval->l_head->l_next->l_hatom);
				diatonic_interval_to_notename(x, dia, true, &buf);
			}
			llll_appendsym(out_ll, gensym(buf), 0, WHITENULL_llll);
			bach_freeptr(buf);
		} else
			llll_appenddouble(out_ll, this_midicents, 0, WHITENULL_llll);
		llll_appendlong(out_ll, this_pc, 0, WHITENULL_llll);
		llll_appendllll_clone(out_ll, this_diatonic_interval, 0, WHITENULL_llll, NULL);
		llll_appendllll_clone(out_ll, this_coord, 0, WHITENULL_llll, NULL);
		llll_appendlong(out_ll, velocity, 0, WHITENULL_llll);
	}
	
	llll_prependsym(out_ll, router, 0, WHITENULL_llll);

	return out_ll;
}

void changed_bang(t_tonnetz *x)
{
	llllobj_outlet_bang((t_object *)x, LLLL_OBJ_UI, 7);
}

void select_point(t_tonnetz *x, t_tonnetz_pt_coord coord, char remove_from_selection, char dont_select_only_output_info, char only_inscreen_points)
{
	// add the velocity (i.e. select/unselect the point)
	if (!dont_select_only_output_info) {
		if (ARE_COORD_IN_VEL_MATRIX(coord.coord1, coord.coord2))
			x->velocities[TONNETZ_VEL_OFFSET(coord.coord1)][TONNETZ_VEL_OFFSET(coord.coord2)] = remove_from_selection ? 0 : CONST_DEFAULT_VELOCITY;
		if (!remove_from_selection) 
			x->last_selected_pt = coord;
	}
	
	systhread_mutex_lock(x->c_mutex);
	// find the clicked lattice llllelem
	t_llllelem *foundelem = NULL, *elem;
	for (elem = x->tonnetz_data->l_head; elem; elem = elem->l_next) {
		t_llll *temp = hatom_getllll(&elem->l_hatom);
		
		if (only_inscreen_points && !hatom_getlong(&temp->l_tail->l_hatom)) 
			break;

		t_llll *ll = hatom_getllll(&temp->l_head->l_hatom);
		long c1 = hatom_getlong(&ll->l_head->l_hatom);
		long c2 = hatom_getlong(&ll->l_head->l_next->l_hatom);
		if (c1 == coord.coord1 && c2 == coord.coord2) {
			foundelem = elem;
			break;
		}
	}
	
	// output from clicked outlet
	t_llll *out_ll = tonnetz_node_as_llllelem_to_point_info_for_output(x, foundelem, gensym("clicked"));
	
	systhread_mutex_unlock(x->c_mutex);
	
	if (!dont_select_only_output_info)
		changed_bang((t_tonnetz *)x);
	
	llllobj_outlet_llll((t_object *)x, LLLL_OBJ_UI, 6, out_ll);
	
	llll_free(out_ll);
}

void tonnetz_mousedown(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers){
	t_tonnetz_pt_coord coord;

	evnum_incr();

	llll_format_modifiers(&modifiers, NULL);

	x->mouse_is_down = true;
	x->mousedrag_pt = pt;
	
	if (pixel_coordinates_to_point_coordinates(x, patcherview, pt, &coord)) {
		x->mousedown_tonnetz_pt = coord;
		if (ARE_COORD_IN_VEL_MATRIX(coord.coord1, coord.coord2)) {
			if (modifiers & eControlKey) {
				x->is_velocity_dragging = 1;
				x->dragging_velocity = x->velocities[TONNETZ_VEL_OFFSET(coord.coord1)][TONNETZ_VEL_OFFSET(coord.coord2)];
			} else {
				select_point(x, coord, modifiers & eCommandKey, modifiers & eAltKey, true);
			}
		}
		jbox_redraw((t_jbox *)x);
	}
}

void tonnetz_mouseup(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers){
	if (x->is_velocity_dragging > -1) 
		llllobj_outlet_bang((t_object *) x, LLLL_OBJ_UI, 3);

	x->mouse_is_down = false;
	x->is_velocity_dragging = -1;
}

void tonnetz_mousedrag(t_tonnetz *x, t_object *patcherview, t_pt pt, long modifiers){
	llll_format_modifiers(&modifiers, NULL);  

	if (modifiers == eControlKey + eAltKey) {
		// dragging tonnetz
		double lattice_step = x->lattice_step * x->zoom;
		double lattice_triangle_height = x->lattice_step * x->zoom * SQRT_3/2.;
		
		x->center_offset[0] -= ((pt.x - x->mousedrag_pt.x) / lattice_step);
		x->center_offset[1] += ((pt.y - x->mousedrag_pt.y) / lattice_triangle_height);
		x->center_offset[0] -= ((pt.y - x->mousedrag_pt.y) / lattice_triangle_height)/2.;
		x->need_refresh_tonnetz_coordinates = true;
		x->mousedrag_pt = pt;
        invalidate_static_layers_and_repaint(x);
		return;
	} 
	
	if (x->is_velocity_dragging > -1) {
		long new_velocity;
		double to_add = ((double)(pt.y - x->mousedrag_pt.y)) / CONST_DRAGGING_VELOCITY;
		systhread_mutex_lock(x->c_mutex);
		x->dragging_velocity -= to_add;
		new_velocity = round(x->dragging_velocity);
		
		long c1 = x->mousedown_tonnetz_pt.coord1;
		long c2 = x->mousedown_tonnetz_pt.coord2;
		
		CLIP_ASSIGN(new_velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);

		if (ARE_COORD_IN_VEL_MATRIX(c1, c2))
			if (new_velocity != x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)])  
				x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] = new_velocity;

		
		x->dragging_velocity = new_velocity;
		
		x->mousedrag_pt.y = pt.y;
		
		systhread_mutex_unlock(x->c_mutex);
		jbox_redraw((t_jbox *) x);
	} else {
		t_tonnetz_pt_coord coord;
		if (pixel_coordinates_to_point_coordinates(x, patcherview, pt, &coord)) {
			if (ARE_COORD_IN_VEL_MATRIX(coord.coord1, coord.coord2)) {
				if (!(modifiers & eControlKey)) {
					if ((modifiers & eCommandKey && x->velocities[TONNETZ_VEL_OFFSET(coord.coord1)][TONNETZ_VEL_OFFSET(coord.coord2)] > 0) ||
						(!(modifiers & eCommandKey) && x->velocities[TONNETZ_VEL_OFFSET(coord.coord1)][TONNETZ_VEL_OFFSET(coord.coord2)] == 0)){
						select_point(x, coord, modifiers & eCommandKey, modifiers & eAltKey, true);
						jbox_redraw((t_jbox *)x);
					}
				} 
			}
		}
	} 
}

void tonnetz_mousewheel(t_tonnetz *x, t_object *view, t_pt pt, long modifiers, double x_inc, double y_inc){
	llll_format_modifiers(&modifiers, NULL);  
	
	if (modifiers == eCommandKey || modifiers == eShiftKey + eCommandKey) { // change side value
		double old_zoom = x->zoom;
		double new_zoom = old_zoom;
		const double TONNETZ_Y_MOUSEWHEEL_FACTOR = 3;

		new_zoom -= y_inc * TONNETZ_Y_MOUSEWHEEL_FACTOR * (modifiers & eShiftKey ? CONST_FINER_FROM_KEYBOARD : 1.);

		new_zoom = CLAMP(new_zoom, TONNETZ_MIN_ZOOM/100., TONNETZ_MAX_ZOOM/100.);
		object_attr_setfloat((t_object *)x, gensym("zoom"), new_zoom * 100);
		
		// notify zoom change
		t_llll *ll = llll_get();
		llll_appendsym(ll, _llllobj_sym_zoom, 0, WHITENULL_llll);
		llll_appenddouble(ll, new_zoom, 0, WHITENULL_llll);
		llllobj_outlet_llll((t_object *)x, LLLL_OBJ_UI, 6, ll);
		llll_free(ll);
	}
}

long tonnetz_key(t_tonnetz *x, t_object *patcherview, long keycode, long modifiers, long textcharacter){
	llll_format_modifiers(&modifiers, &keycode);
	if (keycode == 't' && modifiers & eCommandKey) {
		rotate_tonnetz_selected_points(x, true);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == 'r' && modifiers & eCommandKey) {
		rotate_tonnetz_selected_points(x, false);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == JKEY_UPARROW && modifiers & eCommandKey) {
		translate_tonnetz_selected_points(x, 0, 1);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == JKEY_DOWNARROW && modifiers & eCommandKey) {
		translate_tonnetz_selected_points(x, 0, -1);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == JKEY_LEFTARROW && modifiers & eCommandKey) {
		translate_tonnetz_selected_points(x, -1, 0);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == JKEY_RIGHTARROW && modifiers & eCommandKey) {
		translate_tonnetz_selected_points(x, 1, 0);
		changed_bang((t_tonnetz *)x);
		return 1;
	} else if (keycode == JKEY_ESC) {
		x->center_offset[0] = x->center_offset[1] = 0.;
		x->need_refresh_tonnetz_coordinates = true;
        invalidate_static_layers_and_repaint(x);
		return 1;
	} else if (keycode == 'd' && modifiers & eCommandKey && modifiers & eShiftKey) {
		send_values(x, true, true, true, true, true, true);
		return 1;
	} else if (textcharacter == 32) {
		tonnetz_dumpselection(x);
		return 1;
	}
	return 0;
}


t_tonnetz_pt_cubic_coord to_cubic_coord(t_tonnetz_pt_coord coord)
{
	// converting coordinates to cubic
	t_tonnetz_pt_cubic_coord res;
	res.coord1 = coord.coord1;
	res.coord2 = coord.coord2;
	res.coord3 = coord.coord1 + coord.coord2;
	return res;
}

t_tonnetz_pt_coord from_cubic_coord(t_tonnetz_pt_cubic_coord coord)
{
	t_tonnetz_pt_coord res;
	res.coord1 = coord.coord1;
	res.coord2 = coord.coord2;
	return res;
}

t_tonnetz_pt_coord tonnetz_pt_translation(t_tonnetz_pt_coord coord, t_tonnetz_pt_coord amount)
{
	t_tonnetz_pt_coord res;
	res.coord1 = coord.coord1 + amount.coord1;
	res.coord2 = coord.coord2 + amount.coord2;
	return res;
}

t_tonnetz_pt_coord tonnetz_pt_rotation(t_tonnetz_pt_coord coord, char clockwise)
{
	// converting coordinates to cubic
	t_tonnetz_pt_cubic_coord cubic_coord = to_cubic_coord(coord);
	t_tonnetz_pt_cubic_coord res;
	if (clockwise) {
		res.coord1 = cubic_coord.coord3;
		res.coord2 = -cubic_coord.coord1;
		res.coord3 = -cubic_coord.coord2;
	} else {
		res.coord1 = -cubic_coord.coord2;
		res.coord2 = cubic_coord.coord3;
		res.coord3 = -cubic_coord.coord1;
	}
	return from_cubic_coord(res);
}

long manhattan_distance(t_tonnetz_pt_coord coord1, t_tonnetz_pt_coord coord2)
{
	t_tonnetz_pt_cubic_coord cubic_coord1 = to_cubic_coord(coord1);
	t_tonnetz_pt_cubic_coord cubic_coord2 = to_cubic_coord(coord2);
    return (labs(cubic_coord1.coord1 - cubic_coord2.coord1) + labs(cubic_coord1.coord2 - cubic_coord2.coord2) + labs(cubic_coord1.coord3 - cubic_coord2.coord3)) / 2;
}


void rotate_tonnetz_selected_points(t_tonnetz *x, char clockwise)
{
	long i, j;
	
	systhread_mutex_lock(x->c_mutex);
	
	t_llll *elems_to_put = llll_get();
	
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
		for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
			if (x->velocities[i][j] > 0) {
				t_tonnetz_pt_coord rotated = tonnetz_pt_rotation(build_tonnetz_pt_coord(i - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET, j - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET), clockwise);
				if (ARE_COORD_IN_VEL_MATRIX(rotated.coord1, rotated.coord2)) {
					t_llll *this_ll = llll_get();
					llll_appendlong(this_ll, rotated.coord1, 0, WHITENULL_llll);
					llll_appendlong(this_ll, rotated.coord2, 0, WHITENULL_llll);
					llll_appendlong(this_ll, x->velocities[i][j], 0, WHITENULL_llll);
					llll_appendllll(elems_to_put, this_ll, 0, WHITENULL_llll);
				}
			}
	
	clear_velocities(x);
	
	t_llllelem *elem;
	for (elem = elems_to_put->l_head; elem; elem = elem->l_next) {
		t_llll *ll = hatom_getllll(&elem->l_hatom);
		long c1 = hatom_getlong(&ll->l_head->l_hatom);
		long c2 = hatom_getlong(&ll->l_head->l_next->l_hatom);
		long vel = hatom_getlong(&ll->l_head->l_next->l_next->l_hatom);
		if (ARE_COORD_IN_VEL_MATRIX(c1, c2))
			x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] = vel;
	}

	systhread_mutex_unlock(x->c_mutex);

	llll_clear(elems_to_put);

	jbox_redraw((t_jbox *)x);
}


void translate_tonnetz_selected_points(t_tonnetz *x, long delta_coord1, long delta_coord2)
{
	long i, j;
	
	systhread_mutex_lock(x->c_mutex);
	
	t_llll *elems_to_put = llll_get();
	for (i = 0; i < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; i++)
		for (j = 0; j < CONST_MAX_VELOCITY_POINTS_PER_DIMENSION; j++)
			if (x->velocities[i][j] > 0) {
				long i_coord = i - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET;
				long j_coord = j - CONST_VELOCITY_ARRAY_ZERO_ZERO_OFFSET;
				if (ARE_COORD_IN_VEL_MATRIX(i_coord + delta_coord1, j_coord + delta_coord2)) {
					t_llll *this_ll = llll_get();
					llll_appendlong(this_ll, i_coord + delta_coord1, 0, WHITENULL_llll);
					llll_appendlong(this_ll, j_coord + delta_coord2, 0, WHITENULL_llll);
					llll_appendlong(this_ll, x->velocities[i][j], 0, WHITENULL_llll);
					llll_appendllll(elems_to_put, this_ll, 0, WHITENULL_llll);
				}
			}
	
	clear_velocities(x);
	
	t_llllelem *elem;
	for (elem = elems_to_put->l_head; elem; elem = elem->l_next) {
		t_llll *ll = hatom_getllll(&elem->l_hatom);
		long c1 = hatom_getlong(&ll->l_head->l_hatom);
		long c2 = hatom_getlong(&ll->l_head->l_next->l_hatom);
		long vel = hatom_getlong(&ll->l_head->l_next->l_next->l_hatom);
		if (ARE_COORD_IN_VEL_MATRIX(c1, c2))
			x->velocities[TONNETZ_VEL_OFFSET(c1)][TONNETZ_VEL_OFFSET(c2)] = vel;
	}
	
	systhread_mutex_unlock(x->c_mutex);

	llll_clear(elems_to_put);

	jbox_redraw((t_jbox *)x);
}
