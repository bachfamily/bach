/*
 *  notation_commons.c
 *
 * Copyright (C) 2010-2020 Andrea Agostini and Daniele Ghisi
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License
 * as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 *
 */

/**
    notation_commons.c - common functions (or useful functions) for notation objects
*/

#include "foundation/bach.h"
#include "notation/notation.h" // header with all the structures for the notation objects

//#include "graphics/llll_modifiers.h" 
//#include "math/llll_math.h"

// GLOBAL VARIABLE

const char *notation_obj_lexpr_subs[] = {"onset", "cents", "duration", "velocity", "symduration", "symonset", "tail", "symtail", "voice", "measure", "tie", "noteindex", "chordindex", "index", "grace", "pitch", "part", "voiceensemble", "poc"};
const long notation_obj_lexpr_subs_count = 19;


DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_notation_obj, voicenames_as_llll, notation_obj_getattr_voicenames)
DEFINE_LLLL_ATTR_DEFAULT_GETTER(t_notation_obj, stafflines_as_llll, notation_obj_getattr_stafflines)


long notationobj_get_notification_outlet(t_notation_obj *r_ob)
{
    switch (r_ob->obj_type) {
        case k_NOTATION_OBJECT_ROLL:
            return 6;
            break;

        case k_NOTATION_OBJECT_SCORE:
            return 7;
            break;

        case k_NOTATION_OBJECT_SLOT:
            return 1;
            break;

        default:
            return 0;
            break;
    }
}

// returns the height for base pt, vzoom = 1.
double notationobj_get_supposed_standard_uheight(t_notation_obj *r_ob)
{
    long num_staves = get_num_staves(r_ob, true);
    // calculating vertical spacing
    double overall_vertical_spacing  = 0;
    double one_system_height = 0;
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        if (!voice->hidden && (voice->number == r_ob->num_voices - 1 || voice_get_next(r_ob, voice)->part_index == 0))
            overall_vertical_spacing += voice->vertical_uspacing;
    one_system_height = 14 * CONST_STEP_UY + num_staves * 14 * CONST_STEP_UY + overall_vertical_spacing;
    return ((r_ob->num_systems > 0) ? r_ob->num_systems : 1) * one_system_height + r_ob->head_vertical_additional_uspace;
}


void notationobj_reset_size_related_stuff(t_notation_obj *r_ob)
{
    r_ob->step_y = CONST_STEP_UY * r_ob->zoom_y;
    r_ob->zoom_y_with_antialias = r_ob->zoom_y;
    adjust_zoom_for_non_antialiased_lines(r_ob);
    r_ob->system_jump = get_system_jump(r_ob);
    calculate_voice_offsets(r_ob);
    recompute_total_length(r_ob);
    reset_all_articulations_positions(r_ob);
}

void notationobj_set_vzoom_depending_on_height(t_notation_obj *r_ob, double height)
{
    double supposedheight = notationobj_get_supposed_standard_uheight(r_ob);
    r_ob->needed_uheight = supposedheight;
    r_ob->needed_uheight_for_one_system = supposedheight / ((r_ob->num_systems > 0) ? r_ob->num_systems : 1);
    r_ob->zoom_y = MAX(0.01, height / supposedheight);
    atom_setsym(&r_ob->vertical_zoom, _llllobj_sym_Auto);
    //        post("supposed: %f. this: %f.--> zoom %f", supposedheight, height, x->r_ob.zoom_y);
    notationobj_reset_size_related_stuff(r_ob);
}







//// **************************** ////
//// ***** COMMON ATTRIBUTES **** ////
//// **************************** ////

// TO DO

// ******************* MAX VERSION **************************
#ifdef BACH_MAX

void write_text_standard_account_for_vinset(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard(g, jf, textcolor, text, x1, r_ob->j_inset_y + y1, r_ob->width - x1 + 30 * r_ob->zoom_y, r_ob->height - y1 + 30 * r_ob->zoom_y);
}

void write_text_standard_account_for_vinset_singleline(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard_singleline(g, jf, textcolor, text, x1, r_ob->j_inset_y + y1, r_ob->width - x1 + 30 * r_ob->zoom_y, r_ob->height - y1 + 30 * r_ob->zoom_y);
}

void paint_beam_line(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, double x1, double y1, double x2, double y2, double width, double direction)
{
    //actually, it is a quadrilater
    if (direction == -1){
        y1 -= width;
        y2 -= width;
    }
    jgraphics_set_source_jrgba(g, &color); 
    jgraphics_set_line_width(g, 0.);
    jgraphics_move_to(g, x1, y1);
    jgraphics_line_to(g, x1, y1 + width);
    jgraphics_line_to(g, x2, y2 + width);
    jgraphics_line_to(g, x2, y2);
    jgraphics_close_path(g); 
    jgraphics_fill(g);    
}

void write_text_standard_account_for_insets(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard(g, jf, textcolor, text, r_ob->j_inset_x + x1, r_ob->j_inset_y + y1, r_ob->inner_width - x1, r_ob->inner_height - y1);
}

void write_text_standard_account_for_insets_singleline(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard_singleline(g, jf, textcolor, text, r_ob->j_inset_x + x1, r_ob->j_inset_y + y1, r_ob->inner_width - x1, r_ob->inner_height - y1);
}

#endif // MAX_VERSION

// ******************* JUCE VERSION **************************
#ifdef BACH_JUCE

void write_text_standard_account_for_vinset(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard(g, jf, textcolor, text, x1, r_ob->j_inset_y + y1, (r_ob->inner_width + r_ob->j_inset_x) - x1, r_ob->inner_height - y1);
}

// wrong one: it is the same as the previous one, but I don't wanna touch things! :)
void write_text_standard_account_for_vinset(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{ // write the text, without deleting truncated letters
    write_text_standard(g, jf, textcolor, text, x1, r_ob->j_inset_y + y1, (r_ob->inner_width + r_ob->j_inset_x) - x1, r_ob->inner_height - y1);
}

void paint_beam_line(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, double x1, double y1, double x2, double y2, double width, double direction)
{
    Path p;
    if (direction == -1){
        y1 -= width;
        y2 -= width;
    }
    p.addQuadrilateral(x1, y1, x1, y1 + width, x2, y2 + width, x2, y2);
    jgraphics_set_source_jrgba(g, &color);
    g->fillPath(p);
}

// char is supposed being encoded as UTF-8
void write_text_standard_account_for_insets(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char *text, double x1, double y1)
{
    write_text_standard(g, jf, textcolor, text, r_ob->j_inset_x + x1, r_ob->j_inset_y + y1, r_ob->inner_width - x1, r_ob->inner_height - y1);
}
#endif // JUCE_VERSION



char timepoints_compare(t_timepoint tp1, t_timepoint tp2){ 
// compares two timepoints. Returns 1 if tp1 is greater, -1 if tp2 is greater, 0 if they coincide.
    if (tp1.measure_num > tp2.measure_num) 
        return 1;
    else if ((tp1.measure_num == tp2.measure_num) && (rat_rat_cmp(tp1.pt_in_measure, tp2.pt_in_measure) == 1)) 
        return 1;
    else if ((tp1.measure_num == tp2.measure_num) && (rat_rat_cmp(tp1.pt_in_measure, tp2.pt_in_measure) == 0)) 
        return 0;
    else return -1;
}


t_symbol *get_querying_label_from_querying_llll(t_notation_obj *r_ob, t_llll *input_as_llll, char also_destroy_label)
{
    t_symbol *outsym = NULL;
    if (input_as_llll && input_as_llll->l_head && input_as_llll->l_head->l_next && hatom_gettype(&input_as_llll->l_head->l_next->l_hatom) == H_LLLL) {
        t_llll *thisllll = hatom_getllll(&input_as_llll->l_head->l_next->l_hatom);
        if (thisllll && thisllll->l_head && thisllll->l_head->l_next && hatom_gettype(&thisllll->l_head->l_hatom) == H_SYM && 
            hatom_getsym(&thisllll->l_head->l_hatom) == _llllobj_sym_label && hatom_gettype(&thisllll->l_head->l_next->l_hatom) == H_SYM) {
            outsym = hatom_getsym(&thisllll->l_head->l_next->l_hatom);
            if (also_destroy_label)
                llll_destroyelem(input_as_llll->l_head->l_next);
        }
    }
    
    return outsym;
}

t_symbol *get_querying_label_from_GIMME(t_notation_obj *r_ob, t_symbol *s, long ac, t_atom *av)
{
    t_symbol *outsym = NULL;
    if (ac) {
        t_llll *input_as_llll = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, s, ac, av, LLLL_PARSE_RETAIN);
        outsym = get_querying_label_from_querying_llll(r_ob, input_as_llll, false);
        llll_free(input_as_llll);
    }
    return outsym;
}


char measure_has_visible_tempo(t_measure *meas)
{
    if (!meas)
        return false;
    for (t_tempo *tempo = meas->firsttempo; tempo; tempo = tempo->next) {
        if (!tempo->hidden)
            return true;
    }
    return false;
}

// painting stuff
void paint_timesignature(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_jfont *jf_ts, long clef, double staff_top, t_measure *curr_meas, char big)
{
    long i;
    int num_ts = ((clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FFGG) || (clef == k_CLEF_FG)) ? 2 : 1; // number of time signatures to paint
    double *tsbox_y1a = (double *) bach_newptr(num_ts * sizeof(double));
    double *tsbox_y1b = (double *) bach_newptr(num_ts * sizeof(double));
    double tsbox_x1 = unscaled_xposition_to_xposition(r_ob, (curr_meas->tuttipoint_reference ? curr_meas->tuttipoint_reference->offset_ux : 0) + curr_meas->start_barline_offset_ux + CONST_SCORE_USPACE_AFTER_START_BARLINE_WITH_TS); 
    double tsbox_x_width = curr_meas->timesignature_uwidth * r_ob->zoom_y * (big ? r_ob->big_time_signatures_ratio : 1);
    double tsbox_y_height;
    char num_txt[150]; char den_txt[50]; 
    long len_utf_num, len_utf_den;
    char *num_utf, *den_utf;
    
    if (r_ob->spacing_type == k_SPACING_PROPORTIONAL) {
        if (r_ob->show_time_signatures != 2)
            tsbox_x1 = tsbox_x1 - 2 * CONST_SCORE_USPACE_AFTER_START_BARLINE_WITH_TS - tsbox_x_width;
        else {
            tsbox_x1 = tsbox_x1 - CONST_SCORE_USPACE_AFTER_START_BARLINE_WITH_TS - tsbox_x_width / 2.;
        }
    }
    
    for (i = 0; i < num_ts; i++) {
        double this_staff_top, this_staff_bottom;
        switch (clef) {
            case k_CLEF_FFGG: case k_CLEF_GG: case k_CLEF_FGG: 
            {
                if (r_ob->show_time_signatures == 2)
                    this_staff_top = (i == 0) ? staff_top : staff_top + 12 * r_ob->step_y;
                else
                    this_staff_top = (i == 0) ? staff_top + 14 * r_ob->step_y : staff_top + (14 + 12) * r_ob->step_y;
                break; 
            }
            default: 
            { 
                this_staff_top = (i == 0) ? staff_top : staff_top + 12 * r_ob->step_y; 
                break; 
            }
        }

        if (r_ob->show_time_signatures == 2) {
            this_staff_top -= 8 * r_ob->step_y * (big ? r_ob->big_time_signatures_ratio : 1);
            
            if (curr_meas && measure_has_visible_tempo(curr_meas))
                this_staff_top -= 8 * r_ob->step_y + MAX(0, (r_ob->tempi_uy_pos - 24) * r_ob->zoom_y) + 4.5 * r_ob->step_y; // account for tempo, avoid overlapping
            else if (curr_meas && !curr_meas->voiceparent->prev)
                this_staff_top -= 4.5 * r_ob->step_y;
            else
                this_staff_top -= 2.5 * r_ob->step_y;
        }
        
        this_staff_bottom = this_staff_top + 8 * r_ob->step_y;
        
        tsbox_y1a[i] = this_staff_top + r_ob->notation_typo_preferences.ts_uy_shift * r_ob->zoom_y * (big ? r_ob->big_time_signatures_ratio : 1);
        tsbox_y1b[i] = tsbox_y1a[i] + (big ? r_ob->big_time_signatures_ratio : 1) * (this_staff_bottom - this_staff_top) / 2.;
        
        tsbox_y_height = 80 * r_ob->zoom_y; 
        num_utf = charset_unicodetoutf8_debug(curr_meas->timesignature.num_unicode, curr_meas->timesignature.len_num, &len_utf_num);
        den_utf = charset_unicodetoutf8_debug(curr_meas->timesignature.den_unicode, curr_meas->timesignature.len_den, &len_utf_den);
        strncpy(num_txt, num_utf, 150);
        strncpy(den_txt, den_utf, 49);
        bach_freeptr(num_utf);
        bach_freeptr(den_utf);
        write_text(g, jf_ts, color, num_txt, tsbox_x1, tsbox_y1a[i], tsbox_x_width, tsbox_y_height, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
        write_text(g, jf_ts, color, den_txt, tsbox_x1, tsbox_y1b[i], tsbox_x_width, tsbox_y_height, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
    }
    bach_freeptr(tsbox_y1a);
    bach_freeptr(tsbox_y1b);
}



void update_playhead_cant_trespass_loop_end(t_notation_obj *r_ob)
{
    if (!r_ob->show_loop_region || !r_ob->use_loop_region) {
        r_ob->playhead_cant_trespass_loop_end = false;
        return;
    }
    
    if (r_ob->play_head_start_ms < r_ob->loop_region.end.position_ms)
        r_ob->playhead_cant_trespass_loop_end = true;
    else
        r_ob->playhead_cant_trespass_loop_end = false;
}


// returns -1 if the point (point_x, point_y) is on the loop start line, 1 for loop end line, 0 otherwise
e_element_types is_in_loop_region(t_notation_obj *r_ob, t_rect rect, long point_x, long point_y){
    double start_x = r_ob->loop_region_pixel_start, end_x = r_ob->loop_region_pixel_end;
    double playhead_y1, playhead_y2;
    get_playhead_ypos(r_ob, rect, &playhead_y1, &playhead_y2);
    if (fabs(point_x - start_x) < 2 + 2 * r_ob->zoom_y && point_y < r_ob->height - (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y) 
        return k_LOOP_START;
    if (fabs(point_x - end_x) < 2 + 2 * r_ob->zoom_y && point_y < r_ob->height - (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y) 
        return k_LOOP_END;
    if (point_x <= end_x 
        && point_x >= start_x
        && r_ob->height - point_y > (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y + fabs(CONST_XSCROLLBAR_Y_SHIFT) 
        && playhead_y2 - point_y < 8 * r_ob->zoom_y
        )
        return k_LOOP_REGION;

    return k_NONE;
}

void paint_loop_region(t_notation_obj *r_ob, t_jgraphics* g, t_rect rect, t_jrgba color, double start_x, double end_x, double playhead_y1, double playhead_y2, double width){
    double loop_rect_width = MIN(rect.width, end_x) - MAX(0, start_x);
    
    r_ob->loop_region_pixel_start = start_x;
    r_ob->loop_region_pixel_end = end_x;
    if (loop_rect_width >= 0) {
        paint_filledrectangle(g, r_ob->use_loop_region ? change_alpha(color, 0.2) : change_alpha(change_luminosity(color, 0.5), 0.05), MAX(0, start_x), playhead_y1, loop_rect_width, playhead_y2 - playhead_y1);
        paint_stripedrectangle(g, change_alpha(color, 0.7), r_ob->use_loop_region ? color : change_alpha(change_luminosity(color, 0.5), 0.7), MAX(0, start_x), playhead_y2 - 7 * r_ob->zoom_y, loop_rect_width, 7 * r_ob->zoom_y, 8 * r_ob->zoom_y, 8 * r_ob->zoom_y);
        
        if (start_x > 0 && start_x < rect.width) {
            paint_line(g, color, start_x, playhead_y1, start_x, playhead_y2, width);
            
            jgraphics_move_to(g, start_x, playhead_y1);
            jgraphics_line_to(g, start_x, playhead_y1 - 3 * r_ob->zoom_y);
            jgraphics_line_to(g, start_x + 3 * r_ob->zoom_y, playhead_y1 - 3 * r_ob->zoom_y);
            jgraphics_close_path(g);
            jgraphics_set_source_jrgba(g, &color);
            jgraphics_fill_preserve(g);
            jgraphics_stroke(g); 
        }
        
        if (end_x > 0 && end_x < rect.width) {
            paint_line(g, color, end_x, playhead_y1, end_x, playhead_y2, width);
            
            jgraphics_move_to(g, end_x, playhead_y1);
            jgraphics_line_to(g, end_x, playhead_y1 - 3 * r_ob->zoom_y);
            jgraphics_line_to(g, end_x - 3 * r_ob->zoom_y, playhead_y1 - 3 * r_ob->zoom_y);
            jgraphics_close_path(g);
            jgraphics_set_source_jrgba(g, &color);
            jgraphics_fill_preserve(g);
            jgraphics_stroke(g); 
        }
    }
    
}

// buf must already be initialized to buf_size
int get_names_as_text(t_llll *ll, char *buf, long buf_size)
{
    // THIS LINE WOULD BE IDEAL, but "llll_to_text_buf_limited" is marked as "not working"
    // llll_to_text_buf_limited(ll, buf, buf_size, 0, BACH_DEFAULT_MAXDECIMALS, 0, NULL);

    char *temp = NULL;
    llll_to_text_buf(ll, &temp, 0, BACH_DEFAULT_MAXDECIMALS, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
    long size = snprintf_zero(buf, buf_size, "%s", temp);
    bach_freeptr(temp);
    return size;
}

// buf must already be initialized to buf_size
void get_voicenames_as_text(t_notation_obj *r_ob, t_voice *voice, char *buf, long buf_size)
{
    t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
    t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
    if (first == last)
        get_names_as_text(voice->r_it.names, buf, buf_size);
    else {
        t_voice *temp;
        long size = 0;
        for (temp = first; temp && temp->number < r_ob->num_voices && size < buf_size; temp = voice_get_next(r_ob, temp)) {
            if (temp != first && size < buf_size - 2) {
                buf[size++] = '\r';
                buf[size++] = '\n';
            }
            size += get_names_as_text(temp->r_it.names, buf + size, buf_size - size);
            if (temp == last)
                break;
        }
    }
        
}

void paint_marker(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_jfont* jf, t_marker *marker, double marker_x, double marker_y1, double marker_y2, double linewidth, char also_paint_name, double *namewidth)
{
    
    char name_direction = marker->name_painted_direction;
    double height = 0;
    
    paint_line(g, color, marker_x, marker_y1, marker_x, marker_y2, linewidth);
    
    if (marker->role != k_MARKER_ROLE_NONE) {
        t_jfont *jf_special_text_markers = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, round(6 * r_ob->zoom_y));  // text font for markers
        t_jrgba specialcolor = marker->role == k_MARKER_ROLE_TEMPO ? build_jrgba(0.6, 0.2, 0.2, 1) : (marker->role == k_MARKER_ROLE_TIME_SIGNATURE ? build_jrgba(0.2, 0.2, 0.6, 1) : (marker->role == k_MARKER_ROLE_MEASURE_BARLINE ? build_jrgba(0.2, 0.6, 0.6, 1) : (marker->role == k_MARKER_ROLE_MEASURE_DIVISION ? build_jrgba(0.6, 0.6, 0.2, 1) : build_jrgba(0.6, 0.2, 0.6, 1))));
        paint_dashed_y_line(g, specialcolor, marker_x, marker_y1, marker_y2, linewidth, 3 * r_ob->zoom_y);
        if (namewidth)
            *namewidth = 0;
        write_text_in_vertical(g, jf_special_text_markers, specialcolor, marker->role == k_MARKER_ROLE_TEMPO ? "TEMPO" : (marker->role == k_MARKER_ROLE_TIME_SIGNATURE ? "TIME SIG" : (marker->role == k_MARKER_ROLE_MEASURE_BARLINE ? "BARLINE" : (marker->role == k_MARKER_ROLE_MEASURE_DIVISION ? "DIVISION" : "SUBDIVISION"))), name_direction < 0 ? marker_x : marker_x - 10 * r_ob->zoom_y, marker_y1 + 3 * r_ob->zoom_y, 10 * r_ob->zoom_y, marker_y2 - marker_y1 - 6 * r_ob->zoom_y, (marker->role == k_MARKER_ROLE_TEMPO ? JGRAPHICS_TEXT_JUSTIFICATION_BOTTOM : JGRAPHICS_TEXT_JUSTIFICATION_TOP) + JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED, 0.8);
        jfont_destroy_debug(jf_special_text_markers);
    }
    
    if (also_paint_name) {
        if (marker->role == k_MARKER_ROLE_NONE) {
            if (marker && marker->r_it.names && marker->r_it.names->l_size > 0) {
                char buf[1000];
                get_names_as_text(marker->r_it.names, buf, 1000);
                if (namewidth)
                    jfont_text_measure(jf, buf, namewidth, &height);
                write_text_standard_account_for_vinset(r_ob, g, jf, color, buf, name_direction < 0 ? marker_x - 3 * r_ob->zoom_y - marker->name_uwidth * r_ob->zoom_y: marker_x + 3 * r_ob->zoom_y, marker_y1 + notationobj_get_marker_voffset(r_ob, marker));
            }
        } else if ((marker->role == k_MARKER_ROLE_TEMPO || marker->role == k_MARKER_ROLE_TIME_SIGNATURE) && marker->content) {
            char *buf = NULL;
            llll_to_text_buf(marker->content, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
            if (namewidth)
                jfont_text_measure(jf, buf, namewidth, &height);
            write_text(g, jf, color, buf, name_direction < 0 ? marker_x - 3 * r_ob->zoom_y - marker->name_uwidth * r_ob->zoom_y : marker_x + 3 * r_ob->zoom_y, marker_y1 + notationobj_get_marker_voffset(r_ob, marker), 200 * r_ob->zoom_y, marker_y2 - marker_y1 - 6 * r_ob->zoom_y,
                                (marker->role == k_MARKER_ROLE_TEMPO ? JGRAPHICS_TEXT_JUSTIFICATION_BOTTOM : JGRAPHICS_TEXT_JUSTIFICATION_TOP) + JGRAPHICS_TEXT_JUSTIFICATION_LEFT, true, true);
            bach_freeptr(buf);
        }
    }

#ifdef BACH_PAINT_IDS
#ifdef BACH_MARKERS_HAVE_ID
    char text[20];
    snprintf_zero(text, 40, "%ld", marker->r_it.ID);
    write_text(g, jf, build_jrgba(0.5, 0.2, 0.5, 1), text, marker_x + 3 * r_ob->zoom_y, marker_y1 + 10 * r_ob->zoom_y, 50 * r_ob->zoom_y, 40, JGRAPHICS_TEXT_JUSTIFICATION_LEFT + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
#endif
#endif
    
}

void paint_tie(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, double x1, double y1, double x2, double y2, char direction){
    double control_point1_x, control_point2_x, control_point1_y, control_point2_y;
    // Bezier curve

    control_point1_x = x1 + 0.2 * (x2 - x1);
    control_point2_x = x1 + 0.8 * (x2 - x1);
    control_point1_y = y1 + CONST_SCORE_TIE_INNER_UHEIGHT * r_ob->zoom_y * (-direction);
    control_point2_y = y2 + CONST_SCORE_TIE_INNER_UHEIGHT * r_ob->zoom_y * (-direction);
    jgraphics_set_source_jrgba(g, &color);
#ifdef BACH_MAX
    jgraphics_set_line_width(g, 0.); 
    jgraphics_move_to(g, x1, y1);
    jgraphics_curve_to(g, control_point1_x, control_point1_y, control_point2_x, control_point2_y, x2, y2);
#endif
#ifdef BACH_JUCE
    Path p;
    p.startNewSubPath(x1, y1);
    p.cubicTo(control_point1_x, control_point1_y, control_point2_x, control_point2_y, x2, y2);
#endif
    control_point1_x = x1 + 0.8 * (x2 - x1);
    control_point2_x = x1 + 0.2 * (x2 - x1);
    control_point1_y = y2 + CONST_SCORE_TIE_OUTER_UHEIGHT * r_ob->zoom_y * (-direction);
    control_point2_y = y1 + CONST_SCORE_TIE_OUTER_UHEIGHT * r_ob->zoom_y * (-direction);
#ifdef BACH_MAX
    jgraphics_curve_to(g, control_point1_x, control_point1_y, control_point2_x, control_point2_y, x1, y1);
    jgraphics_close_path(g);
    jgraphics_fill(g);
#endif
#ifdef BACH_JUCE
    p.cubicTo(control_point1_x, control_point1_y, control_point2_x, control_point2_y, x1, y1);
    p.closeSubPath();
    g->fillPath(p);
#endif
}


void do_paint_lines(t_notation_obj *r_ob, t_jgraphics* g, double x1, double x2, double width, t_jrgba color, double bottommost_line_y, long num_staff_lines, char *staff_lines){
    long i;
    double this_y;
    for (i = 0; i < num_staff_lines; i++){
        this_y = bottommost_line_y - 2 * (staff_lines ? staff_lines[i] : i + 1) * r_ob->step_y;
        paint_line(g, color, x1, this_y, x2, this_y, width);
    }
}


void paint_left_vertical_staffline(t_notation_obj *r_ob, t_jgraphics* g, t_voice *voice, t_jrgba color)
{
        double x_pos = r_ob->j_inset_x + r_ob->voice_names_uwidth * r_ob->zoom_y;
        double top_y = get_staff_top_y(r_ob, voice, true);
        double bottom_y = get_staff_bottom_y(r_ob, voice, true);
        const double LINEWIDTH = 1 * r_ob->zoom_y;
        
        paint_line(g, color, x_pos, top_y, x_pos, bottom_y, LINEWIDTH);
}

void paint_staff_lines(t_notation_obj *r_ob, t_jgraphics* g, double x1, double x2, double width, double middleC_y, long clef, t_jrgba main_staff_color, t_jrgba aux_staff_color, long num_staff_lines, char *staff_lines){
    double this_y = middleC_y + r_ob->j_inset_y;

    switch (clef) {
        case k_CLEF_TENOR:
        case k_CLEF_BARYTONE:
        case k_CLEF_SOPRANO:
        case k_CLEF_MEZZO:
        case k_CLEF_ALTO:
        case k_CLEF_G:
        case k_CLEF_F:
        case k_CLEF_G8va:
        case k_CLEF_G15ma:
        case k_CLEF_G8vb:
        case k_CLEF_G15mb:
        case k_CLEF_F8va:
        case k_CLEF_F15ma:
        case k_CLEF_F8vb:
        case k_CLEF_F15mb:
            do_paint_lines(r_ob, g, x1, x2, width, main_staff_color, middleC_y + r_ob->j_inset_y + (clef + 2) * r_ob->step_y, num_staff_lines, staff_lines);
            break;
            
        default: // combinations
        {
            // standard clefs + percussion clef  + none
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_GG) || (clef == k_CLEF_FG) ||  (clef == k_CLEF_G) ||
                (clef == k_CLEF_PERCUSSION) || (clef == k_CLEF_NONE)){
                do_paint_lines(r_ob, g, x1, x2, width, main_staff_color, middleC_y + r_ob->j_inset_y, num_staff_lines, staff_lines); // G staff or similar
            }
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF) || (clef == k_CLEF_FG) ||  (clef == k_CLEF_F)){
                this_y = middleC_y + r_ob->j_inset_y;
                do_paint_lines(r_ob, g, x1, x2, width, main_staff_color, middleC_y + r_ob->j_inset_y + 12 * r_ob->step_y, num_staff_lines, staff_lines); // F staff
            }
            this_y = middleC_y - (2 * 7 * r_ob->step_y) + r_ob->j_inset_y;
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_GG) ||  (clef == k_CLEF_G15ma)){
                do_paint_lines(r_ob, g, x1, x2, width, aux_staff_color, middleC_y - (2 * 7 * r_ob->step_y) + r_ob->j_inset_y, num_staff_lines, staff_lines); // G15 staff
            }
            this_y = middleC_y + (2 * 7 * r_ob->step_y) + r_ob->j_inset_y;
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF) || (clef == k_CLEF_F15mb)){
                do_paint_lines(r_ob, g, x1, x2, width, aux_staff_color, middleC_y + (2 * 7 * r_ob->step_y) + r_ob->j_inset_y + 12 * r_ob->step_y, num_staff_lines, staff_lines); // F15 staff
            }
        }
            break;
    }
}

void write_voicename(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf, double y_pos, char *name, char align, t_jrgba color){
    double width, height, x1, y1;
    long justificationFlags = 0;
    if (strlen(name) > 0) {
        if (align == 0) 
            justificationFlags = JGRAPHICS_TEXT_JUSTIFICATION_LEFT + JGRAPHICS_TEXT_JUSTIFICATION_VCENTERED;
        else if (align == 1) 
            justificationFlags = JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_VCENTERED;
        else 
            justificationFlags = JGRAPHICS_TEXT_JUSTIFICATION_RIGHT + JGRAPHICS_TEXT_JUSTIFICATION_VCENTERED;
        
        x1 = r_ob->j_inset_x + CONST_USPACE_BEFORE_VOICENAMES * r_ob->zoom_y;
        jfont_text_measure(jf, name, &width, &height);
        y1 = y_pos - height/2.;
        write_text(g, jf, color, name, x1, y1, (r_ob->voice_names_uwidth - (CONST_USPACE_BEFORE_VOICENAMES + CONST_USPACE_AFTER_VOICENAMES)) * r_ob->zoom_y, height, justificationFlags, false, false);
    }
}


void paint_clef(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf, double middleC_y, long clef, t_jrgba color, t_jrgba auxcolor)
{
    if (!r_ob->show_clefs)
        return;
    
//#ifdef BACH_MAX
    char Gclefchar[5]; 
    char Fclefchar[5]; 
    char Cclefchar[5]; 
    char Pclefchar[5]; 
    long outlen_G, outlen_F, outlen_C, outlen_P;
    char *Gclefchar_utf, *Fclefchar_utf, *Cclefchar_utf, *Pclefchar_utf;
    // clefs
    Gclefchar_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.clefs_unicode_characters[0], 1, &outlen_G);
    Fclefchar_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.clefs_unicode_characters[1], 1, &outlen_F);
    Cclefchar_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.clefs_unicode_characters[2], 1, &outlen_C);
    Pclefchar_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.clefs_unicode_characters[3], 1, &outlen_P);
    strncpy(Gclefchar, Gclefchar_utf, 4);
    strncpy(Fclefchar, Fclefchar_utf, 4);
    strncpy(Cclefchar, Cclefchar_utf, 4);
    strncpy(Pclefchar, Pclefchar_utf, 4);
    bach_freeptr(Gclefchar_utf);
    bach_freeptr(Fclefchar_utf);
    bach_freeptr(Cclefchar_utf);
    bach_freeptr(Pclefchar_utf);
//#endif
    /*
#ifdef BACH_JUCE
    juce_wchar Gclefchar[2], Fclefchar[2];
    Gclefchar[0] = r_ob->notation_typo_preferences.clefs_unicode_characters[0];
    Gclefchar[1] = 0;
    Fclefchar[0] = r_ob->notation_typo_preferences.clefs_unicode_characters[1];
    Fclefchar[1] = 0;
#endif
     */
    
    double voice_names_uwidth = r_ob->voice_names_uwidth;
    double zoom_y = r_ob->zoom_y, step_y = r_ob->step_y;
    double clef_ux_shift = r_ob->notation_typo_preferences.clef_ux_shift;
    double clef_uy_shift = r_ob->notation_typo_preferences.clef_uy_shift;
    long octave_shift = get_clef_octave_shift(clef);

    t_jfont *jf_littleclefnumber = NULL;
    const char *octave_text = NULL;

    if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FG) || (clef == k_CLEF_GG) ||  (clef == k_CLEF_G))
        write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Gclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + clef_uy_shift) * step_y);
    if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FG) || (clef == k_CLEF_FF) ||  (clef == k_CLEF_F))
        write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Fclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (7.6 + clef_uy_shift) * step_y);
    
    
    if (octave_shift != 0 || (r_ob->show_aux_clefs && (clef == k_CLEF_FFGG || clef == k_CLEF_FGG || clef == k_CLEF_FFG || clef == k_CLEF_GG || clef == k_CLEF_FF))) {
        jf_littleclefnumber = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_CLEF_OCTAVE_NUMBER_BASE_PT * zoom_y);
        octave_text = get_clef_octave_shift_for_clef_text(clef);
    }
    

    if (r_ob->show_aux_clefs && jf_littleclefnumber) {
        if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_GG)) {
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, auxcolor, Gclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + 2 * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, auxcolor, "15", r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_G_CLEF_OCTAVE_NUMBER_UX_SHIFT_ABOVE - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 + 2 * 7 - CONST_G_CLEF_OCTAVE_NUMBER_UY_SHIFT_ABOVE) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
        }
        if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF)) {
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, auxcolor, Fclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (7.6 - 2 * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, auxcolor, "15", r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_F_CLEF_OCTAVE_NUMBER_UX_SHIFT_BELOW - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 - 2 * 7 - CONST_F_CLEF_OCTAVE_NUMBER_UY_SHIFT_BELOW) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
        }
    }
    
    switch (clef) {
        case k_CLEF_G15ma:
        case k_CLEF_G8va:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Gclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + octave_shift * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, color, octave_text, r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_G_CLEF_OCTAVE_NUMBER_UX_SHIFT_ABOVE - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 + octave_shift * 7 - CONST_G_CLEF_OCTAVE_NUMBER_UY_SHIFT_ABOVE) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
            break;

        case k_CLEF_G15mb:
        case k_CLEF_G8vb:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Gclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + octave_shift * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, color, octave_text, r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_G_CLEF_OCTAVE_NUMBER_UX_SHIFT_BELOW - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 + octave_shift * 7 - CONST_G_CLEF_OCTAVE_NUMBER_UY_SHIFT_BELOW) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
            break;
            
        case k_CLEF_F15ma:
        case k_CLEF_F8va:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Fclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (7.6 + octave_shift * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, color, octave_text, r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_F_CLEF_OCTAVE_NUMBER_UX_SHIFT_ABOVE - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 + octave_shift * 7 - CONST_F_CLEF_OCTAVE_NUMBER_UY_SHIFT_ABOVE) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
            break;

        case k_CLEF_F15mb:
        case k_CLEF_F8vb:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Fclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (7.6 + octave_shift * 7 + clef_uy_shift) * step_y);
            write_text(g, jf_littleclefnumber, color, octave_text, r_ob->j_inset_x + clef_ux_shift + (voice_names_uwidth + CONST_F_CLEF_OCTAVE_NUMBER_UX_SHIFT_BELOW - 100) * zoom_y,  r_ob->j_inset_y + middleC_y - (15.8 + octave_shift * 7 - CONST_F_CLEF_OCTAVE_NUMBER_UY_SHIFT_BELOW) * r_ob->step_y, 200 * zoom_y, 200 * zoom_y, JGRAPHICS_TEXT_JUSTIFICATION_HCENTERED + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, false);
            break;

        case k_CLEF_ALTO:
        case k_CLEF_TENOR:
        case k_CLEF_MEZZO:
        case k_CLEF_SOPRANO:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Cclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + clef_uy_shift - 4) * step_y);
            break;

        case k_CLEF_BARYTONE:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Fclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (7.6 + clef_uy_shift + 0) * step_y);
            break;
            
        case k_CLEF_PERCUSSION:
            write_text_standard_account_for_insets_singleline(r_ob, g, jf, color, Pclefchar, 1 + clef_ux_shift + voice_names_uwidth * zoom_y, middleC_y - (15.8 + clef_uy_shift + 2) * step_y);
            break;
            
        default:
            break;
    }
    
    if (jf_littleclefnumber)
        jfont_destroy_debug(jf_littleclefnumber);
}

void paint_keysigaccidentals(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_acc_bogus, t_rational *acc_pattern, t_voice *voice, t_jrgba color, long *clef_mcs, long *mapsto)
{
    unicodeChar acc_text[10]; 
    long i;
    double pos_x = r_ob->zoom_y * CONST_UX_KEYSIGNATURE_START + r_ob->j_inset_x + r_ob->voice_names_uwidth * r_ob->zoom_y;
    acc_text[1] = 0;
    for (i = 0; i < 7; i++){ 
        t_rational this_acc = acc_pattern[mapsto[i]]; //acc_pattern[0]
        if (this_acc.r_num != 0) {
            t_jfont *font;
            double pos_y = mc_to_yposition(r_ob, clef_mcs[mapsto[i]], voice);
 
            acc_text[0] = get_accidental_character(r_ob, this_acc); 
            if (acc_text[0] == 0) {
                font = jf_acc_bogus;
                acc_text[0] = r_ob->accidentals_typo_preferences.unicode_bogus_character; 
            } else
                font = jf_acc;
            {
                long outlen; 
                char *acccharacters_utf;
                char acccharacters[15];
                acccharacters_utf = charset_unicodetoutf8_debug(acc_text, 1, &outlen);
                strncpy(acccharacters, acccharacters_utf, 14);
                write_text(g, font, color, acccharacters, 
                                              pos_x, r_ob->j_inset_y, pos_x * r_ob->zoom_y, pos_y + r_ob->accidentals_typo_preferences.uy_shift * r_ob->zoom_y - r_ob->j_inset_y, 
                                              JGRAPHICS_TEXT_JUSTIFICATION_BOTTOMLEFT, true, false);
                bach_freeptr(acccharacters_utf);
            }
            pos_x += (get_accidental_uwidth(r_ob, this_acc, true) + CONST_KEYSIGNATURE_USPACE_BETWEEN_ACC) * r_ob->zoom_y;
        }
    }
}

long notationobj_get_num_voiceensembles(t_notation_obj *r_ob)
{
    t_voice *voice;
    long count = 0;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        if (voice->part_index == 0)
            count++;
    return count;
}

char do_voices_belong_to_same_voiceensemble(t_notation_obj *r_ob, t_voice *v1, t_voice *v2)
{
    if (v1->number == v2->number)
        return true;
    
    t_voice *m = (v1->number > v2->number) ? v2 : v1;
    t_voice *n = (v1->number > v2->number) ? v1 : v2;
    t_voice *temp;
    
    if (n->part_index == 0)
        return false;
    
    for (temp = voice_get_next(r_ob, m); temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
        if (temp == n)
            break;
        if (temp->part_index == 0)
            return false;
    }
    return true;
}

// get the number of parts of the
long voiceensemble_get_numparts(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble)
{
    if (!any_voice_in_voicenensemble)
        return 0;
    
    t_voice *right = any_voice_in_voicenensemble;
    t_voice *left = any_voice_in_voicenensemble;
    long max = any_voice_in_voicenensemble->part_index;
    while (right && right->number < r_ob->num_voices - 1) {
        t_voice *next = voice_get_next(r_ob, right);
        if (!next || next->part_index == 0)
            break;
        right = next;
        max = MAX(max, right->part_index);
    }
    while (left && left->number >= 0) {
        if (left->part_index == 0)
            break;
        t_voice *prev = voice_get_prev(r_ob, left);
        if (!prev)
            break;
        left = prev;
        max = MAX(max, left->part_index);
    }
    return max + 1;
}

t_voice *voiceensemble_get_firstvoice(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble)
{
    t_voice *left = any_voice_in_voicenensemble;
    while (left && left->number >= 0) {
        if (left->part_index == 0)
            break;
        t_voice *prev = voice_get_prev(r_ob, left);
        if (!prev)
            break;
        left = prev;
    }
    return left;
}

t_voice *voiceensemble_get_lastvoice(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble)
{
    t_voice *right = any_voice_in_voicenensemble;
    while (right && right->number < r_ob->num_voices - 1) {
        t_voice *next = voice_get_next(r_ob, right);
        if (!next || next->part_index == 0)
            break;
        right = next;
    }
    return right;
}


void voiceensemble_break(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble, char add_undo_tick)
{
    long i;
    long part[CONST_MAX_VOICES + 1];
    t_voice *voice;
    
    if (add_undo_tick)
        (r_ob->whole_obj_undo_tick_function)(r_ob);
    
    for (i = 0, voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice), i++) {
        if (do_voices_belong_to_same_voiceensemble(r_ob, voice, any_voice_in_voicenensemble))
            part[i] = 1;
        else
            part[i] = voice->part_index + 1;
    }
    part[i] = -1;
    notation_obj_set_parts(r_ob, part);
}

void voiceensemble_create_from_selection(t_notation_obj *r_ob, char add_undo_tick)
{
    t_voice *first_sel_voice = NULL, *last_sel_voice = NULL;
    t_notation_item *item;
    
    if (add_undo_tick)
        (r_ob->whole_obj_undo_tick_function)(r_ob);

    for (item = r_ob->firstselecteditem; item; item = item->next_selected) {
        if (item->type == k_VOICE) {
            t_voice *voice = (t_voice *)item;
            if (!first_sel_voice || voice->number < first_sel_voice->number)
                first_sel_voice = voice;
            if (!last_sel_voice || voice->number > last_sel_voice->number)
                last_sel_voice = voice;
        }
    }
    
    first_sel_voice = voiceensemble_get_firstvoice(r_ob, first_sel_voice);
    last_sel_voice = voiceensemble_get_firstvoice(r_ob, last_sel_voice);
    
    long i;
    long part[CONST_MAX_VOICES + 1];
    t_voice *voice;
    for (i = 0, voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice), i++) {
        part[i] = voice->part_index + 1;
    }
    part[i] = -1;
    
    for (i = 1, voice = first_sel_voice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice), i++) {
        part[voice->number] = i;
        if (voice == last_sel_voice)
            break;
    }
    notation_obj_set_parts(r_ob, part);
}




t_llll *voiceensemble_get_voicenumbers(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble, char one_based)
{
    t_voice *right = any_voice_in_voicenensemble;
    t_voice *left = any_voice_in_voicenensemble;
    while (right && right->number < r_ob->num_voices - 1) {
        t_voice *next = voice_get_next(r_ob, right);
        if (!next || next->part_index == 0)
            break;
        right = next;
    }
    while (left && left->number >= 0) {
        if (left->part_index == 0)
            break;
        t_voice *prev = voice_get_prev(r_ob, left);
        if (!prev || prev->part_index == 0)
            break;
        left = prev;
    }
    
    t_llll *out = llll_get();
    t_voice *temp;
    for (temp = left; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
        llll_appendlong(out, temp->number + (one_based ? 1 : 0));
        if (temp == right)
            break;
    }
    
    return out;
}


void compatibilize_clef(t_notation_obj *r_ob, long *clef, long with_this_clef)
{
    if (*clef == with_this_clef)
        return; // nothing to do
    
    switch (*clef) {
        case k_CLEF_TENOR:
        case k_CLEF_BARYTONE:
            *clef = k_CLEF_F;
            break;
        case k_CLEF_ALTO:
        case k_CLEF_MEZZO:
        case k_CLEF_SOPRANO:
            *clef = k_CLEF_G;
            break;
        default:
            break;
    }
    
    switch (*clef) {
        case k_CLEF_FFGG:
            return;
        case k_CLEF_FFG:
            if (with_this_clef == k_CLEF_F15mb || with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_FGG:
            if (with_this_clef == k_CLEF_G15ma || with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_FF:
            if (with_this_clef == k_CLEF_G || with_this_clef == k_CLEF_FFG || with_this_clef == k_CLEF_FG)
                *clef = k_CLEF_FFG;
            else if (with_this_clef == k_CLEF_G8va || with_this_clef == k_CLEF_G15ma || with_this_clef == k_CLEF_FFGG || with_this_clef == k_CLEF_FGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_GG:
            if (with_this_clef == k_CLEF_F || with_this_clef == k_CLEF_FGG || with_this_clef == k_CLEF_FG)
                *clef = k_CLEF_FGG;
            else if (with_this_clef == k_CLEF_F8vb || with_this_clef == k_CLEF_F15mb || with_this_clef == k_CLEF_FFGG || with_this_clef == k_CLEF_FFG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_FG:
            if (with_this_clef == k_CLEF_G8va || with_this_clef == k_CLEF_G15ma || with_this_clef == k_CLEF_FGG)
                *clef = k_CLEF_FGG;
            else if (with_this_clef == k_CLEF_F8vb || with_this_clef == k_CLEF_F15mb || with_this_clef == k_CLEF_FFG)
                *clef = k_CLEF_FFG;
            else if (with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_BARYTONE:
        case k_CLEF_TENOR:
        case k_CLEF_F:
            if (with_this_clef == k_CLEF_G || with_this_clef == k_CLEF_SOPRANO || with_this_clef == k_CLEF_ALTO || with_this_clef == k_CLEF_MEZZO || with_this_clef == k_CLEF_FG)
                *clef = k_CLEF_FG;
            else if (with_this_clef == k_CLEF_G8va || with_this_clef == k_CLEF_G15ma || with_this_clef == k_CLEF_FGG)
                *clef = k_CLEF_FGG;
            else if (with_this_clef == k_CLEF_F8vb || with_this_clef == k_CLEF_F15mb)
                *clef = k_CLEF_FF;
            else if (with_this_clef == k_CLEF_FFG)
                *clef = k_CLEF_FFG;
            else if (with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_SOPRANO:
        case k_CLEF_ALTO:
        case k_CLEF_MEZZO:
        case k_CLEF_G:
            if (with_this_clef == k_CLEF_F || with_this_clef == k_CLEF_BARYTONE || with_this_clef == k_CLEF_TENOR)
                *clef = k_CLEF_FG;
            else if (with_this_clef == k_CLEF_F8vb || with_this_clef == k_CLEF_F15mb || with_this_clef == k_CLEF_FFG)
                *clef = k_CLEF_FFG;
            else if (with_this_clef == k_CLEF_G8va || with_this_clef == k_CLEF_G15ma)
                *clef = k_CLEF_GG;
            else if (with_this_clef == k_CLEF_FGG)
                *clef = k_CLEF_FGG;
            else if (with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_PERCUSSION:
            if (with_this_clef != k_CLEF_PERCUSSION)
                *clef = with_this_clef;
            return;
        case k_CLEF_NONE:
            *clef = with_this_clef;
            return;
        case k_CLEF_G15ma:
        case k_CLEF_G8va:
            if (with_this_clef == k_CLEF_G8va || with_this_clef == k_CLEF_G15ma || with_this_clef == k_CLEF_G || with_this_clef == k_CLEF_GG || with_this_clef == k_CLEF_SOPRANO || with_this_clef == k_CLEF_MEZZO || with_this_clef == k_CLEF_ALTO)
                *clef = k_CLEF_GG;
            else if (with_this_clef == k_CLEF_FG || with_this_clef == k_CLEF_F || with_this_clef == k_CLEF_FGG || with_this_clef == k_CLEF_BARYTONE || with_this_clef == k_CLEF_TENOR)
                *clef = k_CLEF_FGG;
            else if (with_this_clef == k_CLEF_FFG || with_this_clef == k_CLEF_FF || with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
        case k_CLEF_F15mb:
        case k_CLEF_F8vb:
            if (with_this_clef == k_CLEF_F8vb || with_this_clef == k_CLEF_F15mb || with_this_clef == k_CLEF_F || with_this_clef == k_CLEF_FF || with_this_clef == k_CLEF_BARYTONE || with_this_clef == k_CLEF_TENOR)
                *clef = k_CLEF_FF;
            else if (with_this_clef == k_CLEF_FG || with_this_clef == k_CLEF_G || with_this_clef == k_CLEF_FFG || with_this_clef == k_CLEF_SOPRANO || with_this_clef == k_CLEF_MEZZO || with_this_clef == k_CLEF_ALTO)
                *clef = k_CLEF_FFG;
            else if (with_this_clef == k_CLEF_FGG || with_this_clef == k_CLEF_GG || with_this_clef == k_CLEF_FFGG)
                *clef = k_CLEF_FFGG;
            return;
    }
}




long get_clef_octave_shift(long clef)
{
    switch (clef) {
        case k_CLEF_G8va:
        case k_CLEF_F8va:
            return 1;

        case k_CLEF_G15ma:
        case k_CLEF_F15ma:
            return 2;

        case k_CLEF_G8vb:
        case k_CLEF_F8vb:
            return -1;
            
        case k_CLEF_G15mb:
        case k_CLEF_F15mb:
            return -2;

        default:
            return 0;
    }
}


const char *get_clef_octave_shift_for_clef_text(long clef)
{
    int shift = get_clef_octave_shift(clef);
    switch (abs(shift)) {
        case 1:
            return "8";
        case 2:
            return "15";
        case 3:
            return "22";
        default:
            return "";
    }
}


long get_voice_clef(t_notation_obj *r_ob, t_voice *voice)
{
/*    t_voice *temp = voice;
    while (temp->part_index != 0)
        temp = voice_get_prev(r_ob, temp);
    return temp ? temp->clef : k_CLEF_G;
 */
    
    t_voice *start = voiceensemble_get_firstvoice(r_ob, voice);
    t_voice *end = voiceensemble_get_lastvoice(r_ob, voice);
    if (start != end) {
        // making clefs compatible across the whole voiceensemble
        t_voice *temp;
        long clef = start->clef;
        for (temp = start; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
            compatibilize_clef(r_ob, &clef, temp->clef);
            if (temp == end)
                break;
        }
        return clef;
    } else {
        return voice->clef;
    }
}

void paint_keysignature(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_acc_bogus, double middleC_y, t_voice *voice, t_jrgba color)
{
    long i;
    long mapsto[7];
    long clef_mcs[7];
    t_rational *acc_pattern = voice->acc_pattern;
    long key = (long)voice->key;
    long clef = get_voice_clef(r_ob, voice);
    
    if (clef == k_CLEF_PERCUSSION)
        return;
    
    // shifts
    long shift = get_clef_octave_shift(clef) * 1200;
    
    if (key > 0) { // # 5ths-circle
        mapsto[0] = 3;
        mapsto[1] = 0;
        mapsto[2] = 4;
        mapsto[3] = 1;
        mapsto[4] = 5;
        mapsto[5] = 2;
        mapsto[6] = 6;
    } else if (key > -100) { // b 5ths-circle
        mapsto[0] = 6;
        mapsto[1] = 2;
        mapsto[2] = 5;
        mapsto[3] = 1;
        mapsto[4] = 4;
        mapsto[5] = 0;
        mapsto[6] = 3;
    } else { // nonstandard
        for (i = 0; i < 7; i++)
            mapsto[i] = i;
    }

    if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FG) || (clef == k_CLEF_GG) ||  (clef == k_CLEF_G) || (clef == k_CLEF_NONE)) { // G clef
        clef_mcs[0] = 7200;
        clef_mcs[1] = 7400;
        clef_mcs[2] = 7600;
        clef_mcs[3] = (key > 0) ? 7700 : 6500;
        clef_mcs[4] = (key > 0) ? 7900 : 6700;
        clef_mcs[5] = 6900;
        clef_mcs[6] = 7100;
        paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
        
        if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_GG)) {
            for (long i = 0; i < 7; i++)
                clef_mcs[i] += 2400;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
        }
    }
    
    if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FG) || (clef == k_CLEF_FF) ||  (clef == k_CLEF_F)) { // F clef
        clef_mcs[0] = 4800;
        clef_mcs[1] = 5000;
        clef_mcs[2] = 5200;
        clef_mcs[3] = (key > 0) ? 5300 : 4100;
        clef_mcs[4] = (key > 0) ? 5500 : 4300;
        clef_mcs[5] = 4500;
        clef_mcs[6] = 4700;
        paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
        
        if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF)) {
            for (long i = 0; i < 7; i++)
                clef_mcs[i] -= 2400;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
        }
    }
    
    
    // single clefs
    switch (clef) {
        case k_CLEF_G15ma:
        case k_CLEF_G8va:
        case k_CLEF_G8vb:
        case k_CLEF_G15mb:
            clef_mcs[0] = 7200 + shift;
            clef_mcs[1] = 7400 + shift;
            clef_mcs[2] = 7600 + shift;
            clef_mcs[3] = (key > 0) ? 7700 + shift : 6500 + shift;
            clef_mcs[4] = (key > 0) ? 7800 + shift : 6700 + shift;
            clef_mcs[5] = 6900 + shift;
            clef_mcs[6] = 7100 + shift;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;

        case k_CLEF_F15ma:
        case k_CLEF_F8va:
        case k_CLEF_F8vb:
        case k_CLEF_F15mb:
            clef_mcs[0] = 4800 + shift;
            clef_mcs[1] = 5000 + shift;
            clef_mcs[2] = 5200 + shift;
            clef_mcs[3] = (key > 0) ? 5300 + shift : 4100 + shift;
            clef_mcs[4] = (key > 0) ? 5500 + shift : 4300 + shift;
            clef_mcs[5] = 4500 + shift;
            clef_mcs[6] = 4700 + shift;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;
            
        case k_CLEF_SOPRANO:
        case k_CLEF_MEZZO:
            clef_mcs[0] = 6000;
            clef_mcs[1] = 6200;
            clef_mcs[2] = 6400;
            clef_mcs[3] = 6500;
            clef_mcs[4] = 6700;
            clef_mcs[5] = 6900;
            clef_mcs[6] = 7100;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;
            
        case k_CLEF_ALTO:
            clef_mcs[0] = 6000;
            clef_mcs[1] = 6200;
            clef_mcs[2] = 6400;
            clef_mcs[3] = (key > 0) ? 6500 : 5300;
            clef_mcs[4] = (key > 0) ? 6700 : 5500;
            clef_mcs[5] = 5700;
            clef_mcs[6] = 5900;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;
            
        case k_CLEF_TENOR:
            clef_mcs[0] = 6000;
            clef_mcs[1] = 6200;
            clef_mcs[2] = 6400;
            clef_mcs[3] = 5300;
            clef_mcs[4] = 5500;
            clef_mcs[5] = 5700;
            clef_mcs[6] = 5900;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;
            
        case k_CLEF_BARYTONE:
            clef_mcs[0] = 4800;
            clef_mcs[1] = 5000;
            clef_mcs[2] = 5200;
            clef_mcs[3] = 5300;
            clef_mcs[4] = 5500;
            clef_mcs[5] = 4500;
            clef_mcs[6] = 4700;
            paint_keysigaccidentals(r_ob, g, jf_acc, jf_acc_bogus, acc_pattern, voice, color, clef_mcs, mapsto);
            break;
            
        default:
            break;
    }
}

char is_clef_multistaff(t_notation_obj *r_ob, long clef)
{
    switch (clef) {
        case k_CLEF_FFGG:
        case k_CLEF_FGG:
        case k_CLEF_FFG:
        case k_CLEF_FG:
        case k_CLEF_GG:
        case k_CLEF_FF:
            return 1;
            break;
            
        default:
            return 0;
            break;
    }
}

void paint_accollatura(t_notation_obj *r_ob, t_jgraphics* g, double stafftop_y, double staffbottom_y, t_jrgba color)
{
    double xx = r_ob->j_inset_x + r_ob->voice_names_uwidth * r_ob->zoom_y - 3;
    const double delta = 0.7 * r_ob->step_y;
    const double width = 2.; // * r_ob->zoom_y;
    double y1 = stafftop_y, y2 = staffbottom_y;
    
    jgraphics_move_to(g, xx + delta, y2 + delta);
    jgraphics_line_to(g, xx, y2);
    jgraphics_line_to(g, xx, y1);
    jgraphics_line_to(g, xx + delta, y1 - delta);
    jgraphics_set_line_width(g,width);
    jgraphics_set_source_jrgba(g, &color);
    jgraphics_stroke(g);
}

void paint_playhead(t_notation_obj *r_ob, t_jgraphics* g, t_rect rect)
{
    double playhead_y1, playhead_y2, play_head_pos;
    if (r_ob->playing) {
        get_playhead_ypos(r_ob, rect, &playhead_y1, &playhead_y2);
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            play_head_pos = unscaled_xposition_to_xposition(r_ob, r_ob->play_head_ux);
        else
            play_head_pos = onset_to_xposition_roll(r_ob, r_ob->play_head_ms, NULL);

        paint_playhead_line(g, r_ob->j_play_rgba, play_head_pos, playhead_y1, playhead_y2, 1., 3 * r_ob->zoom_y);
    } else if (r_ob->show_playhead) {
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            play_head_pos = unscaled_xposition_to_xposition(r_ob, r_ob->play_head_start_ux);
        else
            play_head_pos = onset_to_xposition_roll(r_ob, r_ob->play_head_start_ms, NULL);

        get_playhead_ypos(r_ob, rect, &playhead_y1, &playhead_y2);
        paint_playhead_line(g, r_ob->j_play_rgba, play_head_pos, playhead_y1, playhead_y2, 1., 3 * r_ob->zoom_y);
    }
    
}


void notationobj_paint_legend(t_notation_obj *r_ob, t_jgraphics *g, t_rect rect, t_jfont *jf_text_legend)
{
    // upper legend (selected element's legend)
    char legend_text[256];
    notationobj_get_legend(r_ob, legend_text);
    if (legend_text[0]) {
        double ww, hh;
        jfont_text_measure(jf_text_legend, legend_text, &ww, &hh);
        paint_filledrectangle(g, r_ob->j_background_rgba, 0., 0., ww + r_ob->j_inset_x + 2 * r_ob->zoom_y, 1.3 * r_ob->legend_font_size);
        write_text(g, jf_text_legend, r_ob->j_selectedlegend_rgba, legend_text, r_ob->j_inset_x, 1, rect.width - 2 * r_ob->j_inset_x, rect.height - 1, JGRAPHICS_TEXT_JUSTIFICATION_LEFT + JGRAPHICS_TEXT_JUSTIFICATION_TOP, true, true);
    }
}


double chord_get_max_duration(t_notation_obj *r_ob, t_chord *chord)
{
    double max_duration = 0;
    t_note *curr_nt;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
        for (curr_nt = chord->firstnote; curr_nt; curr_nt = curr_nt->next)
            if (curr_nt->duration > max_duration)
                max_duration = curr_nt->duration;
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
        max_duration = chord->duration_ms;
    }
    return max_duration;
}

long chord_get_max_velocity(t_notation_obj *r_ob, t_chord *chord)
{
    long max_velocity = 0;
    t_note *curr_nt = chord->firstnote;
    while (curr_nt) {
        if (curr_nt->velocity > max_velocity)
            max_velocity = curr_nt->velocity;
        curr_nt = curr_nt->next;
    }
    return max_velocity;
}

// DRAFT FOR HAVING NOTES INSTEAD OF RHOMBOIDS. COULD BE MADE FASTER IF "foo" note and chords were stored somewhere in the breakpoints.
void paint_default_small_notehead_with_accidentals(t_notation_obj *r_ob, t_object *view, t_jgraphics *g, t_jrgba notecolor, double midicents, double notehead_center_x, t_note *note_attachment, double system_shift, double small_note_ratio)
{
    t_jrgba color = notecolor;
    t_voice *voice = !note_attachment ? NULL : (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)note_attachment->parent->voiceparent : (t_voice *)note_attachment->parent->parent->voiceparent);
    t_jfont *jf_smallnote = jfont_create_debug(r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, small_note_ratio * r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y);
    t_jfont *jf_smallacc = jfont_create_debug(r_ob->accidentals_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, small_note_ratio * r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y);
    t_jfont *jf_smallaccbogus = jfont_create_debug(r_ob->accidentals_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, small_note_ratio * r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y);
    t_jfont *jf_text_fractions = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_TEXT_FRACTIONS_PT * r_ob->zoom_y);
    double notehead_left_x;
    double noteuwidth = 0;
    t_note *foo = build_default_note(r_ob);
    t_chord *ch = build_chord_from_notes(r_ob, foo, foo);
    if (note_attachment && r_ob) {
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) 
            ch->parent = note_attachment->parent->parent;
        else if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            ch->voiceparent = (t_rollvoice *)voice;
    }
    ch->is_grace_chord = true;
    ch->r_sym_duration = RAT_1OVER8;
    ch->notehead_unicode_character = get_notehead_unicode_character(r_ob, RAT_1OVER8, &noteuwidth);
    ch->imposed_direction = -1;
    foo->midicents = midicents;
    note_compute_approximation(r_ob, foo);
    calculate_chord_parameters(r_ob, ch, get_voice_clef(r_ob, voice), false);
    
    // ledger lines
    double ledger_lines_y[CONST_MAX_LEDGER_LINES]; 
    int num_ledger_lines = 0, i;
    get_ledger_lines(r_ob, voice, midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(foo)), &num_ledger_lines, ledger_lines_y); // let's obtain the list of ledger lines y
    for (i = 0; i < num_ledger_lines; i++)
        paint_line(g, r_ob->j_mainstaves_rgba, notehead_center_x - CONST_LEDGER_LINES_HALF_UWIDTH * small_note_ratio * r_ob->zoom_y, ledger_lines_y[i], 
                   notehead_center_x + CONST_LEDGER_LINES_HALF_UWIDTH * small_note_ratio * r_ob->zoom_y, ledger_lines_y[i], 1.);
    
    notehead_left_x = notehead_center_x - notehead_get_uwidth(r_ob, RAT_1OVER4, NULL, false) * small_note_ratio / 2;
    
    // notehead and accidentals
    foo->notehead_resize = 1.;
    paint_notehead(r_ob, view, g, jf_smallnote, &color, foo, notehead_center_x, mc_to_yposition_in_scale_for_notes(r_ob, foo, voice, 0.7), system_shift, small_note_ratio);
    paint_noteaccidentals(r_ob, g, jf_smallacc, jf_text_fractions, jf_smallaccbogus, &color, foo, 
                          get_voice_clef(r_ob, voice), mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(foo), voice), notehead_left_x, NULL, NULL);
    free_chord(r_ob, ch);
    jfont_destroy_debug(jf_smallnote);
    jfont_destroy_debug(jf_smallacc);
    jfont_destroy_debug(jf_smallaccbogus);
    jfont_destroy_debug(jf_text_fractions);
}

double note_get_spanning_width(t_notation_obj *r_ob, t_note *nt)
{
    if (!nt) return 0;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (nt->parent && nt->parent->parent && nt->parent->parent->tuttipoint_reference) {
            double al_x = chord_get_alignment_x(r_ob, nt->parent);
            double end_pos = unscaled_xposition_to_xposition(r_ob, nt->parent->parent->tuttipoint_reference->offset_ux + nt->parent->stem_offset_ux + nt->parent->duration_ux);
            if (r_ob->dl_spans_ties) {
                t_note *last_tie = note_get_last_in_tieseq(nt);
                if (last_tie && last_tie != nt)
                    end_pos = unscaled_xposition_to_xposition(r_ob, last_tie->parent->parent->tuttipoint_reference->offset_ux + last_tie->parent->stem_offset_ux + last_tie->parent->duration_ux);
            }
            return end_pos - al_x;
        }
    } else {
        return deltaonset_to_deltaxpixels(r_ob, nt->duration);
    }
    return 0;
}

// use breakpoint_get_pt()
/*
double breakpoint_get_x(t_notation_obj *r_ob, t_bpt *bpt)
{
    if (!bpt) return 0;
    
    t_note *nt = bpt->owner;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (nt->parent && nt->parent->parent && nt->parent->parent->tuttipoint_reference) {
            double al_x = chord_get_alignment_x(r_ob, nt->parent);
            return al_x + note_get_spanning_width(r_ob, nt) * bpt->rel_x_pos;
        }
    } else {
        return onset_to_xposition_roll(r_ob, nt->parent->onset + bpt->rel_x_pos * nt->duration, NULL);
    }
    return 0;
}
*/

void paint_duration_line(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_jrgba notecolor, t_jrgba tailcolor, t_note *curr_nt, double end_pos, double system_shift, double system_jump, char note_unselected, char is_chord_selected, char is_note_selected, char is_durationline_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, t_bpt **selected_breakpoint){
    
    t_voice *voice = r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)curr_nt->parent->voiceparent : (t_voice *)curr_nt->parent->parent->voiceparent;
    
    if (selected_breakpoint)
        *selected_breakpoint = NULL;
    
    double (*mc_to_ypos)(t_notation_obj *, double, t_voice *) = r_ob->breakpoints_have_noteheads ? mc_to_yposition_quantized : mc_to_yposition;
    double mc_or_screen_mc = r_ob->breakpoints_have_noteheads ? curr_nt->midicents : note_get_screen_midicents(curr_nt);
        
    double start_x = curr_nt->center.x + (curr_nt->notehead_uwidth / 2. + get_notehead_durationline_start_ux_shift(r_ob, curr_nt)) * r_ob->zoom_y;
    if (r_ob->show_durations && r_ob->allow_glissandi) { // there are nontrivial breakpoints (trivial bpts are head and tail)
        t_bpt *temp = curr_nt->firstbreakpoint->next;
        double prev_bpt_y = system_shift + mc_to_yposition(r_ob, note_get_screen_midicents(curr_nt), voice);
        double prev_bpt_x = start_x;
        long end_system = -1;
        long curr_system = curr_nt->parent->system_index;
        long number_of_rupture_points = end_system - curr_nt->parent->system_index; 
        long t; 
        long curr_rupture_point = 0;
        double rupture_rel_x[50]; // rupture points TODO Change the 50. 
        
        // getting rupture_points (page view)
        for (t = 0; t < number_of_rupture_points && t < 50; t++)
            rupture_rel_x[t] = (system_index_to_system_end_ms(r_ob, curr_nt->parent->system_index + t) - curr_nt->parent->onset)/ curr_nt->duration;
        
        // first: draw all the curves
        while (temp) {
            double bpt_x, bpt_y;
            // check rupture points (page view)
            if (curr_rupture_point < number_of_rupture_points) {
                while ((curr_rupture_point < number_of_rupture_points) && (temp->rel_x_pos >= rupture_rel_x[curr_rupture_point])) {
                    // draw partial line/curve
                    double bpt_x = r_ob->width - r_ob->j_inset_x;
                    double bpt_y;
 
                    bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, mc_or_screen_mc + rescale_with_slope(rupture_rel_x[curr_rupture_point], temp->prev->rel_x_pos, temp->rel_x_pos, temp->prev->delta_mc, temp->delta_mc, temp->slope), voice);
                    
                    if (r_ob->velocity_handling == k_VELOCITY_HANDLING_DURATIONLINEWIDTH && r_ob->breakpoints_have_velocity) {
                        double width1 = r_ob->durations_line_width * r_ob->zoom_y * (((double) (temp->prev->prev ? temp->prev->velocity : curr_nt->velocity)) / CONST_MAX_VELOCITY + 0.1);
                        double width2 = r_ob->durations_line_width * r_ob->zoom_y * (((double) temp->velocity) / CONST_MAX_VELOCITY + 0.1);
                        paint_doublewidth_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, width1, width2);
                    } else if (r_ob->velocity_handling == k_VELOCITY_HANDLING_DURATIONLINEWIDTH) 
                        paint_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, r_ob->durations_line_width * r_ob->zoom_y * (((double)curr_nt->velocity) / CONST_MAX_VELOCITY + 0.1));
                    else
                        paint_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, r_ob->durations_line_width * r_ob->zoom_y);
                    
                    prev_bpt_x = r_ob->j_inset_x + CONST_ROLL_UX_LEFT_START * r_ob->zoom_y; 
                    prev_bpt_y = bpt_y + system_jump;
                    curr_rupture_point++;
                    curr_system++;
                }
            }
            
            // draw main line/curve
            bpt_x = onset_to_xposition_roll(r_ob, curr_nt->parent->onset+temp->rel_x_pos * curr_nt->duration, &curr_system);
            if (temp->rel_x_pos >= 1. && (r_ob->breakpoints_have_noteheads)) {
                if (!temp->prev || temp->delta_mc != temp->prev->delta_mc)
                    bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, curr_nt->midicents + round(temp->delta_mc), (t_voice *) voice);
                else
                    bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, mc_or_screen_mc + round(temp->delta_mc), (t_voice *) voice);
            } else
                bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, mc_or_screen_mc + round(temp->delta_mc), (t_voice *) voice);
    
            if (r_ob->velocity_handling == k_VELOCITY_HANDLING_DURATIONLINEWIDTH && r_ob->breakpoints_have_velocity)  {
                double width1 = r_ob->durations_line_width * r_ob->zoom_y * (((double) (temp->prev->prev ? temp->prev->velocity : curr_nt->velocity)) / CONST_MAX_VELOCITY + 0.1);
                double width2 = r_ob->durations_line_width * r_ob->zoom_y * (((double) temp->velocity) / CONST_MAX_VELOCITY + 0.1);
                paint_doublewidth_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, width1, width2);
            } else if (r_ob->velocity_handling == k_VELOCITY_HANDLING_DURATIONLINEWIDTH) 
                paint_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, rescale((double)curr_nt->velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY, 0.5, r_ob->durations_line_width * r_ob->zoom_y));
            else if ((r_ob->velocity_handling == k_VELOCITY_HANDLING_COLORSCALE || r_ob->velocity_handling == k_VELOCITY_HANDLING_ALPHACHANNEL || 
                      r_ob->velocity_handling == k_VELOCITY_HANDLING_COLORSPECTRUM) && r_ob->breakpoints_have_velocity) {
                long vel1 = temp->prev->prev ? temp->prev->velocity : curr_nt->velocity;
                t_jrgba color_start = note_get_color(r_ob, curr_nt, !note_unselected && (is_chord_selected || is_note_selected || is_durationline_selected), 
                                                     is_note_played, is_note_locked, is_note_muted, is_note_solo, false, vel1);
                t_jrgba color_end = note_get_color(r_ob, curr_nt, !note_unselected && (is_chord_selected || is_note_selected || is_durationline_selected), 
                                                   is_note_played, is_note_locked, is_note_muted, is_note_solo, false, temp->velocity);
                long num_steps = MAX(labs(vel1 - CLAMP(temp->velocity, 0, CONST_MAX_VELOCITY)) * 1, 1);
                paint_colorgradient_curve(g, color_start, color_end, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, r_ob->durations_line_width * r_ob->zoom_y, num_steps, 
                                          r_ob->velocity_handling == k_VELOCITY_HANDLING_COLORSPECTRUM && 
                                          !(!note_unselected && (is_chord_selected || is_note_selected || is_durationline_selected)), vel1, temp->velocity, CONST_MAX_VELOCITY);
            } else
                paint_curve(g, notecolor, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, r_ob->durations_line_width * r_ob->zoom_y);
            if (temp->rel_x_pos < 1.) { 
                prev_bpt_x = bpt_x; 
                prev_bpt_y = bpt_y; 
            }
            temp = temp->next;
        }
        
        // then draw all the breakpoints (as rhomboids)
        temp = curr_nt->firstbreakpoint->next;
        curr_rupture_point = 0; 
        curr_system = curr_nt->parent->system_index;
        while (temp) {
            // checking rupture points
            if (curr_rupture_point < number_of_rupture_points) {
                while ((curr_rupture_point < number_of_rupture_points) && (temp->rel_x_pos >= rupture_rel_x[curr_rupture_point])) {
                    curr_rupture_point++;
                    curr_system++;
                }
            }
            
            if (temp->rel_x_pos < 1.) {
                double bpt_x = onset_to_xposition_roll(r_ob, curr_nt->parent->onset+temp->rel_x_pos * curr_nt->duration, &curr_system);
                double bpt_y = 0;
                char is_bpt_selected;
                t_jrgba bptcolor;
                
                bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, mc_or_screen_mc + round(temp->delta_mc), (t_voice *) voice);
                
                prev_bpt_x = bpt_x; prev_bpt_y = bpt_y;
                is_bpt_selected = (notation_item_is_selected(r_ob, (t_notation_item *)temp) ^ notation_item_is_preselected(r_ob, (t_notation_item *)temp));
                if (is_bpt_selected && selected_breakpoint) 
                    *selected_breakpoint = temp; 
                bptcolor = tail_get_color(r_ob, curr_nt, (is_chord_selected || is_note_selected || is_durationline_selected || is_bpt_selected), is_note_played, is_note_locked, is_note_muted, is_note_solo, false, r_ob->breakpoints_have_velocity ? temp->velocity : curr_nt->velocity);
                    
                if (r_ob->breakpoints_have_noteheads) {
                    paint_default_small_notehead_with_accidentals(r_ob, view, g, bptcolor, temp->delta_mc + curr_nt->midicents, bpt_x, curr_nt, system_shift, (r_ob->breakpoints_have_velocity && r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE) ? velocity_to_notesize_factor(temp->velocity) : CONST_GRACE_CHORD_SIZE );
                } else { 
                    paint_rhomboid(g, r_ob->j_background_rgba, bptcolor, bpt_x, bpt_y, r_ob->breakpoints_size * 0.6 * r_ob->zoom_y, r_ob->breakpoints_size * r_ob->zoom_y, 0.9);
                }
            } else { //it's a tail
                if (r_ob->breakpoints_have_noteheads && (!temp->prev || temp->delta_mc != temp->prev->delta_mc)) {
                    paint_default_small_notehead_with_accidentals(r_ob, view, g, tailcolor, temp->delta_mc + curr_nt->midicents, end_pos, curr_nt, system_shift, (r_ob->breakpoints_have_velocity && r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE) ? velocity_to_notesize_factor(temp->velocity) : CONST_GRACE_CHORD_SIZE);
                } else { 
                    if (r_ob->show_tails) {
                        double bpt_y = system_shift + curr_rupture_point * system_jump + mc_to_ypos(r_ob, mc_or_screen_mc + round(temp->delta_mc), (t_voice *) voice);
                        paint_line(g, tailcolor, end_pos, bpt_y - r_ob->breakpoints_size * 0.666 * r_ob->zoom_y, end_pos, bpt_y + r_ob->breakpoints_size * 0.666 * r_ob->zoom_y, CONST_NOTETAIL_UWIDTH * r_ob->zoom_y);
                    }
                }
            }
            temp = temp->next;
        }
        
        if (selected_breakpoint && notation_item_is_selected(r_ob, (t_notation_item *)curr_nt->lastbreakpoint) ^ notation_item_is_preselected(r_ob, (t_notation_item *)curr_nt->lastbreakpoint))
            *selected_breakpoint = curr_nt->lastbreakpoint;

    } else if (r_ob->show_durations){
        double line_y = system_shift + mc_to_yposition(r_ob, note_get_screen_midicents(curr_nt), (t_voice *) voice);
        paint_line(g, notecolor, start_x, line_y, end_pos, line_y, r_ob->durations_line_width * r_ob->zoom_y);
        paint_line(g, tailcolor, end_pos, line_y - 2. * r_ob->zoom_y, end_pos, line_y + 2. * r_ob->zoom_y, r_ob->durations_line_width * r_ob->zoom_y);
    }
}

void initialize_or_resize_surface(t_jsurface **surface, long width, long height)
{
    if (surface && *surface)
        jgraphics_surface_destroy(*surface);
    *surface = jgraphics_image_surface_create(JGRAPHICS_FORMAT_ARGB32, width, height);
}

void notationobj_build_clef_gradient_surface(t_notation_obj *r_ob){
    const double SURFACE_HEIGHT = 10;

    initialize_or_resize_surface(&r_ob->clef_gradient_surface, CONST_X_LEFT_START_FADE_NUM_STEPS, SURFACE_HEIGHT);
    t_jrgba fadecol = r_ob->j_background_rgba; //build_jrgba(1, 0, 0, 1); // r_ob->j_background_rgba; 
    double originary_alpha = fadecol.alpha;
    long i, j;
    
    for (i = 0; i < CONST_X_LEFT_START_FADE_NUM_STEPS; i++){
        fadecol.alpha = originary_alpha * ((double) (CONST_X_LEFT_START_FADE_NUM_STEPS - i)) / CONST_X_LEFT_START_FADE_NUM_STEPS;
        for (j = 0; j < SURFACE_HEIGHT; j++)
            jgraphics_image_surface_set_pixel(r_ob->clef_gradient_surface, i, j, fadecol);
    }
}



void notationobj_build_notation_item_surfaces(t_notation_obj *r_ob, t_object *view, t_rect rect){
    char *noteheadchar_utf;
    char noteheadchar[5]; 
    long outlen_notehead;
    double patcher_zoom = patcherview_get_zoomfactor(view);
    long size = ceil(100 * r_ob->zoom_y * patcher_zoom); // loooooose boundary
    t_jfont *jf = jfont_create_debug(r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, 
                                     r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y * patcher_zoom);

    
    initialize_or_resize_surface(&r_ob->quarternotehead_surface, size, size);
    initialize_or_resize_surface(&r_ob->selected_quarternotehead_surface, size, size);
    initialize_or_resize_surface(&r_ob->solo_quarternotehead_surface, size, size);
    initialize_or_resize_surface(&r_ob->mute_quarternotehead_surface, size, size);
    initialize_or_resize_surface(&r_ob->lock_quarternotehead_surface, size, size);
    
    t_jgraphics *g_context1 = jgraphics_create(r_ob->quarternotehead_surface);
    t_jgraphics *g_context2 = jgraphics_create(r_ob->selected_quarternotehead_surface);
    t_jgraphics *g_context3 = jgraphics_create(r_ob->solo_quarternotehead_surface);
    t_jgraphics *g_context4 = jgraphics_create(r_ob->mute_quarternotehead_surface);
    t_jgraphics *g_context5 = jgraphics_create(r_ob->lock_quarternotehead_surface);

    noteheadchar_utf = charset_unicodetoutf8_debug(&r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].unicode_character_black, 1, &outlen_notehead);
    strncpy(noteheadchar, noteheadchar_utf, 4);
    bach_freeptr(noteheadchar_utf);

    if (g_context1) {
        write_text_standard(g_context1, jf, r_ob->j_note_rgba, noteheadchar, 0, r_ob->j_inset_y, size, size);
        jgraphics_destroy(g_context1); 
    }
    if (g_context2) {
        write_text_standard(g_context2, jf, r_ob->j_selection_rgba, noteheadchar, 0, r_ob->j_inset_y, size, size);
        jgraphics_destroy(g_context2); 
    }
    if (g_context3) {
        write_text_standard(g_context3, jf, r_ob->j_solo_rgba, noteheadchar, 0, r_ob->j_inset_y, size, size);
        jgraphics_destroy(g_context3); 
    }
    if (g_context4) {
        write_text_standard(g_context4, jf, r_ob->j_muted_rgba, noteheadchar, 0, r_ob->j_inset_y, size, size);
        jgraphics_destroy(g_context4); 
    }
    if (g_context5) {
        write_text_standard(g_context5, jf, r_ob->j_locked_rgba, noteheadchar, 0, r_ob->j_inset_y, size, size);
        jgraphics_destroy(g_context5); 
    }
    
    jfont_destroy_debug(jf);
}

t_jrgba label_family_to_color(t_notation_obj *r_ob, t_bach_label_family *fam)
{
    // This algorithm assures that families "close" to each other (in the llll of families) have rather different colors!
    // which is rather useful, especially for pattern matching.
    double val =  fmod(llllelem_retrieve_index(r_ob->m_labels.families, fam->llelem) * PI/5., 1.);
    return change_alpha(double_to_color(val, 0., 1., false), 0.7);
/*    t_jrgba color = double_to_color(val, 0., 1., false);
    t_jhsla color_hsla = rgba_to_hsla(color);
    color_hsla.saturation /= 2;
    return change_alpha(hsla_to_rgba(color_hsla), 0.7); */
}

void paint_note_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_note *curr_nt, double *label_family_chord_shape_radius)
{
    if (!curr_nt || !curr_nt->r_it.label_families)
        return;
    
    t_llllelem *elem;
    double label_family_note_shape_radius = CONST_LABEL_FAMILY_NOTE_STARTING_URADIUS * r_ob->zoom_y;
    for (elem = curr_nt->r_it.label_families->l_head; elem; elem = elem->l_next) {
        t_llll *ll = hatom_getllll(&elem->l_hatom);
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
        t_jrgba color = label_family_to_color(r_ob, fam);

        paint_circle(g, color, change_alpha(color, 0.05), curr_nt->center.x, curr_nt->center.y, label_family_note_shape_radius, CONST_LABEL_FAMILY_LINE_WIDTH);
//        paint_circle_stroken(g, color, curr_nt->center.x, curr_nt->center.y, label_family_note_shape_radius, CONST_LABEL_FAMILY_LINE_WIDTH);
        
        label_family_note_shape_radius += CONST_LABEL_FAMILY_NOTE_SEPARATION_URADIUS * r_ob->zoom_y;
    }
    
    if (label_family_chord_shape_radius && *label_family_chord_shape_radius < label_family_note_shape_radius)
        *label_family_chord_shape_radius = label_family_note_shape_radius;
}



void paint_chord_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_chord *curr_ch, double start_label_family_chord_shape_radius)
{
    if (!curr_ch || !curr_ch->r_it.label_families)
        return;
    
    t_llllelem *elem;
    double label_family_chord_shape_radius = start_label_family_chord_shape_radius;
    for (elem = curr_ch->r_it.label_families->l_head; elem; elem = elem->l_next) {
        t_llll *ll = hatom_getllll(&elem->l_hatom);
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
        t_jrgba color = label_family_to_color(r_ob, fam);
        double top_y, bottom_y;
        
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            top_y = curr_ch->topmost_y;
            bottom_y = curr_ch->bottommost_y;
        } else {
            top_y = curr_ch->lastnote->center.y;
            bottom_y = curr_ch->firstnote->center.y;
        }
        
        paint_rectangle(g, color, change_alpha(color, 0.05), 
                        curr_ch->stem_x - curr_ch->left_uextension * r_ob->zoom_y - label_family_chord_shape_radius,
                        top_y - label_family_chord_shape_radius, 
                        curr_ch->left_uextension + curr_ch->right_uextension + 2 * label_family_chord_shape_radius, 
                        bottom_y - top_y + 2 * label_family_chord_shape_radius, CONST_LABEL_FAMILY_LINE_WIDTH);
        
        label_family_chord_shape_radius += CONST_LABEL_FAMILY_NOTE_SEPARATION_URADIUS * r_ob->zoom_y;
    }
}

void paint_measure_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_measure *curr_meas)
{
    if (!curr_meas || !curr_meas->r_it.label_families || !curr_meas->tuttipoint_reference)
        return;
    
    t_llllelem *elem;
    double staff_top = get_staff_top_y(r_ob, (t_voice *) curr_meas->voiceparent, false);
    double staff_bottom = get_staff_bottom_y(r_ob, (t_voice *) curr_meas->voiceparent, false);
    t_rect label_rect = build_rect(unscaled_xposition_to_xposition(r_ob, curr_meas->start_barline_offset_ux + curr_meas->tuttipoint_reference->offset_ux), staff_top, curr_meas->width_ux * r_ob->zoom_y * r_ob->zoom_x, staff_bottom - staff_top);
    for (elem = curr_meas->r_it.label_families->l_head; elem; elem = elem->l_next) {
        t_llll *ll = hatom_getllll(&elem->l_hatom);
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
        t_jrgba color = label_family_to_color(r_ob, fam);
        
        paint_rectangle(g, color, change_alpha(color, 0.05),
                        label_rect.x, label_rect.y, label_rect.width, label_rect.height, CONST_LABEL_FAMILY_LINE_WIDTH);
        
        double delta = CONST_LABEL_FAMILY_NOTE_SEPARATION_URADIUS * r_ob->zoom_y;
        label_rect.x -= delta;
        label_rect.y -= delta;
        label_rect.width += 2 * delta;
        label_rect.height += 2 * delta;
    }
}


double label_family_contour_ux_to_x(t_notation_obj *r_ob, double ux)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        return ux + r_ob->zoom_y * (CONST_ROLL_UX_LEFT_START + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad - r_ob->screen_ms_start * CONST_X_SCALING * r_ob->zoom_x) + r_ob->j_inset_x;
//        return r_ob->zoom_y * (CONST_ROLL_UX_LEFT_START + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad + (ux - r_ob->screen_ms_start * CONST_X_SCALING) * r_ob->zoom_x) + r_ob->j_inset_x;
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        return unscaled_xposition_to_xposition(r_ob, ux/(r_ob->zoom_x * r_ob->zoom_y));
    return 0;
    
}

t_beziercs *label_family_contour_apply_zoom(t_notation_obj *r_ob, t_beziercs *contour)
{
    long num_segments = contour->num_segments;
    t_pt *pts = (t_pt *)bach_newptr(num_segments * sizeof(t_pt));
    t_pt *cp1 = (t_pt *)bach_newptr(num_segments * sizeof(t_pt));
    t_pt *cp2 = (t_pt *)bach_newptr(num_segments * sizeof(t_pt));
    long i;
    
    for (i = 0; i < num_segments; i++) {
        // modifying ux coordinate to x
        pts[i].x = unscaled_xposition_to_xposition(r_ob, contour->vertices[i].x);
        pts[i].y = contour->vertices[i].y;
        
        cp1[i].x = unscaled_xposition_to_xposition(r_ob, contour->ctrl_pt_1[i].x);
        cp1[i].y = contour->ctrl_pt_1[i].y;
        
        cp2[i].x = unscaled_xposition_to_xposition(r_ob, contour->ctrl_pt_2[i].x);
        cp2[i].y = contour->ctrl_pt_2[i].y;
    }
    
    t_beziercs *res = beziercs_build(num_segments, pts, cp1, cp2);
    bach_freeptr(pts);
    bach_freeptr(cp1);
    bach_freeptr(cp2);
    return res;
}


void paint_venn_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g)
{
    t_llllelem *famelem;
    t_bach_label_manager *man = &r_ob->m_labels;
    for (famelem = man->families->l_head; famelem; famelem = famelem->l_next) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&famelem->l_hatom);
        
        // updating, if needed
//        dev_post("restore this!!!");
        if (fam->need_update_contour) { // TO DO: restore!!!!
            if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_BOUNDINGBOX || r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_VENN)
                update_label_family_contour(r_ob, fam, g);
            fam->need_update_contour = false;
        }
        
        if (fam->contour && fam->contour->num_segments > 1) {
            // painting
            t_jrgba color = label_family_to_color(r_ob, fam);
            t_jrgba color_inner = change_alpha(color, 0.05);
            t_beziercs *zoomed_contour = label_family_contour_apply_zoom(r_ob, fam->contour);
            paint_beziercs(g, &color, &color_inner, 1., zoomed_contour);
            beziercs_free(zoomed_contour);
        }
    }
}


void paint_notehead(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_jfont *jf, t_jrgba *notecolor, t_note *curr_nt, double note_x_real, double note_y_real, double system_shift, double grace_ratio)
{
    // draw the notehead
    char *noteheadchar_utf;
    char noteheadchar[5]; 
    long outlen_notehead;
    t_jfont *jf_custom_noteheads = NULL;
    double noteheads_font_size = r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y;
    double custom_font_size = noteheads_font_size;
    char *custom_font_name = NULL;
    double notehead_resize = curr_nt->notehead_resize;
    
    char notehead_need_custom_font = false;
    char notehead_is_standard_quarternote = true; //< Flag telling if we can use the standard notehead, which is already in a layer for efficiency
    char standard_quarternote_color = 0; //< If the quarternote is standard, this will indicate which color it is (0 = note color, 1 = selection, 2 = lock, 3 = mute, 4 = solo)
    
    // Setting text boxes
    double note_x_textbox, note_y_textbox;
    note_x_textbox = note_x_real - ((curr_nt->notehead_uwidth * grace_ratio / 2.) * r_ob->zoom_y);
    note_y_textbox = system_shift + mc_to_yposition_in_scale_for_notes(r_ob,curr_nt, notation_item_get_voice(r_ob, (t_notation_item *)curr_nt), 1);

//    dev_post("note: x_real: %.2f, textbox: %.2f", note_x_real, note_x_textbox);
    
//    curr_nt->notehead_textbox_left_corner.x = note_x_textbox;
//    curr_nt->notehead_textbox_left_corner.y = note_y_textbox;

    
    if (r_ob->link_notehead_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_to_slot - 1].slot_type == k_SLOT_TYPE_INT && curr_nt->slot[r_ob->link_notehead_to_slot - 1].firstitem) {
        // OLD WAY of changing notehead
        unicodeChar val = *((long *) curr_nt->slot[r_ob->link_notehead_to_slot - 1].firstitem->item); 
        noteheadchar_utf = charset_unicodetoutf8_debug(&val, 1, &outlen_notehead);
        strncpy(noteheadchar, noteheadchar_utf, 4);
        bach_freeptr(noteheadchar_utf);
        notehead_is_standard_quarternote = false;
        
    } else if (r_ob->link_notehead_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_to_slot - 1].slot_type == k_SLOT_TYPE_NOTEHEAD && curr_nt->slot[r_ob->link_notehead_to_slot - 1].firstitem) {
        // NEW WAY
        long notehead_id = notationobj_notehead_symbol2id(r_ob, ((t_symbol *) curr_nt->slot[r_ob->link_notehead_to_slot - 1].firstitem->item));
        unicodeChar val = notationobj_notehead_id2unicodechar(r_ob, notehead_id, curr_nt->parent->r_sym_duration);
        noteheadchar_utf = charset_unicodetoutf8_debug(&val, 1, &outlen_notehead);
        strncpy(noteheadchar, noteheadchar_utf, 4);
        bach_freeptr(noteheadchar_utf);
        notehead_is_standard_quarternote = false;
        custom_font_size = r_ob->noteheads_typo_preferences.nhpref[notehead_id].base_pt * r_ob->zoom_y;
        if (custom_font_size != noteheads_font_size)
            notehead_need_custom_font = true;
        t_symbol *font = r_ob->noteheads_typo_preferences.nhpref[notehead_id].font;
        if (font && font != _llllobj_sym_default) {
            custom_font_name = font->s_name;
            notehead_need_custom_font = true;
        }

    } else {
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            noteheadchar_utf = charset_unicodetoutf8_debug(&curr_nt->parent->notehead_unicode_character, 1, &outlen_notehead);
            if (curr_nt->parent->notehead_unicode_character != r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].unicode_character_black)
                notehead_is_standard_quarternote = false;
        } else 
            noteheadchar_utf = charset_unicodetoutf8_debug(&r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].unicode_character_black, 1, &outlen_notehead);
        strncpy(noteheadchar, noteheadchar_utf, 4);
        bach_freeptr(noteheadchar_utf);
    }
    
    if (r_ob->link_notehead_font_to_slot && r_ob->slotinfo[r_ob->link_notehead_font_to_slot - 1].slot_type == k_SLOT_TYPE_TEXT && curr_nt->slot[r_ob->link_notehead_font_to_slot - 1].firstitem && curr_nt->slot[r_ob->link_notehead_font_to_slot - 1].length > 0){
        custom_font_name = (char *)curr_nt->slot[r_ob->link_notehead_font_to_slot - 1].firstitem->item;
        notehead_need_custom_font = true;
        notehead_is_standard_quarternote = false;
    }
    
    if (curr_nt->parent->is_grace_chord)
        notehead_resize *= grace_ratio;
    
    if (notehead_resize != 1.){
        t_voice *voice = (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? ((t_voice *)curr_nt->parent->parent->voiceparent) : ((t_voice *)curr_nt->parent->voiceparent));
        custom_font_size = noteheads_font_size * notehead_resize;
        note_y_textbox = system_shift + mc_to_yposition_in_scale_for_notes(r_ob, curr_nt, voice, notehead_resize);
        notehead_need_custom_font = true;
        notehead_is_standard_quarternote = false;
    }
    
    if (USE_BITMAPS_FOR_STANDARD_QUARTERNOTEHEADS) {
        if (jrgba_compare(notecolor, &r_ob->j_note_rgba) != 1) {
            if (jrgba_compare(notecolor, &r_ob->j_selection_rgba) == 1) 
                standard_quarternote_color = 1;
            else if (jrgba_compare(notecolor, &r_ob->j_locked_rgba) == 1) 
                standard_quarternote_color = 2;
            else if (jrgba_compare(notecolor, &r_ob->j_muted_rgba) == 1) 
                standard_quarternote_color = 3;
            else if (jrgba_compare(notecolor, &r_ob->j_solo_rgba) == 1) 
                standard_quarternote_color = 4;
            else 
                notehead_is_standard_quarternote = false;
        }
    }

    if (notehead_need_custom_font)
        jf_custom_noteheads = jfont_create_debug(custom_font_name ? custom_font_name : r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, custom_font_size);

    
    if (USE_BITMAPS_FOR_STANDARD_QUARTERNOTEHEADS && notehead_is_standard_quarternote && view) {
        // I hoped we could gain more CPU than the one we actually gain by doing this. However...
        jgraphics_set_source_rgba(g, 0, 0, 0, 1); // to avoid alpha transparency blending
        jgraphics_translate(g, note_x_textbox, note_y_textbox);
        switch (standard_quarternote_color) {
            // TO DO: SHOULD NOT USE DRAW FAST: DOES NOT SUPPORT ZOOM!!!!
            case 1: jgraphics_image_surface_draw_fast(g, r_ob->selected_quarternotehead_surface); break;
            case 2: jgraphics_image_surface_draw_fast(g, r_ob->lock_quarternotehead_surface); break;
            case 3: jgraphics_image_surface_draw_fast(g, r_ob->mute_quarternotehead_surface); break;
            case 4: jgraphics_image_surface_draw_fast(g, r_ob->solo_quarternotehead_surface); break;
            default: jgraphics_image_surface_draw_fast(g, r_ob->quarternotehead_surface); break;
        }
        jgraphics_translate(g, -note_x_textbox, -note_y_textbox);
    } else {
//        dev_post("note_textbox_x: %.2f", note_textbox_x);
        write_text_standard_account_for_vinset_singleline(r_ob, g, notehead_need_custom_font ? jf_custom_noteheads : jf, *notecolor, noteheadchar, note_x_textbox, note_y_textbox);
    }
    
    if (notehead_need_custom_font)
        jfont_destroy_debug(jf_custom_noteheads);
}
    
void paint_noteaccidentals(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_text_fractions, t_jfont *jf_acc_bogus, t_jrgba *color, 
                            t_note *curr_nt, long clef, double note_y_real, double stem_x, 
                            double *acc_top_uextension, double *acc_bottom_uextension){
    if (curr_nt->show_accidental)  { // Is there one or more accidentals to show??
        
        t_chord *curr_ch = curr_nt->parent;
        double grace_ratio = curr_ch->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1.;
        
        if (r_ob->accidentals_display_type == k_ACCIDENTALS_CLASSICAL) { // classical accidental
            // updating top/bottom values if needed
            double acc_top, acc_bottom;
            t_jfont *jf_custom_accidentals = NULL, *jf_custom_accidentals_bogus = NULL;
            char need_jf_custom_accidentals = false;
            char acccharacters[15]; 
            long outlen;
            char *acccharacters_utf;
            char is_bogus;
            double acc_x, acc_y;
            double accidentals_resize = curr_nt->accidentals_resize * grace_ratio;

            if (acc_top_uextension) 
                *acc_top_uextension = get_accidental_top_uextension(r_ob, note_get_screen_accidental(curr_nt)) * r_ob->zoom_y * accidentals_resize;
            if (acc_bottom_uextension) 
                *acc_bottom_uextension = get_accidental_bottom_uextension(r_ob, note_get_screen_accidental(curr_nt)) * r_ob->zoom_y * accidentals_resize;
            if (acc_top_uextension) {
                acc_top = note_y_real - 0.7 * *acc_top_uextension;
                if (acc_top < curr_ch->topmost_y) 
                    curr_ch->topmost_y = acc_top;
            }
            if (acc_bottom_uextension) {
                acc_bottom = note_y_real + 0.7 * *acc_bottom_uextension;
                if (acc_bottom > curr_ch->bottommost_y) 
                    curr_ch->bottommost_y = acc_bottom;
            }
            
            // drawing accidental
            if (curr_nt->num_accidentals == 0)  // Weird: if (curr_nt->show_accidental) there's an accidental to show: let's check; otherwise it is bogus
                calculate_chord_parameters(r_ob, curr_nt->parent, clef, false);
            
            is_bogus = (curr_nt->num_accidentals == 0 || curr_nt->accidental_text[0] == 0);
            
            if (is_bogus) {
                acccharacters_utf = charset_unicodetoutf8_debug(&r_ob->accidentals_typo_preferences.unicode_bogus_character, 1, &outlen);
                acc_x = stem_x + curr_nt->accidental_stem_delta_ux * r_ob->zoom_y - r_ob->j_inset_x;
                acc_y = note_y_real + (r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].uwidth * 0.58 * r_ob->zoom_y) - r_ob->j_inset_y;
            } else {
                acccharacters_utf = charset_unicodetoutf8_debug(curr_nt->accidental_text, curr_nt->num_accidentals, &outlen);
                acc_x = stem_x + curr_nt->accidental_stem_delta_ux * r_ob->zoom_y - r_ob->j_inset_x + r_ob->accidentals_typo_preferences.ux_shift * r_ob->zoom_y;
                acc_y = note_y_real + r_ob->accidentals_typo_preferences.uy_shift * r_ob->zoom_y; // - r_ob->j_inset_y;
            }
            strncpy(acccharacters, acccharacters_utf, 14);

            if (accidentals_resize != 1.){
                need_jf_custom_accidentals = true;
                jf_custom_accidentals = jfont_create_debug(r_ob->accidentals_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->accidentals_typo_preferences.base_pt * r_ob->zoom_y * accidentals_resize);
                jf_custom_accidentals_bogus = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, round(8.8 * r_ob->zoom_y) * accidentals_resize);
                acc_y = note_y_real + r_ob->accidentals_typo_preferences.uy_shift * r_ob->zoom_y * accidentals_resize; // - r_ob->j_inset_y;
            }
                        
            write_text(g, need_jf_custom_accidentals ? (is_bogus ? jf_custom_accidentals_bogus : jf_custom_accidentals) : (is_bogus ? jf_acc_bogus : jf_acc), 
                                          *color, acccharacters, r_ob->j_inset_x, 0, acc_x, acc_y, JGRAPHICS_TEXT_JUSTIFICATION_BOTTOMRIGHT, true, false);

            bach_freeptr(acccharacters_utf);
            if (need_jf_custom_accidentals) {
                jfont_destroy_debug(jf_custom_accidentals);
                jfont_destroy_debug(jf_custom_accidentals_bogus);
            }
            
        } else if (r_ob->accidentals_display_type == k_ACCIDENTALS_FRACTION || r_ob->accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION) { // show fraction
            int num, den;
            char frac_text[20];    
            double width, height, left_bottom_corner_x, left_bottom_corner_y;
            t_jfont *jf_custom_fractions = jf_text_fractions;
            
            num = rat_num(note_get_screen_accidental(curr_nt));
            den = rat_den(note_get_screen_accidental(curr_nt));
            if (r_ob->accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION && den < r_ob->tone_division) {
                int factor = r_ob->tone_division / den;
                den *= factor; 
                num *= factor;
            } 
            if (num >= 0) 
                snprintf_zero(frac_text, 20, "+%d/%d", num, den);
            else
                snprintf_zero(frac_text, 20, "-%d/%d", -num, den);
            
            if (curr_ch->is_grace_chord) 
                jf_custom_fractions = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_TEXT_FRACTIONS_PT * r_ob->zoom_y);
            
            jfont_text_measure(jf_custom_fractions, frac_text, &width, &height);
            //                            post("Needed: %f width, %f height", width, height); 
            left_bottom_corner_x = stem_x + curr_nt->accidental_stem_delta_ux * r_ob->zoom_y;
            left_bottom_corner_y = note_y_real + (r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].uwidth * 0.58 * r_ob->zoom_y * grace_ratio);
            paint_rectangle(g, get_grey(0.5), get_grey(1.), left_bottom_corner_x - width - CONST_WIDTH_ADD_FRACTIONS, left_bottom_corner_y - height, width + CONST_WIDTH_ADD_FRACTIONS, height, 1.);
            write_text(g, jf_custom_fractions, *color, frac_text, 
                                          r_ob->j_inset_x, r_ob->j_inset_y, left_bottom_corner_x - r_ob->j_inset_x, left_bottom_corner_y - r_ob->j_inset_y,
                                          JGRAPHICS_TEXT_JUSTIFICATION_BOTTOMRIGHT, true, false);

            if (curr_ch->is_grace_chord)
                jfont_destroy_debug(jf_custom_fractions);
            
        } else if (r_ob->accidentals_display_type == k_ACCIDENTALS_CENTS) { // show cents difference
            double floatacc = 200. * rat2double(note_get_screen_accidental(curr_nt));
            char cents_text[20];    
            double width, height, left_bottom_corner_x, left_bottom_corner_y;
            t_jfont *jf_custom_fractions = jf_text_fractions;

            if (floatacc >= 0) 
                snprintf_zero(cents_text, 20, "+%dc", (int)floatacc); 
            else 
                snprintf_zero(cents_text, 20, "-%dc", (int)(-floatacc)); 
            
            if (curr_ch->is_grace_chord) 
                jf_custom_fractions = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_TEXT_FRACTIONS_PT * r_ob->zoom_y);

            jfont_text_measure(jf_custom_fractions, cents_text, &width, &height);
            
            //                            post("Needed: %f width, %f height", width, height); 
            left_bottom_corner_x = stem_x + curr_nt->accidental_stem_delta_ux * r_ob->zoom_y;
            left_bottom_corner_y = note_y_real +(r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].uwidth * 0.59 * r_ob->zoom_y * grace_ratio);
            paint_rectangle(g, get_grey(0.5), get_grey(1.), left_bottom_corner_x - width - CONST_WIDTH_ADD_FRACTIONS, left_bottom_corner_y - height, width + CONST_WIDTH_ADD_FRACTIONS, height, 1.);
            write_text(g, jf_custom_fractions, *color, cents_text, 
                                          r_ob->j_inset_x, r_ob->j_inset_y, left_bottom_corner_x - r_ob->j_inset_x, left_bottom_corner_y - r_ob->j_inset_y, 
                                          JGRAPHICS_TEXT_JUSTIFICATION_BOTTOMRIGHT, true, false);
            
            if (curr_ch->is_grace_chord)
                jfont_destroy_debug(jf_custom_fractions);
        }
    } // else: don't show accidental!
}

void reset_articulation_position_for_chord(t_notation_obj *r_ob, t_chord *ch)
{
    long i; t_note *nt;
    for (i = 0; i < ch->num_articulations; i++)
        ch->articulation[i].need_recompute_position = true;
    for (nt = ch->firstnote; nt; nt = nt->next){
        for (i = 0; i < nt->num_articulations; i++)
            nt->articulation[i].need_recompute_position = true;
    }
    
    ch->topmost_y = -1;
    ch->bottommost_y = -1;
    ch->beam_y = -1;
    ch->topmost_y_noacc = -1;
    ch->bottommost_y_noacc = -1;

    
    // Slot linkage
    if (r_ob->link_articulations_to_slot > 0 && r_ob->link_articulations_to_slot <= CONST_MAX_SLOTS) {
        long s = r_ob->link_articulations_to_slot - 1;
        if (r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS) {
            t_slotitem *item;
            for (nt = ch->firstnote; nt; nt = nt->next) {
                for (item = nt->slot[s].firstitem; item; item = item->next)
                    ((t_articulation *)item->item)->need_recompute_position = true;
            }
            item = notation_item_get_slot_firstitem(r_ob, (t_notation_item *)ch, s);
            if (item)
                ((t_articulation *)item->item)->need_recompute_position = true;
        }
    }
}


void erase_all_topmost_and_bottommost_y_infos(t_notation_obj *r_ob)
{
    t_voice *tmp_voice; t_chord *tmp_chord;
    for (tmp_voice = r_ob->firstvoice; (tmp_voice && (tmp_voice->number < r_ob->num_voices)); tmp_voice = voice_get_next(r_ob, tmp_voice))
        for (tmp_chord = chord_get_first(r_ob, tmp_voice); tmp_chord; tmp_chord = chord_get_next(tmp_chord)) {
            tmp_chord->topmost_y = -1;
            tmp_chord->bottommost_y = -1;
            tmp_chord->beam_y = -1;
        }
}

void erase_all_topmost_and_bottommost_y_noacc_infos(t_notation_obj *r_ob)
{
    t_voice *tmp_voice; t_chord *tmp_chord;
    for (tmp_voice = r_ob->firstvoice; (tmp_voice && (tmp_voice->number < r_ob->num_voices)); tmp_voice = voice_get_next(r_ob, tmp_voice))
        for (tmp_chord = chord_get_first(r_ob, tmp_voice); tmp_chord; tmp_chord = chord_get_next(tmp_chord)) {
            tmp_chord->topmost_y_noacc = -1;
            tmp_chord->bottommost_y_noacc = -1;
        }
}

void reset_all_articulations_positions(t_notation_obj *r_ob)
{
    erase_all_topmost_and_bottommost_y_infos(r_ob);
    erase_all_topmost_and_bottommost_y_noacc_infos(r_ob);
    
    // OLD WAY + NEW WAY
    t_voice *voice; t_chord *chord; t_note *note; long i;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord)) {
            for (i = 0; i < chord->num_articulations; i++)
                chord->articulation[i].need_recompute_position = true;
            if (r_ob->link_articulations_to_slot > 0 && r_ob->link_articulations_to_slot <= CONST_MAX_SLOTS) {
                long s = r_ob->link_articulations_to_slot - 1;
                if (r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS) {
                    t_slotitem *it = notation_item_get_slot_firstitem(r_ob, (t_notation_item *)chord, s);
                    if (it)
                        ((t_articulation *)it->item)->need_recompute_position = true;
                }
            }
            for (note = chord->firstnote; note; note = note->next) {
                for (i = 0; i < note->num_articulations; i++)
                    note->articulation[i].need_recompute_position = true;
                if (r_ob->link_articulations_to_slot > 0 && r_ob->link_articulations_to_slot <= CONST_MAX_SLOTS) {
                    long s = r_ob->link_articulations_to_slot - 1;
                    if (r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS) {
                        t_slotitem *item;
                        for (item = note->slot[s].firstitem; item; item = item->next)
                            ((t_articulation *)item->item)->need_recompute_position = true;
                    }
                }
            }
        }
    }
}





/* OLD FUNCTION
// use stem_direction == 0 for rests
void paint_articulation(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, void *articulation_owner, char owner_type,
                        long number, char stem_direction, double stem_x, double note_x_real, double note_y_real, double note_width,
                        double extension_end_x)
{
    
    char obj_type = r_ob->obj_type;
    if (number >= 0 && number < CONST_MAX_ARTICULATIONS_PER_NOTE) {
        
        t_articulation *this_art = (owner_type == k_CHORD) ?    &(((t_chord *) articulation_owner)->articulation[number]) :
        &(((t_note *) articulation_owner)->articulation[number]);
        double grace_ratio = (owner_type == k_CHORD ? ( ((t_chord *) articulation_owner)->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1 ) :
                              ( ((t_note *) articulation_owner)->parent->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1 ));
        t_jfont *jf_art = jfont_create_debug(r_ob->articulations_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->articulations_typo_preferences.base_pt[this_art->articulation_ID] * r_ob->zoom_y * grace_ratio);
        
        long articulation_utf_len;
        char *articulation_utf;
        char articulation_txt[5];
        if (this_art->need_recompute_position) {
#ifdef BACH_ARTICULATION_POSITION_DEBUG
            char debug = true; // paint debug lines for articulations
#else
            char debug = false;
#endif
            
            t_chord *chord = (owner_type == k_CHORD) ? (t_chord *)articulation_owner : ((t_note *) articulation_owner)->parent;
            t_voice *voice = (obj_type == k_NOTATION_OBJECT_SCORE) ? (t_voice *)chord->parent->voiceparent :  (t_voice *)chord->voiceparent;
            double top_y_with_articulation, bottom_y_with_articulation;
            double articulation_width, articulation_height;
            long ID = this_art->articulation_ID;
            if (debug)
                paint_circle_filled(g, build_jrgba(1,0,0,1), note_x_real, note_y_real, 4);
            if (ID >= 0 && ID <= CONST_MAX_ARTICULATION_ID){
                double left_x, left_y;
                char flipped = !((stem_direction < 0 || r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_ABOVE_NOTE) && !(r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_BELOW_NOTE));
                
                if (stem_direction == 0)
                    flipped = false; // it's a rest
                
                this_art->character = flipped ?    r_ob->articulations_typo_preferences.flipped_char[ID] :
                r_ob->articulations_typo_preferences.main_char[ID];
                left_x = note_x_real - note_width / 2. * grace_ratio;
                left_y = note_y_real - r_ob->step_y * grace_ratio; // it is for the moment the y-CENTER of the articulation
                articulation_utf = charset_unicodetoutf8_debug(&this_art->character, 1, &articulation_utf_len);
                strncpy(articulation_txt, articulation_utf, 4);
                bach_freeptr(articulation_utf);
                
                jfont_text_measure(jf_art, articulation_txt, &articulation_width, &articulation_height);
                
                articulation_height = (flipped ? r_ob->articulations_typo_preferences.flipped_uheight[ID] : r_ob->articulations_typo_preferences.main_uheight[ID]) * r_ob->zoom_y;
                
                if (debug)
                    paint_circle_filled(g, build_jrgba(1,0,0,1), left_x, left_y, 1);
                
                if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_NOTE_SIDE) {
                    if (flipped)
                        left_y = chord->bottommost_y_noacc + articulation_height / 2.;
                    else
                        left_y = chord->topmost_y_noacc - articulation_height / 2.;
                } else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_ABOVE_NOTE) {
                    left_y = chord->topmost_y_noacc - articulation_height / 2.;
                } else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_BELOW_NOTE) {
                    left_y = chord->bottommost_y_noacc + articulation_height / 2.;
                } else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD) {
                    if (chord->direction > 0)
                        left_y = chord->lastnote->center.y - r_ob->step_y - articulation_height / 2.;
                    else if (chord->direction < 0)
                        left_y = chord->firstnote->center.y + r_ob->step_y + articulation_height / 2.;
                } else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG) {
                    if (chord->direction > 0)
                        left_y = chord->beam_y + articulation_height / 2.;
                    else if (chord->direction < 0)
                        left_y = chord->beam_y - articulation_height / 2.;
                }
                
                if (r_ob->articulations_typo_preferences.options[ID] & k_ARTICULATION_OPTION_CENTER_OVER_NOTE)
                    left_x = note_x_real - articulation_width / 2.;
                else if (r_ob->articulations_typo_preferences.options[ID] & k_ARTICULATION_OPTION_CENTER_OVER_STEM)
                    left_x = stem_x - articulation_width / 2.;
                
                if (debug)
                    paint_line(g, build_jrgba(0,1,0,1), left_x, left_y, left_x + 20, left_y, 1);
                
                if (r_ob->articulations_typo_preferences.options[ID] & k_ARTICULATION_OPTION_OUTSIDE_STAFF) {
                    double top_y = get_staff_top_y(r_ob, voice, false);
                    double bottom_y = get_staff_bottom_y(r_ob, voice, false);
                    double top_art = left_y - articulation_height / 2.;
                    double bottom_art = left_y + articulation_height / 2.;
                    double nudge = r_ob->articulations_typo_preferences.outside_staff_uy_nudge[ID] * r_ob->zoom_y;
                    if ((bottom_art > top_y && bottom_art < bottom_y) ||
                        (top_art > top_y && top_art < bottom_y) ||
                        (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_ABOVE_NOTE && bottom_art > top_y) ||
                        (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_BELOW_NOTE && top_art < bottom_y)){
                        if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_NOTE_SIDE)
                            left_y = flipped ? bottom_y + articulation_height / 2. + nudge : top_y - articulation_height / 2. - nudge;
                        else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD || r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG)
                            left_y = flipped ? top_y - nudge : bottom_y + nudge;
                        else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_ABOVE_NOTE)
                            left_y = top_y - articulation_height / 2. - nudge;
                        else if (r_ob->articulations_typo_preferences.positioning[ID] == k_ARTICULATION_POSITIONING_BELOW_NOTE)
                            left_y = bottom_y + articulation_height / 2. + nudge;
                        else if (bottom_y - left_y > left_y - top_y)
                            left_y = top_y - articulation_height / 2. - nudge;
                        else
                            left_y = bottom_y + articulation_height / 2. + nudge;
                    }
                }
                
                // predefined shifts
                if (!flipped) {
                    left_x += r_ob->articulations_typo_preferences.main_char_ux_shift[ID] * r_ob->zoom_y;
                    left_y -= r_ob->articulations_typo_preferences.main_char_uy_shift[ID] * r_ob->zoom_y;
                } else {
                    left_x += r_ob->articulations_typo_preferences.flipped_char_ux_shift[ID] * r_ob->zoom_y;
                    left_y -= r_ob->articulations_typo_preferences.flipped_char_uy_shift[ID] * r_ob->zoom_y;
                }
                
                if (r_ob->articulations_typo_preferences.options[ID] & k_ARTICULATION_OPTION_AVOID_STAFF_LINES) {
                    double top_y = get_staff_top_y(r_ob, voice, false);
                    double bottom_y = get_staff_bottom_y(r_ob, voice, false);
                    double this_y;
                    for (this_y = top_y - 2 * r_ob->step_y; this_y < bottom_y + 2 * r_ob->step_y; this_y += 2 * r_ob->step_y) {
                        if (left_y >= this_y && left_y <= this_y + 2 * r_ob->step_y) {
                            left_y = this_y + r_ob->step_y;
                            if (flipped && chord->bottommost_y_noacc > left_y - articulation_height/2.)
                                left_y += 2* r_ob->step_y;
                            if (!flipped && chord->topmost_y_noacc < left_y + articulation_height/2.)
                                left_y -= 2* r_ob->step_y;
                            
                            break;
                        }
                    }
                }
                
                if (debug)
                    paint_line(g, build_jrgba(0,0,0,1), left_x, left_y, left_x + 20, left_y, 1);
                
                if (debug)
                    paint_rectangle(g, build_jrgba(0,1, 0.5, 1), build_jrgba(1,0, 0.5, 0.2), left_x,
                                    left_y - articulation_height / 2., articulation_width, articulation_height, 1);
                
                // last shift: the y is brought to the writing position
                if (!flipped) { // articulation over note
                    left_y -= r_ob->articulations_typo_preferences.main_uy_center[ID] * r_ob->zoom_y;
                    top_y_with_articulation = left_y + (r_ob->articulations_typo_preferences.main_uy_center[ID] - r_ob->articulations_typo_preferences.main_uheight[ID]/2.) * r_ob->zoom_y;
                    if (top_y_with_articulation < chord->topmost_y) chord->topmost_y = top_y_with_articulation;
                    if (top_y_with_articulation < chord->topmost_y_noacc) chord->topmost_y_noacc = top_y_with_articulation;
                } else { // articulation under note
                    left_y -= r_ob->articulations_typo_preferences.flipped_uy_center[ID] * r_ob->zoom_y;
                    bottom_y_with_articulation = left_y + (r_ob->articulations_typo_preferences.flipped_uy_center[ID] + r_ob->articulations_typo_preferences.flipped_uheight[ID]/2.) * r_ob->zoom_y;
                    if (bottom_y_with_articulation > chord->bottommost_y) chord->bottommost_y = bottom_y_with_articulation;
                    if (bottom_y_with_articulation > chord->bottommost_y_noacc) chord->bottommost_y_noacc = bottom_y_with_articulation;
                }
                
                if (debug)
                    paint_circle_filled(g, build_jrgba(0,0,1,1), left_x, left_y, 1);
                
                this_art->x_pos = left_x - stem_x;
                this_art->y_pos = left_y;
                this_art->width = articulation_width;
                this_art->height = (flipped ? r_ob->articulations_typo_preferences.flipped_uheight[ID] : r_ob->articulations_typo_preferences.main_uheight[ID]) * r_ob->zoom_y;
                this_art->middle_x_pos = left_x + articulation_width / 2.;
                this_art->middle_y_pos = left_y + (flipped ? r_ob->articulations_typo_preferences.flipped_uy_center[ID] : r_ob->articulations_typo_preferences.main_uy_center[ID]) * r_ob->zoom_y;
            }
            this_art->need_recompute_position = false;
        }
        
        articulation_utf = charset_unicodetoutf8_debug(&this_art->character, 1, &articulation_utf_len);
        strncpy(articulation_txt, articulation_utf, 4);
        bach_freeptr(articulation_utf);
        write_text_standard_account_for_vinset(r_ob, g, jf_art, *color, articulation_txt, stem_x + this_art->x_pos, this_art->y_pos);
        
        if (r_ob->articulations_typo_preferences.extension_line_char[this_art->articulation_ID] > 0 && r_ob->show_articulations_extensions) { // extension line
            double total_width = extension_end_x - (stem_x + this_art->x_pos + this_art->width/2.) - CONST_ARTICULATION_EXTENSION_END_UTRIM * r_ob->zoom_y;
            double one_char_width, one_char_height;
            unicodeChar *all_chars_txt;
            long num_chars, i;
            
            
            char *utf;
            long utflen;
            utf = charset_unicodetoutf8_debug(&r_ob->articulations_typo_preferences.extension_line_char[this_art->articulation_ID], 1, &utflen);
            //                    strncpy(articulation_txt, articulation_utf, 4);
            jfont_text_measure(jf_art, utf, &one_char_width, &one_char_height);
            bach_freeptr(utf);
            num_chars = floor(total_width / one_char_width);
            if (num_chars > 0) {
                all_chars_txt = (unicodeChar *) bach_newptr((num_chars + 1) * sizeof(unicodeChar));
                for (i = 0; i < num_chars; i++)
                    all_chars_txt[i] = r_ob->articulations_typo_preferences.extension_line_char[this_art->articulation_ID];
                all_chars_txt[i] = 0;
                utf = charset_unicodetoutf8_debug(all_chars_txt, num_chars, &utflen);
                write_text_standard_account_for_vinset(r_ob, g, jf_art, *color, utf, stem_x + this_art->x_pos + this_art->width,
                                              this_art->y_pos - r_ob->articulations_typo_preferences.extension_line_uy_offset[this_art->articulation_ID] * r_ob->zoom_y);
                bach_freeptr(utf);
                bach_freeptr(all_chars_txt);
                
            }
        }
        
        jfont_destroy_debug(jf_art); 
    }
}
*/



// use stem_direction == 0 for rests
// part direction == 0 for no-parting 1 for above 2 for below
void paint_articulation(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_articulation *art, t_notation_item *articulation_owner,
                        char stem_direction, double stem_x, double note_x_real, double note_y_real, double note_width, double extension_end_x, char part_direction)
{
    
    char obj_type = r_ob->obj_type;
    long ID = art->articulation_ID;

    double grace_ratio = (articulation_owner->type == k_CHORD ? ( ((t_chord *) articulation_owner)->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1 ) :
                          ( ((t_note *) articulation_owner)->parent->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1 ));
    t_jfont *jf_art = jfont_create_debug((ID >= 0 && ID < r_ob->articulations_typo_preferences.num_articulations && r_ob->articulations_typo_preferences.artpref[ID].font && r_ob->articulations_typo_preferences.artpref[ID].font != _llllobj_sym_default) ? r_ob->articulations_typo_preferences.artpref[ID].font->s_name : r_ob->articulations_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->articulations_typo_preferences.artpref[art->articulation_ID].base_pt * r_ob->zoom_y * grace_ratio);
    
    long articulation_utf_len;
    char *articulation_utf = NULL;
    char articulation_txt[5];
    t_chord *chord = (articulation_owner->type == k_CHORD) ? (t_chord *)articulation_owner : ((t_note *) articulation_owner)->parent;
    t_voice *voice = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)chord->voiceparent : (chord->parent ? (t_voice *)chord->parent->voiceparent : NULL));
    
    if (art->need_recompute_position) { // c'mon this is not a big deal, we might also paint at every cycle...
#ifdef BACH_ARTICULATION_POSITION_DEBUG
        char debug = true; // paint debug lines for articulations
#else
        char debug = false;
#endif
        
        t_voice *voice = (obj_type == k_NOTATION_OBJECT_SCORE) ? (t_voice *)chord->parent->voiceparent :  (t_voice *)chord->voiceparent;
        double articulation_width, articulation_height;
        
        if (debug)
            paint_circle_filled(g, build_jrgba(1,0,0,1), note_x_real, note_y_real, 4);
        
        if (ID >= 0 && ID < r_ob->articulations_typo_preferences.num_articulations){
            double left_x, left_y;
            char flipped = false;
            long positioning = r_ob->articulations_typo_preferences.artpref[ID].positioning;
            
            
            // switching articulation position for parts
            if (part_direction != 0) {
                switch (positioning){
                    case k_ARTICULATION_POSITIONING_NOTE_SIDE:
                    case k_ARTICULATION_POSITIONING_ABOVE_NOTE:
                    case k_ARTICULATION_POSITIONING_BELOW_NOTE:
                        positioning = part_direction > 0 ? k_ARTICULATION_POSITIONING_ABOVE_NOTE : k_ARTICULATION_POSITIONING_BELOW_NOTE;
                        break;
                    default:
                        break;
                }
            }
            
            flipped = !((stem_direction < 0 || positioning == k_ARTICULATION_POSITIONING_ABOVE_NOTE) && !(positioning == k_ARTICULATION_POSITIONING_BELOW_NOTE));
            
            if (stem_direction == 0)
                flipped = false; // it's a rest
            
            art->character = flipped ? r_ob->articulations_typo_preferences.artpref[ID].flipped_char : r_ob->articulations_typo_preferences.artpref[ID].main_char;
            left_x = note_x_real - note_width / 2. * grace_ratio;
            left_y = note_y_real - r_ob->step_y * grace_ratio; // it is for the moment the y-CENTER of the articulation
            articulation_utf = charset_unicodetoutf8_debug(&art->character, 1, &articulation_utf_len);
            strncpy(articulation_txt, articulation_utf, 4);
            bach_freeptr(articulation_utf);
            
            jfont_text_measure(jf_art, articulation_txt, &articulation_width, &articulation_height);
            
            articulation_height = (flipped ? r_ob->articulations_typo_preferences.artpref[ID].flipped_uheight : r_ob->articulations_typo_preferences.artpref[ID].main_uheight) * r_ob->zoom_y;
            
            if (debug)
                paint_circle_filled(g, build_jrgba(1,0,0,1), left_x, left_y, 1);
            
            double beam_y;
            
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                beam_y = chord->firstnote ? chord->beam_y : get_staff_top_y(r_ob, voice, false);
                if (r_ob->articulations_typo_preferences.artpref[ID].options & k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS) {
                    long nb = get_num_beams_from_figure(chord->figure);
                    if (nb > 1) {
                        if (stem_direction < 0)
                            beam_y -= (nb - 1) * CONST_BEAMINGS_UDISTANCE * r_ob->zoom_y;
                        else if (stem_direction > 0)
                            beam_y += (nb - 1) * CONST_BEAMINGS_UDISTANCE * r_ob->zoom_y;
                    }
                }
            } else {
                beam_y = ((chord->direction < 0) ? chord->firstnote->center.y + 7 * r_ob->step_y : chord->lastnote->center.y - 7 * r_ob->step_y);
            }
            
            
            switch (positioning) {
                case k_ARTICULATION_POSITIONING_NOTE_SIDE:
                    if (flipped)
                        left_y = chord->bottommost_y_noacc + articulation_height / 2.;
                    else
                        left_y = chord->topmost_y_noacc - articulation_height / 2.;
                    break;
                    
                case  k_ARTICULATION_POSITIONING_ABOVE_NOTE:
                    left_y = chord->topmost_y_noacc - articulation_height / 2.;
                    break;
                    
                case k_ARTICULATION_POSITIONING_BELOW_NOTE:
                    left_y = chord->bottommost_y_noacc + articulation_height / 2.;
                    break;
                
                case k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD:
                    if (chord->direction > 0)
                        left_y = chord->lastnote->center.y - r_ob->step_y - articulation_height / 2.;
                    else if (chord->direction < 0)
                        left_y = chord->firstnote->center.y + r_ob->step_y + articulation_height / 2.;
                    else // it's a rest
                        left_y = chord->lastnote->center.y;
                    break;
                    
                case k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG:
                    if (chord->direction > 0)
                        left_y = beam_y + articulation_height / 2.;
                    else if (chord->direction < 0)
                        left_y = beam_y - articulation_height / 2.;
                    else // it's a rest
                        left_y = beam_y;
                    break;

                default:
                    break;
            }

            
            if (r_ob->articulations_typo_preferences.artpref[ID].options & k_ARTICULATION_OPTION_CENTER_OVER_NOTE ||
                (!r_ob->show_stems || (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && rat_long_cmp(chord->figure, 1) >= 0))) // or it doesn't have any stem
                left_x = note_x_real - articulation_width / 2.;
            else if (r_ob->articulations_typo_preferences.artpref[ID].options & k_ARTICULATION_OPTION_CENTER_OVER_STEM)
                left_x = stem_x - articulation_width / 2.;
            
            if (debug)
                paint_line(g, build_jrgba(0,1,0,1), left_x, left_y, left_x + 20, left_y, 1);
            
            if (r_ob->articulations_typo_preferences.artpref[ID].options & k_ARTICULATION_OPTION_OUTSIDE_STAFF) {
                double top_y = get_staff_top_y(r_ob, voice, false);
                double bottom_y = get_staff_bottom_y(r_ob, voice, false);
                double top_art = left_y - articulation_height / 2.;
                double bottom_art = left_y + articulation_height / 2.;
                double nudge = r_ob->articulations_typo_preferences.artpref[ID].outside_staff_uy_nudge * r_ob->zoom_y;
                
                // accounting for ledger lines
                if (note_y_real < top_y)
                    top_y = note_y_real;
                else if (note_y_real > bottom_y)
                    bottom_y= note_y_real;
                
                if ((bottom_art > top_y && bottom_art < bottom_y) ||
                    (top_art > top_y && top_art < bottom_y) ||
                    (positioning == k_ARTICULATION_POSITIONING_ABOVE_NOTE && bottom_art > top_y) ||
                    (positioning == k_ARTICULATION_POSITIONING_BELOW_NOTE && top_art < bottom_y)){
                    if (positioning == k_ARTICULATION_POSITIONING_NOTE_SIDE)
                        left_y = flipped ? bottom_y + articulation_height / 2. + nudge : top_y - articulation_height / 2. - nudge;
                    else if (positioning == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD || positioning == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG)
                        left_y = flipped ? top_y - nudge : bottom_y + nudge;
                    else if (positioning == k_ARTICULATION_POSITIONING_ABOVE_NOTE)
                        left_y = top_y - articulation_height / 2. - nudge;
                    else if (positioning == k_ARTICULATION_POSITIONING_BELOW_NOTE)
                        left_y = bottom_y + articulation_height / 2. + nudge;
                    else if (bottom_y - left_y > left_y - top_y)
                        left_y = top_y - articulation_height / 2. - nudge;
                    else
                        left_y = bottom_y + articulation_height / 2. + nudge;
                }
            }
            
            // predefined shifts
            if (!flipped) {
                left_x += r_ob->articulations_typo_preferences.artpref[ID].main_char_ux_shift * r_ob->zoom_y * grace_ratio;
                left_y -= r_ob->articulations_typo_preferences.artpref[ID].main_char_uy_shift * r_ob->zoom_y * grace_ratio;
            } else {
                left_x += r_ob->articulations_typo_preferences.artpref[ID].flipped_char_ux_shift * r_ob->zoom_y * grace_ratio;
                left_y -= r_ob->articulations_typo_preferences.artpref[ID].flipped_char_uy_shift * r_ob->zoom_y * grace_ratio;
            }
            
            if (r_ob->articulations_typo_preferences.artpref[ID].options & k_ARTICULATION_OPTION_AVOID_STAFF_LINES) {
                double top_y = get_staff_top_y(r_ob, voice, false);
                double bottom_y = get_staff_bottom_y(r_ob, voice, false);
                double this_y;
                for (this_y = top_y - 2 * r_ob->step_y; this_y < bottom_y + 2 * r_ob->step_y; this_y += 2 * r_ob->step_y) {
                    if (left_y >= this_y && left_y <= this_y + 2 * r_ob->step_y) {
                        left_y = this_y + r_ob->step_y;
                        if (flipped && chord->bottommost_y_noacc > left_y - articulation_height/2.)
                            left_y += 2* r_ob->step_y;
                        if (!flipped && chord->topmost_y_noacc < left_y + articulation_height/2.)
                            left_y -= 2* r_ob->step_y;
                        
                        break;
                    }
                }
            }
            
            if (debug)
                paint_line(g, build_jrgba(0,0,0,1), left_x, left_y, left_x + 20, left_y, 1);
            
            if (debug)
                paint_rectangle(g, build_jrgba(0,1, 0.5, 1), build_jrgba(1,0, 0.5, 0.2), left_x,
                                left_y - articulation_height / 2., articulation_width, articulation_height, 1);
            
            // last shift: the y is brought to the writing position
            if (!flipped) { // articulation over note
                left_y -= r_ob->articulations_typo_preferences.artpref[ID].main_uy_center * r_ob->zoom_y;
            } else { // articulation under note
                left_y -= r_ob->articulations_typo_preferences.artpref[ID].flipped_uy_center * r_ob->zoom_y;
            }
            
            if (debug)
                paint_circle_filled(g, build_jrgba(0,0,1,1), left_x, left_y, 1);
            
            art->x_pos = left_x - stem_x;
            art->flipped = flipped;
            art->y_pos = left_y - voice->middleC_y;
            art->width = articulation_width;
            art->height = (flipped ? r_ob->articulations_typo_preferences.artpref[ID].flipped_uheight : r_ob->articulations_typo_preferences.artpref[ID].main_uheight) * r_ob->zoom_y;
            art->middle_x_pos = left_x + articulation_width / 2.;
            art->middle_y_pos = left_y + (flipped ? r_ob->articulations_typo_preferences.artpref[ID].flipped_uy_center : r_ob->articulations_typo_preferences.artpref[ID].main_uy_center) * r_ob->zoom_y;
        }
        art->need_recompute_position = false;
    }
    
    double real_y_pos = art->y_pos + voice->middleC_y;
    
    if (!art->flipped) {
        double top_y_with_articulation = real_y_pos + (r_ob->articulations_typo_preferences.artpref[ID].main_uy_center - r_ob->articulations_typo_preferences.artpref[ID].main_uheight/2.) * r_ob->zoom_y;
        if (top_y_with_articulation < chord->topmost_y) chord->topmost_y = top_y_with_articulation;
        if (top_y_with_articulation < chord->topmost_y_noacc) chord->topmost_y_noacc = top_y_with_articulation;
    } else {
        double bottom_y_with_articulation = real_y_pos + (r_ob->articulations_typo_preferences.artpref[ID].flipped_uy_center + r_ob->articulations_typo_preferences.artpref[ID].flipped_uheight/2.) * r_ob->zoom_y;
        if (bottom_y_with_articulation > chord->bottommost_y) chord->bottommost_y = bottom_y_with_articulation;
        if (bottom_y_with_articulation > chord->bottommost_y_noacc) chord->bottommost_y_noacc = bottom_y_with_articulation;
    }
    
    
    articulation_utf = charset_unicodetoutf8_debug(&art->character, 1, &articulation_utf_len);
    strncpy(articulation_txt, articulation_utf, 4);
    bach_freeptr(articulation_utf);
    write_text_standard_account_for_vinset_singleline(r_ob, g, jf_art, *color, articulation_txt, stem_x + art->x_pos, real_y_pos);
    
    if (r_ob->articulations_typo_preferences.artpref[art->articulation_ID].extension_line_char > 0 && r_ob->show_articulations_extensions) { // extension line
        double total_width = extension_end_x - (stem_x + art->x_pos + art->width/2.) - CONST_ARTICULATION_EXTENSION_END_UTRIM * r_ob->zoom_y;
        double one_char_width, one_char_height;
        unicodeChar *all_chars_txt;
        long num_chars, i;
        
        
        char *utf;
        long utflen;
        utf = charset_unicodetoutf8_debug(&r_ob->articulations_typo_preferences.artpref[art->articulation_ID].extension_line_char, 1, &utflen);
        //                    strncpy(articulation_txt, articulation_utf, 4);
        jfont_text_measure(jf_art, utf, &one_char_width, &one_char_height);
        bach_freeptr(utf);
        num_chars = floor(total_width / one_char_width);
        if (num_chars > 0) {
            all_chars_txt = (unicodeChar *) bach_newptr((num_chars + 1) * sizeof(unicodeChar));
            for (i = 0; i < num_chars; i++)
                all_chars_txt[i] = r_ob->articulations_typo_preferences.artpref[art->articulation_ID].extension_line_char;
            all_chars_txt[i] = 0;
            utf = charset_unicodetoutf8_debug(all_chars_txt, num_chars, &utflen);
            write_text_standard_account_for_vinset_singleline(r_ob, g, jf_art, *color, utf, stem_x + art->x_pos + art->width,
                                          real_y_pos - r_ob->articulations_typo_preferences.artpref[art->articulation_ID].extension_line_uy_offset * r_ob->zoom_y);
            bach_freeptr(utf);
            bach_freeptr(all_chars_txt);
            
        }
    }
    
    jfont_destroy_debug(jf_art); 
}



void paint_annotation_from_slot(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_notation_item *item,
                                double x_pos, long slot, t_jfont *jf_ann, double staff_top_y,
                                char *last_annotation_text, double *annotation_sequence_start_x_pos, double *annotation_sequence_end_x_pos,
                                double *annotation_line_y_pos)
{
    e_annotations_filterdup_modes thinmode = (e_annotations_filterdup_modes)r_ob->thinannotations;
    
    if (item->type == k_NOTE) {
        t_note *note = (t_note *)item;
        double pad = 1 * r_ob->zoom_y;
        t_chord *chord = note->parent;
        char *buf = NULL;
        char must_free = false, must_show = false, must_use_clearing_symbol = false;
        
        if (r_ob->slotinfo[slot].slot_type == k_SLOT_TYPE_TEXT)
            buf = note->slot[slot].firstitem ? (char *)note->slot[slot].firstitem->item : NULL;
        else {
            t_llll *ll = note_get_single_slot_values_as_llll(r_ob, note, k_CONSIDER_FOR_DUMPING, slot, false);
            if (ll) llll_behead(ll);
            llll_to_text_buf(ll, &buf, 0, BACH_DEFAULT_MAXDECIMALS, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
            llll_free(ll);
            must_free = true;
        }
        
        
        must_show = true;
        if (thinmode != k_ANNOTATIONS_FILTERDUP_DONT) {
            if (buf && !strcmp(last_annotation_text, buf)) {
                // we need to filter out this annotation, it's the same as the previous one
                must_show = false;
                *annotation_sequence_end_x_pos = x_pos;
            } else {
                switch (thinmode) {
                    case k_ANNOTATIONS_FILTERDUP_DO_WITHCLEARINGSYM:
                        if (last_annotation_text[0])
                            must_use_clearing_symbol = true;
                        break;

                    case k_ANNOTATIONS_FILTERDUP_DO_WITHLINE:
                        if (last_annotation_text[0] && *annotation_sequence_start_x_pos < *annotation_sequence_end_x_pos) {
                            double start_x = *annotation_sequence_start_x_pos + 1 * r_ob->zoom_y;
                            double end_x = *annotation_sequence_end_x_pos + 9 * r_ob->zoom_y;
                            double line_y = *annotation_line_y_pos;
                            paint_line(g, *color, start_x, line_y, end_x, line_y, 1);
                            paint_line(g, *color, end_x, line_y, end_x, line_y + 4 * r_ob->zoom_y, 1);
                        }
                        break;

                    default:
                        break;
                }

                if (buf)
                    snprintf_zero(last_annotation_text, BACH_MAX_LAST_ANNOTATION_TEXT_CHARS, "%s", buf);
                else
                    last_annotation_text[0] = 0;
                *annotation_sequence_start_x_pos = *annotation_sequence_end_x_pos = x_pos;
            }
        }
        
        if (buf && must_show) {
            double ann_width, ann_height;
            double y_pos = 0;
            jfont_text_measure(jf_ann, buf, &ann_width, &ann_height);
            if (chord->topmost_y_noacc > staff_top_y)
                chord->topmost_y_noacc = staff_top_y;
            y_pos = chord->topmost_y_noacc - pad - ann_height;
            write_text_standard_account_for_vinset_singleline(r_ob, g, jf_ann, *color, buf, x_pos, y_pos);
            chord->topmost_y_noacc = chord->topmost_y_noacc - ann_height - 2 * pad;
            
            *annotation_line_y_pos = y_pos + 7 * r_ob->zoom_y;
            *annotation_sequence_start_x_pos = x_pos + ann_width;

        } else if (must_use_clearing_symbol) {
            char buf_clearing_sym[2048];
            snprintf_zero(buf_clearing_sym, 2048, "%s", r_ob->annotations_clearingsym ? r_ob->annotations_clearingsym->s_name : "ord.");
            double ann_width, ann_height;
            jfont_text_measure(jf_ann, buf, &ann_width, &ann_height);
            if (chord->topmost_y_noacc > staff_top_y)
                chord->topmost_y_noacc = staff_top_y;
            write_text_standard_account_for_vinset_singleline(r_ob, g, jf_ann, *color, buf_clearing_sym, x_pos, chord->topmost_y_noacc - pad - ann_height);
            chord->topmost_y_noacc = chord->topmost_y_noacc - ann_height - 2 * pad;
        }
        
        if (buf && must_free)
            bach_freeptr(buf);
    }
}



char is_scorechord_before_scorechord(t_notation_obj *r_ob, t_chord *chord1, t_chord *chord2){
    t_chord *ch;
    for (ch = chord_get_next(chord1); ch; ch = chord_get_next(ch))
        if (ch == chord2)
            return true;

    return false;
}

char is_barline_tuttipoint(t_notation_obj *r_ob, t_measure_end_barline *barline)
{
    t_measure *meas = barline->owner;
    if ((meas->next && meas->next->tuttipoint_reference && 
            meas->next->tuttipoint_reference->measure[meas->voiceparent->v_ob.number] == meas->next &&
            meas->next->tuttipoint_reference->all_voices_are_together) ||
        (!meas->next && r_ob->all_voices_end_together))
        return 1;
    return 0;
}

char is_tuttipoint_with_same_ts(t_notation_obj *r_ob, t_tuttipoint *tpt)
{
    if (tpt) {
        for (long i = 1; i < r_ob->num_voices; i++)
            if (!ts_are_equal(&tpt->measure[i-1]->timesignature, &tpt->measure[i]->timesignature))
                return 0;
        return 1;
    }
    return 0;
}

char is_barline_tuttipoint_with_same_ts(t_notation_obj *r_ob, t_measure_end_barline *barline)
{
    if (is_barline_tuttipoint(r_ob, barline)) {
        t_measure *meas = barline->owner;
        if (!meas->next)
            return 0;
        return is_tuttipoint_with_same_ts(r_ob, meas->next->tuttipoint_reference);
    }
    return 0;
}

void paint_slur(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_slur *slur, 
                char paint_control_points, t_jrgba linecolor, t_jrgba pointcolor, double point_radius, double line_width, double dash_length){ 
    double x1, y1, x2, y2, x3, y3, x4, y4;
    double slur_semiwidth = CONST_SCORE_SLUR_UWIDTH * r_ob->zoom_y / 2.; 
    double slur_base_length;
    
    if (slur->need_recompute_position) {
        t_note *start = slur->start_note, *end = slur->end_note;
        char direction = (slur->direction) ? slur->direction : -start->parent->direction;
        double alpha;
        double long_base, delta_x, a, b, h;
        char reversed = false;
        t_chord *chord;
        double raise1_y = 0, raise2_y = 0, raisestart_y = 0, raiseend_y = 0;
        
        // gotta switch start and end notes? (if chords are reversed!)
        if (is_scorechord_before_scorechord(r_ob, end->parent, start->parent)){
            t_note *temp;
            temp = start;
            start = end;
            end = temp;
            reversed = true;
        } 
                
        // standard positioning for start point and end point
        slur->start_x = start->parent->parent->tuttipoint_reference->offset_ux + start->parent->stem_offset_ux + start->notecenter_stem_delta_ux;
        slur->end_x = end->parent->parent->tuttipoint_reference->offset_ux + end->parent->stem_offset_ux + end->notecenter_stem_delta_ux;
        slur->start_y = start->center.y + 2 * r_ob->step_y * (- direction);
        slur->end_y = end->center.y + 2 * r_ob->step_y * (- direction);
        
        // particular cases for start point and end point
        if (direction == -1 && end->parent->direction == -1) 
            slur->end_x = end->parent->parent->tuttipoint_reference->offset_ux + end->parent->stem_offset_ux - CONST_SLUR_USEPARATION_FROM_STEM * r_ob->zoom_y;

        if (slur->start_x == slur->end_x) slur->end_x += 5 * r_ob->zoom_y; 

        if (r_ob->slurs_shown_chordwise && direction * end->parent->direction == 1 && rat_long_cmp(end->parent->figure, 1) < 0) {
            slur->end_x = xposition_to_unscaled_xposition(r_ob, end->parent->stem_x) - CONST_SLUR_USEPARATION_FROM_STEM * r_ob->zoom_y; 
            if (direction == 1)
                slur->end_y = end->parent->topmost_y + 2 * r_ob->step_y; 
            else
                slur->end_y = end->parent->bottommost_y - 2 * r_ob->step_y; 
        } else if (r_ob->slurs_shown_chordwise && direction * start->parent->direction == 1 && rat_long_cmp(start->parent->figure, 1) < 0) {
            slur->start_x = xposition_to_unscaled_xposition(r_ob, start->parent->stem_x) + CONST_SLUR_USEPARATION_FROM_STEM * r_ob->zoom_y; 
            if (direction == 1)
                slur->start_y = start->parent->topmost_y + 2 * r_ob->step_y; 
            else
                slur->start_y = start->parent->bottommost_y - 2 * r_ob->step_y; 
        }

        // calculating standard control points
        delta_x = slur->end_x - slur->start_x;
        long_base = sqrt(delta_x * delta_x + (slur->start_y - slur->end_y) * (slur->start_y - slur->end_y));
        alpha = fabs(atan(-(slur->end_y - slur->start_y)/(slur->end_x - slur->start_x)));

        a = long_base * CLAMP(0.3 - 0.12 * long_base/400., 0.18, 0.3);
        b = long_base - a;
        h = CLAMP(CONST_SLUR_MIN_UHEIGHT + (CONST_SLUR_MAX_UHEIGHT - CONST_SLUR_MIN_UHEIGHT) * long_base/400., CONST_SLUR_MIN_UHEIGHT, CONST_SLUR_MAX_UHEIGHT) * r_ob->zoom_y;
        
        if ((direction == 1 && slur->end_y <= slur->start_y) || (direction == -1 && slur->end_y >= slur->start_y)) {
            slur->cp1_rel_x = a * cos(alpha) - h * sin(alpha);
            slur->cp1_y = (slur->cp1_rel_x * tan(alpha) + h / cos(alpha)) * (- direction);
            slur->cp2_rel_x = b * cos(alpha) - h * sin(alpha);
            slur->cp2_y = (slur->cp2_rel_x * tan(alpha) + h / cos(alpha)) * (- direction);
            slur->cp1_rel_x += slur->start_x;
            slur->cp2_rel_x += slur->start_x;
            slur->cp1_y += slur->start_y;
            slur->cp2_y += slur->start_y;
        } else {
            slur->cp1_rel_x = slur->start_x + a / cos(alpha) + (h - a*tan(alpha)) * sin(alpha);
            slur->cp1_y = slur->start_y + (h - a*tan(alpha)) * cos(alpha) * (- direction);
            slur->cp2_rel_x = slur->start_x + b / cos(alpha) + (h - b*tan(alpha)) * sin(alpha);
            slur->cp2_y = slur->start_y + (h - b*tan(alpha)) * cos(alpha) * (- direction);
        }

        // modify (if needed) control points, so that the slur does not cross notes or stems
        chord = start->parent;
        if (start->parent != end->parent){
            for (    chord = chord_get_next(start->parent); 
                    chord && chord_get_prev(chord) != end->parent; // && chord_get_prev(chord) != chord_get_prev(end->parent); 
                    chord = chord_get_next(chord)) {
                    
                if (direction == 1) {
                    long count = 0;
                    char is_good = false;
                    double d1, d2, d, s, s_used, d_step;
                    double stem_ux = xposition_to_unscaled_xposition(r_ob, chord->stem_x);
                    double top_y = (r_ob->slurs_avoid_accidentals ? chord->topmost_y : chord->topmost_y_noacc) - CONST_SLUR_AVOID_OBJECTS_PAD * r_ob->zoom_y;
                    
                    // special case: last chord 
                    if (chord == end->parent && (!r_ob->slurs_avoid_accidentals || chord->topmost_y_noacc + CONST_EPSILON5 < chord->topmost_y_noacc))
                        continue;

                    if (chord->topmost_y_noacc + CONST_EPSILON5 < chord->topmost_y_noacc) {
                        // the topmost point is on an accidental. gotta find its deplacement!
                        t_note *nt; 
                        double topmost = chord->lastnote->center.y;
                        double delta_ux_candidate = 0.;
                        for (nt = end->parent->firstnote; nt; nt = nt->next) {
                            double new_candidate = nt->center.y - note_get_accidental_top_uextension(r_ob, nt) * r_ob->zoom_y;
                            if (new_candidate < topmost) {
                                topmost = new_candidate;
                                delta_ux_candidate = nt->accidental_stem_delta_ux;
                            }
                        }
                        stem_ux += delta_ux_candidate;
                        top_y = topmost - CONST_SLUR_AVOID_LAST_ACCIDENTALS_PAD * r_ob->zoom_y;
                    }
                    
                    d1 = pt_line_distance_vertical(stem_ux, top_y, slur->start_x, slur->start_y, slur->cp2_rel_x, slur->cp2_y);
                    d2 = pt_line_distance_vertical(stem_ux, top_y, slur->cp1_rel_x, slur->cp1_y, slur->end_x, slur->end_y);

                    // how big is the superposition? 
                    is_good = (d1 < 0 && d2 < 0);
                    d = MAX(d1 > 0 ? fabs(d1) : 0, d2 > 0 ? fabs(d2) : 0.);
                        
                    // we compute the position of chord between the start chord and the end chord
                    s = CLAMP((stem_ux - slur->start_x)/(slur->end_x - slur->start_x), 0., 1.);
                    s_used = r_ob->slurs_always_symmetrical ? 0.5 : s; // if slurs are always symmetrical, we always modify left side as much as right side
                    
                    d_step = d/3; //3 must become some CONST_SLUR_AUTOFIND_SHAPE_STEP
                    
                    while (!is_good && count < 1000) {
                        // what do we do? We could: A. raise start/end points; B. shift control points left/right; C. raise control points
                        double w_a = 0, w_b = 0, w_c = 0;
                        double t1, t2;
                        w_b = CLAMP(fabs(s-0.5) * 2. * CLAMP(long_base/4000., 0., 1.), 0., 1.);
                        if (slur->cp1_rel_x - d_step * w_b * (1 - s_used) < slur->start_x || slur->cp2_rel_x + d_step * w_b * s_used > slur->end_x)
                            w_b = 0;
                        t1 = MAX(raise1_y, raise2_y)/h;
                        t2 = MAX(raisestart_y, raiseend_y)/h;
                        w_a = (1 - w_b) * CLAMP((t1 - 1)/3. - (t2 - 1)/3. + fabs(s-0.5), 0., 1.);
                        w_c = 1 - w_b - w_a;
                        
                        if (w_a > 0.) {
                            if (r_ob->slurs_always_symmetrical && false){
                                raisestart_y += d_step * w_a * (1 - s);
                                raiseend_y += d_step * w_a * s;
                                slur->start_y -= d_step * w_a * (1 - s);
                                slur->end_y -= d_step * w_a * s;
                                // we raise alsothe control points
                                raise1_y += d_step * w_a * (1 - s);
                                raise2_y += d_step * w_a * s;
                                slur->cp1_y -= d_step * w_a * (1 - s);
                                slur->cp2_y -= d_step * w_a * s;
                            } else {
                                raisestart_y += d_step * w_a * (1 - s);
                                raiseend_y += d_step * w_a * s;
                                slur->start_y -= d_step * w_a * (1 - s);
                                slur->end_y -= d_step * w_a * s;
                            }
                        }
                        
                        if (w_b > 0.) {
                            slur->cp1_rel_x -= d_step * w_b * (1 - s_used);
                            slur->cp2_rel_x += d_step * w_b * s_used;
                        }

                        if (w_c > 0.) {
                            // we raise the control points
                            raise1_y += d_step * w_c * (1 - s_used);
                            raise2_y += d_step * w_c * s_used;
                            slur->cp1_y -= d_step * w_c * (1 - s_used);
                            slur->cp2_y -= d_step * w_c * s_used;
                        }                        

                        d1 = pt_line_distance_vertical(stem_ux, top_y, slur->start_x, slur->start_y, slur->cp2_rel_x, slur->cp2_y);
                        d2 = pt_line_distance_vertical(stem_ux, top_y, slur->cp1_rel_x, slur->cp1_y, slur->end_x, slur->end_y);
                        is_good = (d1 < 0 && d2 < 0);
                        count++;
                    }
                    if (count == 1000) {
                        post("Slur couldn't be correctly painted");
                    }
                }
            }
        }

        slur->cp1_rel_x = (slur->cp1_rel_x - slur->start_x) / delta_x;
        slur->cp2_rel_x = (slur->cp2_rel_x - slur->start_x) / delta_x;

        if (reversed) {
            double temp;
            temp = slur->start_x; slur->start_x = slur->end_x; slur->end_x = temp;
            temp = slur->start_y; slur->start_y = slur->end_y; slur->end_y = temp;
//            temp = slur->cp1_rel_x; slur->cp1_rel_x = slur->cp2_rel_x; slur->cp2_rel_x = temp;
            temp = slur->cp1_y; slur->cp1_y = slur->cp2_y; slur->cp2_y = temp;
        }
        slur->need_recompute_position = false;
    }
    
    // real painting
    x1 = unscaled_xposition_to_xposition(r_ob, slur->start_x);
    y1 = slur->start_y;
    x4 = unscaled_xposition_to_xposition(r_ob, slur->end_x);
    y4 = slur->end_y;
    slur_base_length = slur->end_x - slur->start_x;
    x2 = unscaled_xposition_to_xposition(r_ob, slur->start_x + slur->cp1_rel_x * slur_base_length);
    y2 = slur->cp1_y;
    x3 = unscaled_xposition_to_xposition(r_ob, slur->start_x + slur->cp2_rel_x * slur_base_length);
    y3 = slur->cp2_y;
#ifdef BACH_MAX
    jgraphics_set_line_width(g, 0.); 
    jgraphics_set_source_jrgba(g, &color);
    jgraphics_move_to(g, x1, y1);
    jgraphics_curve_to(g, x2, y2 + slur_semiwidth, x3, y3 + slur_semiwidth, x4, y4);
    jgraphics_curve_to(g, x3, y3 - slur_semiwidth, x2, y2 - slur_semiwidth, x1, y1);
    jgraphics_close_path(g);
    jgraphics_fill(g);
#endif
#ifdef BACH_JUCE
    jgraphics_set_source_jrgba(g, &color);
    Path p;
    p.startNewSubPath(x1, y1);
    p.cubicTo(x2, y2 + slur_semiwidth, x3, y3 + slur_semiwidth, x4, y4);
    p.cubicTo(x3, y3 - slur_semiwidth, x2, y2 - slur_semiwidth, x1, y1);
    p.closeSubPath();
    g->fillPath(p);
#endif
    
    if (paint_control_points) {
        paint_line(g, linecolor, x1, y1, x2, y2, line_width);
        paint_line(g, linecolor, x2, y2, x3, y3, line_width);
        paint_line(g, linecolor, x3, y3, x4, y4, line_width);
        paint_line(g, linecolor, x4, y4, x1, y1, line_width);
        paint_circle_filled(g, get_grey(1.), x1, y1, CONST_SLUR_START_END_POINT_SEL_WIDTH);
        paint_circle_stroken(g, pointcolor, x1, y1, CONST_SLUR_START_END_POINT_SEL_WIDTH, 1);
        paint_circle_filled(g, pointcolor, x1, y1, point_radius);
        paint_circle_filled(g, pointcolor, x2, y2, point_radius);
        paint_circle_filled(g, pointcolor, x3, y3, point_radius);
        paint_circle_filled(g, get_grey(1.), x4, y4, CONST_SLUR_START_END_POINT_SEL_WIDTH);
        paint_circle_stroken(g, pointcolor, x4, y4, CONST_SLUR_START_END_POINT_SEL_WIDTH, 1);
        paint_circle_filled(g, pointcolor, x4, y4, point_radius);
    }
}



void get_legend(t_notation_obj *r_ob, t_note *curr_nt, t_bpt *selected_breakpoint, char *there_is_legend, char *legend_text){
    
    char obj_type = r_ob->obj_type; 
    if ((r_ob->num_selecteditems == 1 && r_ob->firstselecteditem->type == k_NOTE && (t_note *)r_ob->firstselecteditem == curr_nt) ||
        (r_ob->num_selecteditems == 1 && r_ob->firstselecteditem->type == k_CHORD && curr_nt->parent && (t_chord *)r_ob->firstselecteditem == curr_nt->parent && curr_nt->parent->num_notes == 1)){
        // single note, or chord with a single note
        t_note *temp_nt = NULL;
        if (r_ob->firstselecteditem->type == k_CHORD) 
            temp_nt = curr_nt->parent->firstnote;
        else
            temp_nt = curr_nt;
        
        if (there_is_legend) 
            *there_is_legend = 1;
        
        char onset_text[256], dur_text[256];
        time_to_char_buf(r_ob, chord_get_onset_ms(temp_nt->parent), onset_text, 256);
        time_to_char_buf(r_ob, obj_type == k_NOTATION_OBJECT_SCORE ? temp_nt->parent->duration_ms : temp_nt->duration, dur_text, 256);

        if (r_ob->show_note_names) {
            char notename[255];
            note_get_pitch(r_ob, temp_nt).toTextBuf(notename, 255);
            if (obj_type == k_NOTATION_OBJECT_SCORE)
                snprintf(legend_text, 255, "%s   Cents %.1f   Duration " RATIONAL_PRINTF_FMT "   Velocity %ld   Onset %s   Duration %s", notename, temp_nt->midicents, temp_nt->parent->r_sym_duration.r_num, temp_nt->parent->r_sym_duration.r_den, temp_nt->velocity, onset_text, dur_text);
            else if (obj_type == k_NOTATION_OBJECT_ROLL)
                snprintf(legend_text, 255, "%s   Onset %s   Cents %.1f   Duration %s   Velocity %ld", notename, onset_text, temp_nt->midicents, dur_text, temp_nt->velocity);
        } else {
            if (obj_type == k_NOTATION_OBJECT_SCORE)
                snprintf(legend_text, 255, "Cents %.1f   Duration " RATIONAL_PRINTF_FMT "   Velocity %ld   Onset %s   Duration %s", temp_nt->midicents, temp_nt->parent->r_sym_duration.r_num, temp_nt->parent->r_sym_duration.r_den, temp_nt->velocity, onset_text, dur_text);
            else if (obj_type == k_NOTATION_OBJECT_ROLL)
                snprintf(legend_text, 255, "Onset %s   Cents %.1f   Duration %s   Velocity %ld", onset_text, temp_nt->midicents, dur_text, temp_nt->velocity);
        }
        
    } else if (r_ob->num_selecteditems == 1 && r_ob->firstselecteditem->type == k_CHORD && (t_chord *)r_ob->firstselecteditem == curr_nt->parent) {
        // chord
        char onset_text[256], dur_text[256];
        time_to_char_buf(r_ob, chord_get_onset_ms(curr_nt->parent), onset_text, 256);
        time_to_char_buf(r_ob, chord_get_max_duration(r_ob, curr_nt->parent), dur_text, 256);

        if (there_is_legend)
            *there_is_legend = 1;
        if (obj_type == k_NOTATION_OBJECT_SCORE) {
            snprintf(legend_text, 255, "Duration " RATIONAL_PRINTF_FMT "   Onset %s   Duration %s", curr_nt->parent->r_sym_duration.r_num, curr_nt->parent->r_sym_duration.r_den, onset_text, dur_text);
        } else if (obj_type == k_NOTATION_OBJECT_ROLL)
            snprintf(legend_text, 255, "Onset %s  Duration %s", onset_text, dur_text);
        
    } else if (r_ob->num_selecteditems == 1 && r_ob->firstselecteditem->type == k_PITCH_BREAKPOINT && selected_breakpoint && (t_bpt *)r_ob->firstselecteditem == selected_breakpoint) {
        if (!selected_breakpoint->next) {
            // duration tail
            if (there_is_legend) 
                *there_is_legend = 1;
            
            char dur_text[256], end_text[256];
            time_to_char_buf(r_ob, curr_nt->duration, dur_text, 256);
            time_to_char_buf(r_ob, curr_nt->parent->onset + curr_nt->duration, end_text, 256);

            if (r_ob->breakpoints_have_velocity && r_ob->allow_glissandi)
                snprintf(legend_text, 255, "Cents %.1f (Δ %s%.1f)   Duration %s   End %s   Velocity %ld", curr_nt->midicents + curr_nt->lastbreakpoint->delta_mc, curr_nt->lastbreakpoint->delta_mc >= 0 ? "+" : "", curr_nt->lastbreakpoint->delta_mc, dur_text, end_text, (long)curr_nt->lastbreakpoint->velocity);
            else if (r_ob->allow_glissandi)
                snprintf(legend_text, 255, "Cents %.1f (Δ %s%.1f)   Duration %s   End %s", curr_nt->midicents + curr_nt->lastbreakpoint->delta_mc, curr_nt->lastbreakpoint->delta_mc >= 0 ? "+" : "", curr_nt->lastbreakpoint->delta_mc, dur_text, end_text);
            else if (r_ob->breakpoints_have_velocity)
                snprintf(legend_text, 255, "Cents %.1f   Duration %s   End %s   Velocity %ld", curr_nt->midicents, dur_text, end_text, (long)curr_nt->lastbreakpoint->velocity);
            else
                snprintf(legend_text, 255, "Cents %.1f   Duration %s   End %s", curr_nt->midicents, dur_text, end_text);
        } else {
            // breakpoint
            if (there_is_legend) 
                *there_is_legend = 1;

            char pos_text[256];
            time_to_char_buf(r_ob, selected_breakpoint->owner->parent->onset + selected_breakpoint->rel_x_pos * selected_breakpoint->owner->duration, pos_text, 256);
            
            if (r_ob->breakpoints_have_velocity)
                snprintf(legend_text, 255, "Position %s   Cents %.1f (Δ %s%.1f)   Velocity %ld", pos_text, selected_breakpoint->owner->midicents+selected_breakpoint->delta_mc, selected_breakpoint->delta_mc >= 0 ? "+" : "", selected_breakpoint->delta_mc, (long)selected_breakpoint->velocity);
            else
                snprintf(legend_text, 255, "Position %s   Cents %.1f (Δ %s%.1f)", pos_text, selected_breakpoint->owner->midicents+selected_breakpoint->delta_mc, selected_breakpoint->delta_mc >= 0 ? "+" : "", selected_breakpoint->delta_mc);
        }
    } else if (r_ob->num_selecteditems > 1) {
        if (there_is_legend) 
            *there_is_legend = 1;
        snprintf(legend_text, 255, "%ld Selected Items", r_ob->num_selecteditems);
    }
}


char are_only_all_tied_chords_selected(t_notation_obj *r_ob, t_chord **first_sel, t_chord **last_sel, char *all_chords_have_one_note)
{
    char res = false;
    if (r_ob->firstselecteditem && r_ob->firstselecteditem->type == k_CHORD) {
        t_chord *ch = (t_chord *)r_ob->firstselecteditem;
        t_chord *right = ch, *left = ch;
        
        if (ch->num_notes != 1)
            *all_chords_have_one_note = false;
        else
            *all_chords_have_one_note = true;
        
        while (right && chord_get_next(right) &&  chord_is_all_tied_to(r_ob, right, false, NULL) && notation_item_is_selected(r_ob, (t_notation_item *)chord_get_next(right))) {
            right = chord_get_next(right);
            if (right->num_notes != 1)
                *all_chords_have_one_note = false;
        }
        
        while (left && chord_get_prev(left) && chord_is_all_tied_from(left, false) && notation_item_is_selected(r_ob, (t_notation_item *)chord_get_prev(left))) {
            left = chord_get_prev(left);
            if (right->num_notes != 1)
                *all_chords_have_one_note = false;
        }
        
        *first_sel = left;
        *last_sel = right;
        
        t_chord *temp;
        for (temp = left; temp; temp = chord_get_next(temp)) {
            temp->r_it.flags |= k_FLAG_COUNT;
            if (temp == right)
                break;
        }
        
        res = true;

        t_notation_item *item;
        for (item = r_ob->firstselecteditem; item; item = item->next_selected) {
            if (!(item->flags & k_FLAG_COUNT)) {
                res = false;
                break;
            }
        }

            
        for (temp = left; temp; temp = chord_get_next(temp)) {
            temp->r_it.flags &= ~k_FLAG_COUNT;
            if (temp == right)
                break;
        }
        
    }
    return res;
}

char are_only_all_tied_notes_selected(t_notation_obj *r_ob, t_note **first_sel, t_note **last_sel)
{
    char res = false;
    if ((r_ob->firstselecteditem && r_ob->firstselecteditem->type == k_CHORD && ((t_chord *)r_ob->firstselecteditem)->num_notes == 1) || (r_ob->firstselecteditem && r_ob->firstselecteditem->type == k_NOTE)) {
        
        t_note *nt = r_ob->firstselecteditem->type == k_NOTE ? (t_note *)r_ob->firstselecteditem : ((t_chord *)r_ob->firstselecteditem)->firstnote;
        t_note *right = nt, *left = nt;
        
        while (right && right->tie_to && right->tie_to != WHITENULL && (notation_item_is_selected(r_ob, (t_notation_item *)right->tie_to) ||
                                                                        (right->tie_to->parent && right->tie_to->parent->num_notes == 1 && notation_item_is_selected(r_ob, (t_notation_item *)right->tie_to->parent)))) {
            right = right->tie_to;
        }
        
        while (left && left->tie_from && left->tie_from != WHITENULL && (notation_item_is_selected(r_ob, (t_notation_item *)left->tie_from) ||
                                                                        (left->tie_from->parent && left->tie_from->parent->num_notes == 1 && notation_item_is_selected(r_ob, (t_notation_item *)left->tie_from->parent)))) {
            left = left->tie_from;
        }
        
        *first_sel = left;
        *last_sel = right;
        
        t_note *temp;
        for (temp = left; temp; temp = temp->tie_to) {
            temp->r_it.flags |= k_FLAG_COUNT;
            if (temp == right)
                break;
        }
        
        res = true;
        
        t_notation_item *item;
        for (item = r_ob->firstselecteditem; item; item = item->next_selected) {
            if (item->type == k_NOTE) {
                if (!(item->flags & k_FLAG_COUNT)) {
                    res = false;
                    break;
                }
            } else if (item->type == k_CHORD) {
                t_chord *temp_ch = (t_chord *)item;
                if (temp_ch->num_notes != 1 || !temp_ch->firstnote || !(temp_ch->firstnote->r_it.flags & k_FLAG_COUNT)) {
                    res = false;
                    break;
                }
            } else {
                res = false;
                break;
            }
        }
        
        
        for (temp = left; temp; temp = temp->tie_to) {
            temp->r_it.flags &= ~k_FLAG_COUNT;
            if (temp == right)
                break;
        }
        
    }
    return res;
}

void notationobj_get_legend(t_notation_obj *r_ob, char *legend_text)
{
    
    char obj_type = r_ob->obj_type;
    long num_sel = r_ob->num_selecteditems;
    t_notation_item *firstsel = r_ob->firstselecteditem;
    
    legend_text[0] = 0;
    
    if (r_ob->legend < 1)
        return;
    
    if (num_sel == 1 && firstsel && firstsel->type == k_MARKER) {
        t_marker *mk = (t_marker *)firstsel;
        char onset_text[256];
        char buf[1000];
        double marker_onset = mk->position_ms;
        get_names_as_text(mk->r_it.names, buf, 1000);
        
        time_to_char_buf(r_ob, marker_onset, onset_text, 256);
        if (buf[0])
            snprintf_zero(legend_text, 256, "Onset %s   Name %s", onset_text, buf);
        else
            snprintf_zero(legend_text, 256, "Onset %s", onset_text);
        
    } else if (num_sel == 1 && firstsel && firstsel->type == k_VOICE) {
        t_voice *voice = (t_voice *)firstsel;
        char buf[1000];
        long numparts = voiceensemble_get_numparts(r_ob, voice);
        get_names_as_text(voice->r_it.names, buf, 1000);
        
        if (numparts <= 1) {
            if (buf[0])
                snprintf_zero(legend_text, 256, "Voice %ld   Name %s", voice->number + 1, buf);
            else
                snprintf_zero(legend_text, 256, "Voice %ld", voice->number + 1);
        } else {
            t_llll *ll = voiceensemble_get_voicenumbers(r_ob, voice, true);
            char *llbuf = NULL;
            llll_to_text_buf(ll, &llbuf, 0, BACH_DEFAULT_MAXDECIMALS, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
            snprintf_zero(legend_text, 256, "Voices %s", llbuf, buf);
            bach_freeptr(llbuf);
            llll_free(ll);
        }
        
    } else if (num_sel == 1 && firstsel && firstsel->type == k_MEASURE) {
        t_measure *meas = (t_measure *)firstsel;
        char ts_num[256];
        if (meas->timesignature.num_numerator_elements == 1)
            snprintf_zero(ts_num, 256, "%d", meas->timesignature.numerator);
        else {
            long j, len;
            long offset = 1;
            strcpy(ts_num, "(");
            for (j = 0; j < meas->timesignature.num_numerator_elements && offset < 230; j++) {
                char partstring[20];
                if (j < meas->timesignature.num_numerator_elements - 1)
                    snprintf_zero(partstring, 20, "%d+", meas->timesignature.numerator_elements[j]);
                else
                    snprintf_zero(partstring, 20, "%d)", meas->timesignature.numerator_elements[j]);
                len = strlen(partstring);
                strcpy(ts_num + offset, partstring);
                offset += len;
            }
            ts_num[offset] = '\0';
        }
        double onset_ms = meas->firstchord ? chord_get_onset_ms(meas->firstchord) : unscaled_xposition_to_ms(r_ob, meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux, 1);
        
        char onset_text[256], dur_text[256];
        time_to_char_buf(r_ob, onset_ms, onset_text, 256);
        time_to_char_buf(r_ob, rat2double(meas->r_total_duration_sec) * 1000., dur_text, 256);
        snprintf_zero(legend_text, 256, "Measure %ld   Voice %ld   Time Signature %s/%d   Onset %s   Duration %s", meas->measure_number + 1, meas->voiceparent->v_ob.number + 1, ts_num, meas->timesignature.denominator, onset_text, dur_text);
        
    } else if ((num_sel == 1 && firstsel && firstsel->type == k_NOTE) ||
               (num_sel == 1 && firstsel && firstsel->type == k_CHORD && ((t_chord *)firstsel)->num_notes == 1)) {
        // single note, or chord with a single note
        
        t_note *nt = NULL;
        if (firstsel->type == k_CHORD)
            nt = ((t_chord *)firstsel)->firstnote;
        else
            nt = ((t_note *)firstsel);
        
        char onset_text[256], dur_text[256];
        time_to_char_buf(r_ob, chord_get_onset_ms(nt->parent), onset_text, 256);
        time_to_char_buf(r_ob, obj_type == k_NOTATION_OBJECT_SCORE ? nt->parent->duration_ms : nt->duration, dur_text, 256);
        
        if (r_ob->show_note_names) {
            char notename[255];
            note_get_pitch(r_ob, nt).toTextBuf(notename, 255);
            if (obj_type == k_NOTATION_OBJECT_SCORE)
                snprintf(legend_text, 255, "%s   Cents %.1f   Duration " RATIONAL_PRINTF_FMT "   Velocity %ld   Onset %s   Duration %s", notename, nt->midicents, nt->parent->r_sym_duration.r_num, nt->parent->r_sym_duration.r_den, nt->velocity, onset_text, dur_text);
            else if (obj_type == k_NOTATION_OBJECT_ROLL)
                snprintf(legend_text, 255, "%s   Onset %s   Cents %.1f   Duration %s   Velocity %ld", notename, onset_text, nt->midicents, dur_text, nt->velocity);
        } else {
            if (obj_type == k_NOTATION_OBJECT_SCORE)
                snprintf(legend_text, 255, "Cents %.1f   Duration " RATIONAL_PRINTF_FMT " (%s)   Velocity %ld   Onset %s ", nt->midicents, nt->parent->r_sym_duration.r_num, nt->parent->r_sym_duration.r_den, dur_text, nt->velocity, onset_text);
            else if (obj_type == k_NOTATION_OBJECT_ROLL)
                snprintf(legend_text, 255, "Onset %s   Cents %.1f   Duration %s   Velocity %ld", onset_text, nt->midicents, dur_text, nt->velocity);
        }
        
    } else if (num_sel == 1 && firstsel && firstsel->type == k_CHORD) { // single chord
        t_chord *ch = (t_chord *)firstsel;
        char onset_text[256], dur_text[256];
        time_to_char_buf(r_ob, chord_get_onset_ms(ch), onset_text, 256);
        time_to_char_buf(r_ob, chord_get_max_duration(r_ob, ch), dur_text, 256);
        
        if (obj_type == k_NOTATION_OBJECT_SCORE) {
            snprintf(legend_text, 255, "Duration " RATIONAL_PRINTF_FMT "   Onset %s   Duration %s", rat_abs(ch->r_sym_duration).r_num, ch->r_sym_duration.r_den, onset_text, dur_text);
        } else if (obj_type == k_NOTATION_OBJECT_ROLL)
            snprintf(legend_text, 255, "Onset %s  Duration %s", onset_text, dur_text);
        
    } else if (num_sel == 1 && firstsel && firstsel->type == k_PITCH_BREAKPOINT) {
        t_bpt *bpt = (t_bpt *)firstsel;
        t_note *nt = bpt->owner;
        if (nt) {
            if (!bpt->next) {
                // duration tail
                char dur_text[256], end_text[256];
                time_to_char_buf(r_ob, nt->duration, dur_text, 256);
                time_to_char_buf(r_ob, nt->parent->onset + nt->duration, end_text, 256);
                
                if (r_ob->breakpoints_have_velocity && r_ob->allow_glissandi)
                    snprintf(legend_text, 255, "Cents %.1f (Δ %s%.1f)   Duration %s   End %s   Velocity %ld", nt->midicents + nt->lastbreakpoint->delta_mc, nt->lastbreakpoint->delta_mc >= 0 ? "+" : "", nt->lastbreakpoint->delta_mc, dur_text, end_text, (long)nt->lastbreakpoint->velocity);
                else if (r_ob->allow_glissandi)
                    snprintf(legend_text, 255, "Cents %.1f (Δ %s%.1f)   Duration %s   End %s", nt->midicents + nt->lastbreakpoint->delta_mc, nt->lastbreakpoint->delta_mc >= 0 ? "+" : "", nt->lastbreakpoint->delta_mc, dur_text, end_text);
                else if (r_ob->breakpoints_have_velocity)
                    snprintf(legend_text, 255, "Cents %.1f   Duration %s   End %s   Velocity %ld", nt->midicents, dur_text, end_text, (long)nt->lastbreakpoint->velocity);
                else
                    snprintf(legend_text, 255, "Cents %.1f   Duration %s   End %s", nt->midicents, dur_text, end_text);
            } else {
                // breakpoint
                char pos_text[256];
                time_to_char_buf(r_ob, nt->parent->onset + bpt->rel_x_pos * nt->duration, pos_text, 256);
                
                if (r_ob->breakpoints_have_velocity)
                    snprintf(legend_text, 255, "Position %s (%d%%)   Cents %.1f (Δ %s%.1f)   Velocity %ld", pos_text, (int)round(bpt->rel_x_pos*100), nt->midicents + bpt->delta_mc, bpt->delta_mc >= 0 ? "+" : "", bpt->delta_mc, (long)bpt->velocity);
                else
                    snprintf(legend_text, 255, "Position %s (%d%%)  Cents %.1f (Δ %s%.1f)", pos_text, (int)round(bpt->rel_x_pos*100), nt->midicents+bpt->delta_mc, bpt->delta_mc >= 0 ? "+" : "", bpt->delta_mc);
            }
        }
        
    } else if (r_ob->num_selecteditems > 1) {
        
        // checking all tied chords
        t_chord *start = NULL, *end = NULL;
        t_note *startnt = NULL, *endnt = NULL;
        char all_chords_have_one_note = false;
        if (obj_type == k_NOTATION_OBJECT_SCORE) {
            if (are_only_all_tied_chords_selected(r_ob, &start, &end, &all_chords_have_one_note) && start && end) {
                t_chord *temp;
                double duration = 0;
                t_rational sym_duration = long2rat(0);
                for (temp = start; temp; temp = chord_get_next(temp)) {
                    duration += chord_get_max_duration(r_ob, temp);
                    sym_duration = rat_rat_sum(sym_duration, rat_abs(temp->r_sym_duration));
                    if (temp == end) break;
                }
                
                char onset_text[256], dur_text[256];
                time_to_char_buf(r_ob, chord_get_onset_ms(start), onset_text, 256);
                time_to_char_buf(r_ob, duration, dur_text, 256);
                
                if (all_chords_have_one_note && start->firstnote) {
                    t_note *nt = start->firstnote;
                    if (r_ob->show_note_names) {
                        char notename[255];
                        note_get_pitch(r_ob, nt).toTextBuf(notename, 255);
                        if (obj_type == k_NOTATION_OBJECT_SCORE)
                            snprintf(legend_text, 255, "%s   Cents %.1f   Duration " RATIONAL_PRINTF_FMT "   Velocity %ld   Onset %s   Duration %s", notename, nt->midicents, sym_duration.r_num, sym_duration.r_den, nt->velocity, onset_text, dur_text);
                        else if (obj_type == k_NOTATION_OBJECT_ROLL)
                            snprintf(legend_text, 255, "%s   Onset %s   Cents %.1f   Duration %s   Velocity %ld", notename, onset_text, nt->midicents, dur_text, nt->velocity);
                    } else {
                        if (obj_type == k_NOTATION_OBJECT_SCORE)
                            snprintf(legend_text, 255, "Cents %.1f   Duration " RATIONAL_PRINTF_FMT " (%s)   Velocity %ld   Onset %s ", nt->midicents, sym_duration.r_num, sym_duration.r_den, dur_text, nt->velocity, onset_text);
                        else if (obj_type == k_NOTATION_OBJECT_ROLL)
                            snprintf(legend_text, 255, "Onset %s   Cents %.1f   Duration %s   Velocity %ld", onset_text, nt->midicents, dur_text, nt->velocity);
                    }
                    
                } else {
                    snprintf(legend_text, 255, "Duration " RATIONAL_PRINTF_FMT " (%s)    Onset %s", sym_duration.r_num, sym_duration.r_den, dur_text, onset_text);
                }
                
                
            } else if (are_only_all_tied_notes_selected(r_ob, &startnt, &endnt) && startnt && endnt && startnt->parent && endnt->parent){

                t_chord *temp;
                double duration = 0;
                t_rational sym_duration = long2rat(0);
                start = startnt->parent;
                end = endnt->parent;
                for (temp = start; temp; temp = chord_get_next(temp)) {
                    duration += chord_get_max_duration(r_ob, temp);
                    sym_duration = rat_rat_sum(sym_duration, rat_abs(temp->r_sym_duration));
                    if (temp == end) break;
                }
                
                char onset_text[256], dur_text[256];
                time_to_char_buf(r_ob, chord_get_onset_ms(start), onset_text, 256);
                time_to_char_buf(r_ob, duration, dur_text, 256);

                t_note *nt = startnt;
                if (r_ob->show_note_names) {
                    char notename[255];
                    note_get_pitch(r_ob, nt).toTextBuf(notename, 255);
                    if (obj_type == k_NOTATION_OBJECT_SCORE)
                        snprintf(legend_text, 255, "%s   Cents %.1f   Duration " RATIONAL_PRINTF_FMT "   Velocity %ld   Onset %s   Duration %s", notename, nt->midicents, sym_duration.r_num, sym_duration.r_den, nt->velocity, onset_text, dur_text);
                    else if (obj_type == k_NOTATION_OBJECT_ROLL)
                        snprintf(legend_text, 255, "%s   Onset %s   Cents %.1f   Duration %s   Velocity %ld", notename, onset_text, nt->midicents, dur_text, nt->velocity);
                } else {
                    if (obj_type == k_NOTATION_OBJECT_SCORE)
                        snprintf(legend_text, 255, "Cents %.1f   Duration " RATIONAL_PRINTF_FMT " (%s)   Velocity %ld   Onset %s ", nt->midicents, sym_duration.r_num, sym_duration.r_den, dur_text, nt->velocity, onset_text);
                    else if (obj_type == k_NOTATION_OBJECT_ROLL)
                        snprintf(legend_text, 255, "Onset %s   Cents %.1f   Duration %s   Velocity %ld", onset_text, nt->midicents, dur_text, nt->velocity);
                }

            } else {
                snprintf(legend_text, 255, "%ld Selected Items", r_ob->num_selecteditems);
            }
            
        } else {
            snprintf(legend_text, 255, "%ld Selected Items", r_ob->num_selecteditems);
        }
    }
}


void repaint_left_background_part(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect, double fade_left_x_pixel, double fade_right_x_pixel){
    const double pad = graphic_rect.height/10.;
    t_jrgba leftbgcolor = r_ob->j_background_rgba;
//    if (r_ob->repaint_left_background_part_with_full_alpha)
//        leftbgcolor.alpha = 1;
    paint_filledrectangle(g, leftbgcolor, 0., 0, fade_left_x_pixel+0.5, graphic_rect.height);
    jgraphics_image_surface_draw(g, r_ob->clef_gradient_surface, build_rect(0, 0, CONST_X_LEFT_START_FADE_NUM_STEPS, 10), build_rect(fade_left_x_pixel, 0 - pad, fade_right_x_pixel - fade_left_x_pixel, graphic_rect.height + 2 * pad));
}

// v_alignment: 1 = top, -1 = bottom
// returns the ending pixel of the frame
double paint_label_for_ruler(t_notation_obj *r_ob, t_jgraphics* g, double milliseconds, double x_pos, double y_pos, char v_alignment){
    char text[1000];
    double width, height;
    char sign = (milliseconds >= 0 ? 1 : -1);
    long work_ms = fabs(milliseconds);
    long mins = work_ms  /60000;
    long secs = (work_ms - mins * 60000) / 1000;
    long millisecs = work_ms - mins * 60000 - secs * 1000;
    t_jfont *text_font = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, r_ob->ruler_labels_font_size * r_ob->zoom_y);
    if (millisecs == 0)
        snprintf_zero(text, 1000, (sign >= 0) ? "%ld'%02ld\"" : "-%ld'%02ld\"", mins, secs);
    else
        snprintf_zero(text, 1000, (sign >= 0) ? "%ld'%02ld\"%03ld" : "%ld'%02ld\"%03ld", mins, secs, millisecs);
    jfont_text_measure(text_font, text, &width, &height); // we get how much space do we need
    paint_filledrectangle(g, r_ob->j_background_rgba , x_pos - width / 2., v_alignment > 0 ? y_pos : y_pos - height, width, height);
    write_text_standard_singleline(g, text_font, r_ob->j_ruler_rgba, text, x_pos - width / 2., v_alignment > 0 ? y_pos : y_pos - height, width + 10, height + 10);
    jfont_destroy_debug(text_font);

    return x_pos + width/2.;
}

//1ms -> 5ms .
//5ms -> 10ms -
//10ms -> 50ms .
//50ms -> 100ms -
//100ms -> 500sec .
//500ms -> 1sec -
//1 sec -> 5sec .
//5 sec -> 10 sec -
//10 sec -> 30 sec
//30 sec -> 1 min -
//1 min -> 5 min .
//5 min -> 10 min -
//10 min -> 30 min 
//30 min -> 1 h -

double best_scale_ms(t_notation_obj *r_ob, double ms_optimum){
    long i;
    double points[15];
    
    points[0] = 1;
    points[1] = 5;
    points[2] = 10;
    points[3] = 50;
    points[4] = 100;
    points[5] = 500;
    points[6] = 1000;
    points[7] = 5000;
    points[8] = 10000;
    points[9] = 30000;
    points[10] = 60000;
    points[11] = 300000;
    points[12] = 600000;
    points[13] = 1800000;
    points[14] = 3600000;
    
    for (i = 0; i < 15; i++) {
        if (points[i] > ms_optimum)
            break;
    }
    
    if (i == 0)
        return points[0];
    
    if (ms_optimum >= points[14])
        return points[14];
    
    if (i == 5 || i == 3 || i == 1) {
        if (fabs(ms_optimum - points[i]) < 2.5 *fabs(ms_optimum - points[i - 1])) // needed because milliseconds writing like 1'12"140 require a lot of space, so we push them farther in the scale
            return points[i];
    } else {
        if (fabs(ms_optimum - points[i]) < fabs(ms_optimum - points[i - 1]))
            return points[i];
    }

    return points[i - 1];
}


long ms_delta_to_num_subdivisions(t_notation_obj *r_ob, double ms_delta){
    if (fabs(ms_delta - 60000) < CONST_EPSILON1 || fabs(ms_delta - 3600000) < CONST_EPSILON1)
        return 6;
    else if (fabs(ms_delta - 5) < CONST_EPSILON1 || fabs(ms_delta - 50) < CONST_EPSILON1
               || fabs(ms_delta - 500) < CONST_EPSILON1 || fabs(ms_delta - 5000) < CONST_EPSILON1
               || fabs(ms_delta - 300000) < CONST_EPSILON1)
        return 5;
    else if (fabs(ms_delta - 30000) < CONST_EPSILON1 || fabs(ms_delta - 1800000) < CONST_EPSILON1)
        return 3;
    else 
        return 10;
}

long ms_delta_to_smallest_zoom_factor(t_notation_obj *r_ob, double ms_delta){
/*    if (fabs(ms_delta - 60000) < CONST_EPSILON1 || fabs(ms_delta - 3600000) < CONST_EPSILON1) {
        return 6;
    } else 
        return 10;*/

    if (fabs(ms_delta - 10) < CONST_EPSILON1 || fabs(ms_delta - 100) < CONST_EPSILON1 || fabs(ms_delta - 1000) < CONST_EPSILON1 || fabs(ms_delta - 10000) < CONST_EPSILON1
        || fabs(ms_delta - 60000) < CONST_EPSILON1 || fabs(ms_delta - 600000) < CONST_EPSILON1 || fabs(ms_delta - 3600000) < CONST_EPSILON1)
        return 2;
    else if (fabs(ms_delta - 5) < CONST_EPSILON1 || fabs(ms_delta - 50) < CONST_EPSILON1 || fabs(ms_delta - 500) < CONST_EPSILON1 || fabs(ms_delta - 5000) < CONST_EPSILON1
             || fabs(ms_delta - 300000) < CONST_EPSILON1)
        return 5;
    else if (fabs(ms_delta - 30000) < CONST_EPSILON1 || fabs(ms_delta - 1800000) < CONST_EPSILON1)
        return 3;
    else 
        return 10;

}

long ms_delta_to_biggest_zoom_factor(t_notation_obj *r_ob, double ms_delta){
/*    if (fabs(ms_delta - 10000) < CONST_EPSILON1 || fabs(ms_delta - 6000000) < CONST_EPSILON1) {
        return 6;
    } else 
        return 10;*/
    
    if (fabs(ms_delta - 1) < CONST_EPSILON1 || fabs(ms_delta - 10) < CONST_EPSILON1 || fabs(ms_delta - 100) < CONST_EPSILON1 || 
        fabs(ms_delta - 1000) < CONST_EPSILON1 || fabs(ms_delta - 60000) < CONST_EPSILON1)
        return 5;
    else if (fabs(ms_delta - 5) < CONST_EPSILON1 || fabs(ms_delta - 50) < CONST_EPSILON1 || fabs(ms_delta - 500) < CONST_EPSILON1 || fabs(ms_delta - 5000) < CONST_EPSILON1
             || fabs(ms_delta - 30000) < CONST_EPSILON1 || fabs(ms_delta - 1800000) < CONST_EPSILON1)
        return 2;
    else if (fabs(ms_delta - 10000) < CONST_EPSILON1 || fabs(ms_delta - 300000) < CONST_EPSILON1)
        return 3;
    else 
        return 10;
    
}


void paint_ruler_and_grid_for_roll(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect){
    if (r_ob->ruler > 0 || r_ob->show_grid) {
        double actwidth = graphic_rect.width - r_ob->j_inset_x - r_ob->postdomain_width + 1; // +1 is a little pad to account for equality
        double pixel_delta = 0; 
        double ms_delta = r_ob->grid_step_ms;
        double ms_delta_sub = r_ob->grid_step_ms;
        double start_ms = r_ob->grid_step_ms * (round(r_ob->screen_ms_start / r_ob->grid_step_ms) - 1);
        double start_x = onset_to_xposition_roll(r_ob, start_ms, NULL);
        double pix; 
        long i; 
        double ms;
        
        if (start_x != start_x) start_x = 0; // start_x was NaN
        
        long num_subdivisions = r_ob->grid_subdivisions;
        double bottom_y = (r_ob->need_hscrollbar && r_ob->show_hscrollbar) ? graphic_rect.height - (CONST_XSCROLLBAR_UHEIGHT + CONST_XSCROLLBAR_WHITE_UPAD_UPON + 2) * r_ob->zoom_y : graphic_rect.height;
        char only_divisions = false; double pix_delta_forsubdivisions;
        long number_of_labels = 0, label_step = 1, number_of_divisions_in_window, div;
        long tick_offset = 0;
        
        if (num_subdivisions <= 0) 
            num_subdivisions = 1;
        
        pixel_delta = (onset_to_xposition_roll(r_ob, ms_delta, NULL) - onset_to_xposition_roll(r_ob, 0, NULL));
        
        if (pixel_delta < 0)
            return;
        
        pix_delta_forsubdivisions = pixel_delta / num_subdivisions;
        if (r_ob->ruler_mode == 1){
            // intelligent ruler
            // best representation: pix_delta must be around CONST_OPTIMAL_PIXEL_DELTA_FOR_RULER_BIG_TICKS  
            
            double ms_delta_optimum = CONST_OPTIMAL_PIXEL_DELTA_FOR_RULER_BIG_TICKS / (r_ob->zoom_y * CONST_X_SCALING * r_ob->zoom_x);
            ms_delta = best_scale_ms(r_ob, ms_delta_optimum);
            pixel_delta = ms_delta * r_ob->zoom_y * CONST_X_SCALING * r_ob->zoom_x;
            num_subdivisions = ms_delta_to_num_subdivisions(r_ob, ms_delta);

            ms_delta_sub = ms_delta / num_subdivisions;
            pix_delta_forsubdivisions = pixel_delta / num_subdivisions;
            
            start_ms = floor(start_ms/ms_delta) * ms_delta;
            start_x = onset_to_xposition_roll(r_ob, start_ms, NULL);
            
            tick_offset = start_ms/ms_delta - floor(start_ms/ms_delta);

        } else {
            if (pix_delta_forsubdivisions < CONST_RULER_MINIMUM_DELTA_PIXEL_FOR_SUBDIVISIONS_TICKS) {
                only_divisions = true;
                ms_delta_sub = ms_delta;
                pix_delta_forsubdivisions = pixel_delta;
            } else {
                only_divisions = false;
                ms_delta_sub = ms_delta / num_subdivisions;
            }
        }
        
        r_ob->current_first_grid_ms = start_ms;
        r_ob->current_grid_subdivision_ms = ms_delta_sub;
        r_ob->current_num_grid_subdivisions = num_subdivisions;
        
        // lines
        double prev_pix = -10000000;
        long count = 0;
        long ms_limit = MAX(1000000, r_ob->length_ms);
        for (pix = start_x, i = tick_offset, ms = start_ms; pix <= actwidth && ms < ms_limit; pix += pix_delta_forsubdivisions, ms += ms_delta_sub, i++){
            
            if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
                pix = onset_to_xposition_roll(r_ob, ms, NULL);
                if (prev_pix == pix) count++; else count = 0;
                if (count > 100) break;
                if (pix != pix) { pix = prev_pix; continue; } // NaN
            }

            if (!r_ob->fade_predomain && ms + CONST_EPSILON_DOUBLE_EQ < r_ob->screen_ms_start)
                continue;

            if (pix < 0)
                continue;
            
            if (only_divisions || i % num_subdivisions == 0) { // main division
                if (r_ob->show_grid)
                    paint_line(g, r_ob->j_main_grid_rgba, pix, 0, pix, bottom_y, 1.);
                if (r_ob->ruler == 1 || r_ob->ruler == 3) // ruler above
                    paint_line(g, r_ob->j_ruler_rgba, pix, 0, pix, CONST_RULER_MAIN_TICKS_UHEIGHT * r_ob->zoom_y, 1.);
                if (r_ob->ruler == 2 || r_ob->ruler == 3) // ruler below
                    paint_line(g, r_ob->j_ruler_rgba, pix, bottom_y - CONST_RULER_MAIN_TICKS_UHEIGHT * r_ob->zoom_y, pix, bottom_y, 1.);
            } else { // subdivision
                if (r_ob->show_grid)
                    paint_line(g, r_ob->j_subdivision_grid_rgba, pix, 0, pix, bottom_y, 1.);
                if (r_ob->ruler == 1 || r_ob->ruler == 3) // ruler above
                    paint_line(g, r_ob->j_ruler_rgba, pix, 0, pix, CONST_RULER_SECONDARY_TICKS_UHEIGHT * r_ob->zoom_y, 1.);
                if (r_ob->ruler == 2 || r_ob->ruler == 3) // ruler below
                    paint_line(g, r_ob->j_ruler_rgba, pix, bottom_y - CONST_RULER_SECONDARY_TICKS_UHEIGHT * r_ob->zoom_y, pix, bottom_y, 1.);
            }
            
            prev_pix = pix;
        }
        
        // labels
        if (r_ob->ruler_mode == 1){
            label_step = 1;
        } else {
            number_of_labels = round(actwidth/(100 * r_ob->zoom_y));
            number_of_divisions_in_window = round((r_ob->screen_ms_end - r_ob->screen_ms_start)/r_ob->grid_step_ms);
            label_step = floor(((double) number_of_divisions_in_window) / number_of_labels);
            if (label_step <= 0) 
                label_step = 1;
        }
        
        if (r_ob->show_ruler_labels) {
            double prev_pix = -10000000;
            long count = 0;
            for (ms = start_ms, pix = start_x, i = tick_offset, div = 0; pix <= actwidth && ms < ms_limit; pix += pix_delta_forsubdivisions, ms += ms_delta_sub, i++){

                if (!r_ob->fade_predomain && ms + CONST_EPSILON_DOUBLE_EQ < r_ob->screen_ms_start)
                    continue;
                
                if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
                    pix = onset_to_xposition_roll(r_ob, ms, NULL);
                    if (prev_pix == pix) count++; else count = 0;
                    if (count > 100) break;
                    if (pix != pix) { pix = prev_pix; continue; } // NaN
                }
                if (only_divisions || i % num_subdivisions == 0) { // main division
                    if (r_ob->ruler == 1 || r_ob->ruler == 3) { // ruler above
                        if ((div + 1) % label_step == 0)
                            paint_label_for_ruler(r_ob, g, ms, pix, CONST_RULER_MAIN_TICKS_UHEIGHT * r_ob->zoom_y, 1);
                    }
                    if (r_ob->ruler == 2 || r_ob->ruler == 3) { // ruler below
                        if ((div + 1) % label_step == 0)
                            paint_label_for_ruler(r_ob, g, ms, pix, bottom_y - CONST_RULER_MAIN_TICKS_UHEIGHT * r_ob->zoom_y, -1);
                    }
                    div++;
                }
                prev_pix = pix;
            }
        }
    }
}

char is_in_linear_edit_mode(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if (r_ob->notation_cursor.voice)
            return 1;
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (r_ob->notation_cursor.measure)
            return 1;
    }
    return 0;
}


void update_all_accidentals_for_voice_if_needed(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        switch (r_ob->show_accidentals_preferences) {
            case k_SHOW_ACC_ALL:
            case k_SHOW_ACC_NONE:
            case k_SHOW_ACC_CLASSICAL:
            case k_SHOW_ACC_ALLALTERED_NONATURALS:
                // nothing to do;
                return;
                
            default:
            {
                t_chord *chord;
                t_note *note;
                for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord)) {
                    char changed = false;
                    for (note = chord->firstnote; note; note = note->next) {
                        note->show_accidental = true;
                        changed = true;
                    }
                    chord->need_recompute_parameters |= changed;
                }
            }
                break;
        }
    }
}


void update_all_accidentals_for_chord_if_needed(t_notation_obj *r_ob, t_chord *chord)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        update_all_accidentals_for_voice_if_needed(r_ob, (t_voice *)chord->voiceparent);
}


void update_all_accidentals_if_needed(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_voice *voice;
        
        if (r_ob->show_accidentals_preferences == 0)
            return;
        
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
            update_all_accidentals_for_voice_if_needed(r_ob, voice);
    }
}




void update_hscrollbar_and_paint_it_if_needed(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect){

    if (r_ob->is_editing_type == k_NONE && !is_in_linear_edit_mode(r_ob))
        update_hscrollbar(r_ob, r_ob->lambda_spacing != k_CUSTOMSPACING_NONE ? 1 : 2);

    if (r_ob->need_hscrollbar && r_ob->show_hscrollbar){ // there is a scrollbar to show
        double middle_x, middle_y, scrollbar_start_x, scrollbar_start_y, white_scrollbar_bg_start_y, scrollbar_height = CONST_XSCROLLBAR_UHEIGHT * r_ob->zoom_y;

        // scrollbar position
        scrollbar_start_x = round_to_semiinteger(r_ob->hscrollbar_x);
        scrollbar_start_y = round_to_semiinteger(graphic_rect.height - (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y + CONST_XSCROLLBAR_Y_SHIFT);
        white_scrollbar_bg_start_y = scrollbar_start_y - CONST_XSCROLLBAR_WHITE_UPAD_UPON * r_ob->zoom_y;
        
        // bg strip
        paint_filledrectangle(g, r_ob->j_background_rgba, 0., white_scrollbar_bg_start_y, graphic_rect.width, graphic_rect.height - white_scrollbar_bg_start_y);
        
        // paint shadow if needed
        if (r_ob->j_mouse_is_down && (r_ob->j_mousedown_obj_type == k_SCROLLBAR_LEFT_AREA || r_ob->j_mousedown_obj_type == k_SCROLLBAR_RIGHT_AREA))
            paint_filledrectangle(g, build_jrgba(0.9, 0.9, 0.9, 1.), 2 * r_ob->zoom_y, scrollbar_start_y, graphic_rect.width - 4 * r_ob->zoom_y, round(scrollbar_height));
        
        // paint scrollbar
        paint_rectangle_rounded(g, r_ob->j_scrollbar_rgba, 
            add_luminosity(r_ob->j_scrollbar_rgba, 0.5), 
            scrollbar_start_x, scrollbar_start_y,
            round(r_ob->hscrollbar_width), round(scrollbar_height), 1., 1, 1);
        // three lines at the middle of the scrolling bar
        middle_x = r_ob->hscrollbar_x + r_ob->hscrollbar_width/2;
        middle_y = scrollbar_start_y + round(scrollbar_height) / 2.;
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x, middle_y - 0.3 * scrollbar_height, middle_x, middle_y + 0.3 * scrollbar_height, 0.5);
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x-3, middle_y - 0.3 * scrollbar_height, middle_x-3, middle_y + 0.3 * scrollbar_height, 0.5);
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x+3, middle_y - 0.3 * scrollbar_height, middle_x+3, middle_y + 0.3 * scrollbar_height, 0.5);
    }
}

double get_max_vscrollbar_width_or_inset_x(t_notation_obj *r_ob){
    double vscr_width = get_vscrollbar_width(r_ob);
    return MAX(vscr_width, r_ob->j_inset_x);
}

double get_vscrollbar_width(t_notation_obj *r_ob){
    if (r_ob->need_vscrollbar && r_ob->show_vscrollbar) {
        double res = (CONST_YSCROLLBAR_UWIDTH + 2) * r_ob->zoom_y - CONST_YSCROLLBAR_X_SHIFT + CONST_YSCROLLBAR_WHITE_UPAD_LEFT * r_ob->zoom_y;
        return res;
    } else 
        return 0;
}

void update_vscrollbar_and_paint_it_if_needed(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect){
    
    if (r_ob->is_editing_type == k_NONE)
        update_vscrollbar(r_ob, 0);
    
    if (r_ob->need_vscrollbar && r_ob->show_vscrollbar){ // there is a yscrollbar to show
        double middle_x, middle_y, scrollbar_start_x, scrollbar_start_y, white_scrollbar_bg_start_x, scrollbar_width = CONST_YSCROLLBAR_UWIDTH * r_ob->zoom_y;

        // scrollbar position
        scrollbar_start_x = round_to_semiinteger(graphic_rect.width - (CONST_YSCROLLBAR_UWIDTH + 2) * r_ob->zoom_y + CONST_YSCROLLBAR_X_SHIFT);
        scrollbar_start_y = round_to_semiinteger(r_ob->vscrollbar_y);
        white_scrollbar_bg_start_x = scrollbar_start_x - CONST_YSCROLLBAR_WHITE_UPAD_LEFT * r_ob->zoom_y;
        
        // bg strip
        paint_filledrectangle(g, r_ob->j_background_rgba, white_scrollbar_bg_start_x, 0, graphic_rect.width - white_scrollbar_bg_start_x, graphic_rect.height);
        
        // paint shadow if needed
        if (r_ob->j_mouse_is_down && (r_ob->j_mousedown_obj_type == k_SCROLLBAR_TOP_AREA || r_ob->j_mousedown_obj_type == k_SCROLLBAR_BOTTOM_AREA))
            paint_filledrectangle(g, build_jrgba(0.9, 0.9, 0.9, 1.), scrollbar_start_x, 2 * r_ob->zoom_y, scrollbar_width, graphic_rect.height - 4 * r_ob->zoom_y);

        // paint scrollbar
        paint_rectangle_rounded(g, r_ob->j_scrollbar_rgba, 
                               add_luminosity(r_ob->j_scrollbar_rgba, 0.5),  
                               scrollbar_start_x, scrollbar_start_y,  
                               round(scrollbar_width), round(r_ob->vscrollbar_height), 1., 1, 1);

        // three lines at the middle of the scrolling bar
        middle_x = scrollbar_start_x + scrollbar_width/2.;
        middle_y = r_ob->vscrollbar_y + r_ob->vscrollbar_height/2;
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x - 0.3 * scrollbar_width, middle_y, middle_x + 0.3 * scrollbar_width, middle_y, 0.5);
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x - 0.3 * scrollbar_width, middle_y + 3, middle_x + 0.3 * scrollbar_width, middle_y + 3, 0.5);
        paint_line(g, r_ob->j_scrollbar_rgba, middle_x - 0.3 * scrollbar_width, middle_y - 3, middle_x + 0.3 * scrollbar_width, middle_y - 3, 0.5);
    }
}

t_jrgba get_default_selection_rectangle_fill_color(){
    t_jrgba selection_interior; 
    selection_interior.red = 0.6; 
    selection_interior.green = 0.8; 
    selection_interior.blue = 1.; 
    selection_interior.alpha = 0.1;
    return selection_interior;
}

t_jrgba get_default_selection_rectangle_border_color(){
    t_jrgba selection_border; 
    selection_border.red = 0.37; 
    selection_border.green = 0.37; 
    selection_border.blue = 0.37; 
    selection_border.alpha = 1.;
    return selection_border;
}

t_jrgba get_default_selection_rectangle_zooming_fill_color(){
    t_jrgba selection_interior; 
    selection_interior.red = 0.9; 
    selection_interior.green = 0.6; 
    selection_interior.blue = 0.6; 
    selection_interior.alpha = 0.1;
    return selection_interior;
}


void paint_selection_rectangle(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba border_color, t_jrgba interior_color){
    // interior
    paint_filledrectangle(g, interior_color, r_ob->j_mousedown_point.x, r_ob->j_mousedown_point.y, r_ob->j_mousedrag_point.x - r_ob->j_mousedown_point.x, r_ob->j_mousedrag_point.y - r_ob->j_mousedown_point.y);
    // line
    paint_strokenrectangle(g, border_color, r_ob->j_mousedown_point.x, r_ob->j_mousedown_point.y, r_ob->j_mousedrag_point.x - r_ob->j_mousedown_point.x, r_ob->j_mousedrag_point.y - r_ob->j_mousedown_point.y, 0.5);
}


e_element_types pt_to_dilation_rectangle_obj(t_notation_obj *r_ob, t_pt pt)
{
    double x1 = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? onset_to_xposition_roll(r_ob, r_ob->dilation_rectangle.left_ms, NULL) : unscaled_xposition_to_xposition(r_ob, r_ob->dilation_rectangle.left_ux));
    double x2 = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? onset_to_xposition_roll(r_ob, r_ob->dilation_rectangle.right_ms, NULL) : unscaled_xposition_to_xposition(r_ob, r_ob->dilation_rectangle.right_ux));
    double y1 = mc_to_yposition(r_ob, r_ob->dilation_rectangle.top_mc, r_ob->dilation_rectangle.top_voice);
    double y2 = mc_to_yposition(r_ob, r_ob->dilation_rectangle.bottom_mc, r_ob->dilation_rectangle.bottom_voice);
    double half_side = CONST_DILATION_RECTANGLE_SQUARES_USIDE * r_ob->zoom_y / 2.;
    double ymiddle = (y1 + y2)/2.;
    double xmiddle = (x1 + x2)/2.;
    if (fabs(pt.y - y1) <= half_side) {
        // y1 is correct
        if (fabs(pt.x - x1) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_TOPLEFT_SQ;
        if (fabs(pt.x - x2) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_TOPRIGHT_SQ;
        if (fabs(pt.x - xmiddle) <= half_side) 
            return k_DILATION_RECTANGLE_TOPMIDDLE_SQ;
    } else if (fabs(pt.y - ymiddle) <= half_side) {
        // ymiddle is correct
        if (fabs(pt.x - x1) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_MIDDLELEFT_SQ;
        if (fabs(pt.x - x2) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_MIDDLERIGHT_SQ;
    } else if (fabs(pt.y - y2) <= half_side) {
        // y2 is correct
        if (fabs(pt.x - x1) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_BOTTOMLEFT_SQ;
        if (fabs(pt.x - x2) <= half_side && r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
            return k_DILATION_RECTANGLE_BOTTOMRIGHT_SQ;
        if (fabs(pt.x - xmiddle) <= half_side) 
            return k_DILATION_RECTANGLE_BOTTOMMIDDLE_SQ;
    }
    
    if (pt.x >= x1 && pt.x <= x2 && pt.y >=y1 && pt.y <= y2)
        return k_DILATION_RECTANGLE_BODY;
    
    return k_NONE;
}


void paint_dilation_rectangle(t_notation_obj *r_ob, t_jgraphics* g){
    t_jrgba black = build_jrgba(0, 0, 0, 1);
    t_jrgba white = build_jrgba(1, 1, 1, 0.3);
    t_jrgba innercolor = build_jrgba(0.93, 0.93, 0.84, 0.3);
    double half_side = CONST_DILATION_RECTANGLE_SQUARES_USIDE * r_ob->zoom_y / 2.;
    double x1 = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? onset_to_xposition_roll(r_ob, r_ob->dilation_rectangle.left_ms, NULL) : unscaled_xposition_to_xposition(r_ob, r_ob->dilation_rectangle.left_ux));
    double x2 = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? onset_to_xposition_roll(r_ob, r_ob->dilation_rectangle.right_ms, NULL) : unscaled_xposition_to_xposition(r_ob, r_ob->dilation_rectangle.right_ux));
    double y1 = mc_to_yposition(r_ob, r_ob->dilation_rectangle.top_mc, r_ob->dilation_rectangle.top_voice);
    double y2 = mc_to_yposition(r_ob, r_ob->dilation_rectangle.bottom_mc, r_ob->dilation_rectangle.bottom_voice);
    paint_rectangle(g, black, innercolor, x1, y1, x2-x1, y2-y1, 0.5);
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
        paint_rectangle(g, black, white, x1 - half_side, y1 - half_side, 2 * half_side, 2 * half_side, 0.5);
        paint_rectangle(g, black, white, x2 - half_side, y1 - half_side, 2 * half_side, 2 * half_side, 0.5);
        paint_rectangle(g, black, white, x2 - half_side, y2 - half_side, 2 * half_side, 2 * half_side, 0.5);
        paint_rectangle(g, black, white, x1 - half_side, y2 - half_side, 2 * half_side, 2 * half_side, 0.5);
        paint_rectangle(g, black, white, x1 - half_side, (y1 + y2)/2 - half_side, 2 * half_side, 2 * half_side, 0.5);
        paint_rectangle(g, black, white, x2 - half_side, (y1 + y2)/2 - half_side, 2 * half_side, 2 * half_side, 0.5);
    }
    paint_rectangle(g, black, white, (x1 + x2)/2 - half_side, y1 - half_side, 2 * half_side, 2 * half_side, 0.5);
    paint_rectangle(g, black, white, (x1 + x2)/2 - half_side, y2 - half_side, 2 * half_side, 2 * half_side, 0.5);
}


t_rational denominator_to_natural_tuplet_ratio(long denominator) {
    long perfectlog2 = perfect_log2(denominator);
    if (perfectlog2 >= 0)
        return genrat(1,1);
    else
        return genrat(round(pow(2, floor(log2(denominator)))), denominator);
}

void paint_small_note(t_notation_obj *r_ob,  t_jgraphics* g, t_jrgba color, t_rational duration, 
                        double x_pos, double y_pos, double ratio, double *width) 
{
// ratio is with respect to the base pt size. fills *width with the width of the figure.
    
    // debug lines:
    //paint_line(r_ob, g, r_ob->j_selection_rgba, x_pos - 20, y_pos, x_pos + 20, y_pos, CONST_STEM_WIDTH * ratio);
    //paint_line(r_ob, g, r_ob->j_selection_rgba, x_pos, y_pos  - 20, x_pos, y_pos + 20, CONST_STEM_WIDTH * ratio);

    t_rational natural_ratio = denominator_to_natural_tuplet_ratio(duration.r_den);
    t_rational nontuplet_duration = rat_rat_div(duration, natural_ratio);
    t_jfont *jf, *jf_tuplets;
    t_llllelem *elem;
    double x_offset, first_note_x;
    long tuplet_number = natural_ratio.r_den;
    
    t_llll *drawablellll = get_duration_drawable (nontuplet_duration, long2rat(0), long2rat(1), r_ob->max_dots, 1, true);
//    while (drawablellll->l_depth > 1) llll_flat(drawablellll, 1, 1, 0);
    llll_flatten(drawablellll, 0, 0);
    // we filter the zeros (and the negatives, which - in turn - should never appear)
    llll_filter_zeros_and_negatives(drawablellll);
    // we try to gather things
    llll_gather_if_drawable(drawablellll, r_ob->max_dots);

    *width = 0.;
    jf = jfont_create_debug(r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, ratio * r_ob->notation_typo_preferences.base_pt * r_ob->zoom_y);
    jf_tuplets = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, ratio * round(8.5 * r_ob->zoom_y)); 
    elem = drawablellll->l_head;
    x_offset = 0.; first_note_x = -1.;
    while (elem) {
        double notewidth, stem_x, adj_stem_x, stem_adj_x, stem_top;
        unicodeChar notehead_char;
        t_rational figure; char num_dots; // getting this figure
        char noteheadchars[15]; 
        long noteheadchars_len;
        char *noteheadchars_utf;
        char j;
        double dot_x_offset, dot_y;
        double note_x, note_y;

        is_duration_drawable(r_ob, hatom_getrational(&elem->l_hatom), &figure, &num_dots);

        
        notehead_char = get_notehead_unicode_character(r_ob, figure, &notewidth);
        stem_x = x_pos + notewidth * r_ob->zoom_y * ratio + x_offset;
        adj_stem_x = round(stem_x + 0.5) - 0.5;
        stem_adj_x = adj_stem_x-stem_x; 
        stem_top = y_pos - 18 * r_ob->zoom_y * ratio;
        
        // draw stem if needed
        if (rat_rat_cmp(figure, RAT_1OVER2) <= 0)  // the figure is <= 1/2: we need the stem
            paint_line(g, color, adj_stem_x, y_pos, adj_stem_x, stem_top, CONST_STEM_WIDTH * ratio);

        *width += notewidth * r_ob->zoom_y * ratio * 1.2;
        
        // draw tuplet number if needed
        if (tuplet_number > 1) {
            char text[35]; 
            snprintf_zero(text, 35, "%ld", tuplet_number);  
            write_text_standard_account_for_vinset_singleline(r_ob, g, jf_tuplets, color, text, stem_x - notewidth, stem_top - 8.2 * r_ob->zoom_y);
        }
            
        // draw noteflag
        if (rat_rat_cmp(figure, RAT_1OVER8) <= 0) {
            char firsttailcharacter[5]; 
            char followingtailcharacter[5]; 
            char *followingtailcharacter_utf;
            long outlen;
            char i;
            double flag_x;
            char howmanyflags = perfect_log2(rat_rat_div(RAT_1OVER8, figure).r_num) + 1;
            double firstshift_y, secondshift_y, nextstep_y; 
            if (howmanyflags >= 2) {
                char *firsttailcharacter_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.flag_unicode_characters[2], 1, &outlen);
                strncpy(firsttailcharacter, firsttailcharacter_utf, 4);
                bach_freeptr(firsttailcharacter_utf);
                firstshift_y = stem_top + r_ob->notation_typo_preferences.flag_uy_shifts[2] * r_ob->zoom_y * ratio;
                secondshift_y = stem_top + r_ob->notation_typo_preferences.flag_uy_shifts[4] * r_ob->zoom_y * ratio;
            } else {    
                char *firsttailcharacter_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.flag_unicode_characters[0], 1, &outlen);
                strncpy(firsttailcharacter, firsttailcharacter_utf, 4);
                bach_freeptr(firsttailcharacter_utf);
                firstshift_y = stem_top + r_ob->notation_typo_preferences.flag_uy_shifts[0] * r_ob->zoom_y * ratio;
                secondshift_y = stem_top + r_ob->notation_typo_preferences.flag_uy_shifts[4] * r_ob->zoom_y * ratio;
            }
            followingtailcharacter_utf = charset_unicodetoutf8_debug(&r_ob->notation_typo_preferences.flag_unicode_characters[4], 1, &outlen);
            strncpy(followingtailcharacter, followingtailcharacter_utf, 4);
            bach_freeptr(followingtailcharacter_utf);
            nextstep_y = - r_ob->notation_typo_preferences.further_flag_uy_step_stemup * r_ob->zoom_y * ratio;
            
            flag_x = adj_stem_x - 0.5 * ratio + r_ob->notation_typo_preferences.flag_ux_shift * r_ob->zoom_y;
            if (howmanyflags > 0) 
                *width += notewidth * 0.6;
            
            for (i = 0; i < howmanyflags; i++) {
                // paint a note flag
                int j = (howmanyflags >= 2) ? ((i > 0) ? 4 : 2) : 0;
                double this_flag_x = (r_ob->notation_typo_preferences.flag_noteheadaligned[j] == 1) ? 
                flag_x - notewidth * r_ob->zoom_y * ratio + 1.45 : flag_x; 
                write_text_standard_account_for_vinset_singleline(r_ob, g, jf, color,
                                       (i == 0) ? firsttailcharacter : followingtailcharacter, this_flag_x, 
                                       (i == 0) ? firstshift_y : secondshift_y - (i - 2) * nextstep_y);
                if (i == 0) i++; // we skip the 1/16 flag: we've already drawn that
            }
        }
        
        // draw the notehead
        double small_ux_shift, small_uy_shift;
        get_notehead_specs_from_rdur(r_ob, duration, NULL, NULL, NULL, NULL, &small_ux_shift, &small_uy_shift, NULL);
        note_x = x_pos + x_offset + small_ux_shift * r_ob->zoom_y * ratio;
        if (first_note_x == -1) first_note_x = note_x;
        note_y = y_pos - 30.2 * r_ob->zoom_y * ratio - small_uy_shift * r_ob->zoom_y * ratio; // to be calibrated
        noteheadchars_utf = charset_unicodetoutf8_debug(&notehead_char, 1, &noteheadchars_len);
        strncpy(noteheadchars, noteheadchars_utf, 14);
        bach_freeptr(noteheadchars_utf);
        write_text_standard_account_for_vinset_singleline(r_ob, g, jf, color, noteheadchars, note_x + stem_adj_x, note_y);
        
        // draw dot(s) if needed
        dot_x_offset = 1.5 * notewidth * r_ob->zoom_y * ratio;
        dot_y = y_pos - 28.6 * r_ob->zoom_y * ratio;
        for (j=0; j<num_dots; j++) {
            unicodeChar dot_char = r_ob->notation_typo_preferences.dot_unicode_character;
            char dot_txt[5];
            long dot_utf_len;
            char *dot_utf = charset_unicodetoutf8_debug(&dot_char, 1, &dot_utf_len);
            strncpy(dot_txt, dot_utf, 4);
            bach_freeptr(dot_utf);

            write_text_standard_account_for_vinset_singleline(r_ob, g, jf, color, dot_txt, note_x + dot_x_offset, dot_y);
            dot_x_offset += CONST_DOT_DOT_USEPARATION * r_ob->zoom_y * ratio;
            if (*width < note_x + dot_x_offset - x_pos) 
                *width = note_x + dot_x_offset - x_pos;
        }
        elem = elem->l_next;
        if (elem) {
            // draw the tie
            *width += 4 * r_ob->zoom_y;
            x_offset = *width;
            paint_tie(r_ob, g, color, note_x + 4 * r_ob->zoom_y, y_pos + 3 * r_ob->zoom_y, first_note_x + x_offset + 0 * r_ob->zoom_y, y_pos + 3 * r_ob->zoom_y, -1);
        }
    }
    jfont_destroy_debug(jf);
    jfont_destroy_debug(jf_tuplets);
    llll_free(drawablellll);
}





// notational calculus

long yposition_to_systemnumber(t_notation_obj *r_ob, double yposition){
    if (r_ob->view == k_VIEW_SCROLL) 
        return 0;
    else {
        long system = 0; long i;
        double system_jump = (r_ob->needed_uheight_for_one_system + CONST_SYSTEM_JUMP_USHIFT) * r_ob->zoom_y;
        for (i=0; i<r_ob->num_systems; i++){
            if (yposition > system_jump * i)
                system = i;
            else 
                break;
        }
        if (system < 0) system = 0; 
        if (system > r_ob->num_systems) system = r_ob->num_systems;
        return system;
    }
}

double get_ux_left_start(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL || r_ob->spacing_type == k_SPACING_PROPORTIONAL)
        return CONST_ROLL_UX_LEFT_START * r_ob->show_clefs;
    else
        return CONST_SCORE_UX_LEFT_START * r_ob->show_clefs;
}

// for roll only!
double onset_to_xposition_roll(t_notation_obj *r_ob, double onset, long *system)
{
    long this_system;
    double res = 0;
    if (system) {
        if (*system < 0)
            *system = onset_to_system_index(r_ob, onset);
        this_system = *system;
    } else
        this_system = 0;
    
    if (r_ob->view == k_VIEW_SCROLL)
        res = r_ob->zoom_y * (get_ux_left_start(r_ob) + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad + (onset - r_ob->screen_ms_start) * CONST_X_SCALING * r_ob->zoom_x) + r_ob->j_inset_x;
    else
        res = r_ob->zoom_y * (get_ux_left_start(r_ob) + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad + (onset - this_system * r_ob->ms_on_a_line) * CONST_X_SCALING * r_ob->zoom_x) + r_ob->j_inset_x;
    
    if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
        t_llll *ll = llll_get();
        r_ob->lambda_val = res;
        llll_appendsym(ll, gensym("timetopixel"), 0, WHITENULL_llll);
        llll_appenddouble(ll, onset, 0, WHITENULL_llll);
        llllobj_outlet_llll((t_object *)r_ob, LLLL_OBJ_UI, r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 6 : 7, ll);
        llll_free(ll);
        if (r_ob->lambda_spacing == k_CUSTOMSPACING_PIXELFROMSTART)
            res = unscaled_xposition_to_xposition(r_ob, r_ob->lambda_val);
        else
            res = r_ob->lambda_val; // new pixel
    }
        
    return res;
}


double get_domain_width_pixels(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return deltaonset_to_deltaxpixels(r_ob, r_ob->domain);
    else
        return deltauxpixels_to_deltaxpixels(r_ob, r_ob->domain_ux);
}

double get_predomain_width_pixels(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return onset_to_xposition_roll(r_ob, r_ob->screen_ms_start, NULL);
    else
        return unscaled_xposition_to_xposition(r_ob, r_ob->screen_ux_start);
}

double xposition_to_onset(t_notation_obj *r_ob, double xposition, long system)
{
    double res = system * r_ob->ms_on_a_line + r_ob->screen_ms_start +
                (((xposition - r_ob->j_inset_x) / r_ob->zoom_y) - get_ux_left_start(r_ob) - r_ob->key_signature_uwidth - r_ob->voice_names_uwidth - r_ob->additional_ux_start_pad) / (CONST_X_SCALING * r_ob->zoom_x);
    if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
        t_llll *ll = llll_get();
        r_ob->lambda_val = res;

        if (r_ob->lambda_spacing == k_CUSTOMSPACING_PIXELFROMSTART)
            xposition = xposition_to_unscaled_xposition(r_ob, xposition);

        llll_appendsym(ll, gensym("pixeltotime"), 0, WHITENULL_llll);
        llll_appenddouble(ll, xposition, 0, WHITENULL_llll);
        llllobj_outlet_llll((t_object *)r_ob, LLLL_OBJ_UI, r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 6 : 7, ll);
        llll_free(ll);
        res = r_ob->lambda_val; // new time in ms
    }
//    dev_post("xpos: %.1f, system: %ld --> onset: %.1f", xposition, system, res);
    return res;
}

// these two functions function handling delta-**** are only usable in roll, and do not support custom spacing
double deltaxpixels_to_deltaonset(t_notation_obj *r_ob, double deltaxpixels){
    return deltaxpixels / (r_ob->zoom_y * CONST_X_SCALING * r_ob->zoom_x);
}

double deltaonset_to_deltaxpixels(t_notation_obj *r_ob, double deltaonset){
    return deltaonset * (r_ob->zoom_y * CONST_X_SCALING * r_ob->zoom_x);
}


// mostly for bach.score, but also used by bach.roll
double unscaled_xposition_to_xposition(t_notation_obj *r_ob, double unscaled_x_pos){
    double const_left_start = get_ux_left_start(r_ob);
    double const_x_scaling = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 1. : CONST_X_SCALING_SCORE);

    return r_ob->j_inset_x + (const_left_start + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad) * r_ob->zoom_y + const_x_scaling * (unscaled_x_pos - r_ob->screen_ux_start) * r_ob->zoom_x * r_ob->zoom_y;
}

double xposition_to_unscaled_xposition(t_notation_obj *r_ob, double x_position){
    double const_left_start = get_ux_left_start(r_ob);
    double const_x_scaling = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 1. : CONST_X_SCALING_SCORE);
    
    return r_ob->screen_ux_start + (x_position - r_ob->j_inset_x - (const_left_start + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad) * r_ob->zoom_y) / (const_x_scaling * r_ob->zoom_x * r_ob->zoom_y);
}

double deltauxpixels_to_deltaxpixels(t_notation_obj *r_ob, double deltauxpixels){
    return deltauxpixels * (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 1. : CONST_X_SCALING_SCORE) * r_ob->zoom_x * r_ob->zoom_y;
}


double deltaxpixels_to_deltauxpixels(t_notation_obj *r_ob, double deltaxpixels){
    return deltaxpixels / ((r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? 1. : CONST_X_SCALING_SCORE) * r_ob->zoom_x * r_ob->zoom_y);
}

// for roll only
double onset_to_unscaled_xposition(t_notation_obj *r_ob, double onset)
{
    if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
        return xposition_to_unscaled_xposition(r_ob, onset_to_xposition_roll(r_ob, onset, NULL));
    } else {
        // THIS BOTTOM LINE IS EQUIVALENT TO xposition_to_unscaled_xposition(r_ob, onset_to_xposition_roll(r_ob, onset, NULL))
        // but of course way faster ;)
        return r_ob->screen_ux_start + ((onset - r_ob->screen_ms_start) * CONST_X_SCALING);
    }
}

// onset-to-xposition, for score
double ms_to_xposition(t_notation_obj *r_ob, double ms, char mode)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        return onset_to_xposition_roll(r_ob, ms, NULL);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        return unscaled_xposition_to_xposition(r_ob, ms_to_unscaled_xposition(r_ob, ms, mode));
    } else
        return 0;
}


double xposition_to_ms(t_notation_obj *r_ob, double xpos, char mode)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        return xposition_to_onset(r_ob, xpos, 0);
        
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        // if mode == 1, the position is computed only BEFORE the next barline.
        return unscaled_xposition_to_ms(r_ob, xposition_to_unscaled_xposition(r_ob, xpos), mode);
    } else
        return 0.;
}

double ms_to_unscaled_xposition(t_notation_obj *r_ob, double ms, char mode)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        return onset_to_unscaled_xposition(r_ob, ms);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        // if mode == 1, the position is computed only BEFORE the next barline.
        // E.g. if one has a 4/4 note and then a 4/4 rest, tempo = 60, t.s. = 4/4, the 3900 ms will not be in the SECOND measure, but at the end of the first one!
        t_chord *left = NULL, *right = NULL; double left_ms = 0, right_ms = 0;
        t_voice *voice;
        t_measure *meas;
        t_chord *chord;
        double left_ux = 0, right_ux = 0;
        char is_left_chord_whole_measure_chord = false, is_right_chord_whole_measure_chord = true;
        if (ms < 0.)
            return 0;
        
        // we try to find two chords who have ms directly < and ms > of our ms
        
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) {
                if (meas->firstchord && right && (meas->firstchord->onset > right_ms))
                    break;
                else {
                    for (chord = meas->firstchord; chord; chord = chord->next) {
                        char is_chord_whole_measure_chord = is_chord_a_whole_measure_rest(r_ob, chord);
                        if (fabs(chord->onset - ms) < CONST_EPSILON_DOUBLE_EQ && !is_chord_whole_measure_chord) {
                            return chord_get_alignment_ux(r_ob, chord); // precise!!!
                        } else if ((chord->onset >= ms) && (!right || (right && (chord->onset < right_ms || (fabs(chord->onset - right_ms) < CONST_EPSILON_DOUBLE_EQ && is_right_chord_whole_measure_chord && !is_chord_whole_measure_chord))))) {
                            right = chord;
                            is_right_chord_whole_measure_chord = is_chord_whole_measure_chord;
                            right_ms = chord->onset;
                            right_ux = is_chord_whole_measure_chord ? right->parent->tuttipoint_reference->offset_ux + right->parent->start_barline_offset_ux : chord_get_alignment_ux(r_ob, right);
                            if (mode == 1 && !right->prev)
                                right_ux = right->parent->tuttipoint_reference->offset_ux + right->parent->start_barline_offset_ux;
                        } else if ((chord->onset >= ms) && right) {
                            break;
                        } else if ((chord->onset <= ms) && (!left || (left && (chord->onset > left_ms || (fabs(chord->onset - left_ms) < CONST_EPSILON_DOUBLE_EQ && is_left_chord_whole_measure_chord && !is_chord_whole_measure_chord))))) {
                            left = chord;
                            is_left_chord_whole_measure_chord = is_chord_whole_measure_chord;
                            left_ms = chord->onset;
                            left_ux = is_chord_whole_measure_chord ? left->parent->tuttipoint_reference->offset_ux + left->parent->start_barline_offset_ux : chord_get_alignment_ux(r_ob, left);
                        }
                    }
                }
            }
        
        if (left && right){
            if (left_ms == right_ms)
                return left_ux;
            else
                return left_ux + (right_ux - left_ux) *    (ms - left_ms) / (right_ms - left_ms);
        } else if (right) {
            if (ms == right_ms || right_ms == 0)
                return right_ux;
            else
                return right_ux * ms / right_ms; // was (right_ms - ms) at the denominator
        } else if (left) {
            double ms_measure_end = left->onset + left->duration_ms;
            if (ms == left_ms)
                return left_ux;
            else if (ms_measure_end == left_ms)
                return left->parent->tuttipoint_reference->offset_ux + left->parent->start_barline_offset_ux + left->parent->width_ux;
            else
                return left_ux + (left->parent->tuttipoint_reference->offset_ux + left->parent->start_barline_offset_ux + left->parent->width_ux - left_ux)
                * (ms - left_ms) / (ms_measure_end - left_ms);
        } else 
            return 0.;
    } else {
        return 0.;
    }
}


double unscaled_xposition_to_ms(t_notation_obj *r_ob, double ux, char mode, char accurate)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        return xposition_to_onset(r_ob, unscaled_xposition_to_xposition(r_ob, ux),0);
        
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        // if mode == 1, the position is computed only BEFORE the next barline.
        // E.g. if one has a 4/4 note and then a 4/4 rest, tempo = 60, t.s. = 4/4, the 3900 ms will not be in the SECOND measure, but at the end of the first one!
        t_chord *left = NULL, *right = NULL; double left_ux = 0, right_ux = 0;
        t_scorevoice *voice; t_measure *meas; t_chord *chord;
        char left_is_emptyrest = false, right_is_emptyrest = false;
        
        if (ux <= 0.)
            return 0;
        
        // we try to find two chords who have unscaled_x directly < and directly > of our ux
        for (voice = (t_scorevoice *)r_ob->firstvoice; voice && voice->v_ob.number < r_ob->num_voices; voice = voice->next) {
            for (meas = voice->firstmeasure; meas; meas = meas->next) {
                if (!meas->tuttipoint_reference)
                    return 0;
                else if (meas->firstchord &&
                         (chord_get_alignment_ux(r_ob, meas->firstchord) > ux) && right &&
                         (!right_is_emptyrest || right->parent->voiceparent == voice) &&
                         (chord_get_alignment_ux(r_ob, meas->firstchord) > right_ux))
                    break;
                else {
                    for (chord = meas->firstchord; chord; chord = chord->next) {
                        double this_chord_align_pt_ux = is_measure_single_whole_rest(r_ob, meas) ? meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux : chord_get_alignment_ux(r_ob, chord);
                        if (this_chord_align_pt_ux == ux) {
                            return chord->onset; // precise!!!
                        } else if (this_chord_align_pt_ux > ux &&
                                   (!right || (right_is_emptyrest && chord_get_onset_ms(chord) <= chord_get_onset_ms(right) + CONST_EPSILON1)
                                    || (this_chord_align_pt_ux < right_ux))) {
                                       right_is_emptyrest = is_measure_single_whole_rest(r_ob, meas);
                                       right = chord;
                                       right_ux = this_chord_align_pt_ux;
                                       if (mode == 1 && !right->prev)
                                           right_ux = meas->tuttipoint_reference->offset_ux + chord->parent->start_barline_offset_ux;
                                   } else if ((this_chord_align_pt_ux > ux) && right) {
                                       break;
                                   } else if (this_chord_align_pt_ux < ux &&
                                              (!left || (left_is_emptyrest && chord_get_onset_ms(chord) >= chord_get_onset_ms(left) - CONST_EPSILON1)
                                               || (left && (this_chord_align_pt_ux > left_ux)))) {
                                                  left_is_emptyrest = is_measure_single_whole_rest(r_ob, meas);
                                                  left = chord;
                                                  left_ux = this_chord_align_pt_ux;
                                              }
                    }
                }
            }
        }
        
        //    if (right_is_emptyrest)
        //        right = NULL;
        
        if (left && right){
            double left_onset = accurate ? notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)left) : left->onset;
            double right_onset = accurate ? notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)right) : right->onset;
            if (left_ux == right_ux)
                return left_onset;
            else
                return left_onset + (right_onset - left_onset) * (MIN(ux, right_ux) - left_ux)/(right_ux - left_ux);
        } else if (right) {
            double right_onset = accurate ? notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)right) : right->onset;
            if (ux == right_ux || right_ux == 0)
                return right_onset;
            else
                return right_onset * MIN(ux, right_ux) / right_ux; // was (right_ux - ux) at the denominator
        } else if (left) {
            double left_onset = accurate ? notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)left) : left->onset;
            double left_duration = accurate ? notation_item_get_duration_ms_accurate(r_ob, (t_notation_item *)left) : left->duration_ms;
            double ux_measure_end = left->parent->tuttipoint_reference->offset_ux + left->parent->start_barline_offset_ux + left->parent->width_ux;
            if (ux == left_ux)
                return left_onset;
            else if (ux_measure_end == left_ux)
                return left_onset + left_duration;
            else
                return left_onset + left_duration * (ux - left_ux) / (ux_measure_end - left_ux);
        } else 
            return 0.;
    } else
        return 0.;
}





double timepoint_to_ms(t_notation_obj *r_ob, t_timepoint tp, long voicenum)
{
    t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voicenum);
    t_measure *this_meas;
    t_timepoint tp0;
    
    if (!voice)
        return 0;
    
    this_meas = nth_measure_of_scorevoice(voice, tp.measure_num);
    
    if (!this_meas || !this_meas->tuttipoint_reference) {
        if (tp.measure_num >= voice->num_measures && voice->num_measures > 0 && voice->lastmeasure && voice->lastmeasure->tuttipoint_reference)
            return voice->lastmeasure->tuttipoint_reference->onset_ms + voice->lastmeasure->tuttipoint_onset_ms + voice->lastmeasure->total_duration_ms;
        else
            return 0;
    }
    
    tp0 = build_timepoint(this_meas->measure_number, long2rat(0));
    return 1000 * rat2double(get_rat_durations_sec_between_timepoints(r_ob, voice, tp0, tp)) + this_meas->tuttipoint_onset_ms + this_meas->tuttipoint_reference->onset_ms;
}

// on all voices: COULD BE DONE MUUUUUUUCH BETTER AND FASTER!!!!!!
t_timepoint ms_to_timepoint_autochoose_voice(t_notation_obj *r_ob, double ms, char mode, long *chosen_voice)
{
    long i;
    double min_diff = 0;
    t_timepoint best_tp = build_timepoint_with_voice(0, long2rat(0), 0);
    long best_i = -1;
    for (i = 0; i < r_ob->num_voices; i++){
        t_timepoint tp = ms_to_timepoint(r_ob, ms, i, mode);
        double this_ms = timepoint_to_ms(r_ob, tp, i);
        double diff = fabs(this_ms - ms);
        if (best_i < 0 || diff < min_diff) {
            min_diff = diff;
            best_i = i;
            best_tp = tp;
        }
    }
    if (chosen_voice)
        *chosen_voice = best_i;
    return best_tp;
}

// mode is one of the e_ms_to_tp_modes
t_timepoint ms_to_timepoint(t_notation_obj *r_ob, double ms, long voicenum, char mode)
{
    t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voicenum);
    t_measure *this_meas = NULL, *tmp_meas;
    
    if (voice && voice->firstmeasure) {
        
        tmp_meas = voice->firstmeasure;
        if (ms <= 0)
            return build_timepoint_with_voice(0, long2rat(0), voicenum);
        
        while (tmp_meas && tmp_meas->tuttipoint_reference) {
            if (ms/1000. <= rat2double(tmp_meas->tuttipoint_reference->r_onset_sec) + rat2double(tmp_meas->r_tuttipoint_onset_sec) + rat2double(tmp_meas->r_total_duration_sec) + CONST_EPSILON_SELECT) {
                this_meas = tmp_meas;
                break;
            }
            tmp_meas = tmp_meas->next;
        }
        
        if (this_meas && this_meas->tuttipoint_reference) {
            t_chord *tmp_chord = this_meas->firstchord;
            if (!this_meas->firstchord)
                return build_timepoint_with_voice(this_meas->measure_number, long2rat(0), voicenum);
            if (ms <= this_meas->firstchord->onset + CONST_EPSILON_SELECT)
                return build_timepoint_with_voice(this_meas->measure_number, long2rat(0), voicenum);
            while (tmp_chord) {
                double next_chord_onset = (tmp_chord->next) ? tmp_chord->next->onset : 1000.*(rat2double(this_meas->tuttipoint_reference->r_onset_sec) + rat2double(this_meas->r_tuttipoint_onset_sec) + rat2double(this_meas->r_total_duration_sec));
                t_rational this_chord_pim = tmp_chord->r_sym_onset;
                t_rational next_chord_pim = (tmp_chord->next) ? tmp_chord->next->r_sym_onset : measure_get_sym_duration(this_meas);
                if (fabs(ms - next_chord_onset) < CONST_EPSILON_SELECT)
                    return (tmp_chord->next || !this_meas->next) ? build_timepoint_with_voice(this_meas->measure_number, next_chord_pim, voicenum) : build_timepoint_with_voice(this_meas->next->measure_number, long2rat(0), voicenum);
                else if (ms < next_chord_onset) {
                    t_timepoint res;
                    if (mode == k_MS_TO_TP_RETURN_LEFT_CHORD)
                        res = build_timepoint_with_voice(this_meas->measure_number, this_chord_pim, voicenum);
                    else if (mode == k_MS_TO_TP_RETURN_RIGHT_CHORD)
                        res = (tmp_chord->next || !this_meas->next) ? build_timepoint_with_voice(this_meas->measure_number, next_chord_pim, voicenum) : build_timepoint_with_voice(this_meas->next->measure_number, long2rat(0), voicenum);
                    else if (mode == k_MS_TO_TP_RETURN_NEAREST){
                        double prev_chord_onset = tmp_chord->onset;
                        if (fabs(ms - prev_chord_onset) < fabs(ms - next_chord_onset))
                            res = build_timepoint_with_voice(this_meas->measure_number, this_chord_pim, voicenum);
                        else
                            res = build_timepoint_with_voice(this_meas->measure_number, next_chord_pim, voicenum);
                    } else if (mode == k_MS_TO_TP_RETURN_INTERPOLATION){
                        t_timepoint left = build_timepoint(this_meas->measure_number, this_chord_pim);
                        t_timepoint right = build_timepoint(this_meas->measure_number, next_chord_pim);
                        double prev_chord_onset = tmp_chord->onset;
                        res = interpolate_timepoints(left, right, (ms - prev_chord_onset)/(next_chord_onset - prev_chord_onset));
                        res.voice_num = voicenum;
                    }
                    if (this_meas->next && rat_rat_cmp(res.pt_in_measure, measure_get_sym_duration(this_meas)) >= 0) {
                        res.measure_num ++;
                        res.pt_in_measure = long2rat(0);
                    }
                    
                    return res;
                }
                tmp_chord = tmp_chord->next;
            }
            
            if (this_meas->next)
                return build_timepoint_with_voice(this_meas->next->measure_number, long2rat(0), voicenum);
            
            return build_timepoint_with_voice(this_meas->measure_number, measure_get_sym_duration(this_meas), voicenum);
        }
        
        return build_timepoint_with_voice(voice->lastmeasure->measure_number, measure_get_sym_duration(voice->lastmeasure), voicenum);
    }
    
    return build_timepoint_with_voice(0, long2rat(0), voicenum);
}

t_timepoint rat_sec_to_timepoint(t_notation_obj *r_ob, t_rational rat_sec, long voicenum)
{
    t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voicenum);
    t_measure *this_meas = NULL, *tmp_meas = voice->firstmeasure;
    if (rat_sec.r_num <= 0)
        return build_timepoint(0, long2rat(0));
    
    while (tmp_meas) {
        if (rat_rat_cmp(rat_sec, measure_get_overall_rat_onset_sec_plus_duration(tmp_meas)) <= 0) {
            this_meas = tmp_meas;
            break;
        }
        tmp_meas = tmp_meas->next;
    }
    
    if (this_meas) {
        t_chord *tmp_chord = this_meas->firstchord;
        if (!this_meas->firstchord) return build_timepoint(this_meas->measure_number, long2rat(0));
        if (rat_rat_cmp(rat_sec, chord_get_overall_rat_onset_sec(this_meas->firstchord)) <= 0)
            return build_timepoint(this_meas->measure_number, long2rat(0));
        while (tmp_chord) {
            t_rational this_chord_r_onset_sec = chord_get_overall_rat_onset_sec(tmp_chord);
            t_rational next_chord_r_onset_sec = tmp_chord->next ? chord_get_overall_rat_onset_sec(tmp_chord->next) : measure_get_overall_rat_onset_sec_plus_duration(this_meas);
            t_rational this_chord_pim = tmp_chord->r_sym_onset;
            t_rational next_chord_pim = (tmp_chord->next) ? tmp_chord->next->r_sym_onset : measure_get_sym_duration(this_meas);
            
            if (rat_rat_cmp(rat_sec, next_chord_r_onset_sec) < 0) 
                return build_timepoint(this_meas->measure_number, rat_rescale(rat_sec, this_chord_r_onset_sec, next_chord_r_onset_sec, this_chord_pim, next_chord_pim));
            
            // this should work well as long as there are no tempo changes between this_chord and next_chord!
            // TO DO: handle the tempi change case!!!
            
            tmp_chord = tmp_chord->next;
        }
        
        if (this_meas->next)
            return build_timepoint(this_meas->next->measure_number, long2rat(0));
        
        return build_timepoint(this_meas->measure_number, measure_get_sym_duration(this_meas));
    }
    
    return build_timepoint(voice->lastmeasure->measure_number, measure_get_sym_duration(voice->lastmeasure));
}


// A hack, because the <lasttuttipoint> field is in the t_score structure, and NOT in the t_notation_obj,
// and we do need the last tuttipoint somewhere in this more abstract layer
t_tuttipoint *tuttipoint_get_last_from_measures(t_notation_obj *r_ob)
{
    double min_offset_ux = -1;
    t_tuttipoint *tpt = NULL;
    for (t_voice *voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        t_scorevoice *sv = (t_scorevoice *)voice;
        if (sv && sv->lastmeasure && sv->lastmeasure->tuttipoint_reference && sv->lastmeasure->tuttipoint_reference->offset_ux > min_offset_ux) {
            tpt = sv->lastmeasure->tuttipoint_reference;
            min_offset_ux = sv->lastmeasure->tuttipoint_reference->offset_ux;
        }
    }
    return tpt;
}

double timepoint_to_unscaled_xposition(t_notation_obj *r_ob, t_timepoint tp, char sample_all_voices, char zero_pim_is_first_chord)
{
    long voicenum = tp.voice_num;
    t_scorevoice *voice_min = NULL, *voice_max = NULL, *voice;
    t_rational left_pim = long2rat(-1), right_pim = long2rat(-1);
    t_rational pim = tp.pt_in_measure; // point in measure
    t_measure *meas;
    
    double left_ux = 0, right_ux = 0;
    
    if (sample_all_voices) {
        voice_min = (t_scorevoice *)r_ob->firstvoice;
        voice_max = (t_scorevoice *)nth_voice(r_ob, r_ob->num_voices - 1);
    } else {
        voice_min = (t_scorevoice *)nth_voice(r_ob, voicenum);
        voice_max = voice_min;
    }
    for (voice = voice_min; voice && voice->prev != voice_max; voice = voice->next) {
        t_rational total_meas_duration;
        t_chord *chord;
        meas = nth_measure_of_scorevoice(voice, tp.measure_num);
        
        if (!meas || !meas->tuttipoint_reference)
            continue;
        
        total_meas_duration = measure_get_sym_duration(meas);
        
        if (rat_rat_cmp(pim, long2rat(0)) <= 0) {
            if (zero_pim_is_first_chord && meas->firstchord)
                return chord_get_alignment_ux(r_ob, meas->firstchord);
            else
                return meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux;
        }
        if (rat_rat_cmp(pim, total_meas_duration) >= 0)
            return meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux;
        
        for (chord = meas->firstchord; chord; chord = chord->next) {
            char is_chord_whole_rest = is_chord_a_whole_measure_rest(r_ob, chord);
            t_rational thischord_pim = chord->r_sym_onset;
            if (rat_rat_cmp(thischord_pim, pim) <= 0 && !is_chord_whole_rest && (left_pim.r_num < 0 || rat_rat_cmp(left_pim, thischord_pim) < 0)) {
                left_pim = thischord_pim;
                left_ux = chord_get_alignment_ux(r_ob, chord);
            }
            if (rat_rat_cmp(pim, thischord_pim) <= 0 && !is_chord_whole_rest && (right_pim.r_num < 0 || rat_rat_cmp(thischord_pim, right_pim) < 0)) {
                right_pim = thischord_pim;
                right_ux = chord_get_alignment_ux(r_ob, chord);
            }
            if (left_pim.r_num >= 0 && rat_rat_cmp(left_pim, right_pim) == 0)
                return right_ux;
            
        }
    }
    
    if (left_pim.r_num >= 0 && right_pim.r_num >= 0)
        return left_ux + rat2double(rat_rat_div(rat_rat_diff(pim, left_pim), rat_rat_diff(right_pim, left_pim))) * (right_ux - left_ux);
    
    meas = nth_measure_of_scorevoice(voice_min, tp.measure_num);
    if (!meas || !meas->tuttipoint_reference) {
        t_tuttipoint *lasttuttipoint = tuttipoint_get_last_from_measures(r_ob);
        if (lasttuttipoint && tp.measure_num >= 0)
            return lasttuttipoint->offset_ux + lasttuttipoint->width_ux;
        else
            return 0;
    }
    
    if (left_pim.r_num >= 0)
        return left_ux + rat2double(rat_rat_div(rat_rat_diff(pim, left_pim), rat_rat_diff(measure_get_sym_duration(meas), left_pim))) * (meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux - left_ux);
    //        return meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux;
    
    return meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux * rat2double(tp.pt_in_measure)/rat2double(measure_get_sym_duration(meas));
    //    return meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux;
}




char parse_open_timepoint_syntax_from_llllelem(t_notation_obj *r_ob, t_llllelem *arguments, double *ux, double *ms, t_timepoint *tp, char zero_pim_is_measure_first_chord, char accurate)
{
    t_llll *temp = llll_get();
    char res = 0;
    llll_appendhatom_clone(temp, &arguments->l_hatom, 0, WHITENULL_llll);
    res = parse_open_timepoint_syntax(r_ob, temp, ux, ms, tp, false, accurate);
    llll_free(temp);
    return res;
}

// returns true if error, false otherwise
// open timepoint syntax is <name>, or <ms>, or (<measure>) or (<measure> <position_in_measure>) or (<voice> <measure> <position_in_measure>)
char parse_open_timepoint_syntax(t_notation_obj *r_ob, t_llll *arguments, double *ux, double *ms, t_timepoint *tp,
                                 char zero_pim_is_measure_first_chord, char accurate)
{
    double unscaled_x = 0;
    double arguments_ms = 0;
    
    if (arguments && arguments->l_depth == 1 && arguments->l_size >= 1) {
        if (is_hatom_number(&arguments->l_head->l_hatom)) {
            // This is just a single number: milliseconds
            arguments_ms = hatom_getdouble(&arguments->l_head->l_hatom);
            unscaled_x = ms_to_unscaled_xposition(r_ob, arguments_ms, 1);
        } else {
            // This is possibly a name
            t_notation_item *it;
            lock_general_mutex(r_ob);
            it = names_to_single_notation_item(r_ob, arguments);
            if (it) {
                arguments_ms = notation_item_get_onset_ms(r_ob, it);
                if (ux)
                    unscaled_x = ms_to_unscaled_xposition(r_ob, arguments_ms, 1);
            }
            unlock_general_mutex(r_ob);
        }
        if (tp)
            *tp = ms_to_timepoint(r_ob, arguments_ms, 0, k_MS_TO_TP_RETURN_INTERPOLATION);
        
    } else if (arguments && arguments->l_depth >= 2 && arguments->l_size >= 1 && hatom_gettype(&arguments->l_head->l_hatom) == H_LLLL) {
        // (measure) or (measure position_in_measure) or (measure position_in_measure voice)
        t_llll *innerllll = hatom_getllll(&arguments->l_head->l_hatom);
        
        if (innerllll->l_size == 0) {
            // () is an invalid timepoint
            return true;
        }
        
        char is_voice_defined = true;
        t_timepoint arguments_tp = llll_to_timepoint(r_ob, innerllll, &is_voice_defined, false);
        
        if (arguments_tp.measure_num >= 0) {
            if (ux || ms)
                unscaled_x = timepoint_to_unscaled_xposition(r_ob, arguments_tp, is_voice_defined ? false : true, zero_pim_is_measure_first_chord);
            if (ms)
                arguments_ms = unscaled_xposition_to_ms(r_ob, unscaled_x, 1, accurate);
        }
        if (tp) {
            arguments_tp.voice_num = MAX(0, arguments_tp.voice_num);
            arguments_tp.measure_num = MAX(0, arguments_tp.measure_num);
            *tp = arguments_tp;
        }
    } else
        return true;
    
    if (ux) 
        *ux = unscaled_x;
    if (ms) 
        *ms = arguments_ms;
    return false;
}























void get_left_and_right_barline_ux_tolerances(t_notation_obj *r_ob, t_measure *measure, double *left, double *right){
    if (measure)
        *left = measure->prev ? measure_get_barline_ux_width(r_ob, measure->prev) + CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE : 0;
    else
        *left = get_barline_ux_width(r_ob, k_BARLINE_FINAL) + CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE;
    *right = CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE;
}


// *barline_clicked is filled with 0 if no barline was clicked, 1 if RIGHT barline was clicked, -1 if left barline was clicked
t_measure *ux_to_measure(t_notation_obj *r_ob, double ux, t_voice *voice, char *barline_clicked){
    t_scorevoice *scorevoice = ((t_scorevoice *)voice);
    t_measure *meas = scorevoice->firstmeasure;
    double left_tolerance = CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE;
    double right_tolerance = CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE;
    
    if (barline_clicked)
        *barline_clicked = 0;
    
    if (ux <= 0.) {
        if (barline_clicked)
            *barline_clicked = 0;
        return meas;
    }
    
    while (meas && meas->tuttipoint_reference && (meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux <= ux))
        meas = meas->next;
    
    if (meas) {
        if (!meas->prev || !meas->tuttipoint_reference) // if there's no tuttipoint it means that perform_analysis_and_change() hasn't been done yet.
            return NULL;
        
        if (barline_clicked)  {
            double right_barline_ux = meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux;
            double left_barline_ux = right_barline_ux - meas->prev->width_ux;
            get_left_and_right_barline_ux_tolerances(r_ob, meas->prev, &left_tolerance, &right_tolerance);
            if (right_barline_ux - ux < right_tolerance)
                *barline_clicked = 1;
            else if (ux - left_barline_ux < left_tolerance)
                *barline_clicked = -1;
        }
        return meas->prev;
    } else {
        if (scorevoice && scorevoice->lastmeasure && scorevoice->lastmeasure->tuttipoint_reference) {
            double last_barline_ux = scorevoice->lastmeasure->tuttipoint_reference->offset_ux + scorevoice->lastmeasure->start_barline_offset_ux + scorevoice->lastmeasure->width_ux;
            if (last_barline_ux >= ux) {
                if (barline_clicked)  {
                    double left_barline_ux = scorevoice->lastmeasure->tuttipoint_reference->offset_ux + scorevoice->lastmeasure->start_barline_offset_ux;
                    get_left_and_right_barline_ux_tolerances(r_ob, scorevoice->lastmeasure, &left_tolerance, &right_tolerance);
                    if (last_barline_ux - ux < right_tolerance)
                        *barline_clicked = 1;
                    else if (ux - left_barline_ux < left_tolerance)
                        *barline_clicked = -1;
                }
                return scorevoice->lastmeasure;
            }
        }
    }
    
    if (barline_clicked && scorevoice && scorevoice->lastmeasure && scorevoice->lastmeasure->tuttipoint_reference){
        double last_barline_ux = scorevoice->lastmeasure->tuttipoint_reference->offset_ux + scorevoice->lastmeasure->start_barline_offset_ux + scorevoice->lastmeasure->width_ux;
        get_left_and_right_barline_ux_tolerances(r_ob, NULL, &left_tolerance, &right_tolerance);
        if (ux > last_barline_ux && ux - last_barline_ux < left_tolerance) {
            *barline_clicked = 1;
            return scorevoice->lastmeasure;
        }
    }
    
    return NULL;
}














// for both

// 0 -based
long yposition_to_voicenumber(t_notation_obj *r_ob, double yposition, long system, e_voiceensemble_interface_policy voiceensemble_policy)
{
    t_voice *voice = r_ob->firstvoice;
    double system_jump, yposition_without_system_jump;
    
    if (system < 0) // auto calculation
        system = yposition_to_systemnumber(r_ob, yposition);
    
    system_jump = r_ob->system_jump;
    yposition_without_system_jump = yposition - system_jump * system;
    // then we find the voice

    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        t_voice *next = voice_get_next(r_ob, voice);
        t_voice *nextens = voiceensemble_get_next(r_ob, voice);
        
        if (voice->hidden)
            continue;

        if (voiceensemble_policy == k_VOICEENSEMBLE_INTERFACE_NONE)
            continue;

        if (voiceensemble_policy == k_VOICEENSEMBLE_INTERFACE_ACTIVE && voice->part_index + 1 != r_ob->active_part)
            continue;

        if (voiceensemble_policy == k_VOICEENSEMBLE_INTERFACE_FIRST && voice->part_index != 0)
            continue;

        if (voiceensemble_policy == k_VOICEENSEMBLE_INTERFACE_LAST && (next && next->number < r_ob->num_voices && next->part_index != 0))
            continue;

        if (voice->number < r_ob->num_voices - 1 && (!nextens || nextens->number >= r_ob->num_voices ||
            yposition_without_system_jump < nextens->offset_y + r_ob->vscrollbar_pixnudge + ((CONST_DEFAULT_ROLLVOICES_SPACING_UY - voice->vertical_uspacing) / 2. + CONST_VOICE_THRESHOLD) * r_ob->zoom_y))
            return voice->number;
        
        else if (voice->number == r_ob->num_voices - 1)
            return r_ob->num_voices - 1;
    }
    
    if (voiceensemble_policy == k_VOICEENSEMBLE_INTERFACE_ACTIVE)
        return -1; // = none
    else
        return r_ob->num_voices - 1;
}


double yposition_to_mc(t_notation_obj *r_ob, double yposition, t_voice *voice, long *system)
{
    // leave voice = NULL to have automatic voice; leave system < 0
    double y, micro_adj, res, system_jump;
    long oct;
    int sc_pitch;
    long sc_all_mcs[8] = {0, 200, 400, 500, 700, 900, 1100, 1200};
    // get system
    long thissystem;
    if (system) {
        if (*system < 0) {
            thissystem = yposition_to_systemnumber(r_ob, yposition);
            *system = thissystem;
        } else
            thissystem = *system;
    } else
        thissystem = yposition_to_systemnumber(r_ob, yposition);
    
    if (!voice) {
        long voicenumber = yposition_to_voicenumber(r_ob, yposition, thissystem, k_VOICEENSEMBLE_INTERFACE_FIRST);
        voice = nth_voice(r_ob, voicenumber);
        if (!voice) {
            object_error((t_object *) r_ob, "An error has occurred. Couldn't find any voice.");
            return 6000.; // default
        }
    }
    
    system_jump = r_ob->system_jump;
    
    y = (voice->middleC_y - (yposition - thissystem * system_jump)) / ((double) r_ob->step_y);    // y position in number of steps from middle C
    oct = floor((y + (5 * 7)) / 7.);    // octave (5 is the middle octave)
    sc_pitch = ((((int)floor(y)) + (5 * 7)) % 7);
    if (sc_pitch < 0)
        sc_pitch += 7;
    double adj_y = y - floor(y);
    micro_adj = (1. - adj_y) * sc_all_mcs[sc_pitch] + adj_y * sc_all_mcs[sc_pitch + 1];
    //    post("oct: %d, sc_pitch: %d, sc_mc_base: %d, micro_adj: %d", oct, sc_pitch, sc_mc_base, micro_adj);
    res = oct * 1200 + micro_adj;
    return res;
}


t_symbol *acc_to_symbol(t_rational acc){
    if (rat_rat_cmp(acc, RAT_1OVER4) == 0)
        return gensym("+");
    else if (rat_rat_cmp(acc, RAT_1OVER2) == 0)
        return gensym("#");
    else if (rat_rat_cmp(acc, genrat(3, 4)) == 0)
        return gensym("#+");
    else if (rat_rat_cmp(acc, genrat(1, 1)) == 0)
        return gensym("x");
    else if (rat_rat_cmp(acc, genrat(-1, 4)) == 0)
        return gensym("d");
    else if (rat_rat_cmp(acc, genrat(-1, 2)) == 0)
        return gensym("b");
    else if (rat_rat_cmp(acc, genrat(-3, 4)) == 0)
        return gensym("db");
    else if (rat_rat_cmp(acc, genrat(-1, 1)) == 0)
        return gensym("bb");
    else if (acc.r_num == 0)
        return gensym("n");
    else {
        char direction = acc.r_num > 0 ? 1 : -1;
        t_rational abs_acc = rat_abs(acc);
        char result[100]; 
        result[0] = 0; 
        long cur = 0;
        while (cur < 90 && rat_rat_cmp(abs_acc, RAT_1OVER8) >= 0) {
            if (rat_long_cmp(abs_acc, 1) >= 0)  {
                if (direction > 0) {
                    snprintf_zero(result + cur, 100 - cur, "x");
                    cur ++;
                } else {
                    snprintf_zero(result + cur, 100 - cur, "bb");
                    cur += 2;
                }
                abs_acc = rat_long_diff(abs_acc, 1);
            } else if (rat_rat_cmp(abs_acc, RAT_1OVER2) >= 0) {
                snprintf_zero(result + cur, 100 - cur, direction > 0 ? "#" : "b"); 
                cur++;
                abs_acc = rat_rat_diff(abs_acc, RAT_1OVER2);
            } else if (rat_rat_cmp(abs_acc, RAT_1OVER4) >= 0) {
                snprintf_zero(result + cur, 100 - cur, direction > 0 ? "+" : "d"); 
                cur++;
                abs_acc = rat_rat_diff(abs_acc, RAT_1OVER4);
            } else if (rat_rat_cmp(abs_acc, RAT_1OVER8) >= 0) {
                snprintf_zero(result + cur, 100 - cur, direction > 0 ? "^" : "v"); 
                cur++;
                abs_acc = rat_rat_diff(abs_acc, RAT_1OVER8);
            }
        }
        return gensym(result);
    }
}

t_rational symbol_to_acc(t_symbol *sym)
{
    t_rational acc = long2rat(0);
    if (false) {
        // old parser
        
        long len = strlen(sym->s_name);
        char *temp = (char *) bach_newptr(len + 3);
        temp[0] = 'd';
        temp[1] = 'o'; // dummy note, just need accidentals
        temp[len+2] = 0;
        strncpy(temp + 2, sym->s_name, len);
        long screen_mc, last_used_octave = 4;
        notename2midicents(4, &last_used_octave, temp, &screen_mc, &acc);
        bach_freeptr(temp);
        
    } else {
        // new parser
        t_alterParser p;
        acc = p.parse(sym->s_name);
        if (acc.r_den == 0)
            acc = long2rat(0);
    }

    
    return acc;
}

t_symbol *key_and_mode_to_sym(t_notation_obj *r_ob, char key, e_modes mode, t_rational *acc_pattern){
    if (mode == k_MODE_NONSTANDARD) {
        char string[300];
        long i, cursor = 0;
        for (i = 0; i < 7 && cursor < 280; i++) {
            char part[5];
            snprintf_zero(part, 5, "%s ", acc_to_symbol(acc_pattern[i])->s_name);
            strcpy(string + cursor, part);
            cursor += strlen(part);
        }
        string[cursor] = 0;
        return gensym(string);
    } else if (mode == k_MODE_MAJOR) {
        switch (key) {
            case 0: return gensym("CM");
            case 1: return gensym("GM");
            case 2: return gensym("DM");
            case 3: return gensym("AM");
            case 4: return gensym("EM");
            case 5: return gensym("BM");
            case 6: return gensym("F#M");
            case 7: return gensym("C#M");
            case -1: return gensym("FM");
            case -2: return gensym("BbM");
            case -3: return gensym("EbM");
            case -4: return gensym("AbM");
            case -5: return gensym("DbM");
            case -6: return gensym("GbM");
            case -7: return gensym("CbM");
            default: return gensym("CM");
        }
    } else if (mode == k_MODE_MINOR) {
        switch (key) {
            case 0: return gensym("Am");
            case 1: return gensym("Em");
            case 2: return gensym("Bm");
            case 3: return gensym("F#m");
            case 4: return gensym("C#m");
            case 5: return gensym("G#m");
            case 6: return gensym("D#m");
            case 7: return gensym("A#m");
            case -1: return gensym("Dm");
            case -2: return gensym("Gm");
            case -3: return gensym("Cm");
            case -4: return gensym("Fm");
            case -5: return gensym("Bbm");
            case -6: return gensym("Ebm");
            case -7: return gensym("Abm");
            default: return gensym("Am");
        }
    }
    return gensym("CM");
}

void parse_sym_to_key_and_mode(t_notation_obj *r_ob, t_symbol *sym, char *key, char *mode, t_rational *acc_pattern){
    long screen_mc, i;
    t_rational screen_acc;
    // first we get the mode
    long len = strlen(sym->s_name);
    if (strstr(sym->s_name, " ")) { // nonstandard! has . separations "#  #  b  # "
        char *p, *temp;
        char *name_cpy = (char *) bach_newptr(len+1);
        strncpy_zero(name_cpy, sym->s_name, len + 1);
        p = strtok(name_cpy, " ");
        *mode = k_MODE_NONSTANDARD;
        *key = -100;
        for (i = 0; i < 7; i++) // erase whole acc_pattern
            acc_pattern[i] = long2rat(0);
        i = 0;
        temp = (char *) bach_newptr(len + 4);
        while (p && i < 7) {
            if (false) {
                temp[0] = 'd';
                temp[1] = 'o'; // dummy note, just need accidentals
                strncpy_zero(temp + 2, p, len - 2);
                temp[len+2] = 0;
                screen_acc = long2rat(0);
                notename2midicents(r_ob->middleC_octave, &r_ob->last_used_octave, temp, &screen_mc, &screen_acc);
                acc_pattern[i] = screen_acc;
            } else {
                strncpy_zero(temp, p, len);
                acc_pattern[i] = symbol_to_acc(gensym(temp));
            }

            p = strtok(NULL, " ");
            i++;
        }
        bach_freeptr(temp);    
        bach_freeptr(name_cpy);
    } else { // major or minor key, as Cm, DM, F#m, but also quartertonal CqM or Ddm
        if (len > 0) {
            if (sym->s_name[len-1] == 'm')
                *mode = k_MODE_MINOR;
            else
                *mode = k_MODE_MAJOR;
            screen_mc = 6000; 
            screen_acc = long2rat(0);
            notename2midicents(r_ob->middleC_octave, &r_ob->last_used_octave, sym->s_name, &screen_mc, &screen_acc);
            *key = basenote2key(r_ob, screen_mc, screen_acc, *mode, acc_pattern);
        } else {
            *key = 0;
            *mode = k_MODE_MAJOR;
            for (i = 0; i < 7; i++)
                acc_pattern[i] = long2rat(0);
        }
    }
}

double get_key_uwidth(t_notation_obj *r_ob, t_voice *voice) { // returns un unscaled x width
    long i; double width = 0.;
    for (i = 0; i < 7; i++)
        if (voice->acc_pattern[i].r_num != 0)
            width += (get_accidental_uwidth(r_ob, voice->acc_pattern[i], true) + CONST_KEYSIGNATURE_USPACE_BETWEEN_ACC);
    return width;
}


void get_staff_range_mc(int clef, long *mc_min, long *mc_max)
{
    long shift = get_clef_octave_shift(clef);
    switch (clef) {
        case k_CLEF_FFGG: 
            *mc_min = 1900; 
            *mc_max = 10100;
            return;
        case k_CLEF_FFG:
            *mc_min = 1900;
            *mc_max = 7700;
            return;
        case k_CLEF_FGG:  
            *mc_min = 4300;
            *mc_max = 10100;
            return;
        case k_CLEF_FF:  
            *mc_min = 1900;
            *mc_max = 5700;
            return;
        case k_CLEF_FG:  
            *mc_min = 4300;
            *mc_max = 7700;
            return;
        case k_CLEF_GG:  
            *mc_min = 6400;
            *mc_max = 10100;
            return;
        case k_CLEF_G:  
        case k_CLEF_NONE:  
        case k_CLEF_G8va:
        case k_CLEF_G8vb:
        case k_CLEF_G15ma:
        case k_CLEF_G15mb:
            *mc_min = 6400 + shift * 1200;
            *mc_max = 7700 + shift * 1200;
            return;
        case k_CLEF_F:
        case k_CLEF_F8va:
        case k_CLEF_F8vb:
        case k_CLEF_F15ma:
        case k_CLEF_F15mb:
            *mc_min = 4300 + shift * 1200;
            *mc_max = 5700 + shift * 1200;
            return;
        case k_CLEF_SOPRANO:  
            *mc_min = 6000;
            *mc_max = 7400;
            return;
        case k_CLEF_ALTO:  
            *mc_min = 5300;
            *mc_max = 6700;
            return;
        case k_CLEF_TENOR:  
            *mc_min = 5000;
            *mc_max = 6400;
            return;
        case k_CLEF_MEZZO:  
            *mc_min = 5700;
            *mc_max = 7100;
            return;
        case k_CLEF_BARYTONE:  
            *mc_min = 4700;
            *mc_max = 6000;
            return;
        default:
            *mc_min = 0;
            *mc_max = 0;
            return;
    }
}


char is_mc_within_whole_staves_range(t_notation_obj *r_ob, double mc, int clef) {
    switch (clef) {
        case k_CLEF_FFGG: 
            return (mc >= 1700 && mc <= 10100);
        case k_CLEF_FFG:
            return (mc >= 1700 && mc <= 7700);
        case k_CLEF_FGG:  
            return (mc >= 4100 && mc <= 10100);
        case k_CLEF_FF:  
            return (mc >= 1700 && mc <= 5700);
        case k_CLEF_FG:  
            return (mc >= 4100 && mc <= 7700);
        case k_CLEF_GG:  
            return (mc >= 6400 && mc <= 10100);
        default:
            return is_mc_within_staff(r_ob, mc, clef);
    }
}


int max_and_min_mc_to_default_clef(t_notation_obj *r_ob, double min_mc, double max_mc){
    if (min_mc >= 8200) { // G15
        return k_CLEF_G15ma;
    } else if (min_mc >= 7000) { //G or G8 or GG
        if (max_mc <= 8800)
            return k_CLEF_G;
        else if (max_mc <= 10000)
            return k_CLEF_G8va;
        else
            return k_CLEF_GG;
    } else if (min_mc >= 5800) { // G or GG
        if (max_mc <= 8800)
            return k_CLEF_G;
        else
            return k_CLEF_GG;
    } else if (min_mc >= 3500) { // F or FG or FGG
        if (max_mc <= 6400)
            return k_CLEF_F;
        else if (max_mc <= 8800)
            return k_CLEF_FG;
        else
            return k_CLEF_FGG;
    } else if (min_mc >= 2300) { // F8 or FF or FFG or FFGG
        if (max_mc <= 5200)
            return k_CLEF_F8vb;
        else if (max_mc <= 6400)
            return k_CLEF_FF;
        else if (max_mc <= 8800)
            return k_CLEF_FFG;
        else
            return k_CLEF_FFGG;
    } else {
        if (max_mc <= 4000)
            return k_CLEF_F15mb;
        else if (max_mc <= 6400)
            return k_CLEF_FF;
        else if (max_mc <= 8800)
            return k_CLEF_FFG;
        else
            return k_CLEF_FFGG;
    }
    return k_CLEF_G;    // should never happen
}


char is_y_within_voice_staff(t_notation_obj *r_ob, double y, t_voice *voice)
{
    double staff_top = get_staff_top_y(r_ob, voice, false);
    double staff_bottom = get_staff_bottom_y(r_ob, voice, false);
    if (y >= staff_top && y <= staff_bottom)
        return 1;
    return 0;
}

char is_y_within_any_staff(t_notation_obj *r_ob, double y)
{
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        if (is_y_within_voice_staff(r_ob, y, voice))
            return 1;
    return 0;
}

char is_y_between_this_staff_and_the_next_or_prev(t_notation_obj *r_ob, double y, t_voice *voice) {
    t_voice *nextvoice = voice_get_next(r_ob, voice);
    t_voice *prevvoice = voice_get_prev(r_ob, voice);

    if (nextvoice && nextvoice->number < r_ob->num_voices) {
        double staff_bottom = get_staff_bottom_y(r_ob, voice, false);
        double staff_top = get_staff_top_y(r_ob, nextvoice, false);
        if (y >= staff_bottom && y <= staff_top)
            return 1;
    }

    if (prevvoice && prevvoice->number < r_ob->num_voices) {
        double staff_bottom = get_staff_bottom_y(r_ob, prevvoice, false);
        double staff_top = get_staff_top_y(r_ob, voice, false);
        if (y >= staff_bottom && y <= staff_top)
            return -1;
    }

    return 0;
}

// beware: this does NOT account for nonstandard staff lines!!!
char is_mc_within_staff(t_notation_obj *r_ob, double mc, int clef) {
    long shift = get_clef_octave_shift(clef);
    
    switch (clef) {
        case k_CLEF_FFGG: 
            return (((mc >= 8800) && (mc <= 10100)) || ((mc >= 6400) && (mc <= 7700)) || ((mc >= 4100) && (mc <= 5700)) || ((mc >= 1700) && (mc <= 3300)));
        case k_CLEF_FFG:
            return (((mc >= 6400) && (mc <= 7700)) || ((mc >= 4100) && (mc <= 5700)) || ((mc >= 1700) && (mc <= 3300)));
        case k_CLEF_FGG:  
            return (((mc >= 8800) && (mc <= 10100)) || ((mc >= 6400) && (mc <= 7700)) || ((mc >= 4100) && (mc <= 5700)));
        case k_CLEF_FF:  
            return (((mc >= 4100) && (mc <= 5700)) || ((mc >= 1700) && (mc <= 3300)));
        case k_CLEF_FG:  
            return (((mc >= 6400) && (mc <= 7700)) || ((mc >= 4100) && (mc <= 5700)));
        case k_CLEF_GG:  
            return (((mc >= 8800) && (mc <= 10100)) || ((mc >= 6400) && (mc <= 7700)));

        case k_CLEF_NONE:
        case k_CLEF_G: 
        case k_CLEF_G8va:
        case k_CLEF_G8vb:
        case k_CLEF_G15ma:
        case k_CLEF_G15mb:
            return ((mc >= 6400 + shift * 1200) && (mc <= 7700 + shift * 1200));

        case k_CLEF_F:
        case k_CLEF_F8va:
        case k_CLEF_F8vb:
        case k_CLEF_F15ma:
        case k_CLEF_F15mb:
            return ((mc >= 4100 + shift * 1200) && (mc <= 5700 + shift * 1200));

        case k_CLEF_SOPRANO:
            return ((mc >= 6000) && (mc <= 7400));
        case k_CLEF_MEZZO: 
            return ((mc >= 5700) && (mc <= 7100));
        case k_CLEF_ALTO: 
            return ((mc >= 5300) && (mc <= 6700));
        case k_CLEF_TENOR: 
            return ((mc >= 5000) && (mc <= 6400));
        case k_CLEF_BARYTONE: 
            return ((mc >= 4700) && (mc <= 6000));
        case k_CLEF_PERCUSSION: 
            return ((mc >= 6400) && (mc <= 7700));
        default:
            return 0;
    }
}

char is_rest_within_staff(t_notation_obj *r_ob, t_chord *rest)
{
    if (!rest->parent || !rest->parent->voiceparent)
        return 0;
    
    double mc = rest_get_dummy_mc(r_ob, rest);
    
    if (rat_long_cmp(rest->figure, 1) == 0) {
        double steps = midicents_to_diatsteps_from_middleC(r_ob, mc);
        mc = scaleposition_to_midicents(steps+1);
    }
    
    return is_mc_within_staff(r_ob, mc, get_voice_clef(r_ob, (t_voice *)rest->parent->voiceparent));
}

double scaleposition_to_yposition(t_notation_obj *r_ob, long scaleposition, t_voice *v_ob)
{
//    return voiceoffset + v_ob->middleC_y - scaleposition * r_ob->step_y;
    return v_ob->middleC_y - scaleposition * r_ob->step_y + r_ob->j_inset_y;
}

double scaleposition_to_uyposition(t_notation_obj *r_ob, long scaleposition, t_voice *v_ob)
{
    return scaleposition_to_yposition(r_ob, scaleposition, v_ob)/r_ob->zoom_y;
}

// *note is only needed if notehead is custom
double mc_to_yposition_in_scale_for_notes(t_notation_obj *r_ob, t_note *note, t_voice *v_ob, double notehead_resize){ // discretized to the possible locations of the notehead ON the staff line or BETWEEN two staff lines
    return mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(note), v_ob) + notehead_resize * (-30. - get_notehead_uy_shift(r_ob, note)) * r_ob->zoom_y;
}


double mc_to_yposition_in_scale(t_notation_obj *r_ob, double mc, t_voice *v_ob){ // discretized to the possible locations of the notehead ON the staff line or BETWEEN two staff lines
//no CONST_Y_NOTE_TRANSL constant: this returns the REAL pixel position corresponding to a given midicent!
    long oct = floor(mc / 1200.);
    double pitch = mc - oct * 1200.; 
    long sc_pitch;
    double to_return;
    if (pitch <= 100) 
        sc_pitch = 0;
    else if (pitch <= 300)
        sc_pitch = 1;
    else if (pitch <= 450)
        sc_pitch = 2;
    else if (pitch <= 600)
        sc_pitch = 3;
    else if (pitch <= 800)
        sc_pitch = 4;
    else if (pitch <= 1000)
        sc_pitch = 5;
    else if (pitch <= 1150)
        sc_pitch = 6;
    else {
        oct ++; 
        sc_pitch = 0;
    }
//    post("oct: %d, sc_pitch: %d", oct, sc_pitch);
    to_return = v_ob->middleC_y - ((oct - 5) * 7 + sc_pitch) * r_ob->step_y; // no CONST_Y_NOTE_TRANSL constant: this returns the REAL pixel position!
    return to_return; // + voiceoffset;
}

double mc_to_yposition_quantized(t_notation_obj *r_ob, double mc, t_voice *v_ob)
{
    long screen_mc;
    t_rational screen_acc;
    mc_to_screen_approximations(r_ob, mc, &screen_mc, &screen_acc, v_ob->acc_pattern, v_ob->full_repr);    // automatic approximation
    return mc_to_yposition_in_scale(r_ob, screen_mc, v_ob);
}

double mc_to_yposition(t_notation_obj *r_ob, double mc, t_voice *v_ob){
//no CONST_Y_NOTE_TRANSL constant: this returns the REAL pixel position corresponding to a given midicent!
    double to_return;
    long oct = floor(mc / 1200.);
    double pitch = mc - oct * 1200.; 
    double sc_pitch;
    if (pitch <= 200) {
        sc_pitch = 0 + pitch /200.;
    } else if (pitch <= 400) {
        sc_pitch = 1 + (pitch - 200) /200.;
    } else if (pitch <= 500) {
        sc_pitch = 2 + (pitch - 400) /100.;
    } else if (pitch <= 700) {
        sc_pitch = 3 + (pitch - 500) /200.;
    } else if (pitch <= 900) {
        sc_pitch = 4 + (pitch - 700) /200.;
    } else if (pitch <= 1100) {
        sc_pitch = 5 + (pitch - 900) /200.;
    } else {
        sc_pitch = 6 + (pitch - 1100) /100.;
    }
//    post("oct: %d, sc_pitch: %d", oct, sc_pitch);
    to_return = v_ob->middleC_y - ((oct - 5) * 7 + sc_pitch) * r_ob->step_y; // no CONST_Y_NOTE_TRANSL constant: this returns the REAL pixel position!
    return to_return; // + voiceoffset;
}


t_symbol *full_repr_to_symbol(t_notation_obj *r_ob, t_voice *voice)
{
    long i = 0, cur = 0;
    long i_step = (r_ob->tone_division != 2 && r_ob->tone_division!= 4 && r_ob->tone_division != 8) ? 4 : 8/r_ob->tone_division;
    char res[300];
    for (i = 0; i < 48 && cur < 270; i += i_step) {
        if (i > 0) 
            res[cur++] = ' ';
        t_symbol *this_acc = acc_to_symbol(voice->full_repr[i]);
        long length = strlen(this_acc->s_name);
        strncpy(res + cur, this_acc->s_name, length);
        cur += length;
    }
    res[cur] = 0;
    return gensym(res);
}



// takes the r_ob->full_acc_repr symbol, parse it to properly fill each voice->full_repr, and each r_ob->full_acc_repr[i]
void parse_fullaccpattern_to_voices(t_notation_obj *r_ob)
{
    t_voice *voice;
    long v;
    for (voice = r_ob->firstvoice, v = 0; voice && voice->number < r_ob->num_voices && v < r_ob->num_voices; v++, voice = voice_get_next(r_ob, voice)) {
        if (r_ob->full_acc_repr[v]) {
            t_llll *fap = llll_from_text_buf(r_ob->full_acc_repr[v]->s_name);    // full accidental pattern
            if (fap && fap->l_head) {
                if (hatom_gettype(&fap->l_head->l_hatom) == H_SYM && (hatom_getsym(&fap->l_head->l_hatom) == _llllobj_sym_default || hatom_getsym(&fap->l_head->l_hatom) == _llllobj_sym_none)) {
                    fill_default_full_repr(r_ob, voice->full_repr, voice->key, voice->mode, voice->acc_pattern);
                    r_ob->full_acc_repr[v] = _llllobj_sym_default;
                } else {
                    t_llllelem *elem;
                    long i = 0;
                    long i_step = (r_ob->tone_division != 2 && r_ob->tone_division!= 4 && r_ob->tone_division != 8) ? 4 : 8/r_ob->tone_division;
                    for (elem = fap->l_head; elem && i < 48; elem = elem->l_next, i += i_step) {
                        if (hatom_gettype(&elem->l_hatom) == H_SYM)
                            voice->full_repr[i] = symbol_to_acc(hatom_getsym(&elem->l_hatom));
                    } 
                    r_ob->full_acc_repr[v] =  full_repr_to_symbol(r_ob, voice);
                }
            }
            llll_free(fap);
        }
    }
}


void mc_to_screen_approximations(t_notation_obj *r_ob, double mc, long *screen_note, t_rational *screen_accidental, t_rational *key_acc_pattern, t_rational *full_repr){
    mc_to_screen_approximations_do(r_ob->tone_division, r_ob->accidentals_preferences, mc, screen_note, screen_accidental, key_acc_pattern, full_repr);
}

void mc_to_screen_approximations_do(long tone_division, char accidentals_preferences, double mc, long *screen_note, t_rational *screen_accidental, 
                                    t_rational *key_acc_pattern, t_rational *full_repr){
    
    t_pitch pitch = t_pitch::fromMC(mc, tone_division, (e_accidentals_preferences)accidentals_preferences, key_acc_pattern, full_repr);
    
    *screen_note = pitch.toMC_wo_accidental();
    *screen_accidental = pitch.alter();
    return;
/*
    
// converts a midicents number in the accidentals, with respect to the given full_accidental_representation (representing for each note)
    double fl = floor(mc/1200);
    double step_mc = 200. / tone_division;
    double rescaled = (mc - 1200 * fl) / step_mc;
    // this is a scaled value which tells us where the mc are with respect to the normalized grid 0 1 2 3 4 5... 
    
    long numsteps = 6 * tone_division;
    long gridstep = (long)round(rescaled);
    char toadd = (gridstep >= numsteps);
    char toadd2 = 0;
    double gridstep_12norm;
    double natural_steps[8];
    long natural_approx_step = -1, i;
    t_rational natural_ratio, grid_ratio;
    gridstep %= numsteps; // modulo the number of steps of the grid
    // now we have the step, we gotta find what it means with respect to the NATURAL notes.
    // where is the closest natural notes with respect to the grid?
    // e.g. i'm at gridstep 3; gotta normalize it at 12.
    gridstep_12norm = gridstep * 12. / numsteps;
    // now we have to find the 12-degree natural approximation {0, 2, 4, 5, 7, 9, 11} that suits our gridstep_12norm
    
    natural_steps[0] = 0.;
    natural_steps[1] = 2.;
    natural_steps[2] = 4.;
    natural_steps[3] = 5.;
    natural_steps[4] = 7.;
    natural_steps[5] = 9.;
    natural_steps[6] = 11.;
    natural_steps[7] = 12.;
    
    // test the full_repr, if any
    if (natural_approx_step < 0 && full_repr && (tone_division == 2 || tone_division == 4 || tone_division == 8)) {
        double gridstep_48norm = gridstep * 48. / numsteps;
        long round_gridstep_48norm = round(gridstep_48norm);
        if (fabs(round_gridstep_48norm - gridstep_48norm) < CONST_EPSILON4 || fabs(round_gridstep_48norm - gridstep_48norm) > 12. - CONST_EPSILON4){
            if (round_gridstep_48norm >= 48) {
                round_gridstep_48norm -= 48;
                toadd2 = 1;
            } else if (round_gridstep_48norm < 0) {
                round_gridstep_48norm += 48;
                toadd2 = -1;
            }
            if (round_gridstep_48norm < 0 || round_gridstep_48norm >= 48) {
                dev_post("Bug in mc_to_screen_approximation_do!");
                round_gridstep_48norm = 0;
            }
            t_rational acc = full_repr[round_gridstep_48norm];
            t_rational prod = rat_long_prod(acc, 8);
            double approx_step = (round_gridstep_48norm - prod.r_num)/4.;
            if (prod.r_den == 1 && is_number_in_double_array_with_modulo(approx_step, 7, natural_steps, CONST_EPSILON4, 12)) {
                natural_approx_step = round(approx_step);
                if (natural_approx_step < 0) {
                    natural_approx_step += 12;
                    toadd2 = -1;
                } else if (natural_approx_step > 11) {
                    natural_approx_step -= 12;
                    toadd2 = 1;
                }
            }
        }
    }


    // test the key degrees
    if (natural_approx_step < 0 && key_acc_pattern) { // see if it fits to a step in the current key
        for (i = 0; i < 7; i++){
            double pattern_step = natural_steps[i] + rat2double(key_acc_pattern[i]) * 2.;
            if (fabs(gridstep_12norm - pattern_step) < CONST_EPSILON4 || fabs(gridstep_12norm - pattern_step) > 12. - CONST_EPSILON4) {
                natural_approx_step = natural_steps[i];
                if (gridstep_12norm > natural_approx_step && key_acc_pattern[i].r_num < 0)
                    toadd2 = 1;
                else if (gridstep_12norm < natural_approx_step && key_acc_pattern[i].r_num > 0)
                    toadd2 = -1;
                break;
            }
        }
    }
    
    // test the natural notes
    if (natural_approx_step < 0) {
        for (i = 0; i < 7; i++){
            if (fabs(gridstep_12norm - natural_steps[i]) < CONST_EPSILON4 || fabs(gridstep_12norm - natural_steps[i]) > 12. - CONST_EPSILON4) {
                natural_approx_step = natural_steps[i];
                break;
            }
        }
    }

    // test the intermediate steps
    if (natural_approx_step < 0) {
        for (i = 0; i < 7; i++){
            if (gridstep_12norm > natural_steps[i] && gridstep_12norm < natural_steps[i+1]) {
                if (accidentals_preferences == k_ACC_FLATS)
                    natural_approx_step = natural_steps[i+1];
                else if (accidentals_preferences == k_ACC_SHARPS)
                    natural_approx_step = natural_steps[i];
                else { // auto
                    // we privilegiate Bb, Ab, Eb and all the rest as sharps
                    if (natural_steps[i] == 9. || natural_steps[i] == 7. || natural_steps[i] == 2.) {
                        if (gridstep_12norm >= (natural_steps[i] + natural_steps[i+1])/2.)
                            natural_approx_step = natural_steps[i+1];
                        else
                            natural_approx_step = natural_steps[i];
                    } else {
                        if (gridstep_12norm > (natural_steps[i] + natural_steps[i+1])/2.)
                            natural_approx_step = natural_steps[i+1];
                        else
                            natural_approx_step = natural_steps[i];
                    }
                }
            }
        }
    }

    *screen_note = 1200 * ((long) fl + toadd + toadd2) + 100 * natural_approx_step;

    natural_ratio.r_num = natural_approx_step + 12 * toadd2;
    natural_ratio.r_den = 12;
    grid_ratio.r_num = gridstep;
    grid_ratio.r_den = numsteps;
    
    *screen_accidental = rat_rat_diff(grid_ratio, natural_ratio);
    screen_accidental->r_num *= 6;
//    post("%d/%d + %d/%d = %d/%d", grid_ratio.r_num, grid_ratio.r_den, natural_ratio.r_num, natural_ratio.r_den, screen_accidental->r_num, screen_accidental->r_den); 
    rat_reduce(screen_accidental);
    */
}



/*

t_pitch pitch_fromMC(long tone_division, char accidentals_preferences, double mc, t_rational *key_acc_pattern, t_rational *full_repr)
{
    // converts a midicents number in the accidentals, with respect to the given full_accidental_representation (representing for each note)
    double fl = floor(mc/1200);
    double step_mc = 200. / tone_division;
    double rescaled = (mc - 1200 * fl) / step_mc; // this is a scaled value which tells us where the mc are with respect to the normalized grid 0 1 2 3 4 5...
    long gridstep = (long)round(rescaled); // step index on the microtonal grid
    long numsteps = 6 * tone_division;
    long add_one_octave = (gridstep >= numsteps); // if the grid step is numsteps, we need to add 1 octave
    long add_another_octave = 0;
    double gridstep_12norm;
    double natural_steps[8];
    long natural_approx_diatstep = -1, natural_approx_step = -1, i;
    t_rational natural_ratio, grid_ratio;
    const double PERFECT_MATCH_THRESHOLD = 0.0005;
    
    gridstep %= numsteps; // modulo the number of steps of the grid
    
    // now we have the step, we gotta find what it means with respect to the NATURAL notes.
    // where is the closest natural notes with respect to the grid?
    // e.g. i'm at gridstep 3 in a 24-TET; gotta normalize it at 12...
    gridstep_12norm = gridstep * 12. / numsteps; // ...so that now our 3 becomes 1.5
    
    
    // now we have to find the 12-degree natural approximation {0, 2, 4, 5, 7, 9, 11} that suits our gridstep_12norm
    
    natural_steps[0] = 0.;
    natural_steps[1] = 2.;
    natural_steps[2] = 4.;
    natural_steps[3] = 5.;
    natural_steps[4] = 7.;
    natural_steps[5] = 9.;
    natural_steps[6] = 11.;
    natural_steps[7] = 12.;
    
    // test the full_repr, if any
    if (natural_approx_step < 0 && full_repr && (tone_division == 2 || tone_division == 4 || tone_division == 8)) {
        double gridstep_48norm = gridstep * 48. / numsteps;
        long round_gridstep_48norm = round(gridstep_48norm);
        
        if (fabs(round_gridstep_48norm - gridstep_48norm) < PERFECT_MATCH_THRESHOLD || fabs(round_gridstep_48norm - gridstep_48norm) > 12. - PERFECT_MATCH_THRESHOLD){
            // precise match
            
            if (round_gridstep_48norm >= 48) {
                round_gridstep_48norm -= 48;
                add_another_octave = 1;
            } else if (round_gridstep_48norm < 0) {
                round_gridstep_48norm += 48;
                add_another_octave = -1;
            }
            if (round_gridstep_48norm < 0 || round_gridstep_48norm >= 48) {
                dev_post("Bug in mc_to_screen_approximation_do!");
                round_gridstep_48norm = 0;
            }
            t_rational acc = full_repr[round_gridstep_48norm];
            t_rational prod = rat_long_prod(acc, 8);
            double approx_step = (round_gridstep_48norm - prod.r_num)/4.;
            
            if (prod.r_den == 1) {
                long j = -1;
                for (long i = 0; i < 7; i++) {
                    double diff = fabs(approx_step - natural_steps[i]);
                    if (diff < PERFECT_MATCH_THRESHOLD || diff > 12 - PERFECT_MATCH_THRESHOLD) {
                        j = i;
                        break;
                    }
                }
                
                if (j >= 0) {
                    natural_approx_diatstep = j;
                    natural_approx_step = round(approx_step);
                    if (natural_approx_step < 0) {
                        natural_approx_step += 12;
                        add_another_octave = -1;
                    } else if (natural_approx_step > 11) {
                        natural_approx_step -= 12;
                        add_another_octave = 1;
                    }
                }
            }
        }
    }
    
    
    // if not found, test the key degrees
    if (natural_approx_step < 0 && key_acc_pattern) { // see if it fits to a step in the current key
        for (i = 0; i < 7; i++){
            double pattern_step = natural_steps[i] + rat2double(key_acc_pattern[i]) * 2.;
            if (fabs(gridstep_12norm - pattern_step) < PERFECT_MATCH_THRESHOLD || fabs(gridstep_12norm - pattern_step) > 12. - PERFECT_MATCH_THRESHOLD) {
                natural_approx_diatstep = i;
                natural_approx_step = natural_steps[i];
                if (gridstep_12norm > natural_approx_step && key_acc_pattern[i].r_num < 0)
                add_another_octave = 1;
                else if (gridstep_12norm < natural_approx_step && key_acc_pattern[i].r_num > 0)
                add_another_octave = -1;
                break;
            }
        }
    }
    
    // if not found, test the natural notes
    if (natural_approx_step < 0) {
        for (i = 0; i < 7; i++){
            if (fabs(gridstep_12norm - natural_steps[i]) < PERFECT_MATCH_THRESHOLD || fabs(gridstep_12norm - natural_steps[i]) > 12. - PERFECT_MATCH_THRESHOLD) {
                natural_approx_diatstep = i;
                natural_approx_step = natural_steps[i];
                break;
            }
        }
    }
    
    // if not found, test the intermediate steps
    if (natural_approx_step < 0) {
        for (i = 0; i < 7; i++){
            if (gridstep_12norm > natural_steps[i] && gridstep_12norm < natural_steps[i+1]) {
                if (accidentals_preferences == k_ACC_FLATS) {
                    natural_approx_diatstep = i+1;
                    natural_approx_step = natural_steps[i+1];
                } else if (accidentals_preferences == k_ACC_SHARPS) {
                    natural_approx_diatstep = i;
                    natural_approx_step = natural_steps[i];
                } else { // auto
                    // Default enharmonicity: we privilegiate Bb, Ab, Eb and all the rest will be sharps
                    if (natural_steps[i] == 9. || natural_steps[i] == 7. || natural_steps[i] == 2.) {
                        if (gridstep_12norm >= (natural_steps[i] + natural_steps[i+1])/2.) {
                            natural_approx_diatstep = i+1;
                            natural_approx_step = natural_steps[i+1];
                        } else {
                            natural_approx_diatstep = i;
                            natural_approx_step = natural_steps[i];
                        }
                    } else {
                        if (gridstep_12norm > (natural_steps[i] + natural_steps[i+1])/2.) {
                            natural_approx_diatstep = i+1;
                            natural_approx_step = natural_steps[i+1];
                        } else {
                            natural_approx_diatstep = i;
                            natural_approx_step = natural_steps[i];
                        }
                    }
                }
            }
        }
    }
    
    
    long steps = ((long) fl + add_one_octave + add_another_octave) * 7 + natural_approx_diatstep;
    
    natural_ratio.r_num = natural_approx_step + 12 * add_another_octave;
    natural_ratio.r_den = 12;
    grid_ratio.r_num = gridstep;
    grid_ratio.r_den = numsteps;
    
    t_rational accidental = rat_rat_diff(grid_ratio, natural_ratio) * 6;
    
    return t_pitch(steps % 7, accidental, steps / 7);
}

*/






t_lexpr *notation_obj_lexpr_new(short ac, t_atom *av)
{
    t_lexpr *le = lexpr_new(ac, av, notation_obj_lexpr_subs_count, notation_obj_lexpr_subs, NULL);
    if (!le) {
        error("Expression contains errors.");
    }
    return le;
}



char is_natural_note(long mc){
// says whether a mc represents a natural note (w/o any accidental)
    switch (mc % 1200) {
        case 0: case 200: case 400: case 500: case 700: case 900: case 1100:
            return 1;
        default:
            return 0;
    }
}

// also recomputes the domain!
void update_domain(t_notation_obj *r_ob) {
    char object_type = r_ob->obj_type;
    if (r_ob->inner_width < 0) // not yet painted!
        return;

    if (object_type == k_NOTATION_OBJECT_ROLL) {

        r_ob->domain_ux = (r_ob->inner_width - r_ob->postdomain_width + r_ob->j_inset_x - get_max_vscrollbar_width_or_inset_x(r_ob) - (get_ux_left_start(r_ob) + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad) * r_ob->zoom_y) / (1 * r_ob->zoom_x * r_ob->zoom_y);
 
//        dev_post("domain_ux: %.2f", r_ob->domain_ux);
        
        if (r_ob->lambda_spacing != k_CUSTOMSPACING_NONE) {
            // Custom spacing routine
//            dev_post("startms: %.2f", r_ob->screen_ms_start);
            r_ob->screen_ms_end = xposition_to_onset(r_ob, r_ob->width - get_max_vscrollbar_width_or_inset_x(r_ob), 0);
            r_ob->domain = r_ob->screen_ms_end - r_ob->screen_ms_start;
//            dev_post("startms: %.2f, endms: %.2f, domain: %.2f", r_ob->screen_ms_start, r_ob->screen_ms_end, r_ob->domain);
        } else {
            // Standard routine
            r_ob->domain = r_ob->domain_ux / CONST_X_SCALING;
            r_ob->screen_ms_end = r_ob->screen_ms_start + r_ob->domain;
            
        }
    } else if (object_type == k_NOTATION_OBJECT_SCORE) {
        r_ob->domain_ux = (r_ob->inner_width - r_ob->postdomain_width + r_ob->j_inset_x - get_max_vscrollbar_width_or_inset_x(r_ob) - (get_ux_left_start(r_ob) + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth + r_ob->additional_ux_start_pad) * r_ob->zoom_y) / (CONST_X_SCALING_SCORE * r_ob->zoom_x * r_ob->zoom_y);
        r_ob->screen_ux_end = r_ob->screen_ux_start + r_ob->domain_ux;
    }
}

long getdomain(t_notation_obj *r_ob){
    if (r_ob->inner_width < 0) // not yet painted!
        return -1;

    update_domain(r_ob);
    
    return r_ob->domain;
}

void set_selection_dragging_velocity(t_notation_obj *r_ob){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        switch (curr_it->type) {
            case k_NOTE:
            {
                ((t_note *)curr_it)->draggingvelocity = ((t_note *)curr_it)->velocity;
            }
                break;
                
            case k_CHORD:
            {
                t_note *temp = ((t_chord *)curr_it)->firstnote;
                while (temp){
                    temp->draggingvelocity = temp->velocity;
                    temp = temp->next;
                }
            }
                break;
                
            case k_MEASURE:
            {
                t_chord *temp_ch = ((t_measure *)curr_it)->firstchord;
                while (temp_ch) {
                    t_note *temp = temp_ch->firstnote;
                    while (temp){
                        temp->draggingvelocity = temp->velocity;
                        temp = temp->next;
                    }
                    temp_ch = temp_ch->next;
                }
            }
                break;
                
            case k_PITCH_BREAKPOINT:
            {
                t_bpt *bpt = (t_bpt *)curr_it;
                if (!bpt->next) 
                    (bpt->owner->lastbreakpoint)->draggingvelocity = (bpt->owner->lastbreakpoint)->velocity;
                else 
                    bpt->draggingvelocity = bpt->velocity;
            }
                break;
                
            default:
                break;
        }
        curr_it = curr_it->next_selected;
    }
}

void change_color_depending_on_part(t_notation_obj *r_ob, t_jrgba *color, t_voice *voice)
{
    if (r_ob->show_part_colors && voice && voice->part_index > 0)
        *color = r_ob->part_colors[voice->part_index % CONST_NUM_PART_COLORS];
}


void change_color_depending_on_playlockmute(t_notation_obj *r_ob, t_jrgba *color, char selected, char play, char locked, char muted, char solo, char linear_edited)
{
    if (play) {
        color->red = r_ob->j_play_rgba.red;
        color->blue = r_ob->j_play_rgba.blue;
        color->green = r_ob->j_play_rgba.green;
        color->alpha = r_ob->j_play_rgba.alpha;
    } else {
        char sel = selected ? k_SHOW_WHEN_SELECTED : k_SHOW_WHEN_NOT_SELECTED; 
        if (linear_edited) {
            *color = r_ob->j_linear_edit_rgba;
        } else if (locked && (r_ob->show_lock_color_when & sel) && muted && (r_ob->show_mute_color_when & sel) && solo && (r_ob->show_solo_color_when & sel)) {
            color->red = (r_ob->j_locked_rgba.red + r_ob->j_muted_rgba.red + r_ob->j_solo_rgba.red)/3.;
            color->blue = (r_ob->j_locked_rgba.blue + r_ob->j_muted_rgba.blue + r_ob->j_solo_rgba.blue)/3.;
            color->green = (r_ob->j_locked_rgba.green + r_ob->j_muted_rgba.green + r_ob->j_solo_rgba.green)/3.;
            color->alpha = (r_ob->j_locked_rgba.alpha + r_ob->j_muted_rgba.alpha + r_ob->j_solo_rgba.alpha)/3.;
        } else if (locked && (r_ob->show_lock_color_when & sel) && muted && (r_ob->show_mute_color_when & sel)) {
            color->red = (r_ob->j_locked_rgba.red + r_ob->j_muted_rgba.red)/2.;
            color->blue = (r_ob->j_locked_rgba.blue + r_ob->j_muted_rgba.blue)/2.;
            color->green = (r_ob->j_locked_rgba.green + r_ob->j_muted_rgba.green)/2.;
            color->alpha = (r_ob->j_locked_rgba.alpha + r_ob->j_muted_rgba.alpha)/2.;
        } else if (locked && (r_ob->show_lock_color_when & sel) && solo && (r_ob->show_solo_color_when & sel)) {
            color->red = (r_ob->j_locked_rgba.red + r_ob->j_solo_rgba.red)/2.;
            color->blue = (r_ob->j_locked_rgba.blue + r_ob->j_solo_rgba.blue)/2.;
            color->green = (r_ob->j_locked_rgba.green + r_ob->j_solo_rgba.green)/2.;
            color->alpha = (r_ob->j_locked_rgba.alpha + r_ob->j_solo_rgba.alpha)/2.;
        } else if (solo && (r_ob->show_solo_color_when & sel) && muted && (r_ob->show_mute_color_when & sel)) {
            color->red = (r_ob->j_solo_rgba.red + r_ob->j_muted_rgba.red)/2.;
            color->blue = (r_ob->j_solo_rgba.blue + r_ob->j_muted_rgba.blue)/2.;
            color->green = (r_ob->j_solo_rgba.green + r_ob->j_muted_rgba.green)/2.;
            color->alpha = (r_ob->j_solo_rgba.alpha + r_ob->j_muted_rgba.alpha)/2.;
        } else if (locked && (r_ob->show_lock_color_when & sel)) {
            color->red = r_ob->j_locked_rgba.red;
            color->blue = r_ob->j_locked_rgba.blue;
            color->green = r_ob->j_locked_rgba.green;
            color->alpha = r_ob->j_locked_rgba.alpha;
        } else if (muted && (r_ob->show_mute_color_when & sel)) {
            color->red = r_ob->j_muted_rgba.red;
            color->blue = r_ob->j_muted_rgba.blue;
            color->green = r_ob->j_muted_rgba.green;
            color->alpha = r_ob->j_muted_rgba.alpha;
        } else if (solo && (r_ob->show_solo_color_when & sel)) {
            color->red = r_ob->j_solo_rgba.red;
            color->blue = r_ob->j_solo_rgba.blue;
            color->green = r_ob->j_solo_rgba.green;
            color->alpha = r_ob->j_solo_rgba.alpha;
        } else {
            if (selected) {
                color->red = r_ob->j_selection_rgba.red;
                color->blue = r_ob->j_selection_rgba.blue;
                color->green = r_ob->j_selection_rgba.green;
                color->alpha = r_ob->j_selection_rgba.alpha;
            }
        }
    }
}

void change_color_depending_on_group(t_notation_obj *r_ob, t_jrgba *color, void* element, char type)
{
    if (r_ob->show_groups >= 2) {
        t_chord *ch = NULL;
        if (type == k_CHORD)
            ch = (t_chord *) element;
        else if (type == k_NOTE)
            ch = ((t_note *) element)->parent;
        
        if (ch && ch->r_it.group && ch->r_it.group->ID > 0)
            *color = long_to_color(ch->r_it.group->ID);
    }
}


t_jrgba measure_get_color(t_notation_obj *r_ob, char is_measure_selected, char is_measure_locked, char is_measure_muted, char is_measure_solo, char is_measure_linear_edited)
{
    t_jrgba measurecolor = r_ob->j_note_rgba;
    change_color_depending_on_playlockmute(r_ob, &measurecolor, is_measure_selected, false, is_measure_locked, is_measure_muted, is_measure_solo, is_measure_linear_edited);

    return measurecolor;
}    

t_jrgba get_mainstaff_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo)
{
    t_jrgba staffcolor = r_ob->j_mainstaves_rgba;
    change_color_depending_on_playlockmute(r_ob, &staffcolor, is_voice_selected, false, is_voice_locked, is_voice_muted, is_voice_solo, false);
    return staffcolor;
}    

t_jrgba get_keysig_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo)
{
    t_jrgba keysigcolor = r_ob->j_keysig_rgba;
    change_color_depending_on_playlockmute(r_ob, &keysigcolor, is_voice_selected, false, is_voice_locked, is_voice_muted, is_voice_solo, false);
    return keysigcolor;
}    

t_jrgba clef_get_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo)
{
    t_jrgba staffcolor = r_ob->j_clef_rgba;
    change_color_depending_on_playlockmute(r_ob, &staffcolor, is_voice_selected, false, is_voice_locked, is_voice_muted, is_voice_solo, false);
    return staffcolor;
}    

t_jrgba get_auxclef_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo)
{
    t_jrgba auxclefcolor = r_ob->j_auxiliaryclef_rgba;
    change_color_depending_on_playlockmute(r_ob, &auxclefcolor, is_voice_selected, false, is_voice_locked, is_voice_muted, is_voice_solo, false);
    return auxclefcolor;
}

t_jrgba get_auxstaff_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo)
{
    t_jrgba staffcolor = r_ob->j_auxiliarystaves_rgba;
    change_color_depending_on_playlockmute(r_ob, &staffcolor, is_voice_selected, false, is_voice_locked, is_voice_muted, is_voice_solo, false);
    return staffcolor;
}    

t_jrgba floatlist_slot_to_color(t_slot *slot)
{
    t_jrgba out_color;
    double r = 0., g = 0., b = 0., a = 1.;
    if (slot->firstitem){
        r = *((double *) slot->firstitem->item);
        if (slot->firstitem->next){
            g = *((double *) slot->firstitem->next->item);
            if (slot->firstitem->next->next){
                b = *((double *) slot->firstitem->next->next->item);
                if (slot->firstitem->next->next->next)
                    a = *((double *) slot->firstitem->next->next->next->item);
            }
        }
    }
    out_color.red = r;
    out_color.green = g;
    out_color.blue = b;
    out_color.alpha = a; 
    return out_color;
}



t_jrgba note_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity)
{
    t_jrgba notecolor = r_ob->j_note_rgba;
    
    change_color_depending_on_part(r_ob, &notecolor, notation_item_get_voice(r_ob, (t_notation_item *)note));

    change_color_depending_on_group(r_ob, &notecolor, note, k_NOTE);
    
    if (note && !is_note_played && !is_note_selected)
        note_change_color_depending_on_slot_linkage(r_ob, &notecolor, note);

    change_color_depending_on_playlockmute(r_ob, &notecolor, is_note_selected, is_note_played, is_note_locked, is_note_muted, is_note_solo, is_note_linear_edited);
    
    if (!note) 
        return notecolor; // it is a rest
    
    apply_velocity_handling(r_ob, &notecolor, velocity, is_note_selected, is_note_played);
    
    return notecolor;
}


t_jrgba durationline_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity)
{
    t_jrgba dlcolor = r_ob->j_note_rgba;
    
    change_color_depending_on_part(r_ob, &dlcolor, notation_item_get_voice(r_ob, (t_notation_item *)note));
    
    change_color_depending_on_group(r_ob, &dlcolor, note, k_NOTE);
    
    if (note && !is_note_played && !is_note_selected) {
        note_change_color_depending_on_slot_linkage(r_ob, &dlcolor, note);
        durationline_change_color_depending_on_slot_linkage(r_ob, &dlcolor, note);
    }
    
    change_color_depending_on_playlockmute(r_ob, &dlcolor, is_note_selected, is_note_played, is_note_locked, is_note_muted, is_note_solo, is_note_linear_edited);
    
    if (!note)
        return dlcolor; // it is a rest
    
    apply_velocity_handling(r_ob, &dlcolor, velocity, is_note_selected, is_note_played);
    
    return dlcolor;
}



t_jrgba accidental_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity)
{
    t_jrgba accidentalcolor = r_ob->j_accidentals_rgba;
    
    change_color_depending_on_part(r_ob, &accidentalcolor, notation_item_get_voice(r_ob, (t_notation_item *)note));

    change_color_depending_on_group(r_ob, &accidentalcolor, note, k_NOTE);
    
    if (note && !is_note_played && !is_note_selected)
        note_change_color_depending_on_slot_linkage(r_ob, &accidentalcolor, note);
    
    change_color_depending_on_playlockmute(r_ob, &accidentalcolor, is_note_selected, is_note_played, is_note_locked, is_note_muted, is_note_solo, is_note_linear_edited);
    
    if (!note)
        return accidentalcolor; // it is a rest
    
    apply_velocity_handling(r_ob, &accidentalcolor, velocity, is_note_selected, is_note_played);
    
    return accidentalcolor;
}


t_jrgba tail_get_color(t_notation_obj *r_ob, t_note* note, char is_tail_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity)
{
    t_jrgba tailcolor = r_ob->j_note_rgba;
    
    change_color_depending_on_part(r_ob, &tailcolor, notation_item_get_voice(r_ob, (t_notation_item *)note));
    
    change_color_depending_on_group(r_ob, &tailcolor, note, k_NOTE);
    
    if (note && !is_note_played && !is_tail_selected) {
        note_change_color_depending_on_slot_linkage(r_ob, &tailcolor, note);
        durationline_change_color_depending_on_slot_linkage(r_ob, &tailcolor, note);
    }
    
    change_color_depending_on_playlockmute(r_ob, &tailcolor, is_tail_selected, is_note_played, is_note_locked, is_note_muted, is_note_solo, is_note_linear_edited);

    apply_velocity_handling(r_ob, &tailcolor, velocity, is_tail_selected, is_note_played);
    
    return tailcolor;
}


t_jrgba stem_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba stemcolor = r_ob->j_stem_rgba;

    change_color_depending_on_part(r_ob, &stemcolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));

    change_color_depending_on_group(r_ob, &stemcolor, chord, k_CHORD);
    
    if (!is_chord_played && !is_chord_selected && chord && chord->firstnote)
        note_change_color_depending_on_slot_linkage(r_ob, &stemcolor, chord->firstnote);
    
    change_color_depending_on_playlockmute(r_ob, &stemcolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    if (chord->firstnote)
        apply_velocity_handling(r_ob, &stemcolor, chord_get_max_velocity(r_ob, chord), is_chord_selected, is_chord_played);
    
    return stemcolor;
}



t_jrgba flag_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba flagcolor = r_ob->j_flag_rgba;

    change_color_depending_on_part(r_ob, &flagcolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));

    change_color_depending_on_group(r_ob, &flagcolor, chord, k_CHORD);
    
    change_color_depending_on_playlockmute(r_ob, &flagcolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    if (!is_chord_played && !is_chord_selected && chord && chord->firstnote)
        note_change_color_depending_on_slot_linkage(r_ob, &flagcolor, chord->firstnote);
    
    if (chord->firstnote)
        apply_velocity_handling(r_ob, &flagcolor, chord_get_max_velocity(r_ob, chord), is_chord_selected, is_chord_played);

    return flagcolor;
}


t_jrgba rest_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba restcolor = r_ob->j_rest_rgba;
    
    change_color_depending_on_part(r_ob, &restcolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));

    change_color_depending_on_group(r_ob, &restcolor, chord, k_CHORD);
    
    if (!is_chord_played && !is_chord_selected && chord)
        notation_item_change_color_depending_on_slot_linkage(r_ob, &restcolor, (t_notation_item *)chord);
    
    change_color_depending_on_playlockmute(r_ob, &restcolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    return restcolor;
}



t_jrgba beam_get_color(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->show_part_colors && voice->part_index > 0)
        return r_ob->part_colors[voice->part_index % CONST_NUM_PART_COLORS];

    return r_ob->j_beam_rgba;
}

t_jrgba tuplet_get_color(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->show_part_colors && voice->part_index > 0)
        return r_ob->part_colors[voice->part_index % CONST_NUM_PART_COLORS];

    return r_ob->j_tuplet_rgba;
}


t_jrgba articulation_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba articulationcolor = r_ob->j_articulations_rgba;

    change_color_depending_on_part(r_ob, &articulationcolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));

    change_color_depending_on_group(r_ob, &articulationcolor, chord, k_CHORD);
    
    change_color_depending_on_playlockmute(r_ob, &articulationcolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    if (!is_chord_played && !is_chord_selected && chord && r_ob->link_nitemcolor_to_slot > 0 && r_ob->link_nitemcolor_to_slot <= CONST_MAX_SLOTS && chord->firstnote) {
        t_note *note = chord->firstnote;
        if (note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem && note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item) {
            if ((r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INT) || (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INTLIST))
                articulationcolor = long_to_color(*((long *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item));
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOAT)
                articulationcolor = double_to_color(*((double *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item), r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[0], r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[1], false);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOATLIST)
                articulationcolor = floatlist_slot_to_color(&note->slot[r_ob->link_nitemcolor_to_slot-1]);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_COLOR)
                articulationcolor = *((t_jrgba *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item);
        }
    }
    
    if (chord->firstnote)
        apply_velocity_handling(r_ob, &articulationcolor, chord_get_max_velocity(r_ob, chord), is_chord_selected, is_chord_played);

    return articulationcolor;
}


t_jrgba annotation_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba annotationcolor = r_ob->j_annotation_rgba;
    
    change_color_depending_on_part(r_ob, &annotationcolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));

    change_color_depending_on_group(r_ob, &annotationcolor, chord, k_CHORD);
    
    change_color_depending_on_playlockmute(r_ob, &annotationcolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    if (!is_chord_played && !is_chord_selected && chord && r_ob->link_nitemcolor_to_slot > 0 && r_ob->link_nitemcolor_to_slot <= CONST_MAX_SLOTS && chord->firstnote) {
        t_note *note = chord->firstnote;
        if (note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem && note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item) {
            if ((r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INT) || (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INTLIST))
                annotationcolor = long_to_color(*((long *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item));
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOAT)
                annotationcolor = double_to_color(*((double *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item), r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[0], r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[1], false);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOATLIST)
                annotationcolor = floatlist_slot_to_color(&note->slot[r_ob->link_nitemcolor_to_slot-1]);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_COLOR)
                annotationcolor = *((t_jrgba *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item);
        }
    }
    
    if (chord->firstnote)
        apply_velocity_handling(r_ob, &annotationcolor, chord_get_max_velocity(r_ob, chord), is_chord_selected, is_chord_played);
    
    return annotationcolor;
}


t_jrgba dynamics_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited)
{
    t_jrgba dynamicscolor = r_ob->j_dynamics_rgba;
    
    if (r_ob->j_mousedown_obj_type == k_DYNAMICS && r_ob->j_mousedown_ptr == chord)
        is_chord_selected = true;
    
    change_color_depending_on_part(r_ob, &dynamicscolor, notation_item_get_voice(r_ob, (t_notation_item *)chord));
    
    change_color_depending_on_group(r_ob, &dynamicscolor, chord, k_CHORD);
    
    change_color_depending_on_playlockmute(r_ob, &dynamicscolor, is_chord_selected, is_chord_played, is_chord_locked, is_chord_muted, is_chord_solo, is_chord_linear_edited);
    
    if (!is_chord_played && !is_chord_selected && chord && r_ob->link_nitemcolor_to_slot > 0 && r_ob->link_nitemcolor_to_slot <= CONST_MAX_SLOTS && chord->firstnote) {
        t_note *note = chord->firstnote;
        if (note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem && note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item) {
            if ((r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INT) || (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_INTLIST))
                dynamicscolor = long_to_color(*((long *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item));
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOAT)
                dynamicscolor = double_to_color(*((double *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item), r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[0], r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[1], false);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_FLOATLIST)
                dynamicscolor = floatlist_slot_to_color(&note->slot[r_ob->link_nitemcolor_to_slot-1]);
            else if (r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_type == k_SLOT_TYPE_COLOR)
                dynamicscolor = *((t_jrgba *)note->slot[r_ob->link_nitemcolor_to_slot-1].firstitem->item);
        }
    }
    
//    if (chord->firstnote)
//        apply_velocity_handling(r_ob, &annotationcolor, chord_get_max_velocity(r_ob, chord), is_chord_selected, is_chord_played);
    
    return dynamicscolor;
}





char chord_get_placement_in_screen(t_notation_obj *r_ob, t_chord *chord){
    double tuttipoint_x;

    if (!chord || !chord->parent || !chord->parent->tuttipoint_reference)
        return -2;
    
    tuttipoint_x = chord->parent->tuttipoint_reference->offset_ux;
    if (tuttipoint_x + chord->stem_offset_ux + chord->duration_ux >= r_ob->screen_ux_start - 300 / r_ob->zoom_x){
        if (tuttipoint_x + chord->stem_offset_ux - 20 / r_ob->zoom_x <= r_ob->screen_ux_end)
            return 0;
        else
            return 1;
    }
    return -1;
}

// typographical
void long_to_unicodeChars(t_notation_obj *r_ob, long number, unicodeChar* unichars, long *num_ascii_chars, long maxchars, char plus_sign) 
{
// fills <utfchars> with the unicodeChars related to the <number>, returns also the # of utfchars in <num_ascii_chars>. 
// No more than maxchars (typically, one can set maxchars is the length of the array unichars)
    char *ascii = (char *) bach_newptr(maxchars);
    long i, len;
    snprintf_zero(ascii, maxchars, "%ld", number);

    len = strlen(ascii); 
    if (len >= maxchars - 1) 
        len = plus_sign ? maxchars - 3 : maxchars - 2;  

    *num_ascii_chars = len;

    for (i = 0; i < len; i++) 
        unichars[i] = r_ob->notation_typo_preferences.numbers_unicode_characters[CLAMP(ascii[i] - 48, 0, 9)];

    if (plus_sign) {
        unichars[i++] = r_ob->notation_typo_preferences.plus_unicode_character;
//        *num_ascii_chars++;
    }

    // now i cannot be bigger than len+1, and len will surely be <= maxchars - 2, so we're sure that unichars[i] is correctly allocated
    unichars[i] = 0;
    bach_freeptr(ascii);
}

void llll_to_fixed_unicodeChar_array_and_free(t_llll *ll, long size, unicodeChar *array)
{
    if (ll) {
        llll_to_fixed_unicodeChar_array(ll, size, array);
        llll_free(ll);
    }
}

void llll_to_fixed_double_array_and_free(t_llll *ll, long size, double *array)
{
    if (ll) {
        llll_to_fixed_double_array(ll, size, array);
        llll_free(ll);
    }
}

void llll_to_fixed_char_array_and_free(t_llll *ll, long size, char *array)
{
    if (ll) {
        llll_to_fixed_char_array(ll, size, array);
        llll_free(ll);
    }
}


void set_all_unicode_characters(t_notation_obj *r_ob, long id, unicodeChar ucchar)
{
    r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_black = ucchar;
    r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_white = ucchar;
    r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_whole = ucchar;
    r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_doublewhole = ucchar;
}


// utility
// count = 4 expected: doublewhole, whole, half, quarter
void assign_noteheads_chars(t_notation_obj *r_ob, long count,...)
{
    long i; va_list ap;
    va_start(ap, count);
    for (i = 0; i < count; i++)
        set_all_unicode_characters(r_ob, i+1, (unicodeChar) va_arg(ap, long));
    va_end(ap);
}

// count = 4 expected: doublewhole, whole, half, quarter
void assign_noteheads_uwidths(t_notation_obj *r_ob, long count,...)
{
    long i; va_list ap;
    va_start(ap, count);
    for (i = 0; i < count; i++)
        r_ob->noteheads_typo_preferences.nhpref[i+1].uwidth = (double) va_arg(ap, double);
    va_end(ap);
}

void assign_noteheads_shifts(t_notation_obj *r_ob, double ux, double uy, double small_ux, double small_uy)
{
    long i;
    for (i = k_NOTEHEAD_DOUBLE_WHOLE_NOTE; i <= k_NOTEHEAD_BLACK_NOTE; i++) {
        r_ob->noteheads_typo_preferences.nhpref[i].ux_shift = ux;
        r_ob->noteheads_typo_preferences.nhpref[i].uy_shift = uy;
        r_ob->noteheads_typo_preferences.nhpref[i].small_ux_shift = small_ux;
        r_ob->noteheads_typo_preferences.nhpref[i].small_uy_shift = small_uy;
    }
}

void assign_noteheads_dl_start_shift(t_notation_obj *r_ob, double dlstartshift)
{
    long i;
    for (i = k_NOTEHEAD_DOUBLE_WHOLE_NOTE; i <= k_NOTEHEAD_BLACK_NOTE; i++) {
        r_ob->noteheads_typo_preferences.nhpref[i].durationline_start_ux_shift = dlstartshift;
    }
}


void set_notehead_names(t_noteheads_typo_preferences *ntp, long art_ID, t_symbol *fullname, t_symbol *shortname, t_symbol *alias1, t_symbol *alias2, t_symbol *alias3, t_symbol *alias4, t_symbol *alias5)
{
    ntp->nhpref[art_ID].fullname = fullname;
    ntp->nhpref[art_ID].shortname = shortname;
    ntp->nhpref[art_ID].alias[0] = alias1;
    ntp->nhpref[art_ID].alias[1] = alias2;
    ntp->nhpref[art_ID].alias[2] = alias3;
    ntp->nhpref[art_ID].alias[3] = alias4;
    ntp->nhpref[art_ID].alias[4] = alias5;
}


void load_noteheads_typo_preferences(t_notation_obj *r_ob, t_symbol *font)
{
    t_noteheads_typo_preferences *ntp = &r_ob->noteheads_typo_preferences;
    
    //assigning all names
    long i;
    double base_pt = 24;
    
    if (fontnameeq(font->s_name, "November for bach")) {
        assign_noteheads_chars(r_ob, 4, 'R', 'S', 'T', 'U');
        assign_noteheads_shifts(r_ob, -0.1, -3.6, 0., -4.2);
        assign_noteheads_uwidths(r_ob, 4, 9., 9., 7.5, 7.5);
        assign_noteheads_dl_start_shift(r_ob, -0.7);
        
    } else if (fontnameeq(font->s_name, "Bravura")) {
        assign_noteheads_chars(r_ob, 4, 57504, 57506, 57507, 57508);
        assign_noteheads_shifts(r_ob, 0., 18.3, 0., 3.2); // TO DO
        assign_noteheads_uwidths(r_ob, 4, 9., 9., 7.1, 7.1); // TO DO
        assign_noteheads_dl_start_shift(r_ob, -0.7); // TO DO
            
    } else if (fontnameeq(font->s_name, "Maestro")) {
        assign_noteheads_chars(r_ob, 4, 87, 119, 729, 339);
//        assign_noteheads_shifts(r_ob, 0.3, 4.9, 0.2, 3.2);
//        assign_noteheads_uwidths(r_ob, 4, 8., 8., 7.85, 7.85);
        assign_noteheads_shifts(r_ob, -0.3, 4.9, 0.2, 3.2);
        assign_noteheads_uwidths(r_ob, 4, 8., 8., 7.0, 7.0);
        assign_noteheads_dl_start_shift(r_ob, -0.7);

    } else if (fontnameeq(font->s_name, "Boulez")) {
        
        assign_noteheads_chars(r_ob, 4, 61527, 61559, 61690, 61647);
//        assign_noteheads_shifts(r_ob, 0.2, -0.15, 0.6, -0.4);
//        assign_noteheads_uwidths(r_ob, 4, 9.4, 8.4, 6.8, 6.8);
        assign_noteheads_shifts(r_ob, -0.2, -0.15, -0.05, -0.4);
        assign_noteheads_uwidths(r_ob, 4, 9.4, 8.4, 6.1, 6.1);
        assign_noteheads_dl_start_shift(r_ob, -0.55);

    } else if (fontnameeq(font->s_name, "Sonora")) {
        base_pt = 40;
        assign_noteheads_chars(r_ob, 4, 87, 87, 237, 339);
        assign_noteheads_shifts(r_ob, 0.2, 3.15, 0., 0.4);
        assign_noteheads_uwidths(r_ob, 4, 8., 7.6, 7.0, 7.0);
        assign_noteheads_dl_start_shift(r_ob, -0.55);

    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        
        assign_noteheads_chars(r_ob, 4, 87, 119, 729, 339);
//        assign_noteheads_shifts(r_ob, 0.25, 2.1, 0., 0.);
//        assign_noteheads_uwidths(r_ob, 4, 10.4, 9.4, 8.5, 8.5);
        assign_noteheads_shifts(r_ob, -0.4, 1.1, 0., 0.);
        assign_noteheads_uwidths(r_ob, 4, 10.4, 9.4, 7.6, 7.6);
        assign_noteheads_dl_start_shift(r_ob, -0.75);

    } else { // Petrucci preferences are loaded by default
        
        assign_noteheads_chars(r_ob, 4, 87, 119, 729, 339);
        assign_noteheads_shifts(r_ob, 0.2, 1.74, 0., 0.);
        assign_noteheads_uwidths(r_ob, 4, 8., 7.6, 7.1, 7.1);
        assign_noteheads_dl_start_shift(r_ob, -0.6);
    }
    
    // assigning all base pt
    for (i = 0; i < k_NUM_STANDARD_NOTEHEADS; i++) {
        ntp->nhpref[i].base_pt = base_pt;
    }
    
    for (i = 5; i < k_NUM_STANDARD_NOTEHEADS; i++) {
        ntp->nhpref[i].ux_shift = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].ux_shift;
        ntp->nhpref[i].uy_shift = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].uy_shift;
        ntp->nhpref[i].small_ux_shift = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].small_ux_shift;
        ntp->nhpref[i].small_uy_shift = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].small_uy_shift;
        ntp->nhpref[i].uwidth = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].uwidth;
        ntp->nhpref[i].durationline_start_ux_shift = ntp->nhpref[k_NOTEHEAD_BLACK_NOTE].durationline_start_ux_shift;
    }
    
    
    // STANDARD NOTEHEADS
    i = k_NOTEHEAD_DEFAULT;
    set_notehead_names(ntp, i, _sym_default, _sym_default);

    i = k_NOTEHEAD_DOUBLE_WHOLE_NOTE;
    set_notehead_names(ntp, i, gensym("doublewhole"), gensym("doublewhole"));

    i = k_NOTEHEAD_WHOLE_NOTE;
    set_notehead_names(ntp, i, gensym("whole"), gensym("whole"));

    i = k_NOTEHEAD_WHITE_NOTE;
    set_notehead_names(ntp, i, gensym("white"), gensym("white"), gensym("half"));

    i = k_NOTEHEAD_BLACK_NOTE;
    set_notehead_names(ntp, i, gensym("black"), gensym("black"), gensym("quarter"), gensym("quaver"), gensym("eighth"));

    
    /// NON-STANDARD ONES
    
    i = k_NOTEHEAD_CROSS; // *** NOTEHEAD: CROSS ***
    set_notehead_names(ntp, i, gensym("cross"), gensym("cross"), gensym("x"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 61632);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, 'X');
    } else {
        set_all_unicode_characters(r_ob, i, 191);
    }
    ntp->nhpref[i].uwidth -= 1.5;
    ntp->nhpref[i].uy_shift += 0.05;


    i = k_NOTEHEAD_DIAMOND;
    set_notehead_names(ntp, i, gensym("diamond"), gensym("diamond"), gensym("diam"), gensym("harmonic"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 61519);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, 'V');
    } else {
        set_all_unicode_characters(r_ob, i, 'O');
    }
    ntp->nhpref[i].uwidth -= 1.2;

    
    i = k_NOTEHEAD_NONE;
    set_notehead_names(ntp, i, gensym("none"), gensym("none"), gensym("invisible"));
    set_all_unicode_characters(r_ob, i, 0);
    ntp->nhpref[i].uwidth = 0;
    ntp->nhpref[i].ux_shift = 0;
    ntp->nhpref[i].durationline_start_ux_shift = 0;

    
    i = k_NOTEHEAD_ACCENT;
    set_notehead_names(ntp, i, gensym("accent"), gensym("acc"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 61502);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, '/');
    } else {
        set_all_unicode_characters(r_ob, i, 62);
    }
    ntp->nhpref[i].uwidth = 9.5;
    ntp->nhpref[i].durationline_start_ux_shift -= 0.2;
    ntp->nhpref[i].uy_shift -= 2.9;

    
    i = k_NOTEHEAD_PLUS;
    set_notehead_names(ntp, i, gensym("plus"), gensym("plus"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 61483);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, 'z');
    } else {
        set_all_unicode_characters(r_ob, i, 710);
    }

    
    i = k_NOTEHEAD_BLACK_SQUARE;
    set_notehead_names(ntp, i, gensym("blacksquare"), gensym("blacksquare"), gensym("blacksq"), gensym("bsquare"), gensym("bsq"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, 'Y');
    } else {
        set_all_unicode_characters(r_ob, i, 8211);
    }
    ntp->nhpref[i].uwidth -= 0.5;

    
    i = k_NOTEHEAD_WHITE_SQUARE;
    set_notehead_names(ntp, i, gensym("whitesquare"), gensym("whitesquare"), gensym("whitesq"), gensym("wsquare"), gensym("wsq"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, '\\');
    } else {
        set_all_unicode_characters(r_ob, i, '8800');
    }
    ntp->nhpref[i].uwidth -= 0.5;

    //    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
    i = k_NOTEHEAD_SQUARE;
    set_notehead_names(ntp, i, gensym("square"), gensym("square"), gensym("sq"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, '\\');
        ntp->nhpref[i].unicode_character_black = 'Y';
    } else {
        set_all_unicode_characters(r_ob, i, '8800');
        ntp->nhpref[i].unicode_character_black = 8211;
    }
    ntp->nhpref[i].uwidth -= 0.5;
// }
    
    i = k_NOTEHEAD_BLACK_RHOMBUS;
    set_notehead_names(ntp, i, gensym("blackrhombus"), gensym("blackrhombus"), gensym("blackrh"), gensym("brhombus"), gensym("brh"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, '[');
    } else {
        set_all_unicode_characters(r_ob, i, 8218);
    }
    ntp->nhpref[i].uwidth -= 1.3;

    
    i = k_NOTEHEAD_WHITE_RHOMBUS;
    set_notehead_names(ntp, i, gensym("whiterhombus"), gensym("whiterhombus"), gensym("whiterh"), gensym("wrhombus"), gensym("wrh"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, '^');
    } else {
        set_all_unicode_characters(r_ob, i, 183);
    }
    ntp->nhpref[i].uwidth -= 1.3;

    
//    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        i = k_NOTEHEAD_RHOMBUS;
        set_notehead_names(ntp, i, gensym("rhombus"), gensym("rhombus"), gensym("rh"));
        if (fontnameeq(font->s_name, "Boulez")) {
            set_all_unicode_characters(r_ob, i, 0);
        } else if (fontnameeq(font->s_name, "November for bach")) {
            set_all_unicode_characters(r_ob, i, '^');
            ntp->nhpref[i].unicode_character_black = '[';
        } else {
            set_all_unicode_characters(r_ob, i, 183);
            ntp->nhpref[i].unicode_character_black = 8218;
        }
        ntp->nhpref[i].uwidth -= 1.3;
//    }
    
    
    
    
    i = k_NOTEHEAD_BLACK_TRIANGLE;
    set_notehead_names(ntp, i, gensym("blacktriangle"), gensym("blacktriangle"), gensym("blacktri"), gensym("btri"), gensym("btriangle"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, 'Z');
    } else {
        set_all_unicode_characters(r_ob, i, 177);
    }
    ntp->nhpref[i].uwidth -= 0.5;
    ntp->nhpref[i].durationline_start_ux_shift -= 0.8;

    
    i = k_NOTEHEAD_WHITE_TRIANGLE;
    set_notehead_names(ntp, i, gensym("whitetriangle"), gensym("whitetriangle"), gensym("whitetri"), gensym("wtri"), gensym("wtriangle"));
    if (fontnameeq(font->s_name, "Boulez")) {
        set_all_unicode_characters(r_ob, i, 0);
    } else if (fontnameeq(font->s_name, "November for bach")) {
        set_all_unicode_characters(r_ob, i, ']');
    } else {
        set_all_unicode_characters(r_ob, i, 8212);
    }
    ntp->nhpref[i].uwidth -= 0.5;
    ntp->nhpref[i].durationline_start_ux_shift -= 0.8;

    
//    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        i = k_NOTEHEAD_TRIANGLE;
        set_notehead_names(ntp, i, gensym("triangle"), gensym("triangle"), gensym("tri"));
        if (fontnameeq(font->s_name, "Boulez")) {
            set_all_unicode_characters(r_ob, i, 0);
        } else if (fontnameeq(font->s_name, "November for bach")) {
            set_all_unicode_characters(r_ob, i, ']');
            ntp->nhpref[i].unicode_character_black = 'Z';
        } else {
            set_all_unicode_characters(r_ob, i, 8212);
            ntp->nhpref[i].unicode_character_black = 177;
        }
        ntp->nhpref[i].uwidth -= 0.5;
        ntp->nhpref[i].durationline_start_ux_shift -= 0.8;
//    }
    
    
    /*
    k_NOTEHEAD_DEFAULT = 0,
    k_NOTEHEAD_DOUBLE_WHOLE_NOTE,
    k_NOTEHEAD_WHOLE_NOTE,
    k_NOTEHEAD_WHITE_NOTE,
    k_NOTEHEAD_BLACK_NOTE,
    k_NOTEHEAD_CROSS,
    k_NOTEHEAD_DIAMOND,
    k_NOTEHEAD_NONE,
    k_NOTEHEAD_ACCENT,
    k_NOTEHEAD_PLUS,
    k_NOTEHEAD_BLACK_SQUARE,
    k_NOTEHEAD_WHITE_SQUARE,
    k_NOTEHEAD_BLACK_RHOMBOID,
    k_NOTEHEAD_WHITE_RHOMBOID,
    k_NOTEHEAD_BLACK_TRIANGLE,
    k_NOTEHEAD_WHITE_TRIANGLE,   
    k_NUM_STANDARD_NOTEHEADS,
 */
}


void set_notation_typo_preferences_from_llll(t_notation_obj *r_ob, t_llll *ll)
{
    t_llll *numberchars_ll = NULL, /* *noteheadchars_ll = NULL, */ *restchars_ll = NULL, *clefchars_ll = NULL, /* *noteheadwidths_ll = NULL, */
    *flagchars_ll = NULL, *flagwidths_ll = NULL, *flagyshifts_ll = NULL, *flagnoteheadalignments_ll = NULL;
    
    llll_parseargs((t_object *)r_ob, ll, "dddddddddddddllllll" /*"dddddddddddddddddllllllll" */,
                   gensym("basept"), &r_ob->notation_typo_preferences.base_pt,
                   gensym("timesigbasept"), &r_ob->notation_typo_preferences.base_pt_ts,
                   gensym("timesigyshift"), &r_ob->notation_typo_preferences.ts_uy_shift,
                   gensym("pluschar"), &r_ob->notation_typo_preferences.plus_unicode_character,
                   gensym("dotchar"), &r_ob->notation_typo_preferences.dot_unicode_character,
/*                   gensym("noteheadxshift"), &r_ob->notation_typo_preferences.notehead_ux_shift,
                   gensym("noteheadyshift"), &r_ob->notation_typo_preferences.notehead_uy_shift,
                   gensym("smallnoteheadxshift"), &r_ob->notation_typo_preferences.small_notehead_ux_shift,
                   gensym("smallnoteheadyshift"), &r_ob->notation_typo_preferences.small_notehead_uy_shift, */
                   gensym("restxshift"), &r_ob->notation_typo_preferences.rest_ux_shift,
                   gensym("restyshift"), &r_ob->notation_typo_preferences.rest_uy_shift,
                   gensym("clefxshift"), &r_ob->notation_typo_preferences.clef_ux_shift,
                   gensym("clefyshift"), &r_ob->notation_typo_preferences.clef_uy_shift,
                   gensym("clefyshift"), &r_ob->notation_typo_preferences.clef_uy_shift,
                   gensym("addflagupyshift"), &r_ob->notation_typo_preferences.further_flag_uy_step_stemup,
                   gensym("addflagdownyshift"), &r_ob->notation_typo_preferences.further_flag_uy_step_stemdown,
                   gensym("flagxshift"), &r_ob->notation_typo_preferences.flag_ux_shift,
                   
                   gensym("numberchars"), &numberchars_ll,
/*                   gensym("noteheadchars"), &noteheadchars_ll, */
                   gensym("restchars"), &restchars_ll,
                   gensym("clefchars"), &clefchars_ll,
                   gensym("flagchars"), &flagchars_ll,
/*                   gensym("noteheadwidths"), &noteheadwidths_ll, */
                   gensym("flagwidths"), &flagwidths_ll,
                   gensym("flagyshifts"), &flagyshifts_ll,
                   gensym("flagnoteheadalignments"), &flagnoteheadalignments_ll
                   );
    
    llll_to_fixed_unicodeChar_array_and_free(numberchars_ll, 10, r_ob->notation_typo_preferences.numbers_unicode_characters);
//    llll_to_fixed_unicodeChar_array_and_free(noteheadchars_ll, 4, r_ob->notation_typo_preferences.noteheads_unicode_characters);
    llll_to_fixed_unicodeChar_array_and_free(restchars_ll, 9, r_ob->notation_typo_preferences.rests_unicode_characters);
    llll_to_fixed_unicodeChar_array_and_free(clefchars_ll, 4, r_ob->notation_typo_preferences.clefs_unicode_characters);
    llll_to_fixed_unicodeChar_array_and_free(flagchars_ll, 6, r_ob->notation_typo_preferences.flag_unicode_characters);
//    llll_to_fixed_double_array_and_free(noteheadwidths_ll, 4, r_ob->notation_typo_preferences.notehead_uwidths);
    llll_to_fixed_double_array_and_free(flagwidths_ll, 3, r_ob->notation_typo_preferences.flag_uwidths);
    llll_to_fixed_double_array_and_free(flagyshifts_ll, 6, r_ob->notation_typo_preferences.flag_uy_shifts);
    llll_to_fixed_char_array_and_free(flagyshifts_ll, 6, r_ob->notation_typo_preferences.flag_noteheadaligned);


}


void load_notation_typo_preferences(t_notation_obj *r_ob, t_symbol *font)
{
    double juce_mul = 1;
//    fill_double_array(r_ob->notation_typo_preferences.rest_uwidths, 9, 7.3, 7.3, 7.3, 7.1, 7.0, 7.1,  7.8,  8.7,   9.6);
    fill_double_array(r_ob->notation_typo_preferences.rest_uwidths, 9, 7.3, 7.7, 7.7, 7.1, 8.1, 8.6,  9.1,  9.4,   10.);
    
    if (fontnameeq(font->s_name, "November for bach")) {
#ifdef BACH_JUCE
        juce_mul = 2.5;
#endif
//        double add_y_shift = 8.5;
        r_ob->notation_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->notation_typo_preferences.base_pt_ts = 24. * juce_mul;
        r_ob->notation_typo_preferences.ts_uy_shift = -20.1;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57);
        r_ob->notation_typo_preferences.plus_unicode_character = 'z';
        r_ob->notation_typo_preferences.dot_unicode_character = 46;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 'R', 'S', 'T', 'U'); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.3;
//        r_ob->notation_typo_preferences.notehead_uy_shift = -4.9 + add_y_shift; //-5.1;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.2;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = -4.3 + add_y_shift;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 7.75;
        //        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 7.5, 7.5, 7.6, 7.6); // was THIS!
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 8., 8., 7.9, 7.9);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 'C','D', 'E', 'F', 'G', 'H', 'I', 'J', 'K');
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 'A', '?', 'B', '@');
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -2.9; //-0.1;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 'L', 'O', 'N', 'Q', 'M', 'P');
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.5, 4.5, 4.5); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -29.4+6, -21.+12, -29.4+6, -21.+12, -32.9+6, -18.4+12);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -4.; //55;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 4.; //55;
        
    } else if (fontnameeq(font->s_name, "Bravura")) {
        r_ob->notation_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->notation_typo_preferences.base_pt_ts = 24. * juce_mul;
        r_ob->notation_typo_preferences.ts_uy_shift = -42; // TO DO
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 57472, 57473, 57474, 57475, 57476, 57477, 57478, 57479, 57480, 57481);
        r_ob->notation_typo_preferences.plus_unicode_character = 57484;
        r_ob->notation_typo_preferences.dot_unicode_character = 57852;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.; // TO DO
        r_ob->notation_typo_preferences.rest_uy_shift = 18.3; // TO DO
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 58594, 58595, 58596, 58597, 58598, 58599, 58600, 58601, 58602);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 57424, 57442, 57436, 57450);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.; // TO DO
        r_ob->notation_typo_preferences.clef_uy_shift = 4.4;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); // TO DO
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 57920, 57921, 57922, 57923, 57936, 57937);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.5, 4.5, 4.5); // TO DO
        r_ob->notation_typo_preferences.flag_ux_shift = 0.; // TO DO
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -29.4+6, -21.+12, -29.4+6, -21.+12, -32.9+6, -18.4+12);  // TO DO: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -4.; // TO DO
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 4.; // TO DO
        
    } else if (fontnameeq(font->s_name, "Maestro")) {
#ifdef BACH_JUCE
        juce_mul = 2.5;
#endif
        r_ob->notation_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->notation_typo_preferences.base_pt_ts = 24. * juce_mul;
        r_ob->notation_typo_preferences.ts_uy_shift = -28.55;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57);
        r_ob->notation_typo_preferences.plus_unicode_character = 710;
        r_ob->notation_typo_preferences.dot_unicode_character = 46;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 87, 119, 729, 339); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.3;
//        r_ob->notation_typo_preferences.notehead_uy_shift = -4.9; //-5.1;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.2;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = -3.2;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = -1.;
        //        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 7.5, 7.5, 7.6, 7.6); // was THIS!
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 8., 8., 7.85, 7.85);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 8222, 8721, 211, 338, 8240, 8776, 174, 217, 194);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 38, 63, 66, 247);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -0.2; //-0.1;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 61546, 61680, 61554, 61522, 61515, 212);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.5, 4.5, 4.5); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -29.4, -21., -29.4, -21., -32.9, -18.4);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -4.55;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 4.55;
        
    } else if (fontnameeq(font->s_name, "Boulez")) {
        // OLD VERSION
#ifdef BACH_MAX
        r_ob->notation_typo_preferences.base_pt = 24.;
        r_ob->notation_typo_preferences.base_pt_ts = 24.;
        r_ob->notation_typo_preferences.ts_uy_shift = -23.5;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 61488, 61489, 61490, 61491, 61492, 61493, 61494, 61495, 61496, 61497);
        r_ob->notation_typo_preferences.plus_unicode_character = 61483;
        r_ob->notation_typo_preferences.dot_unicode_character = 61486;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 61527, 61559, 61690, 61647); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.2;
//        r_ob->notation_typo_preferences.notehead_uy_shift = 0.15;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.6;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = 0.4;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 4.4;
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 9.4, 8.4, 6.8, 6.8);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 61666, 61623, 61678, 61646, 61668, 61637, 61608, 61684, 61669);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 61478, 61503, 61506, 61654);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -1.8;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 61515, 61514, 61554, 61522, 61546, 61679);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4., 4., 4.); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -24.4, -15.5, -24.4, -15.5, -29.9, -8.6);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -5.55;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 5.55;
#endif
#ifdef BACH_JUCE
        r_ob->notation_typo_preferences.base_pt = 48.;
        r_ob->notation_typo_preferences.base_pt_ts = 48.;
        r_ob->notation_typo_preferences.ts_uy_shift = -23.5;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 61488, 61489, 61490, 61491, 61492, 61493, 61494, 61495, 61496, 61497);
        r_ob->notation_typo_preferences.plus_unicode_character = 61483;
        r_ob->notation_typo_preferences.dot_unicode_character = 61486;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 61527, 61559, 61690, 61647); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.2;
//        r_ob->notation_typo_preferences.notehead_uy_shift = 0.45;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.6;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = 0.4;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 4.0;
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 8.0, 7.0, 6.8, 6.8);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 61666, 61623, 61678, 61646, 61668, 61637, 61608, 61684, 61669);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 61478, 61503, 61506, 61654);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -1.8;
        r_ob->notation_typo_preferences.stem_unicode_character = 61532; 
        r_ob->notation_typo_preferences.stem_ux_shift = 0.; 
        r_ob->notation_typo_preferences.stem_ux_adjust = 0.; 
        r_ob->notation_typo_preferences.stem_uy_shift_stemup = -14.0; 
        r_ob->notation_typo_preferences.stem_uy_shift_stemdown = -11.0;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 61515, 61514, 61554, 61522, 61546, 61679);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4., 4., 4.); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -27.4, -15.5, -27.4, -15.5, -32.9, -8.6);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -5.55;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 5.55;
#endif
     } else if (fontnameeq(font->s_name, "Sonora")) {
        r_ob->notation_typo_preferences.base_pt = 40.;
        r_ob->notation_typo_preferences.base_pt_ts = 38.2;
        r_ob->notation_typo_preferences.ts_uy_shift = -25.57;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57);
        r_ob->notation_typo_preferences.plus_unicode_character = 233;
        r_ob->notation_typo_preferences.dot_unicode_character = 46;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 87, 87, 237, 339); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.2; //31;
//        r_ob->notation_typo_preferences.notehead_uy_shift = -3.15;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = -0.4;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 1.2;
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 8., 7.6, 7.0, 7.0);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 8222, 931, 211, 338, 8240, 8776, 174, 217, 194);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 38, 63, 66, 247);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -0.6;
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 1, 0, 0, 0);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 106, 74, 105, 73, 106, 74);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.2, 4.2, 4.2); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.; 
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -25.4, -30., -15.4, -31.5, -33.9, -21.1);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -5.5;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 5.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        r_ob->notation_typo_preferences.base_pt = 24.;
        r_ob->notation_typo_preferences.base_pt_ts = 24.;
        r_ob->notation_typo_preferences.ts_uy_shift = -26.;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57);
        r_ob->notation_typo_preferences.plus_unicode_character = 710;
        r_ob->notation_typo_preferences.dot_unicode_character = 46;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 87, 119, 729, 339); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.25;
//        r_ob->notation_typo_preferences.notehead_uy_shift = -2.1;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = 0.;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 2.1;
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 10.4, 9.4, 8.5, 8.5);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 8222, 8721, 211, 338, 8240, 8776, 174, 217, 194);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 38, 63, 66, 247);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -1.1;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 106, 74, 114, 82, 75, 212);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.5, 4.5, 4.5); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -27.4, -15.5, -27.4, -15.5, -32.9, -9.6);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -4.85;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 4.85;
    } else { // Petrucci preferences are loaded by default
        r_ob->notation_typo_preferences.base_pt = 24.;
        r_ob->notation_typo_preferences.base_pt_ts = 23.6;
        r_ob->notation_typo_preferences.ts_uy_shift = -25.11;
        fill_unicodeChar_array(r_ob->notation_typo_preferences.numbers_unicode_characters, 10, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57);
        r_ob->notation_typo_preferences.plus_unicode_character = 710;
        r_ob->notation_typo_preferences.dot_unicode_character = 46;
//        fill_unicodeChar_array(r_ob->notation_typo_preferences.noteheads_unicode_characters, 4, 87, 119, 729, 339); // doublewhole, whole, half, quarter
//        r_ob->notation_typo_preferences.notehead_ux_shift = 0.2; // was 0.4
//        r_ob->notation_typo_preferences.notehead_uy_shift = -1.74;
//        r_ob->notation_typo_preferences.small_notehead_ux_shift = 0.;
//        r_ob->notation_typo_preferences.small_notehead_uy_shift = 0.;
        r_ob->notation_typo_preferences.rest_ux_shift = 0.;
        r_ob->notation_typo_preferences.rest_uy_shift = 2.4; 
//        fill_double_array(r_ob->notation_typo_preferences.notehead_uwidths, 4, 8., 7.6, 7.1, 7.1);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.rests_unicode_characters, 9, 8222, 8721, 211, 338, 8240, 8776, 174, 217, 194);
        fill_unicodeChar_array(r_ob->notation_typo_preferences.clefs_unicode_characters, 4, 38, 63, 66, 247);
        r_ob->notation_typo_preferences.clef_ux_shift = 0.;
        r_ob->notation_typo_preferences.clef_uy_shift = -1.25; //-1.1;
        // here we put the info about, in the following order: 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        // the 1/16 flags are the COMPLETE 1/16 flags (which means, with two "tails"), the "next flag" is an added single flag used for 1/32, and then for all the smaller subdivisions 
        fill_char_array(r_ob->notation_typo_preferences.flag_noteheadaligned, 6, 0, 0, 0, 0, 0, 0); 
        fill_unicodeChar_array(r_ob->notation_typo_preferences.flag_unicode_characters, 6, 106, 63743, 114, 82, 75, 212);
        fill_double_array(r_ob->notation_typo_preferences.flag_uwidths, 3, 4.5, 4.5, 4.5); // 1/8, 1/16, next 
        r_ob->notation_typo_preferences.flag_ux_shift = 0.;
        fill_double_array(r_ob->notation_typo_preferences.flag_uy_shifts, 6, -27.4, -15.5, -27.4, -15.5, -32.9, -10.6);  // 1/8 flag up / down / 1/16 flag up / down / next flags up / down
        r_ob->notation_typo_preferences.further_flag_uy_step_stemup = -4.85;
        r_ob->notation_typo_preferences.further_flag_uy_step_stemdown = 4.85;
        
        if (!(fontnameeq(font->s_name, "Petrucci")))
            object_warn((t_object *) r_ob, "Warning: font %s is not supported as notation font.", font->s_name);
    }
}

void set_articulation_names(t_articulations_typo_preferences *atp, long art_ID, t_symbol *fullname, t_symbol *shortname, t_symbol *alias1, t_symbol *alias2, t_symbol *alias3, t_symbol *alias4, t_symbol *alias5)
{
    atp->artpref[art_ID].fullname = fullname;
    atp->artpref[art_ID].shortname = shortname;
    atp->artpref[art_ID].alias[0] = alias1;
    atp->artpref[art_ID].alias[1] = alias2;
    atp->artpref[art_ID].alias[2] = alias3;
    atp->artpref[art_ID].alias[3] = alias4;
    atp->artpref[art_ID].alias[4] = alias5;
}

void load_articulations_typo_preferences(t_articulations_typo_preferences *atp, t_symbol *font)
{
    long i;
    
    // Setting all xml fields to none: for standard articulations they will be handled directly by the export xml function
    for (i = 0; i < k_NUM_STANDARD_ARTICULATIONS; i++)
        atp->artpref[i].xmlarticulations = atp->artpref[i].xmlornament = atp->artpref[i].xmltechnical = _llllobj_sym_none;
    
    i = k_ARTICULATION_NONE; // *** ARTICULATION: NONE ***
    set_articulation_names(atp, i, _sym_none, _sym_none);
    atp->artpref[i].main_char = 0;
    atp->artpref[i].flipped_char = 0;
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_MANUAL;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 0.;
    atp->artpref[i].extension_line_char = 0;
    atp->artpref[i].base_pt = 24.;
    
    i = k_ARTICULATION_STACCATO; // *** ARTICULATION: STACCATO ***
    set_articulation_names(atp, i, gensym("staccato"), gensym("stacc"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61486;
        atp->artpref[i].flipped_char = 61486;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 46;
        atp->artpref[i].flipped_char = 46;
    } else {
        atp->artpref[i].main_char = 46;
        atp->artpref[i].flipped_char = 46;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_AVOID_STAFF_LINES + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34.7;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.4;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.6;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.8;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.4;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 2;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_ACCENT; // *** ARTICULATION: ACCENT ***
    set_articulation_names(atp, i, gensym("accent"), gensym("acc"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61502;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 47;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 62;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
        atp->artpref[i].main_char_uy_shift = 0.;
        atp->artpref[i].flipped_char_uy_shift = -1.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 24;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 1.5;
        atp->artpref[i].flipped_char_uy_shift = -1.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 30;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 30;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    }
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_PORTATO; // *** ARTICULATION: PORTATO ***
    set_articulation_names(atp, i, gensym("portato"), gensym("port"), gensym("por"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61485;
        atp->artpref[i].flipped_char = 61485;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 45;
    } else {
        atp->artpref[i].main_char = 45;
        atp->artpref[i].flipped_char = 45;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_AVOID_STAFF_LINES + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34.2;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].main_char_uy_shift = 4.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.5;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32.0;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 1;
    atp->artpref[i].extension_line_char = 0;
    
#ifdef BACH_MAX
    i = k_ARTICULATION_TRILL; // *** ARTICULATION: TRILL ***
    set_articulation_names(atp, i, gensym("trill"), gensym("tr"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 169;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 22;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 12;
#endif
#ifdef BACH_JUCE
    i = k_ARTICULATION_TRILL; // *** ARTICULATION: TRILL ***
    set_articulation_names(atp, i, gensym("trill"), gensym("tr"));
    atp->artpref[i].base_pt = 48.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 22;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 12;
#endif
    
    
    i = k_ARTICULATION_TRILL_NATURAL; // *** ARTICULATION: TRILL NATURAL ***
    set_articulation_names(atp, i, gensym("trilln"), gensym("trn"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 172;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 14;
    
    
    i = k_ARTICULATION_TRILL_FLAT; // *** ARTICULATION: TRILL FLAT ***
    set_articulation_names(atp, i, gensym("trillb"), gensym("trb"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 171;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 14;
    
    
    i = k_ARTICULATION_TRILL_SHARP; // *** ARTICULATION: TRILL SHARP ***
    set_articulation_names(atp, i, gensym("trill#"), gensym("tr#"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 179;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 14;

    
    i = k_ARTICULATION_TRILL_DOUBLE_FLAT; // *** ARTICULATION: TRILL DOUBLE FLAT ***
    set_articulation_names(atp, i, gensym("trillbb"), gensym("trbb"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 0;
        atp->artpref[i].flipped_char = 0;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 170;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 14;
    
    
    i = k_ARTICULATION_TRILL_DOUBLE_SHARP; // *** ARTICULATION: TRILL DOUBLE SHARP ***
    set_articulation_names(atp, i, gensym("trillx"), gensym("trx"), gensym("tr##"), gensym("trill##"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61657;
        atp->artpref[i].flipped_char = 61657;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 174;
    } else {
        atp->artpref[i].main_char = 376;
        atp->artpref[i].flipped_char = 376;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_SPAN_TIES;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].main_char_uy_shift = 4.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_uy_shift = 4.; // unused
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 0;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].extension_line_char = 61566;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21;
        atp->artpref[i].extension_line_char = 168;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].extension_line_char = 126;
        atp->artpref[i].extension_line_uy_offset = 3.5;
    }
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 14;
    
    
    
    i = k_ARTICULATION_FERMATA; // *** ARTICULATION: FERMATA ***
    set_articulation_names(atp, i, gensym("fermata"), gensym("ferm"), gensym("corona"));
    atp->artpref[i].base_pt = 22.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61525;
        atp->artpref[i].flipped_char = 61557;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 95;
        atp->artpref[i].flipped_char = 96;
    } else {
        atp->artpref[i].main_char = 85;
        atp->artpref[i].flipped_char = 117;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_COPY_WHEN_SPLIT;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 28;
        atp->artpref[i].flipped_uy_center = 36;
        atp->artpref[i].main_uheight = 9;
        atp->artpref[i].flipped_uheight = 9;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = 24;
        atp->artpref[i].flipped_uy_center = 32;
        atp->artpref[i].main_uheight = 10;
        atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = 19;
        atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = 10;
        atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 26;
        atp->artpref[i].flipped_uy_center = 33;
        atp->artpref[i].main_uheight = 9;
        atp->artpref[i].flipped_uheight = 9;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = 25;
        atp->artpref[i].flipped_uy_center = 33;
        atp->artpref[i].main_uheight = 9;
        atp->artpref[i].flipped_uheight = 9;
    }
    atp->artpref[i].main_char_uy_shift = 5.;
    atp->artpref[i].flipped_char_uy_shift = -5.;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_ACCENT_STACCATO; // *** ARTICULATION: ACCENT+STACCATO ***
    set_articulation_names(atp, i, gensym("accentstaccato"), gensym("accstacc"), gensym("staccatoaccent"), gensym("staccacc"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61502; // unsupported for boulez
        atp->artpref[i].flipped_char = 61502;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 36;
        atp->artpref[i].flipped_char = 35;
    } else {
        atp->artpref[i].main_char = 728;
        atp->artpref[i].flipped_char = 64258;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 32;
        atp->artpref[i].flipped_uy_center = 30.7;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 23;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 30;
        atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    }
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_ACCENT_PORTATO; // *** ARTICULATION: ACCENT+PORTATO ***
    set_articulation_names(atp, i, gensym("accentportato"), gensym("accport"), gensym("portatoaccent"), gensym("portacc"), gensym("poracc"), gensym("accpor"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61502; // unsupported: changed to accent
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 38;
        atp->artpref[i].flipped_char = 37;
    } else if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_char = 228;
        atp->artpref[i].flipped_char = 226;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_char = 730;
        atp->artpref[i].flipped_char = 63743;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 62; // unsupported: changed to accent
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 31;
        atp->artpref[i].flipped_uy_center = 31.7;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8.5;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 24;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 29;
        atp->artpref[i].flipped_uy_center = 36;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 30;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 0.5;
        atp->artpref[i].flipped_char_uy_shift = -1.;
    }
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_PORTATO_STACCATO; // *** ARTICULATION: PORTATO+STACCATO ***
    set_articulation_names(atp, i, gensym("staccatoportato"), gensym("staccport"), gensym("portatostaccato"), gensym("portstacc"), gensym("porstacc"), gensym("staccpor"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61485; // unsupported: just portato
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 34;
        atp->artpref[i].flipped_char = 33;
    } else {
        atp->artpref[i].main_char = 175;
        atp->artpref[i].flipped_char = 60;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 33.5;
        atp->artpref[i].flipped_uy_center = 32.7;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 1;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 24;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
        atp->artpref[i].main_char_uy_shift = 2.5;
        atp->artpref[i].flipped_char_uy_shift = -2.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 30;
        atp->artpref[i].flipped_uy_center = 30.4;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = 30;
        atp->artpref[i].flipped_uy_center = 30;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 4.5;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_STACCATISSIMO; // *** ARTICULATION: STACCATISSIMO ***
    set_articulation_names(atp, i, gensym("staccatissimo"), gensym("staccmo"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61614;
        atp->artpref[i].flipped_char = 61479;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 125;
        atp->artpref[i].flipped_char = 126;
    } else {
        atp->artpref[i].main_char = 198;
        atp->artpref[i].flipped_char = 39;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 33;
        atp->artpref[i].flipped_uy_center = 32.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = 31;
        atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 3;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = 26;
        atp->artpref[i].flipped_uy_center = 25;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 3.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 33;
        atp->artpref[i].flipped_uy_center = 31;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 3.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = 32;
        atp->artpref[i].flipped_uy_center = 31;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 3.5;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_MARTELLATO; // *** ARTICULATION: MARTELLATO ***
    set_articulation_names(atp, i, gensym("martellato"), gensym("mart"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61534;
        atp->artpref[i].flipped_char = 61558;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 39;
        atp->artpref[i].flipped_char = 40;
    } else {
        atp->artpref[i].main_char = 94;
        atp->artpref[i].flipped_char = 118;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 32.5;
        atp->artpref[i].flipped_uy_center = 32.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = 25;
        atp->artpref[i].flipped_uy_center = 25.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = 23;
        atp->artpref[i].flipped_uy_center = 20;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 27.5;
        atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = 27;
        atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_MARTELLATO_STACCATO; // *** ARTICULATION: MARTELLATO+STACCATO ***
    set_articulation_names(atp, i, gensym("martellatostaccato"), gensym("martstacc"), gensym("staccatomartellato"), gensym("staccmart"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = 61534; // unsupported: martellato
        atp->artpref[i].flipped_char = 61558;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = 41;
        atp->artpref[i].flipped_char = 42;
    } else {
        atp->artpref[i].main_char = 168;
        atp->artpref[i].flipped_char = 203;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = 32;
        atp->artpref[i].flipped_uy_center = 31.8;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = 25;
        atp->artpref[i].flipped_uy_center = 25.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = 23;
        atp->artpref[i].flipped_uy_center = 20;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = 27.5;
        atp->artpref[i].flipped_uy_center = 27.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = 27;
        atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_MORDENT_UP; // *** ARTICULATION: MORDENT UP ***
    set_articulation_names(atp, i, gensym("upmordent"), gensym("umord"), gensym("mordent"), gensym("mord"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61549;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 163;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 109;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 23;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_MORDENT_DOWN; // *** ARTICULATION: MORDENT DOWN ***
    set_articulation_names(atp, i, gensym("downmordent"), gensym("dmord"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61517;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 164;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 77;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 23;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 8;
    }
    atp->artpref[i].main_char_uy_shift = 2.5;
    atp->artpref[i].flipped_char_uy_shift = -2.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_DOUBLE_MORDENT; // *** ARTICULATION: DOUBLE MORDENT ***
    set_articulation_names(atp, i, gensym("doublemordent"), gensym("mmord"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61621;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 165;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 181;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 6.5;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 23;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    }
    atp->artpref[i].main_char_uy_shift = 4;
    atp->artpref[i].flipped_char_uy_shift = -4;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_GRUPPETTO; // *** ARTICULATION: GRUPPETTO ***
    set_articulation_names(atp, i, gensym("gruppetto"), gensym("grupp"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61524;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 166;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 84;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_OUTSIDE_STAFF + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 35.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 26.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 33;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7.5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 32.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    }
    atp->artpref[i].main_char_uy_shift = 4;
    atp->artpref[i].flipped_char_uy_shift = -4;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_HARMONIC; // *** ARTICULATION: HARMONIC ***
    set_articulation_names(atp, i, gensym("harmonic"), gensym("harm"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61551;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 44;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 111;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD + k_ARTICULATION_OPTION_AVOID_STAFF_LINES + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_COPY_WHEN_SPLIT;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34.7;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.6;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.8;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.8;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.6;
    }
    atp->artpref[i].main_char_uy_shift = 3.5;
    atp->artpref[i].flipped_char_uy_shift = -3.5;
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 4;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_LEFT_HAND_PIZZICATO; // *** ARTICULATION: LEFT HAND PIZZICATO ***
    set_articulation_names(atp, i, gensym("lefthandpizzicato"), gensym("lhpizz"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61483;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 123;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 43;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD + k_ARTICULATION_OPTION_AVOID_STAFF_LINES + k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 34.9;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.7;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.7;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.9;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.7;
    }
    atp->artpref[i].main_char_uy_shift = 3.5;
    atp->artpref[i].flipped_char_uy_shift = -3.5;
    atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_BOWING_UP; // *** ARTICULATION: BOWING UP ***
    set_articulation_names(atp, i, gensym("upbowing"), gensym("ubow"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61618;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 62;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 8804;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_OUTSIDE_STAFF;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.9;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 11;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 24.8;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.9;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 11;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    }
    atp->artpref[i].main_char_uy_shift = 3.5;
    atp->artpref[i].flipped_char_uy_shift = -3.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_BOWING_DOWN; // *** ARTICULATION: BOWING DOWN ***
    set_articulation_names(atp, i, gensym("downbowing"), gensym("dbow"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61619;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 121;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 8805;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_CENTER_OVER_NOTE + k_ARTICULATION_OPTION_OUTSIDE_STAFF;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 30.9;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 9;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.9;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.5;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 10;
    }
    atp->artpref[i].main_char_uy_shift = 3.5;
    atp->artpref[i].flipped_char_uy_shift = -3.5;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_TREMOLO3; // *** ARTICULATION: TREMOLO WITH 3 LINES ***
    set_articulation_names(atp, i, gensym("tremolo3"), gensym("trem3"), gensym("trem"), gensym("tremolo"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61472; // unsupported
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 60;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 230;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_CENTER_OVER_STEM + k_ARTICULATION_OPTION_COPY_WHEN_SPLIT + k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.3;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 15;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 1;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 20.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 12;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 26.4;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 13;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 26.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 12;
    }
    atp->artpref[i].main_char_uy_shift = 4;
    atp->artpref[i].flipped_char_uy_shift = -4;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_TREMOLO2; // *** ARTICULATION: TREMOLO WITH 2 LINES ***
    set_articulation_names(atp, i, gensym("tremolo2"), gensym("trem2"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61472; // unsupported
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 59;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 64;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_CENTER_OVER_STEM + k_ARTICULATION_OPTION_COPY_WHEN_SPLIT + k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29.7;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 11;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 25.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 1;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 21.6;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 9;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.6;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 9;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 9;
    }
    atp->artpref[i].main_char_uy_shift = 4;
    atp->artpref[i].flipped_char_uy_shift = -4;
    atp->artpref[i].extension_line_char = 0;
    
    
    i = k_ARTICULATION_TREMOLO1; // *** ARTICULATION: TREMOLO WITH 1 LINE ***
    set_articulation_names(atp, i, gensym("tremolo1"), gensym("trem1"));
    atp->artpref[i].base_pt = 24.;
    if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 61472; // unsupported
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 58;
    } else {
        atp->artpref[i].main_char = atp->artpref[i].flipped_char = 33;
    }
    atp->artpref[i].positioning = k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG;
    atp->artpref[i].options = k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD + k_ARTICULATION_OPTION_CENTER_OVER_STEM + k_ARTICULATION_OPTION_COPY_WHEN_SPLIT + k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS;
    atp->artpref[i].main_char_ux_shift = 0.;
    atp->artpref[i].flipped_char_ux_shift = 0.;
    atp->artpref[i].outside_staff_uy_nudge = 0.;
    if (fontnameeq(font->s_name, "Maestro")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 31.7;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 7;
    } else if (fontnameeq(font->s_name, "Boulez")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 27.2;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 1;
    } else if (fontnameeq(font->s_name, "November for bach")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 24;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 28.6;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
    } else { // petrucci & others
        atp->artpref[i].main_uy_center = atp->artpref[i].flipped_uy_center = 29;
        atp->artpref[i].main_uheight = atp->artpref[i].flipped_uheight = 5;
    }
    atp->artpref[i].main_char_uy_shift = 4;
    atp->artpref[i].flipped_char_uy_shift = -4;
    atp->artpref[i].extension_line_char = 0;
}

void load_accidentals_typo_preferences(t_notation_obj *r_ob, t_symbol *font)
{

#ifdef BACH_MAX
    double juce_mul = 1;
#endif
    // bogus character (it'll be Arial font)
    r_ob->accidentals_typo_preferences.unicode_bogus_character = 111; // 111 ?
    r_ob->accidentals_typo_preferences.bogus_top_uextension = 3.2;
    r_ob->accidentals_typo_preferences.bogus_bottom_uextension = 3.2;
    r_ob->accidentals_typo_preferences.bogus_uwidth = 6;

    if (fontnameeq(font->s_name, "November for bach")) {
#ifdef BACH_JUCE
        double juce_mul = 2.5;
#endif
        // TO DO: to calibrate
        r_ob->accidentals_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 15.0; // 23.2; //49.8;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 8;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        //        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 61626, 0, 0, 0, 61538, 0, 0, 0, 110, 0, 0, 0, 61475, 0, 0, 0, 61660);
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 'a', 'b', 'c', 'e', 'f', 'h', 'i', 'k', 'l', 'm', 'o', 'p', 'r', 's', 'u', 'v', 'w');
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 
                                                                                                8.5, 14.5, 8.3, 14.5, 8.5, 14.5, 9.3, 14.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 12.5, 3.5, 12.5, 3.5, 12.5, 3.5, 14.5, 
                                                                                                8.5, 8.5, 8.3, 8.3, 8.5, 8.5, 9.5, 9.5, 3.5);
//        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5,
//                                                                                        8.9, 
//                                                                                        10, 8.5, 10, 8.9, 10, 9.5, 11, 3.5);
//        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17,    3.5, 6.5, 3.5, 6.5, 3.5, 6.5, 3.5, 9,
//                                                                                            8.9, 
//                                                                                            8.9, 8.5, 8.5, 8.9, 8.9, 9.5, 9.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 12.4, 12.4, 6.5, 6., 6.5, 6., 7., 7., 7., 5., 5., 7., 7., 9., 9., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 'a', 0, 0, 'f', 0, 0, 'l', 0, 0, 'r', 0, 0, 'w'); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
        
    } else if (fontnameeq(font->s_name, "Bravura")) {
#ifdef BACH_JUCE
        double juce_mul = 2.5;
#endif
        r_ob->accidentals_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->accidentals_typo_preferences.ux_shift = 0.; // TO DO
        r_ob->accidentals_typo_preferences.uy_shift = 48.5; // TO DO
        r_ob->accidentals_typo_preferences.binary_characters_depth = 8; // TO DO
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1; // TO DO
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 57956, 57976, 57985, 57969, 57952, 57968, 57984, 57971, 57953, 57970, 57986, 57973, 57954, 57972, 57987, 57975, 57955);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5,
                          8.5, 14.5, 8.3, 14.5, 8.5, 14.5, 9.3, 14.5, 3.5); // TO DO
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 12.5, 3.5, 12.5, 3.5, 12.5, 3.5, 14.5,
                          8.5, 8.5, 8.3, 8.3, 8.5, 8.5, 9.5, 9.5, 3.5); // TO DO
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 12.4, 12.4, 6.5, 6., 6.5, 6., 7., 7., 7., 5., 5., 7., 7., 9., 9., 7.); // TO DO
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 'a', 0, 0, 'f', 0, 0, 'l', 0, 0, 'r', 0, 0, 'w');
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
        
    } else if (fontnameeq(font->s_name, "Maestro")) {
#ifdef BACH_JUCE
        double juce_mul = 2.5;
#endif
        // TO DO: to calibrate
        r_ob->accidentals_typo_preferences.base_pt = 24. * juce_mul;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 24.0; // 23.2; //49.8;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 2;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
//        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 61626, 0, 0, 0, 61538, 0, 0, 0, 110, 0, 0, 0, 61475, 0, 0, 0, 61660);
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 61626, 0, 0, 0, 0x0062, 0, 0, 0, 110, 0, 0, 0, 61475, 0, 0, 0, 61660);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 0., 0., 0., 10.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 0., 0., 0., 3.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 0., 0., 0., 6., 0., 0., 0., 6., 0., 0., 0., 7., 0., 0., 0., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 61626, 0, 0, 61538, 0, 0, 110, 0, 0, 61475, 0, 0, 61660); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
    } else if (fontnameeq(font->s_name, "Accidentals")) {
#ifdef BACH_MAX
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 15.4; //15.2; //14.4; //47.4;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 8;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 102, 68, 103, 98, 104, 100, 106, 110, 114, 43, 116, 35, 121, 61, 117, 8249);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 8.5, 14.5, 8.3, 14.5, 8.5, 14.5, 9.3, 14.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 12.5, 3.5, 12.5, 3.5, 12.5, 3.5, 14.5, 8.5, 8.5, 8.3, 8.3, 8.5, 8.5, 9.5, 9.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 12.4, 12.4, 9., 7., 9., 7., 7., 7., 7., 5., 5., 7., 7., 9., 9., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 70, 71, 98, 87, 74, 110, 82, 76, 35, 89, 85, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
#endif
#ifdef BACH_JUCE
        r_ob->accidentals_typo_preferences.base_pt = 36.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 14.4; //47.4;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 8;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 102, 68, 103, 98, 104, 100, 106, 110, 114, 43, 116, 35, 121, 61, 117, 8249);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 8.5, 14.5, 8.3, 14.5, 8.5, 14.5, 9.3, 14.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 12.5, 3.5, 12.5, 3.5, 12.5, 3.5, 14.5, 8.5, 8.5, 8.3, 8.3, 8.5, 8.5, 9.5, 9.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 12.4, 12.4, 9., 7., 9., 7., 7., 7., 7., 5., 5., 7., 7., 9., 9., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 70, 71, 98, 87, 74, 110, 82, 76, 35, 89, 85, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
#endif
    } else if (fontnameeq(font->s_name, "Tamburo")) {
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 14.45; //47.45;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 4;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 0, 73, 0, 98, 0, 66, 0, 110, 0, 181, 0, 109, 0, 732, 0, 122);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 8.5, 12.5, 8.3, 12.5, 8.5, 12.5, 9.5, 12.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 10.5, 3.5, 10.5, 3.5, 10.5, 3.5, 12.5, 8.5, 8.5, 8.3, 8.3, 8.5, 8.5, 9.5, 9.5, 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 12.4, 12.4, 6., 6., 6., 6., 6., 6., 6., 5.5, 5.5, 7., 7., 9., 9., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 70, 71, 98, 87, 74, 110, 82, 76, 35, 89, 85, 8249); 
        // TO DO extensions and with TO BE TESTED!!!!
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
    } else if (fontnameeq(font->s_name, "Tempera")) {
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 12.25; // 45.25;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 8;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 46, 53, 55, 64, 65, 72, 75, 80, 84, 86, 93, 96, 103, 104, 113, 115, 122);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 11.6, 11.6, 11.6, 11.6, 11.6, 11.6, 11.6, 11.6, 8., 8.5, 8.5, 12., 9.2, 12., 9.5, 12., 3.);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 4.5, 10., 4.5, 10., 4.5, 10., 4.5, 4.5, 8., 8.7, 8.7, 8.7, 8.9, 8.9, 9.5, 9.5, 3.);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 10., 12., 10.4, 9.8, 6.4, 9.8, 6.4, 6.4, 4.5, 6.5, 6.5, 6.5, 6.5, 6.5, 7.8, 7.8, 6.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 70, 71, 98, 87, 74, 110, 82, 76, 35, 89, 85, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);
    } else if (fontnameeq(font->s_name, "Sonora")) {
        r_ob->accidentals_typo_preferences.base_pt = 40.;
        r_ob->accidentals_typo_preferences.ux_shift = 3.;
        r_ob->accidentals_typo_preferences.uy_shift = 28.; // 45.25;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 2;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 0, 0, 0, 98, 0, 0, 0, 110, 0, 0, 0, 35, 0, 0, 0, 8249);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 0., 0., 0., 10.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 0., 0., 0., 3.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 0., 0., 0., 6., 0., 0., 0., 6., 0., 0., 0., 7., 0., 0., 0., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 0, 0, 98, 0, 0, 110, 0, 0, 35, 0, 0, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
    } else if (fontnameeq(font->s_name, "EngraverFontSet")) {
        // TO DO: to calibrate
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 23.6; //23.2; 
        r_ob->accidentals_typo_preferences.binary_characters_depth = 2;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 0, 0, 0, 98, 0, 0, 0, 110, 0, 0, 0, 35, 0, 0, 0, 8249);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 0., 0., 0., 10.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 0., 0., 0., 3.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 0., 0., 0., 6., 0., 0., 0., 6., 0., 0., 0., 7., 0., 0., 0., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 0, 0, 98, 0, 0, 110, 0, 0, 35, 0, 0, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
    } else if (fontnameeq(font->s_name, "Boulez")) {
        // TO DO: to calibrate
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 18.1; //49.8;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 2;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 61626, 0, 0, 0, 61538, 0, 0, 0, 61550, 0, 0, 0, 61475, 0, 0, 0, 61660);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 0., 0., 0., 10.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 0., 0., 0., 3.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 0., 0., 0., 6., 0., 0., 0., 6., 0., 0., 0., 7., 0., 0., 0., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 61626, 0, 0, 61538, 0, 0, 61550, 0, 0, 61475, 0, 0, 61660); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
    } else { // Petrucci settings are loaded by default
        // TO DO: to calibrate
        r_ob->accidentals_typo_preferences.base_pt = 24.;
        r_ob->accidentals_typo_preferences.ux_shift = 0.;
        r_ob->accidentals_typo_preferences.uy_shift = 21.; //49.8;
        r_ob->accidentals_typo_preferences.binary_characters_depth = 2;
        r_ob->accidentals_typo_preferences.ternary_characters_depth = 1;
        // binary unicode characters
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_binary_character, 17, 8747, 0, 0, 0, 98, 0, 0, 0, 110, 0, 0, 0, 35, 0, 0, 0, 8249);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_top_uextension, 17, 10.5, 0., 0., 0., 10.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_bottom_uextension, 17, 3.5, 0., 0., 0., 3.5, 0., 0., 0., 8.5, 0., 0., 0., 8.5, 0., 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.binary_uwidth, 17, 11.4, 0., 0., 0., 6., 0., 0., 0., 6., 0., 0., 0., 7., 0., 0., 0., 7.);
        // ternary accidentals (wrong!!! unsupported, for now)
        fill_unicodeChar_array(r_ob->accidentals_typo_preferences.unicode_ternary_character, 13, 8747, 0, 0, 98, 0, 0, 110, 0, 0, 35, 0, 0, 8249); 
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_top_extension, 13, 10.5, 0., 0., 10.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_bottom_extension, 13, 3.5, 0., 0., 3.5, 0., 0., 8.5, 0., 0., 8.5, 0., 0., 3.5);
        fill_double_array(r_ob->accidentals_typo_preferences.ternary_width, 13, 11.4, 0., 0., 6., 0., 0., 6., 0., 0., 7., 0., 0., 7.);
        if (!(fontnameeq(font->s_name, "Petrucci")))
            object_warn((t_object *) r_ob, "Warning: font %s is not supported as accidentals font.", font->s_name);
    }
    
}


// notational
t_chord* nth_chord(t_measure *meas, long n){ // returns the nth (0-based) chord of a measure
    t_chord *curr = meas->firstchord; 
    long i;
    
    if (n < 0) 
        return NULL;
    
    if (n >= meas->num_chords) 
        return NULL;
    
    for (i=0; i<n && curr; i++)
        curr = curr->next;
    
    return curr;
    // to be improved: if the chord# is > n/2, pass the list the other way round!
}

// 0-BASED!!!!
t_note* nth_note(t_chord *ch, long n){ // returns the nth (0-based) note of a chord
    t_note *curr = ch->firstnote; long i;

    if (n < 0) 
        return NULL;
    
    if (n >= ch->num_notes) 
        return NULL;
    
    for (i=0; i<n && curr; i++)
        curr = curr->next;
    return curr;
    // to be improved: if the note# is > n/2, pass the list the other way round!
}

// 0-BASED!!!!
t_bpt* nth_breakpoint(t_note *nt, long n){ // returns the nth (0-based) note of a chord
    t_bpt *curr = nt->firstbreakpoint; 
    long i;

    if (n < 0) 
        return NULL;
    
    if (n >= nt->num_breakpoints) 
        return NULL;
    
    for (i = 0; i < n && curr; i++)
        curr = curr->next;
    return curr;
    // to be improved: if the note# is > n/2, pass the list the other way round!
}

// 0-BASED!!!!
t_slotitem *nth_slotitem(t_notation_obj *r_ob, t_notation_item *nitem, long slotnum, long n)
{ // returns the nth (0-based) note of a notation item
    t_slot *slot = notation_item_get_slot(r_ob, nitem, slotnum);
    t_slotitem *curr = slot ? slot->firstitem : NULL;
    long i;

    if (n < 0 || n >= slot->length)
        return NULL;
    
    for (i = 0; i < n && curr; i++)
        curr = curr->next;
    return curr;
    // to be improved: if the note# is > n/2, pass the list the other way round!
}

void initialize_commands(t_notation_obj *r_ob){
    long i;
    for (i= 0; i < CONST_MAX_COMMANDS; i++) {
        r_ob->command_key[i] = 0;
        r_ob->command_note[i] = _llllobj_sym_note;
        r_ob->command_chord[i] = _llllobj_sym_chord;
        r_ob->command_rest[i] = _llllobj_sym_rest;
    }
}


void compute_utf_timesignature(t_notation_obj *r_ob, t_timesignature *ts){ 
    long i = 0;
    long len_ascii_num = 0; long len_ascii_den = 0; 
    long_to_unicodeChars(r_ob, labs(ts->denominator), ts->den_unicode, &len_ascii_den, 49, 0);
    ts->len_den = len_ascii_den;
    if (ts->num_numerator_elements == 1) {
        long_to_unicodeChars(r_ob, labs(ts->numerator), ts->num_unicode, &len_ascii_num, 149, 0);
        ts->len_num = len_ascii_num;
    } else {
        long count = 0;
        for (i = 0; i < ts->num_numerator_elements; i++) {
            unicodeChar partial_utf[30]; long partial_len = 0;
            long_to_unicodeChars(r_ob, labs(ts->numerator_elements[i]), partial_utf, &partial_len, 29, 0);
            if (partial_len > 30) partial_len = 30;
            memcpy(ts->num_unicode + count, partial_utf, partial_len * sizeof(unsigned short));
            count += partial_len;
            
            if (i < ts->num_numerator_elements - 1) { // not the last one: "+" sign
                memcpy(ts->num_unicode + count, &r_ob->notation_typo_preferences.plus_unicode_character, sizeof(unsigned short));
                count ++;
            }
        }
        ts->len_num = count;
    }
}



char is_measure_single_whole_rest(t_notation_obj *r_ob, t_measure *measure){
    if (!r_ob->whole_rests_in_empty_measures || r_ob->is_linear_editing)
        return false;
    return is_measure_empty(r_ob, measure, false) && (measure->num_chords <= 1);
}

// tells if a measure has all rests
char is_measure_empty(t_notation_obj *r_ob, t_measure *measure, char account_for_slots)
{
    t_chord *chord = measure->firstchord;
    while (chord) {
        if (chord->r_sym_duration.r_num >= 0)
            return false;
        if (account_for_slots && notation_item_has_slot_content(r_ob, (t_notation_item *)chord))
            return false;
        chord = chord->next;
    }
    return true;
}

void synchronize_boxes_for_measure(t_notation_obj *r_ob, t_measure *measure)
{
    t_rational sum, meas_sym_dur = measure_get_sym_duration(measure), diff;

    if (!measure->custom_boxing || measure->boxes->l_size == 0) {
        llll_free(measure->boxes);
        measure->boxes = ts_to_beaming_boxes(r_ob, &measure->timesignature, NULL, NULL);
    }
    
    // we check that boxes are ok with total measure symbolic duration
    while (true) {
        char cmp;
        sum = llll_sum_abs_of_rat_llll(measure->boxes);
        diff = rat_rat_diff(meas_sym_dur, sum);
        cmp = rat_long_cmp(diff, 0);
        if (cmp > 0) {
            if (measure->boxes->l_tail) {
                t_rational last_rat = hatom_getrational(&measure->boxes->l_tail->l_hatom);
                if (last_rat.r_num > 0 && rat_rat_cmp(meas_sym_dur, rat_rat_sum(sum, last_rat)) >= 0) {
                    llll_appendrat(measure->boxes, last_rat, 0, WHITENULL_llll);
                    continue;
                }
            }
            llll_appendrat(measure->boxes, diff, 0, WHITENULL_llll);
            break;
        } else if (cmp == 0)
            break;
        else {
            if (measure->boxes->l_tail)
                llll_destroyelem(measure->boxes->l_tail);
            else
                break;
        }
    }
}

void measure_set_ts(t_notation_obj *r_ob, t_measure *measure, t_timesignature *ts)
{
    measure->timesignature = *ts;
    compute_utf_timesignature(r_ob, &measure->timesignature);
    synchronize_boxes_for_measure(r_ob, measure);
    measure->need_check_autocompletion = true;
    measure->need_recompute_beamings = true;
} 


t_timesignature build_simple_timesignature(t_notation_obj *r_ob, long numerator, long denominator) {
    t_llll *ts = llll_get();
    t_timesignature out;
    
    llll_appendlong(ts, numerator, 0, WHITENULL_llll);
    llll_appendlong(ts, denominator, 0, WHITENULL_llll);
    out = get_timesignature_from_llll((t_object *)r_ob, ts);    
    llll_free(ts);
    
    return out;
}

t_timesignature build_2compound_timesignature(t_notation_obj *r_ob, long numerator1, long numerator2, long denominator) {
    t_llll *ts = llll_get();
    t_llll *num = llll_get();
    t_timesignature out;
    
    llll_appendlong(num, numerator1, 0, WHITENULL_llll);
    llll_appendlong(num, numerator2, 0, WHITENULL_llll);
    llll_appendllll(ts, num, 0, WHITENULL_llll);
    llll_appendlong(ts, denominator, 0, WHITENULL_llll);
    out = get_timesignature_from_llll((t_object *)r_ob, ts);    
    llll_free(ts);
    
    return out;
}

t_timesignature build_3compound_timesignature(t_notation_obj *r_ob, long numerator1, long numerator2, long numerator3, long denominator) {
    t_llll *ts = llll_get();
    t_llll *num = llll_get();
    t_timesignature out;
    
    llll_appendlong(num, numerator1, 0, WHITENULL_llll);
    llll_appendlong(num, numerator2, 0, WHITENULL_llll);
    llll_appendlong(num, numerator3, 0, WHITENULL_llll);
    llll_appendllll(ts, num, 0, WHITENULL_llll);
    llll_appendlong(ts, denominator, 0, WHITENULL_llll);
    out = get_timesignature_from_llll((t_object *)r_ob, ts);    
    llll_free(ts);
    
    return out;
}

t_timesignature get_timesignature_from_llll(t_object *n_ob, t_llll *time_signature) {
    t_timesignature outts; 
    outts.numerator_elements[0] = 4;
    outts.numerator = 4; outts.denominator = 4;
    outts.num_numerator_elements = 1;
//    outts.r_it = build_notation_item(k_TIME_SIGNATURE); 
    if (time_signature && (time_signature->l_size >= 2)) {
        if (time_signature->l_depth == 1) { // just (num den)
            outts.numerator = alabs(hatom_getlong(&time_signature->l_head->l_hatom));
            outts.denominator = alabs(hatom_getlong(&time_signature->l_head->l_next->l_hatom));
            if ((outts.numerator == 0) || (outts.denominator == 0)) {
                if (n_ob)
                    object_error(n_ob, "Error. Wrong time signature introduced.");
                outts.numerator = 4;
                outts.denominator = 4;
            }
            outts.numerator_elements[0] = outts.numerator;
            outts.num_numerator_elements = 1;
        } else if (time_signature->l_depth == 2) { // ((num1 num2 ... ) den)
            t_llllelem *elem;
            outts.denominator = alabs(hatom_getlong(&time_signature->l_head->l_next->l_hatom));
            if (outts.denominator == 0) { 
                if (n_ob)
                    object_error(n_ob, "Error. Wrong time signature introduced.");            
                outts.denominator = 4;
            }
            outts.numerator = 0;
            elem = time_signature->l_head;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll* numllll = hatom_getllll(&elem->l_hatom);
                t_llllelem *numelem; 
                int count = 0;
                if (numllll->l_size > 0) {
                    for (numelem = numllll->l_head; numelem && count < CONST_MAX_TS_NUMERATOR_ELEMENTS; numelem = numelem->l_next, count++) {
                        outts.numerator_elements[count] = alabs(hatom_getlong(&numelem->l_hatom));
                        if (outts.numerator_elements[count] == 0) 
                            outts.numerator_elements[count] = 4;
                        outts.numerator += outts.numerator_elements[count];
                    }
                    
                    outts.num_numerator_elements = count;
                }
            }
            if (outts.numerator == 0) {
                outts.denominator = 4;
                outts.numerator = 4; 
                outts.numerator_elements[0] = 4; 
                outts.num_numerator_elements = 1; 
                if (n_ob)
                    object_error(n_ob, "Error. Wrong time signature introduced.");            
            }
        }
    }
    return outts;
}


void measure_set_ts_and_tempo_from_llll(t_notation_obj *r_ob, t_measure *measure, t_llll *time_signature, 
                                        t_llll *tempo, char measure_barline, t_llll *parameters, char when_no_ts_given_use_previous_or_nearest_measure_ts)
{ 
    //    char debug[1000];
    //    llll_to_char_array(time_signature, debug, 1000);
    if (time_signature && (time_signature->l_size >= 2))
        measure->timesignature = get_timesignature_from_llll((t_object *)r_ob, time_signature);
    else if (when_no_ts_given_use_previous_or_nearest_measure_ts) {
        if (measure->prev)
            measure->timesignature = measure->prev->timesignature;
        else if (measure->next)
            measure->timesignature = measure->next->timesignature;
    }
    compute_utf_timesignature(r_ob, &measure->timesignature);
        
    if (tempo && (tempo->l_size >= 1)) {
        // tempo_work is the tempo to work with: since we might need to wrap it, we have to clone it!
        t_llll *tempo_work = llll_clone(tempo); 
        if (tempo_work->l_depth == 1) 
            llll_wrap_once(&tempo_work);
        if (tempo_work->l_depth >= 2) { // more than a tempo (or just one tempo, but still wrapped!)
            t_llllelem *elem;
            for (elem = tempo_work->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_tempo *this_tempo = build_tempo_from_llll(hatom_getllll(&elem->l_hatom), r_ob->tempo_approx_digits);
                    if (this_tempo) {
                        this_tempo->changepoint = rat_clip(this_tempo->changepoint, long2rat(0), measure_get_sym_duration(measure));
                        insert_tempo(r_ob, measure, this_tempo);
                        if (!tempo_is_necessary(this_tempo)) 
                            delete_tempo(r_ob, this_tempo);
                    }
                }
            }
        }
        llll_free(tempo_work);
    }
    
    measure->end_barline->barline_type = measure_barline;
    
    set_measure_parameters(r_ob, measure, parameters);
    synchronize_boxes_for_measure(r_ob, measure);    
}


void tempo_to_char_buf(t_tempo *tempo, char *buf, long buf_size, long max_decimals)
{
    if (tempo->figure_tempo_value.r_den == 1 || max_decimals == 0) // integer tempo
        snprintf_zero(buf, buf_size, " = %ld", tempo->figure_tempo_value.r_num);
    else
        snprintf_zero(buf, buf_size, " = %.*f", max_decimals, rat2double(tempo->figure_tempo_value));
    
}

void time_to_char_buf(t_notation_obj *r_ob, double time_ms, char *buf, long buf_size)
{
    double secs = time_ms/1000.;
    long mins = (long)(secs / 60.);
    long hours = mins / 60;
    mins %= 60;
    secs = fmod(secs, 60.);
    if (!hours) {
        if (!mins) {
            snprintf_zero(buf, buf_size, "%.3fs", secs);
        } else
            snprintf_zero(buf, buf_size, "%ldm %.3fs", mins, secs);
    } else
        snprintf_zero(buf, buf_size, "%ldh %ldm %.3fs", hours, mins, secs);
}


// setting parameters for measure (width, barline, ...)
void set_measure_parameters(t_notation_obj *r_ob, t_measure *measure, t_llll *parameters)
{
    measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags & ~k_FLAG_DEFINES_LOCAL_SPACING_WIDTH);
    measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags & ~k_FLAG_DEFINES_FIXED_WIDTH);
    measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags & ~k_FLAG_REMOVES_FIXED_WIDTH);
    
    if (parameters){
        t_llllelem *elem;
        for (elem = parameters->l_head; elem; elem = elem->l_next){
            if (hatom_gettype(&elem->l_hatom) == H_LLLL){
                t_llll *this_llll = hatom_getllll(&elem->l_hatom);
                if (this_llll && this_llll->l_head && hatom_gettype(&this_llll->l_head->l_hatom) == H_SYM) {
                    t_symbol *router = hatom_getsym(&this_llll->l_head->l_hatom);
                    if (router == _llllobj_sym_widthfactor){
                        if (this_llll->l_head->l_next && is_hatom_number(&this_llll->l_head->l_next->l_hatom)) {
                            measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags | k_FLAG_DEFINES_LOCAL_SPACING_WIDTH);
                            measure->local_spacing_width_multiplier = hatom_getdouble(&this_llll->l_head->l_next->l_hatom);
                            measure->is_spacing_fixed = false;
                        }
                    } else if (router == _llllobj_sym_width){
                        if (this_llll->l_head->l_next && is_hatom_number(&this_llll->l_head->l_next->l_hatom)) {
                            measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags | k_FLAG_DEFINES_FIXED_WIDTH);
                            measure->fixed_spacing_uwidth = hatom_getdouble(&this_llll->l_head->l_next->l_hatom);
                            measure->is_spacing_fixed = true;
                        } else {
                            measure->r_it.flags = (e_bach_internal_notation_flags) (measure->r_it.flags | k_FLAG_REMOVES_FIXED_WIDTH);
                            measure->is_spacing_fixed = false;
                        }
                    } else if (router == _llllobj_sym_shownumber){
                        if (this_llll->l_head->l_next && is_hatom_number(&this_llll->l_head->l_next->l_hatom)) {
                            measure->force_measure_number = true;
                            measure->forced_measure_number = hatom_getlong(&this_llll->l_head->l_next->l_hatom);
                            measure->show_measure_number = true;
                        } else if (this_llll->l_head->l_next && hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM && hatom_getsym(&this_llll->l_head->l_next->l_hatom) == _llllobj_sym_off){
                            measure->force_measure_number = false;
                            measure->forced_measure_number = 0;
                            measure->show_measure_number = false;
                        } else {
                            measure->force_measure_number = false;
                            measure->forced_measure_number = 0;
                            measure->show_measure_number = true;
                        }
                    } else if (router == _llllobj_sym_barline){
                        if (this_llll->l_head->l_next) {
                            if (is_hatom_number(&this_llll->l_head->l_next->l_hatom)) {
                                long l = hatom_getlong(&this_llll->l_head->l_next->l_hatom);
                                measure->end_barline->barline_type = l == 0 ? 'a' : l;
                            } else if (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM) {
                                t_symbol *thissym = hatom_getsym(&this_llll->l_head->l_next->l_hatom);
                                if (thissym && strlen(thissym->s_name) > 0)
                                    measure->end_barline->barline_type = thissym->s_name[0];
                            }
                        }
                    } else if (router == _llllobj_sym_usecustomboxes){
                        if (this_llll->l_head->l_next && is_hatom_number(&this_llll->l_head->l_next->l_hatom)) {
                            long num = hatom_getlong(&this_llll->l_head->l_next->l_hatom);
                            measure->custom_boxing = num != 0 ? true : false;
                            if (!measure->custom_boxing) {
                                llll_clear(measure->boxes);
//                                synchronize_boxes_for_measure(r_ob, measure); // DONE LATER, OUTSIDE
                            }
                        }
                    } else if (router == _llllobj_sym_boxes){
                        llll_clear(measure->boxes);
                        llll_clone_upon(this_llll, measure->boxes);
                        llll_behead(measure->boxes);
                        measure->custom_boxing = measure->boxes->l_size > 0 ? true : false;
//                        synchronize_boxes_for_measure(r_ob, measure); // DONE LATER, OUTSIDE
                    }
                }
            }
        }
    }
}

char tempo_is_necessary(t_tempo *tempo){
// does a tempo duplicate the previous tempo, or is it really necessary??
    t_tempo *prev_tempo = tempo_get_prev(tempo);
    if (!prev_tempo) 
        return 1;
    if (rat_rat_cmp(prev_tempo->tempo_value, tempo->tempo_value) != 0) 
        return 1; 
    if (prev_tempo->interpolation_type != 0) 
        return 1; 
    if (rat_rat_cmp(prev_tempo->tempo_figure, tempo->tempo_figure) != 0) 
        return 1; 
    if (prev_tempo->interpolation_type == 0 && tempo->interpolation_type == 1) 
        return 1; 
    return 0;
}

t_timepoint get_zero_timepoint(){ 
    t_timepoint out_tp;
    out_tp.measure_num = 0;
    out_tp.voice_num = 0;
    out_tp.pt_in_measure = long2rat(0);
    return out_tp;
}

char is_ratio_invalid(t_rational rat) {
    if (rat.r_den == 0)
        return 1;
    else 
        return 0;
}

t_tempo *build_tempo_from_llll(t_llll *tempollll, long num_tempo_approx_digits){
    t_rational value, figure, pt_in_measure;
    char interp;
    t_atom_long approx_tempi_den = ipow(10, num_tempo_approx_digits);
    
    if (!tempollll || tempollll->l_size == 0) 
        return NULL;
    
    value = long2rat(60); 
    figure = RAT_1OVER4; 
    interp = 0;
    pt_in_measure = long2rat(0);

    if (tempollll->l_size == 1) { // just tempo value
        if (hatom_gettype(&tempollll->l_head->l_hatom) == H_LONG)
            value = long2rat(hatom_getlong(&tempollll->l_head->l_hatom));
        else if (hatom_gettype(&tempollll->l_head->l_hatom) == H_RAT)
            value = hatom_getrational(&tempollll->l_head->l_hatom);
        else if (hatom_gettype(&tempollll->l_head->l_hatom) == H_DOUBLE)
            value = approx_double_with_rat_fixed_den(hatom_getdouble(&tempollll->l_head->l_hatom), approx_tempi_den, 0, NULL);
        
        if (is_ratio_invalid(value) || (rat_long_cmp(value, 0) <= 0)) value = long2rat(60);
    } else if (tempollll->l_size >= 2) { // tempofigure + tempovalue
        figure = hatom_getrational(&tempollll->l_head->l_hatom);
        if (is_ratio_invalid(figure) || (rat_long_cmp(figure, 0) == 0))
            figure = RAT_1OVER4;
        else if (rat_long_cmp(figure, 0) < 0)
            figure = rat_abs(figure);
            
        if (hatom_gettype(&tempollll->l_head->l_next->l_hatom) == H_LONG)
            value = long2rat(hatom_getlong(&tempollll->l_head->l_next->l_hatom));
        else if (hatom_gettype(&tempollll->l_head->l_next->l_hatom) == H_RAT)
            value = hatom_getrational(&tempollll->l_head->l_next->l_hatom);
        else if (hatom_gettype(&tempollll->l_head->l_next->l_hatom) == H_DOUBLE)
            value = approx_double_with_rat_fixed_den(hatom_getdouble(&tempollll->l_head->l_next->l_hatom), approx_tempi_den, 0, NULL);

        if (is_ratio_invalid(value) || rat_long_cmp(value, 0) <= 0) 
            value = long2rat(60);

        if (tempollll->l_size >= 3) { // also point in measure
            pt_in_measure = hatom_getrational(&tempollll->l_head->l_next->l_next->l_hatom);

        if (is_ratio_invalid(pt_in_measure) || rat_long_cmp(pt_in_measure, 0) <= 0) 
            pt_in_measure = long2rat(0);
                
            if (tempollll->l_size >= 4) { // also interpolation
                interp = hatom_getlong(&tempollll->l_head->l_next->l_next->l_next->l_hatom);
                if (interp < 0) interp = 0; if (interp > 1) interp = 1;
            }
        }
    }
    
    return build_tempo(pt_in_measure, value, figure, interp);
}

t_tempo *build_tempo(t_rational changepoint, t_rational figure_tempo_value, t_rational tempo_figure, char interpolation_type){ 
    t_tempo *outtempo = (t_tempo *)bach_newptr(sizeof(t_tempo));
    notation_item_init(&outtempo->r_it, k_TEMPO);
    outtempo->next = NULL; outtempo->prev = NULL;
    outtempo->owner = NULL;
    outtempo->changepoint = changepoint;
    outtempo->tempo_figure = tempo_figure;
    outtempo->figure_tempo_value = figure_tempo_value;
    outtempo->hidden = false;
    if (rat_long_cmp(outtempo->figure_tempo_value, 0) <= 0)
        outtempo->figure_tempo_value = long2rat(60);
    outtempo->tempo_value = rat_rat_prod(outtempo->figure_tempo_value, rat_long_prod(tempo_figure, 4));
    outtempo->interpolation_type = interpolation_type; 
    outtempo->tuttipoint_offset_ux = 0.;
    outtempo->uy_offset = 0.;
    outtempo->need_recalculate_onset = true;
    outtempo->hack_measure_number = 0;
    return outtempo;
}


void insert_tempo(t_notation_obj *r_ob, t_measure *measure, t_tempo *tempo_to_insert){
// insert in the measure *measure the tempo *tempo_to_insert after the tempo *after_this_tempo. Leave this NULL to insert at the beginning
    t_tempo *after_this_tempo = measure->lasttempo;
    if (measure->firsttempo) { // not at the beginning
        // gotta find where to put it
        t_tempo *temp = measure->firsttempo;
        while (temp) {
            char cmp = rat_rat_cmp(temp->changepoint, tempo_to_insert->changepoint);
            if (cmp == 0) { // exactly the same point! we delete the old tempo
                after_this_tempo = temp->prev;
                delete_tempo(r_ob, temp);
                break;
            } else if (cmp == 1) {
                after_this_tempo = temp->prev;
                break;
            }
            temp = temp->next;
        }
    }
        
    if (measure->firsttempo) { // not at the beginning
        if (after_this_tempo) {
            if (after_this_tempo->next) { // insert between these
                after_this_tempo->next->prev = tempo_to_insert;
                tempo_to_insert->next = after_this_tempo->next;
                tempo_to_insert->prev = after_this_tempo;
                after_this_tempo->next = tempo_to_insert;
            } else { // insert at the end
                tempo_to_insert->next = NULL;
                tempo_to_insert->prev = after_this_tempo;
                after_this_tempo->next = tempo_to_insert;
                measure->lasttempo = tempo_to_insert;
            }
        } else { // at the beginning
            tempo_to_insert->prev = NULL;
            tempo_to_insert->next = measure->firsttempo;
            measure->firsttempo->prev = tempo_to_insert;
            measure->firsttempo = tempo_to_insert;
        }
    } else { // no tempos in the voices yet
        tempo_to_insert->next = NULL;
        tempo_to_insert->prev = NULL;
        measure->firsttempo = tempo_to_insert;
        measure->lasttempo = tempo_to_insert;
    }
            
    tempo_to_insert->owner = measure; // set the parent field
    
    // increase the # of tempos in the voice
    measure->num_tempi++; 
}


void delete_tempo(t_notation_obj *r_ob, t_tempo *tempo)
{
    t_measure *measure = tempo->owner;
    
    if (measure && tempo){
    
        if (tempo_check_dependencies_before_deleting_it(r_ob, tempo))
            check_correct_scheduling(r_ob, false);
        
        measure->num_tempi --;
        if (tempo->prev) { // not the first tempo
            if (tempo->next) { // not the last tempo
                tempo->prev->next = tempo->next;
                tempo->next->prev = tempo->prev;
            } else { // last tempo
                tempo->prev->next = NULL;
                measure->lasttempo = tempo->prev;
            }
        } else { // first tempo
            if (tempo->next) { // some tempi remain
                tempo->next->prev = NULL;
                measure->firsttempo = tempo->next;
            } else { // there was just 1 tempo
                measure->firsttempo = NULL;
                measure->lasttempo = NULL;
                measure->num_tempi = 0;
            }
        }
        free_tempo(r_ob, tempo);
    }
}

void clear_measure_tempi(t_notation_obj *r_ob, t_measure *meas){
    if (meas->lasttempo) {
        t_tempo *temp = meas->lasttempo; t_tempo *temp2;
        while (temp) {
            temp2 = temp;
            temp = temp->prev;
            delete_tempo(r_ob, temp2);
        }
    }
}

void clear_voice_tempi(t_notation_obj *r_ob, t_scorevoice *voice){
    t_measure *meas = voice->firstmeasure;
    while (meas) {
        clear_measure_tempi(r_ob, meas);
        meas = meas->next;
    }
}


//// BEAMING
void check_dotted_tuplets(t_notation_obj *r_ob, t_tupletinfo *tupletinfo){
    if (!r_ob->admit_dotted_tuplets) {
        t_rational screen_dur;
        char num_dots;
        is_duration_drawable(r_ob, tupletinfo->tuplet_graphical_unit, &screen_dur, &num_dots);
        if (num_dots != 0) {
            long factor = tupletinfo->tuplet_graphical_unit.r_num;
            tupletinfo->tuplet_graphical_unit = genrat(1, tupletinfo->tuplet_graphical_unit.r_den);
            tupletinfo->tuplet_unit = rat_long_div(tupletinfo->tuplet_graphical_unit, factor);
            tupletinfo->tuplet_multiplier = rat_long_prod(tupletinfo->tuplet_multiplier, factor);
        }
    }
}

void fill_tupletinfo_fields(t_notation_obj *r_ob, t_tupletinfo *tupletinfo, t_rational tuplet_local_unit, t_rational pregressed_ratio, t_rational tuplet_sym_duration){
    tupletinfo->tuplet_pregressed_ratio = pregressed_ratio;
    tupletinfo->tuplet_local_unit = tuplet_local_unit;
    tupletinfo->tuplet_sym_duration = tuplet_sym_duration;

    tupletinfo->tuplet_unit = rat_rat_prod(tupletinfo->tuplet_local_unit, tupletinfo->tuplet_pregressed_ratio);
    tupletinfo->tuplet_graphical_unit = tuplet_unit_to_tuplet_graphical_unit(r_ob, tupletinfo->tuplet_local_unit, r_ob->admit_dotted_tuplets);
    tupletinfo->tuplet_local_ratio = rat_rat_div(tupletinfo->tuplet_local_unit, tupletinfo->tuplet_graphical_unit);
    tupletinfo->tuplet_multiplier = rat_long_div(rat_rat_div(tupletinfo->tuplet_sym_duration, tupletinfo->tuplet_unit), tupletinfo->tuplet_local_ratio.r_den);

    tupletinfo->is_tuplet_completed = (tupletinfo->tuplet_multiplier.r_den == 1 || tupletinfo->tuplet_multiplier.r_num == 1);// was: tupletinfo->tuplet_multiplier.r_den == 1
    tupletinfo->is_tuplet_under_linear_edit = false;
    
    check_dotted_tuplets(r_ob, tupletinfo);
}

void fill_tupletinfo_fields2(t_notation_obj *r_ob, t_tupletinfo *tupletinfo, t_rational tuplet_local_ratio, t_rational tuplet_graphical_unit, t_rational pregressed_ratio, t_rational tuplet_multiplier){
    tupletinfo->tuplet_local_ratio = tuplet_local_ratio;
    tupletinfo->tuplet_graphical_unit = tuplet_graphical_unit;
    tupletinfo->tuplet_pregressed_ratio = pregressed_ratio;
    tupletinfo->tuplet_multiplier = tuplet_multiplier;
    
    tupletinfo->tuplet_local_unit = rat_rat_prod(tupletinfo->tuplet_local_ratio, tupletinfo->tuplet_graphical_unit);
    tupletinfo->tuplet_unit = rat_rat_prod(tupletinfo->tuplet_local_unit, tupletinfo->tuplet_pregressed_ratio);
    tupletinfo->tuplet_sym_duration = rat_rat_prod(rat_long_prod(tupletinfo->tuplet_multiplier, tupletinfo->tuplet_local_ratio.r_den), tupletinfo->tuplet_unit);

    tupletinfo->is_tuplet_completed = (tupletinfo->tuplet_multiplier.r_den == 1 || tupletinfo->tuplet_multiplier.r_num == 1); // was: tupletinfo->tuplet_multiplier.r_den == 1
    tupletinfo->is_tuplet_under_linear_edit = false;
    
    check_dotted_tuplets(r_ob, tupletinfo);
}



t_beam *build_beam(t_chord *startchord, t_chord *endchord)
{
    t_beam *outbeam = (t_beam *)bach_newptr(sizeof(t_beam));
    outbeam->next = outbeam->prev = NULL;
    outbeam->beam_start_chord = startchord;
    outbeam->beam_end_chord = endchord;
    outbeam->is_tuplet = false;
    outbeam->is_tick = false;
    outbeam->tick_direction = 0;
    outbeam->has_beam_line = true;
    outbeam->depth = 0;
    outbeam->grace = outbeam->slashed = outbeam->dashed = false;
    outbeam->tuplet_text1[0] = 0;
    outbeam->tuplet_text2[0] = 0;
    outbeam->tuplet_show_bracket = 0;
    outbeam->tuplet_number_display_type = 0;
    outbeam->tuplet_text1_delta_ux = outbeam->tuplet_text1_uy = 0;
    outbeam->direction = 0;
    return outbeam;
}


void append_beam(t_measure *measure, t_beam *beam){
    // append the beam at the end of the linked list of beams for a measure
    
    if (measure->lastbeam) { // not at the beginning
        beam->next = NULL;
        beam->prev = measure->lastbeam;
        measure->lastbeam->next = beam;
        measure->lastbeam = beam;
    } else { // no tempos in the voices yet
        beam->next = beam->prev = NULL;
        measure->firstbeam = measure->lastbeam = beam;
    }
    
    beam->owner = measure; // set the parent field
    
    // increase the # of beams in the voice
    measure->num_beams++; 
}


void delete_beam(t_notation_obj *r_ob, t_measure *measure, t_beam *beam){
    if (beam){
        measure->num_beams--;
        if (beam->prev) { // not the first beam
            if (beam->next) { // not the last beam
                beam->prev->next = beam->next;
                beam->next->prev = beam->prev;
            } else { // last beam
                beam->prev->next = NULL;
                measure->lastbeam = beam->prev;
            }
        } else { // first beam
            if (beam->next) { // some beams remain
                beam->next->prev = NULL;
                measure->firstbeam = beam->next;
            } else { // there was just 1 tempo
                measure->firstbeam = NULL;
                measure->lastbeam = NULL;
                measure->num_beams = 0;
            }
        }
        free_beam(r_ob, beam);
    }
}

void clear_measure_beams(t_notation_obj *r_ob, t_measure *meas){
    if (meas->lastbeam) {
        t_beam *temp = meas->lastbeam; 
        t_beam *temp2;
        while (temp) {
            temp2 = temp;
            temp = temp->prev;
            delete_beam(r_ob, meas, temp2);
        }
    }
}

char is_all_selection_in_one_group(t_notation_obj *r_ob, t_group **whichgroup){ 
    t_notation_item *item;
    t_group *gr = NULL;
    for (item = r_ob->firstselecteditem; item; item = item->next_selected){
        t_chord *thischord = NULL;
        if (item->type == k_CHORD) 
            thischord = (t_chord *)item;
        else if (item->type == k_NOTE) 
            thischord = ((t_note *)item)->parent;
        if (thischord){
            if (!gr && thischord->r_it.group)
                gr = thischord->r_it.group;
            else {
                if (gr && !thischord->r_it.group) {
                    if (whichgroup)
                        *whichgroup = NULL;
                    return 0;
                } else if (thischord->r_it.group != gr) {
                    if (whichgroup)
                        *whichgroup = gr;
                    return 0;
                }
            }
        }
    }
    if (whichgroup)
        *whichgroup = gr;
    return gr ? 1 : 0;
}

t_group *build_and_append_group_from_selection(t_notation_obj *r_ob){ 
    t_group *newgroup = build_group();
    t_notation_item *item;
    
    append_group(r_ob, newgroup);
    
    for (item = r_ob->firstselecteditem; item; item = item->next_selected){
        t_chord *thischord = NULL;
        if (item->type == k_CHORD) 
            thischord = (t_chord *)item;
        else if (item->type == k_NOTE) 
            thischord = ((t_note *)item)->parent;
        if (thischord) {
            if (thischord->r_it.group)
                remove_element_from_group(r_ob, thischord->r_it.group, (t_notation_item *)thischord);
            append_element_in_group(r_ob, newgroup, (t_notation_item *) thischord);
        }
    }
    
    if (newgroup->num_elements <= 1) {
        delete_group(r_ob, newgroup);
        return NULL;
    }
    return newgroup;
}


void append_element_in_group(t_notation_obj *r_ob, t_group *group, t_notation_item *item){
    if (group) {
        if (group->lastelem) { // not at the beginning
            item->next_group_item = NULL;
            item->prev_group_item = group->lastelem;
            group->lastelem->next_group_item = item;
            group->lastelem = item;
        } else { // no tempos in the voices yet
            item->next_group_item = item->prev_group_item = NULL;
            group->firstelem = group->lastelem = item;
        }
        
        // increase the # of elements in the group
        group->num_elements++; 
        item->group = group;
        
#ifdef BACH_CHECK_NOTATION_ITEMS
        notation_item_check(r_ob, item);
#endif
    }
}


void remove_element_from_group(t_notation_obj *r_ob, t_group *group, t_notation_item *element){
    if (group && element){
        group->num_elements--;
        if (group->num_elements > 0) {
            if (element->prev_group_item) { // not the first el
                if (element->next_group_item) { // not the last el
                    element->prev_group_item->next_group_item = element->next_group_item;
                    element->next_group_item->prev_group_item = element->prev_group_item;
                } else { // last el
                    element->prev_group_item->next_group_item = NULL;
                    group->lastelem = element->prev_group_item;
                }
            } else { // first el
                if (element->next_group_item) { // some el remain
                    element->next_group_item->prev_group_item = NULL;
                    group->firstelem = element->next_group_item;
                } else { // there was just 1 el
                    group->firstelem = group->lastelem = NULL;
                    group->num_elements = 0;
                    delete_group(r_ob, group);
                }
            }
        } else {
            delete_group(r_ob, group);
        }
    }
}


t_group *build_group(){ 
    t_group *outgroup = (t_group *)bach_newptr(sizeof(t_group));
    outgroup->next = outgroup->prev = NULL;
    outgroup->num_elements = 0;
    outgroup->ID = 0;
    outgroup->firstelem = outgroup->lastelem = NULL;
    return outgroup;
}


void append_group(t_notation_obj *r_ob, t_group *group){
    // append the group at 
    
    if (r_ob->lastgroup) { // not at the beginning
        group->next = NULL;
        group->prev = r_ob->lastgroup;
        r_ob->lastgroup->next = group;
        r_ob->lastgroup = group;
    } else { // no tempos in the voices yet
        group->next = group->prev = NULL;
        r_ob->firstgroup = r_ob->lastgroup = group;
    }

    // increase the # of beams in the voice
    r_ob->num_groups++; 
    group->ID = r_ob->num_groups;
}


void delete_group(t_notation_obj *r_ob, t_group *group){
    t_group *next = group->next;
    
    // removing references
    t_notation_item *item = group->firstelem;
    while (item){
        t_notation_item *next = item->next_group_item;
        item->group = NULL;
        item->next_group_item = NULL;
        item->prev_group_item = NULL;
        item = next;
    }
    
    // removing group
    if (group){
        r_ob->num_groups--;
        if (group->prev) { // not the first group
            if (group->next) { // not the last group
                group->prev->next = group->next;
                group->next->prev = group->prev;
            } else { // last group
                group->prev->next = NULL;
                r_ob->lastgroup = group->prev;
            }
        } else { // first group
            if (group->next) { // some group remain
                group->next->prev = NULL;
                r_ob->firstgroup = group->next;
            } else { // there was just 1 group
                r_ob->firstgroup = NULL;
                r_ob->lastgroup = NULL;
                r_ob->num_groups = 0;
            }
        }
    }
    while (next) {    // updating IDs
        next->ID--;
        next = next->next;
    }
    free_group(r_ob, group);
}

void clear_all_groups(t_notation_obj *r_ob){
    if (r_ob->lastgroup) {
        t_group *temp = r_ob->lastgroup; 
        t_group *temp2;
        while (temp) {
            temp2 = temp->prev;
            delete_group(r_ob, temp);
            temp = temp2;
        }
    }
}

void clear_all_markers(t_notation_obj *r_ob){
    if (r_ob->lastmarker) {
        t_marker *temp = r_ob->lastmarker; 
        t_marker *temp2;
        while (temp) {
            temp2 = temp;
            temp = temp->prev;
            delete_marker(r_ob, temp2);
        }
    }
}


void adjust_zoom_for_non_antialiased_lines(t_notation_obj *r_ob) {
    if (r_ob->force_non_antialiased_staff_lines) {
        // zooming ... in order to have proper staff lines!!! :-)
        r_ob->step_y = MAX(0.5, round(r_ob->zoom_y * CONST_STEP_UY * 2.) / 2.);
        r_ob->zoom_y = r_ob->step_y / CONST_STEP_UY;
    }
}


void compute_middleC_position_for_all_voices(t_notation_obj *r_ob){
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        compute_middleC_position_for_voice(r_ob, voice);
}

void compute_middleC_position_for_voice(t_notation_obj *r_ob, t_voice *voice){
    // to add for non antialiased staff lines
    double y_adjust_staff = (r_ob->force_non_antialiased_staff_lines) ? - CONST_MIDDLEC_UY * r_ob->zoom_y + round(CONST_MIDDLEC_UY * r_ob->zoom_y) : 0.;
    double voice_vertical_offset = voice->offset_y;
    long clef = get_voice_clef(r_ob, voice);
    
    // deciding middleC position
    if (clef == k_CLEF_FFGG || clef == k_CLEF_FGG || clef == k_CLEF_GG || clef == k_CLEF_G15ma)
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y;
    else if (clef == k_CLEF_FFG || clef == k_CLEF_FG || clef == k_CLEF_G || clef == k_CLEF_NONE || clef == k_CLEF_PERCUSSION)
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y - 14 * CONST_STEP_UY * r_ob->zoom_y;
    else if (clef == k_CLEF_FF || clef == k_CLEF_F)
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y - (14 + 12) * CONST_STEP_UY * r_ob->zoom_y;
    else if (clef == k_CLEF_F15mb)
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y - (2 * 14 + 12) * CONST_STEP_UY * r_ob->zoom_y;
    else if (clef == k_CLEF_SOPRANO || clef == k_CLEF_ALTO || clef == k_CLEF_TENOR || clef == k_CLEF_MEZZO || clef == k_CLEF_BARYTONE || clef == k_CLEF_G8va || clef == k_CLEF_F8vb
             || clef == k_CLEF_G8vb || clef == k_CLEF_F8va || clef == k_CLEF_G15mb || clef == k_CLEF_F15ma) //TO DO: CHECK
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y - (14 + (clef + 2)) * CONST_STEP_UY * r_ob->zoom_y;
    else
        voice->middleC_y = y_adjust_staff + voice_vertical_offset + CONST_MIDDLEC_UY * r_ob->zoom_y;
    
    // taking vertical scrollbar into account
    if (r_ob->need_vscrollbar && r_ob->show_vscrollbar)
        voice->middleC_y += r_ob->vscrollbar_pixnudge;
}

long get_num_steps_in_staff(t_notation_obj *r_ob, t_voice *voice){
    long clef = get_voice_clef(r_ob, voice);
    switch (clef) {
        case k_CLEF_FFGG:
            return 48;
        case k_CLEF_FFG:
        case k_CLEF_FGG:
            return 36;
        case k_CLEF_FF:
        case k_CLEF_GG:
            return 22;
        case k_CLEF_FG:
            return 20;
        default:
            return 8;
    }
}

double get_staff_top_y(t_notation_obj *r_ob, t_voice *voice, char ignore_nonstandard_stafflines) {
    double staff_top = voice->middleC_y + 24 * r_ob->step_y;
    long clef = get_voice_clef(r_ob, voice);
    
    switch (clef) {
        // ordinary clefs
        case k_CLEF_SOPRANO:
        case k_CLEF_ALTO:
        case k_CLEF_TENOR:
        case k_CLEF_MEZZO:
        case k_CLEF_BARYTONE:
        case k_CLEF_G:
        case k_CLEF_G8va:
        case k_CLEF_G8vb:
        case k_CLEF_G15ma:
        case k_CLEF_G15mb:
        case k_CLEF_F:
        case k_CLEF_F8va:
        case k_CLEF_F8vb:
        case k_CLEF_F15ma:
        case k_CLEF_F15mb:
            staff_top = voice->middleC_y + (clef + 2 - 10) * r_ob->step_y;
            break;
            
        default:
        {
            // clef combinations + perc clef
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_GG) || (clef == k_CLEF_FG) || (clef == k_CLEF_NONE) || (clef == k_CLEF_PERCUSSION))
                staff_top = MIN(staff_top, voice->middleC_y - 10 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF) || (clef == k_CLEF_FG))
                staff_top = MIN(staff_top, voice->middleC_y + 2 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_GG))
                staff_top = MIN(staff_top, voice->middleC_y - 24 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF))
                staff_top = MIN(staff_top, voice->middleC_y + 16 * r_ob->step_y);
        }
            break;
    }
    
    // correcting for nonstandard stafflines 
    if (!ignore_nonstandard_stafflines && voice->max_staff_line > 5)
        staff_top -= (voice->max_staff_line - 5) * r_ob->step_y * 2;
    return staff_top;
}

double get_staff_bottom_y(t_notation_obj *r_ob, t_voice *voice, char ignore_nonstandard_stafflines) {
    double staff_bottom = -100000; //0.;
    long clef = get_voice_clef(r_ob, voice);

    switch (clef) {
        case k_CLEF_SOPRANO:
        case k_CLEF_ALTO:
        case k_CLEF_TENOR:
        case k_CLEF_MEZZO:
        case k_CLEF_BARYTONE:
        case k_CLEF_G:
        case k_CLEF_G8va:
        case k_CLEF_G8vb:
        case k_CLEF_G15ma:
        case k_CLEF_G15mb:
        case k_CLEF_F:
        case k_CLEF_F8va:
        case k_CLEF_F8vb:
        case k_CLEF_F15ma:
        case k_CLEF_F15mb:
            staff_bottom = voice->middleC_y + clef * r_ob->step_y;
            break;
            
        default:
        {
            // clef combinations + perc clef
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_GG) || (clef == k_CLEF_FG) || (clef == k_CLEF_NONE) || (clef == k_CLEF_PERCUSSION))
                staff_bottom = MAX(staff_bottom, voice->middleC_y - 2 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF) || (clef == k_CLEF_FG))
                staff_bottom = MAX(staff_bottom, voice->middleC_y + 10 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FGG) || (clef == k_CLEF_GG))
                staff_bottom = MAX(staff_bottom, voice->middleC_y - 16 * r_ob->step_y);
            if ((clef == k_CLEF_FFGG) || (clef == k_CLEF_FFG) || (clef == k_CLEF_FF))
                staff_bottom = MAX(staff_bottom, voice->middleC_y + 24 * r_ob->step_y);
        }
            break;
    }
    
    // correcting for nonstandard stafflines 
    if (!ignore_nonstandard_stafflines && voice->min_staff_line < 1)
        staff_bottom += (1 - voice->min_staff_line) * r_ob->step_y * 2;
    return staff_bottom;
}

t_measure* nth_measure_of_scorevoice(t_scorevoice *voice, long n){ // computes the nth (0-based) measure of a score voice
    t_measure *curr = voice->firstmeasure; 
    long i;
    
    if (n < 0 || n >= voice->num_measures)  
        return NULL;
    
    for (i = 0; i < n && curr; i++)
        curr = curr->next;
    
    return curr;
    // to be improved: if the chord# is > n/2, pass the list the other way round!
}

t_rational ts_to_sym_duration(t_timesignature *ts)
{
    if (ts)
        return genrat(ts->numerator, ts->denominator);
    else
        return long2rat(0);
    
}

t_rational measure_get_sym_duration(t_measure *meas) { // calcualte the symbolic (rational) duration of a measure
    return ts_to_sym_duration(&meas->timesignature);
}

t_rational get_ts_sym_duration(t_timesignature ts) { // calcualte the symbolic (rational) duration of a measure
    return genrat(ts.numerator, ts.denominator);
}

t_rational get_sym_durations_between_timepoints(t_scorevoice *voice, t_timepoint tp1, t_timepoint tp2) { // calcualte the symbolic (rational) duration between two timepoints
    if (timepoints_compare(tp1, tp2) >= 0)
        return long2rat(0);
    else {
        long start_meas = tp1.measure_num;
        long end_meas = tp2.measure_num;
        t_rational start_pim = tp1.pt_in_measure;
        t_rational end_pim = tp2.pt_in_measure;
        t_measure *start_measure = nth_measure_of_scorevoice(voice, start_meas);
        if (start_meas == end_meas)
            return rat_rat_diff(end_pim, start_pim);
        else if (!start_measure)
            return long2rat(0);
        else if (start_meas + 1 == end_meas) 
            return rat_rat_sum(rat_rat_diff(measure_get_sym_duration(start_measure), start_pim), end_pim);
        else {
            t_measure *meas = nth_measure_of_scorevoice(voice, start_meas + 1);
            t_rational intermediate_measures = long2rat(0);
            while (meas && (meas->measure_number < end_meas)) {
                intermediate_measures = rat_rat_sum(intermediate_measures, measure_get_sym_duration(meas));
                meas = meas->next;
            }
            return rat_rat_sum(rat_rat_sum(rat_rat_diff(measure_get_sym_duration(start_measure), start_pim), end_pim), intermediate_measures);
        }
    }
}

t_tempo* tempo_get_first(t_scorevoice *voice) {
    return tempo_get_first_after_measure(voice->firstmeasure);
}

t_tempo* tempo_get_first_after_measure(t_measure *meas) {
    t_tempo *tempo = NULL;
    if (meas) {
        while (!tempo && meas) {
            tempo = meas->firsttempo;
            meas = meas->next;
        }
    }
    return tempo;
}

t_tempo* tempo_get_last(t_scorevoice *voice) {
    t_tempo *tempo = NULL;
    t_measure *meas = voice->lastmeasure;
    if (meas) {
        while ((!(tempo)) && meas) {
            tempo = meas->lasttempo;
            meas = meas->prev;
        }
    }
    return tempo;
}

t_tempo* tempo_get_next(t_tempo *tempo) {
    t_tempo *nexttempo = NULL;
    t_measure *meas;
    if (tempo->next)
        return tempo->next;
    meas = tempo->owner->next;
    if (meas) {
        while ((!(nexttempo)) && meas) {
            nexttempo = meas->firsttempo;
            meas = meas->next;
        }
    }
    return nexttempo;
} 

t_tempo* tempo_get_prev(t_tempo *tempo) {
    t_tempo *prevtempo = NULL;
    t_measure *meas;
    if (tempo->prev)
        return tempo->prev;

    
    meas = tempo->owner->prev;
    if (meas) {
        while ((!(prevtempo)) && meas) {
            prevtempo = meas->lasttempo;
            meas = meas->prev;
        }
    }
    return prevtempo;
}

t_measure* measure_get_next(t_measure *measure)
{
    return measure->next;
}

t_measure* measure_get_prev(t_measure *measure)
{
    return measure->prev;
}



t_timepoint build_timepoint(long measure_num, t_rational point_in_measure) {
    return build_timepoint_with_voice(measure_num, point_in_measure, 0);
}

t_timepoint build_timepoint_with_voice(long measure_num, t_rational point_in_measure, long voice_num) {
    t_timepoint tp;
    tp.measure_num = measure_num;
    tp.pt_in_measure = point_in_measure;
    tp.voice_num = voice_num;
    return tp;
}

t_llll *get_timepoint_as_llll(t_notation_obj *r_ob, t_timepoint tp)
{
    t_llll *out = llll_get();
    if (r_ob->old_timepoint_syntax_bw_compatibility) {
        llll_appendlong(out, tp.measure_num + 1, 0, WHITENULL_llll);
        llll_appendrat(out, tp.pt_in_measure, 0, WHITENULL_llll);
        llll_appendlong(out, tp.voice_num + 1, 0, WHITENULL_llll);
    } else {
        llll_appendlong(out, tp.voice_num + 1, 0, WHITENULL_llll);
        llll_appendlong(out, tp.measure_num + 1, 0, WHITENULL_llll);
        llll_appendrat(out, tp.pt_in_measure, 0, WHITENULL_llll);
    }
    return out;
}

t_rational get_rat_durations_sec_between_timepoints(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp1, t_timepoint tp2) { 
// calcualte the rational duration in ms between two timepoints (must be tp1 < tp2)
    char go_safe = true;
    t_tempo *tempo = tempo_get_first(voice);
    t_rational tp2_tempo = (tempo) ? tempo->tempo_value : long2rat(60);
    t_timepoint intermediate_point = tp1; 
    t_rational intermediate_tempo = (tempo) ? tempo->tempo_value : long2rat(60); 
    t_tempo *tempo_L; t_tempo *tempo_R = NULL;
    t_rational out_duration, last_trapece;
    char tempo_L_has_changed = false;
    t_tempo *first_voice_tempo = tempo_get_first(voice);
    
    if (!voice->firstmeasure)
        return long2rat(0);
    
    if (first_voice_tempo) {
        tempo_L = build_tempo(long2rat(0), first_voice_tempo->figure_tempo_value, first_voice_tempo->tempo_figure, 0); 
//        tempo_L->owner = first_voice_tempo->owner;
        tempo_L->owner = voice->firstmeasure;
    } else {
        tempo_L = build_tempo(long2rat(0), long2rat(60), RAT_1OVER4, 0);
        tempo_L->owner = voice->firstmeasure;
    }
    
    out_duration = long2rat(0);
    while (tempo && (timepoints_compare(build_timepoint(tempo->owner->measure_number, tempo->changepoint), tp2) <= 0)) {
        long cmp1 = timepoints_compare(build_timepoint(tempo->owner->measure_number, tempo->changepoint), tp1);
        if (cmp1 <= 0) { // tempo->changepoint BEFORE tp1
            if (!tempo_L_has_changed)
                free_tempo(r_ob, tempo_L);
            tempo_L = tempo;
            tempo_L_has_changed = true;
        } else {
            // gotta add a trapece
            t_rational newtempo, trapece;
            tempo_R = tempo;
            if (timepoints_compare(build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint), tp1) < 0) {
                intermediate_point = tp1;
                intermediate_tempo = (tempo_L->interpolation_type == 1) ? get_intermediate_tempo(voice, tp1, tempo_L, tempo_R) : tempo_L->tempo_value;
            } else {
                intermediate_point = build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint);
                intermediate_tempo = tempo_L->tempo_value;
            }

            newtempo = (tempo_L->interpolation_type == 1) ? tempo_R->tempo_value : tempo_L->tempo_value;
            
            trapece = get_tempo_trapece_sec(voice, intermediate_tempo, intermediate_point, newtempo, build_timepoint(tempo->owner->measure_number, tempo->changepoint));
            
            if (go_safe) 
                trapece = approx_rat_with_rat(trapece, CONST_RAT_MAX_NUM_SAFETY, CONST_RAT_MAX_DEN_SAFETY);
            out_duration = rat_rat_sum(out_duration, trapece);
            if (go_safe) 
                out_duration = approx_rat_with_rat(out_duration, CONST_RAT_MAX_NUM_SAFETY, CONST_RAT_MAX_DEN_SAFETY);
            if (!tempo_L_has_changed) {
                free_tempo(r_ob, tempo_L);
                tempo_L_has_changed = true;
            }
            tempo_L = tempo;
        }
        tempo = tempo_get_next(tempo);
        tempo_R = tempo;
    }
    
    // last trapece
    if (timepoints_compare(tp2, build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint)) < 0) {  ///    tp1 --- tp2 --- L
        intermediate_point = tp1;
        intermediate_tempo = tempo_L->tempo_value;
    } else if (timepoints_compare(build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint), tp1) < 0) { /// L --- tp1 --- tp2
        intermediate_point = tp1;
        if (tempo_R) 
            intermediate_tempo = (tempo_L->interpolation_type == 1) ? get_intermediate_tempo(voice, tp1, tempo_L, tempo_R) : tempo_L->tempo_value;
        else 
            intermediate_tempo = tempo_L->tempo_value;
    } else {  ///  tp1 --- L --- tp2
        intermediate_point = build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint);
        intermediate_tempo = tempo_L->tempo_value;
    }
    
    if (!tempo_R) // tempo_L was the last tempo! 
        tp2_tempo = tempo_L->tempo_value;
    else if (timepoints_compare(build_timepoint(tempo_R->owner->measure_number, tempo_R->changepoint), tp2) == 0) // tempo change precisely on the end
        tp2_tempo = (tempo_L->interpolation_type == 1) ? tempo_R->tempo_value : tempo_L->tempo_value;
    else // there's another tempo, but later
        tp2_tempo = (tempo_L->interpolation_type == 1) ? get_intermediate_tempo(voice, tp2, tempo_L, tempo_R) : tempo_L->tempo_value;
    
    if (go_safe){
        intermediate_tempo = rat_clip(intermediate_tempo, long2rat(0), long2rat(CONST_MAX_TEMPO_SAFETY));
        tp2_tempo = rat_clip(tp2_tempo, long2rat(0), long2rat(CONST_MAX_TEMPO_SAFETY));
    }
    
    last_trapece = get_tempo_trapece_sec(voice, intermediate_tempo, intermediate_point, tp2_tempo, tp2);
    
    if (go_safe) 
        last_trapece = approx_rat_with_rat(last_trapece, CONST_RAT_MAX_NUM_SAFETY, CONST_RAT_MAX_DEN_SAFETY);
    out_duration = rat_rat_sum(out_duration, last_trapece);
    if (go_safe) 
        out_duration = approx_rat_with_rat(out_duration, CONST_RAT_MAX_NUM_SAFETY, CONST_RAT_MAX_DEN_SAFETY);
    
    if (!tempo_L_has_changed)
        free_tempo(r_ob, tempo_L);

    return out_duration;
}

// calculate tempo trapece area
t_rational get_tempo_trapece_sec(t_scorevoice *voice, t_rational tempo_L_value, t_timepoint tempo_L_tp, t_rational tempo_R_value, t_timepoint tempo_R_tp){ //, char go_safe){
    t_rational r1 = rat_rat_sum(long_rat_div(1, tempo_L_value), long_rat_div(1, tempo_R_value));
    t_rational r2 = get_sym_durations_between_timepoints(voice, tempo_L_tp, tempo_R_tp);
    return rat_rat_prod(rat_long_prod(r1, 120), r2);
}

// calculates the intermediate tempo at point <tp>, in voice <voice>, given the previous <tempo_L> and the following <tempo_R>
t_rational get_intermediate_tempo(t_scorevoice *voice, t_timepoint tp, t_tempo *tempo_L, t_tempo *tempo_R){
    t_rational D = rat_rat_div(get_sym_durations_between_timepoints(voice, build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint), tp), 
                               get_sym_durations_between_timepoints(voice, build_timepoint(tempo_L->owner->measure_number, tempo_L->changepoint), build_timepoint(tempo_R->owner->measure_number, tempo_R->changepoint)));
    t_rational PR0 = rat_rat_prod(tempo_R->tempo_value, tempo_L->tempo_value);
    t_rational PR1 = rat_rat_prod(D, tempo_L->tempo_value);
    t_rational PR2 = rat_rat_prod(long_rat_diff(1, D), tempo_R->tempo_value);

    //    dev_post("D: %ld/%ld, Pr0: %ld/%ld, Pr1: %ld/%ld, Pr2:%ld/%ld", D.r_num, D.r_den, PR0.r_num, PR0.r_den, PR1.r_num, PR1.r_den, PR2.r_num, PR2.r_den);
    
    if (!is_rat_rat_sum_safe(PR1, PR2, CONST_RAT_MAX_DEN_SAFETY) || !is_rat_rat_div_safe(PR0, rat_rat_sum(PR1, PR2), CONST_RAT_MAX_DEN_SAFETY)) {
        double Dd = rat2double(D);
        double tempoLd = rat2double(tempo_L->tempo_value);
        double tempoRd = rat2double(tempo_R->tempo_value);
    
        //    dev_post("Approximation needed for intermediate tempi");
        
        return approx_double_with_rat_fixed_den(tempoRd * tempoLd / (Dd * tempoLd + (1 - Dd) * tempoRd), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
    }
        
    return rat_rat_div(PR0, rat_rat_sum(PR1, PR2));
    
//    return rat_rat_div(rat_rat_prod(tempo_R->tempo_value, tempo_L->tempo_value), 
//                       rat_rat_sum(rat_rat_prod(D, tempo_L->tempo_value), rat_rat_prod(long_rat_diff(1, D), tempo_R->tempo_value)));
}

// same as before, but works with doubles, and wants as input a scale parameter D
// D is the parameter for scaling. When D=0 we get the <tempo_L> value, when D=1 we get the <tempo_R> value.
double get_intermediate_tempo_double(double D, t_tempo *tempo_L, t_tempo *tempo_R){
    double tauL = rat2double(tempo_L->tempo_value);
    double tauR = rat2double(tempo_R->tempo_value);

    // old way:
    //    return tauL + D*(tauR-tauL);
    
    return (tauL*tauR)/(D*tauL + (1-D)*tauR);
}


// convert an information about an absolute onset into a symbolic difference.
// the left and right boundaries are given by two tempi, occurring in <tempo_L_ms> and <tempo_R_ms>, which have a symbolic given distance of <delta_sym_tempi>
// and which has values <tempo_L_value>, <tempo_R_value>. 
// the function returns the symbolic distance between <left_boundary_ms> and <onset_ms>
double get_sym_diff_from_onset_ms(double onset_ms, double tempo_L_ms, double tempo_L_value, double tempo_R_ms, double tempo_R_value, t_rational delta_sym_tempi){
    double v_L = 240/tempo_L_value; // we obtain speeds (see function documentation, chapter "Tempo functions")
    double v_R = 240/tempo_R_value;
    double a = (v_R - v_L)/(rat2double(delta_sym_tempi));
    double eq_delta = v_L * v_L + 2 * a * (onset_ms - tempo_L_ms)/1000.;
    double sqrt_delta, sol1, sol2;

    // see the quadratic formula in section 2.3    "Uniformly accelerating tempo" of the function documentation
    if (eq_delta < 0) 
        eq_delta = 0; // Should NEVER HAPPEN
    
    sqrt_delta = sqrt(eq_delta);
    sol1 = (-v_L + sqrt_delta)/a;
    sol2 = (-v_L - sqrt_delta)/a;
    if (sol1 >= -CONST_EPSILON4 && sol1 < rat2double(delta_sym_tempi) + CONST_EPSILON4)
        return sol1;

    return sol2;
}


 // calculates the rational measure durations (in rational ms)
void calculate_rat_measure_durations_ms(t_notation_obj *r_ob, t_measure *meas)
{
    t_scorevoice *voice = meas->voiceparent;
    t_timepoint tp1, tp2;
    tp1.measure_num = meas->measure_number; tp1.pt_in_measure = long2rat(0); // beginning of measure
    tp2.measure_num = meas->measure_number; tp2.pt_in_measure = measure_get_sym_duration(meas); // end of measure
    meas->r_total_duration_sec = get_rat_durations_sec_between_timepoints(r_ob, voice, tp1, tp2);
    meas->total_duration_ms = rat2double(meas->r_total_duration_sec) * 1000;

}


// calculates the rational measure durations (in rational ms)
void calculate_rat_measure_durations_ms_for_voice(t_notation_obj *r_ob, t_scorevoice *voice)
{
    t_measure *meas;
    
    for (meas = voice->firstmeasure; meas; meas = meas->next)
        calculate_rat_measure_durations_ms(r_ob, meas);

}

t_chord *find_ms_nearest_chord_in_rollvoice(t_notation_obj *r_ob, t_rollvoice *voice, double ms){
    t_chord *ch;
    
    if (voice->firstchord && ms <= voice->firstchord->onset)
        return voice->firstchord;

    if (voice->lastchord && ms >= voice->lastchord->onset)
        return voice->lastchord;

    for (ch = voice->firstchord; ch && ch->next; ch = ch->next){
        if (ms >= ch->onset && ms < ch->next->onset){
            if (fabs(ms - ch->onset) < fabs(ms - ch->next->onset))
                return ch;
            else
                return ch->next;
        }
    }
    return NULL;
}

t_chord *find_ux_nearest_chord_in_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, double ux)
{
    t_measure *meas;
    for (meas = voice->firstmeasure; meas; meas = meas->next){
        if (ux >= meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux &&
            ux < meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux)
            return find_ux_nearest_chord_in_measure(r_ob, meas, ux);
    }
    return NULL;
}

t_chord *find_ux_nearest_nonrest_chord_in_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, double ux)
{
    t_chord *ch = find_ux_nearest_chord_in_scorevoice(r_ob, voice, ux);
    if (!ch->firstnote) {
       // extending to the right
        t_chord *right = chord_get_next_nonrest(ch), *left = chord_get_prev_nonrest(ch);
        
        if (!right && !left)
            return NULL;
        if (!right)
            return left;
        if (!left)
            return right;
        
        double left_ux = chord_get_alignment_ux(r_ob, left);
        double right_ux = chord_get_alignment_ux(r_ob, right);
        if (fabs(left_ux - ux) <= fabs(right_ux - ux))
            return left;
        else
            return right;
    } else
        return ch;
}


t_chord *find_ux_nearest_chord_in_measure(t_notation_obj *r_ob, t_measure *measure, double ux){
// finds the nearest chord to a given unmeasured x (within a measure)
    double diff;
    t_chord *best_chord, *chord;
    double ux_relative_to_tuttipoint = ux - measure->tuttipoint_reference->offset_ux; // + measure->start_barline_offset_ux);
    if (!measure->firstchord) return NULL;
    diff = fabs(measure->firstchord->stem_offset_ux - ux_relative_to_tuttipoint);
    best_chord = measure->firstchord; chord = measure->firstchord->next; 
    while (chord) {
        double this_diff = fabs(chord->stem_offset_ux - ux_relative_to_tuttipoint);
        if (this_diff < diff) {
            diff = this_diff;
            best_chord = chord;
        }
        chord = chord->next;
    }
    return best_chord;
}

t_measure_end_barline *build_measure_end_barline(t_notation_obj *r_ob, t_measure *measure_ref){
    t_measure_end_barline *b = (t_measure_end_barline *)bach_newptr(sizeof(t_measure_end_barline));
    notation_item_init(&b->r_it, k_MEASURE_END_BARLINE);
    b->barline_type = k_BARLINE_AUTOMATIC;
    b->owner = measure_ref;
    return b;
}


void set_need_perform_analysis_and_change_flag(t_notation_obj *r_ob)
{
    r_ob->need_perform_analysis_and_change = true;
}

t_measure *build_measure(t_notation_obj *r_ob, t_llll *time_signature){ 
    t_measure *outmeas = (t_measure *)bach_newptrclear(sizeof(t_measure));

    notation_item_init(&outmeas->r_it, k_MEASURE);
    outmeas->end_barline = build_measure_end_barline(r_ob, outmeas);
    
    outmeas->measure_number = -1;
    outmeas->num_chords = 0;
    outmeas->num_tempi = 0;
    outmeas->firstchord = outmeas->lastchord = NULL;
    outmeas->firsttempo = outmeas->lasttempo = NULL;
    outmeas->firstbeam = outmeas->lastbeam = NULL;
    outmeas->start_barline_offset_ux = 0;
    outmeas->width_ux = 0.;
    outmeas->tuttipoint_reference = NULL;
    outmeas->r_tuttipoint_onset_sec = long2rat(0);
    outmeas->r_total_content_duration = long2rat(0);
    outmeas->r_total_duration_sec = long2rat(0);
    outmeas->tuttipoint_onset_ms = outmeas->total_duration_ms = 0;
    outmeas->need_recompute_beamings = false;
    outmeas->need_recompute_beams_positions = false;
    outmeas->need_check_ties = false;
    outmeas->need_check_autocompletion = false;
    set_need_perform_analysis_and_change_flag(r_ob);
    outmeas->locked = false;
    outmeas->muted = false;
    outmeas->solo = false;
    outmeas->beaming_calculation_flags = k_BEAMING_CALCULATION_DO;

    outmeas->custom_boxing = false;
    outmeas->boxes = llll_get();

    outmeas->local_spacing_width_multiplier = 1.;
    outmeas->fixed_spacing_uwidth = 0.;
    outmeas->is_spacing_fixed = 0;
    
    outmeas->show_measure_number = true;
    outmeas->force_measure_number = false;
    outmeas->forced_measure_number = 0;

    outmeas->rhythmic_tree = llll_get();
//    outmeas->ties_tree = NULL;
    outmeas->info_for_pwgl = llll_get();
    outmeas->lock_rhythmic_tree = false;
    outmeas->measure_filling = -1;
    
    // default time signature
    outmeas->timesignature.numerator = 4;
    outmeas->timesignature.denominator = 4;
    outmeas->timesignature.num_numerator_elements = 1;
    outmeas->timesignature.numerator_elements[0] = 4;
    
    // if time_signature lll is correct, we put that time signature
    if (time_signature) 
        measure_set_ts_and_tempo_from_llll(r_ob, outmeas, time_signature, NULL, k_BARLINE_AUTOMATIC, NULL, false);
    
    if (time_signature) 
        compute_utf_timesignature(r_ob, &outmeas->timesignature);
    
    return outmeas;
}

t_bpt *build_breakpoint(double rel_x_pos, double delta_mc, double velocity, double slope, t_note *owner){
    t_bpt *out = (t_bpt *)bach_newptr(sizeof(t_bpt));
    notation_item_init(&out->r_it, k_PITCH_BREAKPOINT);
    out->owner = owner;
    out->next = out->prev = NULL;
    out->rel_x_pos = rel_x_pos;
    out->delta_mc = delta_mc;
    out->velocity = velocity < 0 ? owner->velocity : velocity;
    out->draggingvelocity = out->velocity;
    out->slope = slope;
    return out;
}

t_duration_line *build_duration_line(t_note *owner){ 
    t_duration_line *out = (t_duration_line *)bach_newptr(sizeof(t_duration_line));
    notation_item_init(&out->r_it, k_DURATION_LINE);
    out->owner = owner;
    return out;
}

t_note *build_default_note(t_notation_obj *r_ob)
{
    double argv[2]; 
    argv[0] = CONST_DEFAULT_NEW_NOTE_DURATION; 
    argv[1] = CONST_DEFAULT_NEW_NOTE_CENTS;
    return build_note_from_ac_av(r_ob, 2, argv);
}

t_note *build_note(t_notation_obj *r_ob, double cents, double duration, long velocity)
{
    double argv[3]; 
    argv[0] = duration; 
    argv[1] = cents;
    argv[2] = velocity;
    return build_note_from_ac_av(r_ob, 3, argv);
}


t_note *build_note_from_ac_av(t_notation_obj *r_ob, long argc, double *argv){
// builds a note from its arguments, and puts it in the element pointed by *note
// arguments can be
// - duration midicents
// - duration midicents velocity
// - duration midicents velocity accidental_num accidental_den 
// - duration midicents velocity accidental_num accidental_den acc_flag
// - duration midicents velocity accidental_num accidental_den acc_flag ID    // argv[0] argv[1] argv[2] argv[3] argv[4] argv[5]

    double this_duration = CONST_DEFAULT_NEW_NOTE_DURATION, this_midicents = CONST_DEFAULT_NEW_NOTE_CENTS, this_velocity = r_ob->default_velocity;
    double this_def_accidental = k_ACCIDENTALS_AUTO, this_ID = -1;
    t_rational this_accidental;
    int i;

    t_note *note = (t_note *)bach_newptrclear(sizeof(t_note));
    notation_item_init(&note->r_it, k_NOTE);

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_item_check_against_tuttipoints(r_ob, (t_notation_item *)note);
#endif
    
    note->durationline = build_duration_line(note);
    note->parent = NULL; // was: (t_chord *)WHITENULL; but why?

    // adding the new note
    if (argc == 2) { // onset duration midicents
        this_duration = argv[0];
        this_midicents = argv[1];
        this_velocity = r_ob->default_velocity;
        this_accidental.r_num = 0;
        this_accidental.r_den = 1;
        this_def_accidental = k_ACCIDENTALS_AUTO;
        this_ID = -1;
    } else if (argc == 3) { // onset duration midicents velocity
        this_duration = argv[0];
        this_midicents = argv[1];
        this_velocity = argv[2];
        this_accidental.r_num = 0;
        this_accidental.r_den = 1;
        this_def_accidental = k_ACCIDENTALS_AUTO;
        this_ID = -1;
    } else if (argc == 5) { // onset duration midicents velocity accidentals
        this_duration = argv[0];
        this_midicents = argv[1];
        this_velocity = argv[2];
        this_accidental.r_num = (long)argv[3];
        this_accidental.r_den = (long)argv[4];
        this_def_accidental = k_ACCIDENTALS_USER;
        this_ID = -1;
    } else if (argc == 6) { // onset duration midicents velocity accidentals acc_flag
        this_duration = argv[0];
        this_midicents = argv[1];
        this_velocity = argv[2];
        this_accidental.r_num = (long)argv[3];
        this_accidental.r_den = (long)argv[4];
        this_def_accidental = argv[5];
        this_ID = -1;
    } else if (argc >= 7) { // onset duration midicents velocity accidentals acc_flag
        this_duration = argv[0];
        this_midicents = argv[1];
        this_velocity = argv[2];
        this_accidental.r_num = (long)argv[3];
        this_accidental.r_den = (long)argv[4];
        this_def_accidental = argv[5];
        this_ID = argv[6];
    }
    rat_reduce(&this_accidental);
    // check validity
    if (this_duration < 0) 
        this_duration = 0;
    this_velocity = CLAMP(this_velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);

    // find the position to add the chord in the chain of chords
    note->duration = this_duration;
    note->midicents = this_midicents;
    note->velocity = this_velocity;        
    note->draggingvelocity = this_velocity;
    
    if (this_def_accidental == k_ACCIDENTALS_USER) {
        note_set_user_enharmonicity_from_screen_representation(note, this_midicents - this_accidental * 200, this_accidental);
    } else {
        note->pitch_original = t_pitch::NaP;
        note_set_auto_enharmonicity(note);
    }
    note->pitch_displayed = note->pitch_original; // just for now
    
    note->show_accidental = true;
    note->tie_to = NULL;
    note->tie_from = NULL;
    note->tie_direction = 0;
    note->locked = false;
    note->muted = false;
    note->played = false;
    note->solo = false;

    note->notehead_ID = k_NOTEHEAD_DEFAULT;
    note->notehead_uwidth = 0;

    
    note->num_articulations = 0;
    note->articulation = NULL;
    
#ifdef BACH_SUPPORT_SLURS
    note->num_slurs_to = 0;
    note->num_slurs_from = 0;
#endif
    note->notehead_resize = note->accidentals_resize = 1.;
    
    // breakpoints
    note->num_breakpoints = 2; // by default: just the beginning and the end
    note->firstbreakpoint = build_breakpoint(0, 0, this_velocity, 0, note);
    note->lastbreakpoint = build_breakpoint(1, 0, this_velocity, 0, note);
    note->firstbreakpoint->next = note->lastbreakpoint; 
    note->lastbreakpoint->prev = note->firstbreakpoint;
    
    // slots: nothing for now, just tabula rasa
    for (i = 0; i< CONST_MAX_SLOTS; i++) {
#ifdef BACH_SLOTS_HAVE_LASTITEM
        note->slot[i].lastitem = NULL;
#endif
        note->slot[i].firstitem = NULL;
#ifdef BACH_SLOTS_HAVE_OWNER
        note->slot[i].owner = note;
#endif
#ifdef BACH_SLOTS_HAVE_ACTIVEITEM
        note->slot[i].activeitem = NULL;
#endif
        note->slot[i].length = 0;
    }
        
    // by default:
    note->next = note->prev = NULL;
    
    check_note_breakpoints(note);
    
    return note;
}

// NEW ONE
t_chord *build_chord_from_notes(t_notation_obj *r_ob, t_note *firstnote, t_note *lastnote) 
{
    long count = 0;
    t_note *temp;
    
    t_chord *this_ch = (t_chord *)bach_newptrclear(sizeof(t_chord));
    
    notation_item_init(&this_ch->r_it, k_CHORD);
    this_ch->lyrics = build_lyrics(this_ch);
    this_ch->dynamics_slot = NULL;

    this_ch->imposed_direction = 0;
    this_ch->just_added_from_separate_parameters = false;
    this_ch->onset = 0;
    this_ch->need_recompute_parameters = false;
    this_ch->voiceparent = NULL;
    this_ch->parent = NULL;
    this_ch->is_score_chord = (r_ob && r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? true : false);
    this_ch->system_index = 0;
    this_ch->rhythmic_tree_elem = NULL;
    this_ch->overall_tuplet_ratio = long2rat(1);
    
    this_ch->firstnote = firstnote;
    this_ch->lastnote = lastnote;

    // set by default
    this_ch->r_sym_duration = RAT_1OVER4;
    this_ch->r_sym_onset = long2rat(0);

    for (temp = firstnote; temp; temp = temp->next) {
        count++;
        temp->parent = this_ch;
        if (temp == lastnote)
            break;
    }
    this_ch->num_notes = count;
    
    this_ch->played = false;
    this_ch->muted = false;
    this_ch->locked = false;
    this_ch->solo = false;
    this_ch->is_grace_chord = false;
    this_ch->dont_split_for_ts_boxes = false;

    this_ch->num_articulations = 0; 
    this_ch->articulation = NULL;

    this_ch->next = this_ch->prev = NULL;
    return this_ch;
}

void clone_slots_for_notation_item(t_notation_obj *r_ob, t_notation_item *from, t_notation_item *to, e_clone_for_types clone_for, char force_clone_for_chords)
{
    // slots
    long i;
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_item_check_slots(r_ob, from);
    notation_item_check_slots(r_ob, to);
#endif

    for (i = 0; i < CONST_MAX_SLOTS; i++) { // first: tabula rasa
        t_slot *slot_to = notation_item_get_slot_extended(r_ob, to, i, force_clone_for_chords);
        if (!slot_to) {
            continue;
        }
        slot_to->firstitem = NULL;
#ifdef BACH_SLOTS_HAVE_LASTITEM
        slot_to->lastitem = NULL;
#endif
#ifdef BACH_SLOTS_HAVE_OWNER
        slot_to->owner = cloned_nt;
#endif
#ifdef BACH_SLOTS_HAVE_ACTIVEITEM
        slot_to->activeitem = NULL;
#endif
        slot_to->length = 0;
    }
    
    
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        
        if (clone_for == k_CLONE_FOR_SPLIT && !r_ob->slotinfo[i].copy_when_split)
            continue;
        
        t_slot *slot_from = notation_item_get_slot_extended(r_ob, from, i, force_clone_for_chords);
        t_slot *slot_to = notation_item_get_slot_extended(r_ob, to, i, force_clone_for_chords);
        if (!slot_from || !slot_to) continue;
        if (slot_from->firstitem) { // there's something in the slot
            long length = slot_from->length;
            t_slotitem *temp, *prec;
            slot_to->length = length;
            // copying items
            temp = slot_from->firstitem;
            prec = NULL;
            while (temp) {
                t_slotitem *newitem = build_slotitem(r_ob, slot_to);
                
                // linking
                if (!prec)
                    slot_to->firstitem = newitem;
                newitem->prev = prec;
                if (prec)
                    prec->next = newitem;
                prec = newitem;
                
                // building the item
                switch (r_ob->slotinfo[i].slot_type) {
                        
                    case k_SLOT_TYPE_FUNCTION:
                    {
                        t_pts *new_pts = (t_pts *)bach_newptr(sizeof(t_pts));
                        new_pts->x = ((t_pts *)temp->item)->x;
                        new_pts->y = ((t_pts *)temp->item)->y;
                        new_pts->slope = ((t_pts *)temp->item)->slope;
                        newitem->item = new_pts;
                    }
                        break;
                    case k_SLOT_TYPE_3DFUNCTION:
                    {
                        t_pts3d *new_pts = (t_pts3d *)bach_newptr(sizeof(t_pts3d));
                        new_pts->x = ((t_pts3d *)temp->item)->x;
                        new_pts->y = ((t_pts3d *)temp->item)->y;
                        new_pts->z = ((t_pts3d *)temp->item)->z;
                        new_pts->slope = ((t_pts3d *)temp->item)->slope;
                        newitem->item = new_pts;
                    }
                        break;
                    case k_SLOT_TYPE_SPAT:
                    {
                        t_spatpt *new_pts = (t_spatpt *)bach_newptr(sizeof(t_spatpt));
                        new_pts->t = ((t_spatpt *)temp->item)->t;
                        new_pts->radius = ((t_spatpt *)temp->item)->radius;
                        new_pts->angle = ((t_spatpt *)temp->item)->angle;
                        new_pts->interp = ((t_spatpt *)temp->item)->interp;
                        newitem->item = new_pts;
                    }
                        break;
                    case k_SLOT_TYPE_INT:
                    case k_SLOT_TYPE_INTLIST:
                    {
                        long *new_long = (long *)bach_newptr(sizeof(long));
                        *new_long = *((long *)temp->item);
                        newitem->item = new_long;
                    }
                        break;
                    case k_SLOT_TYPE_NOTEHEAD:
                    {
                        newitem->item = (t_symbol *)temp->item;
                    }
                        break;
                    case k_SLOT_TYPE_DYNAMICS:
                    {
                        t_dynamics *newdyn = dynamics_clone((t_dynamics *)temp->item, to);
                        newitem->item = newdyn;
                    }
                        break;
                    case  k_SLOT_TYPE_ARTICULATIONS:
                    {
                        // we need to handle the clone_for stuff
                        char must_clone_articulation = true;
                        long id = ((t_articulation *)temp->item)->articulation_ID;
                        long options = r_ob->articulations_typo_preferences.artpref[id].options;
                        if ((clone_for == k_CLONE_FOR_SPLIT && !(options & k_ARTICULATION_OPTION_COPY_WHEN_SPLIT)) ||
                            (clone_for == k_CLONE_FOR_SAME_CHORD && !(options & k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD)) ||
                            (clone_for == k_CLONE_FOR_NEW && !(options & k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD)))
                            must_clone_articulation = false;
                        
                        if (must_clone_articulation) {
                            t_articulation *new_art = build_articulation(r_ob, ((t_articulation *)temp->item)->articulation_ID, to, newitem, ((t_articulation *)temp->item)->original_name);
                            newitem->item = new_art;
                        } else {
                            prec = newitem->prev;
                            if (prec) prec->next = NULL;
                            slotitem_delete(r_ob, i, newitem);
                        }
                    }
                        break;
                    case k_SLOT_TYPE_FLOAT:
                    case k_SLOT_TYPE_FLOATLIST:
                    {
                        double *new_float = (double *)bach_newptr(sizeof(double));
                        *new_float = *((double *)temp->item);
                        newitem->item = new_float;
                    }
                        break;
                    case k_SLOT_TYPE_TEXT:
                    {// something wrong here... TO DO (char *)temp->item
                        newitem->item = (char *)bach_newptr((length + 1) * sizeof(char));
                        strncpy((char *) newitem->item, (char *) temp->item, length);
                        ((char *)newitem->item)[length] = 0;
                    }
                        break;
                    case k_SLOT_TYPE_LLLL:
                    case k_SLOT_TYPE_INTMATRIX:
                    case k_SLOT_TYPE_FLOATMATRIX:
                    case k_SLOT_TYPE_TOGGLEMATRIX:
                    { // something wrong here... TO DO (char *)temp->item
                        t_llll *this_llll = (t_llll *) temp->item;
                        t_llll *cloned = llll_clone(this_llll);
                        newitem->item = cloned;
                    }
                        break;
                    case k_SLOT_TYPE_FILELIST:
                    {
                        t_file *new_file = (t_file *)bach_newptr(sizeof(t_file));
                        new_file->pathID = ((t_file *)temp->item)->pathID;
                        new_file->filename_length = ((t_file *)temp->item)->filename_length;
                        new_file->exists = ((t_file *)temp->item)->exists;
                        t_slotitem *active = slot_get_active_slotitem(slot_from);
                        if (temp == active)
                            slot_set_active_item(slot_to, newitem);
                        strncpy_zero(new_file->filename, ((t_file *)temp->item)->filename, MAX_PATH_CHARS);
                        newitem->item = new_file;
                    }
                        break;
                    case k_SLOT_TYPE_FILTER:
                    case k_SLOT_TYPE_DYNFILTER:
                    {
                        t_biquad *new_biquad = (t_biquad *)bach_newptr(sizeof(t_biquad));
                        *new_biquad = *((t_biquad *)temp->item);
                        newitem->item = new_biquad;
                    }
                        break;
                        
                    case  k_SLOT_TYPE_COLOR:
                    {
                        t_jrgba *new_color = (t_jrgba *)bach_newptr(sizeof(t_jrgba));
                        *new_color = *((t_jrgba *)temp->item);
                        newitem->item = new_color;
                    }
                        break;
                        
                }
                temp = temp->next;
            }
            if (prec) {
#ifdef BACH_SLOTS_HAVE_LASTITEM
                slot_to->lastitem = prec;
                slot_to->lastitem->next = NULL;
#else
                prec->next = NULL;
#endif
            } // (char *)newitem->item  (char *)cloned_nt->slot[6].firstitem->item
        }
    }
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_item_check_slots(r_ob, from);
    notation_item_check_slots(r_ob, to);
#endif

}

void check_note_breakpoints(t_note *note)
{
#ifdef CONFIGURATION_Development
    if (!note->lastbreakpoint || !note->firstbreakpoint) {
        bach_breakpoint(0);
    }
#endif
}


t_note* clone_note(t_notation_obj *r_ob, t_note *note, e_clone_for_types clone_for)
{
// clones a note
    t_bpt *temp_bpt;
    long i; 
    t_note *cloned_nt = (t_note *)bach_newptrclear(sizeof(t_note));

    notation_item_clone(r_ob, &cloned_nt->r_it, &note->r_it);
    
    cloned_nt->durationline = build_duration_line(cloned_nt);
    cloned_nt->next = cloned_nt->prev = NULL;

    // basic values
    cloned_nt->midicents = note->midicents;
    cloned_nt->pitch_original = note->pitch_original;
    cloned_nt->pitch_displayed = note->pitch_displayed;

    cloned_nt->duration = note->duration;
    cloned_nt->locked = note->locked;
    cloned_nt->solo = note->solo;
    cloned_nt->muted = note->muted;
    cloned_nt->played = note->played;
    cloned_nt->velocity = note->velocity;
    
    cloned_nt->notehead_uwidth = note->notehead_uwidth;

// articulations are no longer cloned. Actually they are deprecated.
/*    if (clone_articulations) {
        cloned_nt->num_articulations = note->num_articulations;
        cloned_nt->articulation = (t_articulation *)bach_newptrclear(note->num_articulations * sizeof(t_articulation));
        for (i = 0; i < note->num_articulations; i++) {
            cloned_nt->articulation[i].articulation_ID = note->articulation[i].articulation_ID;
            cloned_nt->articulation[i].need_recompute_position = true;
            cloned_nt->articulation[i].number = i;
            notation_item_init(&cloned_nt->articulation[i].r_it, k_ARTICULATION);
            cloned_nt->articulation[i].owner = (t_notation_item *)cloned_nt;
        }
    } else { */
    cloned_nt->num_articulations = 0;
    cloned_nt->articulation = NULL;
//    }
    
    cloned_nt->parent = note->parent; // same chord, for now
    cloned_nt->tie_from = note->tie_from; // NULL;
    cloned_nt->tie_to = note->tie_to; //NULL;
    cloned_nt->tie_direction = note->tie_direction;

    cloned_nt->notehead_resize = cloned_nt->notehead_resize;
    cloned_nt->accidentals_resize = cloned_nt->accidentals_resize;

#ifdef BACH_SUPPORT_SLURS
    // we don't clone slurs
    cloned_nt->num_slurs_to = 0;
    cloned_nt->num_slurs_from = 0;
    // technical (we don't clone that, we'll recalculate that later)
#endif

    // breakpoints
    cloned_nt->num_breakpoints = 2; // first two bpts are dealt separately with
    cloned_nt->firstbreakpoint = build_breakpoint(0, 0, (note && note->firstbreakpoint) ? note->firstbreakpoint->velocity : -1, 0, cloned_nt);
    cloned_nt->lastbreakpoint = build_breakpoint(1, note->lastbreakpoint->delta_mc, (note && note->lastbreakpoint) ? note->lastbreakpoint->velocity : -1, note->lastbreakpoint->slope, cloned_nt);
    cloned_nt->firstbreakpoint->next = cloned_nt->lastbreakpoint;
    cloned_nt->lastbreakpoint->prev = cloned_nt->firstbreakpoint;

    temp_bpt = note->firstbreakpoint->next;
    for (i = 1; i < note->num_breakpoints - 1; i++) { // inner breakpoints
        add_breakpoint(r_ob, cloned_nt, temp_bpt->rel_x_pos, temp_bpt->delta_mc, temp_bpt->slope, 0, temp_bpt->velocity, 0);
        temp_bpt = temp_bpt->next;
    }
    
    clone_slots_for_notation_item(r_ob, (t_notation_item *)note, (t_notation_item *)cloned_nt, clone_for);
    
    check_note_breakpoints(cloned_nt);
    
    return cloned_nt;
} // clones a note0



// trims the incoming (left) note and returns the right part of the note – after the split
t_note *slice_note(t_notation_obj *r_ob, t_note *note, double left_slice_duration)
{
    double cut_rel_pos = left_slice_duration/note->duration;
    t_note *right_note = clone_note(r_ob, note, k_CLONE_FOR_SPLIT); // new (sliced) note
    long i;
    
    if (note_breakpoints_are_nontrivial(r_ob, note)) {
        // split breakpoints
        double new_midicents = note->midicents;
        t_llll *left_bpt = note_get_partial_breakpoint_values_as_llll(r_ob, note, 0., cut_rel_pos, NULL);
        t_llll *right_bpt = note_get_partial_breakpoint_values_as_llll(r_ob, note, cut_rel_pos, 1., &new_midicents);
        set_breakpoints_values_to_note_from_llll(r_ob, note, left_bpt);
        set_breakpoints_values_to_note_from_llll(r_ob, right_note, right_bpt);
        right_note->midicents = new_midicents;
        llll_free(left_bpt);
        llll_free(right_bpt);
    }
    
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        if (slot_is_temporal(r_ob, i)) { // temporal slots
            // need to split!
            t_llll *left_slot = notation_item_get_partial_single_slot_values_as_llll(r_ob, (t_notation_item *)note, k_CONSIDER_FOR_SAVING, i, 0., cut_rel_pos);
            t_llll *right_slot = notation_item_get_partial_single_slot_values_as_llll(r_ob, (t_notation_item *)note, k_CONSIDER_FOR_SAVING, i, cut_rel_pos, -1.); // -1 means: till the end (it's different from 1. for slot allowing extension beyond note tails)
            llll_wrap_once(&left_slot);
            llll_wrap_once(&right_slot);
            set_slots_values_to_note_from_llll(r_ob, note, left_slot);
            set_slots_values_to_note_from_llll(r_ob, right_note, right_slot);
        }
    }

    add_amount_to_all_trimlinked_slots(r_ob, (t_notation_item *)right_note, left_slice_duration);

    right_note->duration = note->duration - left_slice_duration;
    note->duration = left_slice_duration;

    return right_note;
}


// this function should not be usually called, note_insert() should be preferred.
// this function exists because sometimes internally we need notes to be appended, and not inserted depending on their order.
void note_append_force(t_notation_obj *r_ob, t_chord *chord, t_note *note, unsigned long force_ID){
    note->next = NULL; 
    note->prev = chord->lastnote;
    chord->lastnote->next = note;
    chord->lastnote = note;

    note->parent = chord; // set the parent fiels
    
    // increase the # of notes
    chord->num_notes++; 

#ifdef BACH_NOTES_HAVE_ID
    if (force_ID > 0) {
        shashtable_insert_with_key(r_ob->IDtable, note, force_ID, 1);
        note->r_it.ID = force_ID;
    } else
        note->r_it.ID = shashtable_insert(r_ob->IDtable, note);
#endif
    
    // recalculate parameters
    chord->need_recompute_parameters = true; // we have to recalculate chord parameters 
    set_need_perform_analysis_and_change_flag(r_ob);
}

void note_insert(t_notation_obj *r_ob, t_chord *chord, t_note *note, unsigned long force_ID){
// insert a note in a chord
    if (chord->firstnote) { // there is already at least a note: insert the note in the chord
        if (chord->firstnote->midicents > note->midicents) { // gotta put it at the first position
            note->next = chord->firstnote;
            note->prev = NULL;
            chord->firstnote->prev = note; // NB. was: this_note
            chord->firstnote = note;
        } else {
            t_note *temp_nt = chord->firstnote;
            while(temp_nt){ // cycle on the notes
                if (temp_nt->midicents > note->midicents){
                    // insert the note in the list
                    note->next = temp_nt;
                    note->prev = temp_nt->prev;
                    temp_nt->prev = note;
                    note->prev->next = note;
                    break;
                }
                temp_nt = temp_nt->next;
            }
            if (!temp_nt) { // it means that the cycle hasn't been broken, so we gotta put the chord at the end of the chain
                note->next = NULL; 
                note->prev = chord->lastnote;
                chord->lastnote->next = note;
                chord->lastnote = note;
            }
        }
    } else { // there were no notes in the chord
        note->prev = NULL;
        note->next = NULL;
        chord->firstnote = note;
        chord->lastnote = note;
    }
        
    chord->r_sym_duration = rat_abs(chord->r_sym_duration); // there's one note: can't be a rest any longer
    note->parent = chord; // set the parent field
    
    // increase the # of notes
    chord->num_notes++; 

#ifdef BACH_NOTES_HAVE_ID
    if (force_ID > 0) {
        shashtable_insert_with_key(r_ob->IDtable, note, force_ID, 1);
        note->r_it.ID = force_ID;
    } else
        note->r_it.ID = shashtable_insert(r_ob->IDtable, note);
#endif
    
    // recalculate parameters
    chord->need_recompute_parameters = true; // we have to recalculate chord parameters 
    set_need_perform_analysis_and_change_flag(r_ob);
}

t_tempo* clone_tempo(t_notation_obj *r_ob, t_tempo *tempo){
    t_tempo *newtempo = (t_tempo *)bach_newptr(sizeof(t_tempo));
    notation_item_clone(r_ob, &newtempo->r_it, &tempo->r_it);
    newtempo->changepoint = tempo->changepoint;
    newtempo->tempo_figure = tempo->tempo_figure;
    newtempo->figure_tempo_value = tempo->figure_tempo_value;
    newtempo->tempo_value = tempo->tempo_value;
    newtempo->interpolation_type = tempo->interpolation_type;
    newtempo->r_measure_onset_sec = tempo->r_measure_onset_sec;
    newtempo->tuttipoint_offset_ux = tempo->tuttipoint_offset_ux;
    newtempo->need_recalculate_onset = true;
    
    newtempo->owner = NULL; // will be set when the tempo is inserted

    return newtempo;
}

t_dynamics *build_dynamics(t_notation_item *owner)
{
    t_dynamics *dy = (t_dynamics *)bach_newptrclear(sizeof(t_dynamics));
    dy->text_deparsed = NULL;
    dy->owner_item = owner;
    dy->firstmark = dy->lastmark = NULL;
    dy->dynamics_left_uext = dy->dynamics_right_uext = dy->dynamics_min_uwidth = 0;
    notation_item_init(&dy->r_it, k_DYNAMICS);
    return dy;
}


t_lyrics *build_lyrics(t_chord *owner)
{
    t_lyrics *ly = (t_lyrics *)bach_newptr(sizeof(t_lyrics));
    notation_item_init(&ly->r_it, k_LYRICS);
    ly->label = NULL;
    ly->owner = owner;
    ly->lyrics_dashed_extension = ly->lyrics_ux_shift = ly->lyrics_uwidth = ly->lyrics_uheight = 0;
    return ly;
}

t_chord *clone_chord_without_lyrics(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for)
{
    t_chord *newch = clone_chord(r_ob, chord, clone_for);
    if (r_ob->link_lyrics_to_slot > 0) {
        t_note *note;
        for (note = newch->firstnote; note; note = note->next)
            note_clear_slot(r_ob, note, r_ob->link_lyrics_to_slot - 1, false);
    }
    return newch;
}


t_chord* clone_chord(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for)
{
// clones a chord
    t_chord *newchord = (t_chord *)bach_newptrclear(sizeof(t_chord));

    notation_item_clone(r_ob, &newchord->r_it, &chord->r_it);

    newchord->lyrics = build_lyrics(newchord);
    newchord->dynamics_slot = NULL;
    
    newchord->just_added_from_separate_parameters = false;
    newchord->onset = chord->onset;
    newchord->is_score_chord = chord->is_score_chord;
    newchord->system_index = 0;
    newchord->num_notes = chord->num_notes;
    newchord->parent = NULL; // this is very useful to avoid complications... sorry!
    newchord->rhythmic_tree_elem = NULL;
    newchord->need_recompute_parameters = true;
    set_need_perform_analysis_and_change_flag(r_ob);
    newchord->voiceparent = chord->voiceparent;
    newchord->float_steps = chord->float_steps;
    newchord->played = chord->played;
    newchord->locked = chord->locked;
    newchord->muted = chord->muted;
    newchord->solo = chord->solo;
    newchord->r_sym_duration = chord->r_sym_duration;
    newchord->r_sym_onset = chord->r_sym_onset;
    newchord->duration_ms = chord->duration_ms;
    newchord->r_duration_sec = chord->r_duration_sec;
    newchord->play_r_duration_sec = chord->play_r_duration_sec;
    newchord->play_r_measure_onset_sec = chord->play_r_measure_onset_sec;
    newchord->left_uextension = chord->left_uextension;
    newchord->right_uextension = chord->right_uextension;
    newchord->stem_offset_ux = chord->stem_offset_ux;
    newchord->alignment_ux = chord->alignment_ux;
    newchord->duration_ux = chord->duration_ux;
    newchord->r_measure_onset_sec = chord->r_measure_onset_sec;

    newchord->firstnote = NULL;
    newchord->lastnote = NULL;
    newchord->overall_tuplet_ratio = chord->overall_tuplet_ratio;
    newchord->imposed_direction = 0; // essential here!
    newchord->is_score_chord = chord->is_score_chord;
    newchord->system_index = 0;
    newchord->notehead_unicode_character = chord->notehead_unicode_character;
    newchord->num_dots = chord->num_dots;
    newchord->figure = chord->figure;
    newchord->is_grace_chord = chord->is_grace_chord;
    newchord->dont_split_for_ts_boxes = chord->dont_split_for_ts_boxes;
    
// Chord-attached articulations are deprecated.
/*    long i;
    if (clone_articulations) {
        newchord->num_articulations = chord->num_articulations;
        newchord->articulation = (t_articulation *)bach_newptrclear(chord->num_articulations * sizeof(t_articulation));
        for (i = 0; i < chord->num_articulations; i++) {
            newchord->articulation[i].articulation_ID = chord->articulation[i].articulation_ID;
            newchord->articulation[i].need_recompute_position = true;
            newchord->articulation[i].number = i;
            notation_item_init(&newchord->articulation[i].r_it, k_ARTICULATION);
            newchord->articulation[i].owner = (t_notation_item *)newchord;
        }
    } else { */
        newchord->num_articulations = 0;
        newchord->articulation = NULL;
//    }

    
    if (chord && chord->firstnote) {
        t_note *temp_nt = chord->firstnote; t_note *temp_prev = NULL;
        while (temp_nt) {
            t_note *temp_nt2 = clone_note(r_ob, temp_nt, clone_for);
            temp_nt2->parent = newchord; // change parent!!!
            temp_nt2->prev = temp_prev;
            if (temp_prev) // NOT the first note
                temp_prev->next = temp_nt2;
            else //first note
                newchord->firstnote = temp_nt2;
            
#ifdef BACH_NOTES_HAVE_ID
            temp_nt2->r_it.ID = shashtable_insert(r_ob->IDtable, temp_nt2);
#endif

            temp_prev = temp_nt2;
            temp_nt = temp_nt->next;
        }
        if (temp_prev) {
            temp_prev->next = NULL;
            newchord->lastnote = temp_prev;
        }
    }

#ifdef BACH_CHORDS_HAVE_SLOTS
    clone_slots_for_notation_item(r_ob, (t_notation_item *)chord, (t_notation_item *)newchord, clone_for);
#endif
    
    return newchord;
}

t_chord* clone_selected_notes_into_chord(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for)
{
// clones the selected notes (within a chord) into another chord
    t_chord *newchord = (t_chord *)bach_newptrclear(sizeof(t_chord));
    
    notation_item_init(&newchord->r_it, k_CHORD);
    if (chord->r_it.group)
        append_element_in_group(r_ob, chord->r_it.group, (t_notation_item *)newchord);

    newchord->lyrics = build_lyrics(newchord);
    newchord->dynamics_slot = NULL;

    newchord->just_added_from_separate_parameters = false;
    newchord->onset = chord->onset;
    newchord->num_notes = 0; 
    newchord->parent = chord->parent;
    newchord->rhythmic_tree_elem = NULL;
    newchord->need_recompute_parameters = true;
    set_need_perform_analysis_and_change_flag(r_ob);
    newchord->voiceparent = chord->voiceparent;
    newchord->r_sym_duration = chord->r_sym_duration;
    newchord->r_sym_onset = chord->r_sym_onset;
    newchord->duration_ms = chord->duration_ms;
    newchord->r_duration_sec = chord->r_duration_sec;
    newchord->play_r_duration_sec = chord->play_r_duration_sec;
    newchord->play_r_measure_onset_sec = chord->play_r_measure_onset_sec;
    newchord->left_uextension = chord->left_uextension;
    newchord->right_uextension = chord->right_uextension;
    newchord->stem_offset_ux = chord->stem_offset_ux;
    newchord->alignment_ux = chord->alignment_ux;
    newchord->duration_ux = chord->duration_ux;
    newchord->r_measure_onset_sec = chord->r_measure_onset_sec;

    
    newchord->firstnote = NULL;
    newchord->lastnote = NULL;
    newchord->overall_tuplet_ratio = chord->overall_tuplet_ratio;
    newchord->imposed_direction = 0; // essential here!
    newchord->is_score_chord = chord->is_score_chord;
    newchord->system_index = 0;
    newchord->notehead_unicode_character = chord->notehead_unicode_character;
    newchord->num_dots = chord->num_dots;
    newchord->figure = chord->figure;
    newchord->played = false;
    newchord->locked = false;
    newchord->solo = false;
    newchord->muted = false;
    newchord->is_grace_chord = chord->is_grace_chord;
    newchord->dont_split_for_ts_boxes = chord->dont_split_for_ts_boxes;

    newchord->num_articulations = 0;
    newchord->articulation = NULL;

    if (chord && chord->firstnote) {
        t_note *temp_nt = chord->firstnote; t_note *temp_prev = NULL;
        while (temp_nt) {
            if (notation_item_is_selected(r_ob, (t_notation_item *)temp_nt)) {
                t_note *temp_nt2 = clone_note(r_ob, temp_nt, clone_for);
                newchord->num_notes++;
                temp_nt2->parent = newchord; // change parent!!!
                temp_nt2->prev = temp_prev;
                if (temp_prev) // NOT the first note
                    temp_prev->next = temp_nt2;
                else //first note
                    newchord->firstnote = temp_nt2;
                temp_prev = temp_nt2;
            }
            temp_nt = temp_nt->next;
        }
        if (temp_prev) {
            temp_prev->next = NULL;
            newchord->lastnote = temp_prev;
        }
        return newchord;
    } else
        return NULL;

}

long clone_chord_in_rhythmic_tree_fn(void *data, t_hatom *a, const t_llll *address)
{
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *meas = (t_measure *) ((void **)data)[1];
    long clone_for = *((long *) ((void **)data)[2]);
    t_chord **prev_chord = (t_chord **) ((void **)data)[3];
    
    if (hatom_gettype(a) == H_OBJ){
        t_chord *ch = (t_chord *)hatom_getobj(a);
        t_chord *newch = clone_chord_without_lyrics(r_ob, ch, (e_clone_for_types)clone_for);
        chord_insert_in_measure(r_ob, meas, newch, *prev_chord, 0);
        newch->rhythmic_tree_elem = llll_hatom2elem(a);
        hatom_setobj(a, (t_object *)newch);
        *prev_chord = newch;
    }
    return 0;
}


t_measure* clone_measure(t_notation_obj *r_ob, t_measure *measure, e_clone_for_types clone_for)
{
// clones a measure
    t_measure *newmeasure = (t_measure *)bach_newptrclear(sizeof(t_measure));
    notation_item_clone(r_ob, &newmeasure->r_it, &measure->r_it);
    newmeasure->end_barline = build_measure_end_barline(r_ob, newmeasure);

    newmeasure->timesignature = measure->timesignature;
    newmeasure->r_total_content_duration = measure->r_total_content_duration;
    newmeasure->r_total_duration_sec = measure->r_total_duration_sec;
    newmeasure->r_tuttipoint_onset_sec = measure->r_tuttipoint_onset_sec;
    newmeasure->total_duration_ms = measure->total_duration_ms;
    newmeasure->tuttipoint_onset_ms = measure->tuttipoint_onset_ms;
    
    newmeasure->start_barline_offset_ux = measure->start_barline_offset_ux;
    newmeasure->width_ux= measure->width_ux;
    newmeasure->end_barline->barline_type = measure->end_barline->barline_type;
    newmeasure->timesignature_uwidth = measure->timesignature_uwidth;
    newmeasure->timesignature_spacing_uwidth = measure->timesignature_spacing_uwidth;
    newmeasure->locked = measure->locked;
    newmeasure->muted = measure->muted;
    newmeasure->solo = measure->solo;
    newmeasure->beaming_calculation_flags = k_BEAMING_CALCULATION_DO;
    
    newmeasure->local_spacing_width_multiplier = measure->local_spacing_width_multiplier;
    newmeasure->fixed_spacing_uwidth = measure->fixed_spacing_uwidth;
    newmeasure->is_spacing_fixed = measure->fixed_spacing_uwidth;

    newmeasure->show_measure_number = measure->show_measure_number;
    newmeasure->force_measure_number = measure->force_measure_number;
    newmeasure->forced_measure_number = measure->forced_measure_number;

    newmeasure->info_for_pwgl = llll_get();
    newmeasure->measure_filling = measure->measure_filling;
    newmeasure->lock_rhythmic_tree = measure->lock_rhythmic_tree;
    newmeasure->need_recompute_beamings = true;
    newmeasure->need_recompute_beams_positions = false;
    newmeasure->need_check_ties = true;
    newmeasure->need_check_autocompletion = true;
    
    newmeasure->custom_boxing = measure->custom_boxing;
    newmeasure->boxes = llll_get();
    if (measure->boxes)
        llll_clone_upon(measure->boxes, newmeasure->boxes);

    set_need_perform_analysis_and_change_flag(r_ob);
    
    newmeasure->voiceparent = NULL; // as before, with chords, this is useful. it'll be set when measure is inserted
    newmeasure->tuttipoint_reference = NULL;
    newmeasure->next = newmeasure->prev = NULL;

    newmeasure->firstchord = newmeasure->lastchord = NULL;
    if (!measure->rhythmic_tree) {
        // old way, no rhythmic tree assigned
        t_chord *temp_ch = measure->firstchord, *last_ch = NULL;
        while (temp_ch) {
            t_chord *cloned = clone_chord(r_ob, temp_ch, k_CLONE_FOR_NEW);
            chord_insert_in_measure(r_ob, measure, cloned, last_ch, 0);
            last_ch = cloned; 
        }
        newmeasure->rhythmic_tree = NULL;
    } else {
        t_chord *prevch = NULL;
        void *data[4];
        long clone_for_long = (long)clone_for;
        data[0] = r_ob;
        data[1] = newmeasure;
        data[2] = &clone_for_long;
        data[3] = &prevch;
        newmeasure->rhythmic_tree = llll_clone_extended(measure->rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
        llll_funall(newmeasure->rhythmic_tree, clone_chord_in_rhythmic_tree_fn, data, 1, -1, 0);
    }
    
/*    // chords
    if (measure->rhythmic_tree){
        newmeasure->rhythmic_tree = NULL;
//        newmeasure->rhythmic_tree = llll_clone_extended(measure->rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
    } else 
        newmeasure->rhythmic_tree = NULL;
        
    newmeasure->num_chords = measure->num_chords;
    if (measure && measure->firstchord) {
        t_chord *temp_ch = measure->firstchord; 
        t_chord *temp_prev = NULL;
        while (temp_ch) {
            t_chord *temp_ch2 = clone_chord(r_ob, temp_ch, clone_articulations);
            temp_ch2->parent = newmeasure; // change parent!!!
            temp_ch2->prev = temp_prev;
            if (temp_prev) // NOT the first chord
                temp_prev->next = temp_ch2;
            else //first chord
                newmeasure->firstchord = temp_ch2;
            temp_prev = temp_ch2;
            temp_ch = temp_ch->next;
        }
        if (temp_prev) {
            temp_prev->next = NULL;
            newmeasure->lastchord = temp_prev;
        }
    }*/
    
    // tempi
    newmeasure->num_tempi = measure->num_tempi;
    newmeasure->firsttempo = newmeasure->lasttempo = NULL;
    newmeasure->firstbeam = newmeasure->lastbeam = NULL;
    if (measure && measure->firsttempo) {
        t_tempo *temp_tmp = measure->firsttempo; t_tempo *temp_prev = NULL;
        while (temp_tmp) {
            t_tempo *temp_tmp2 = clone_tempo(r_ob, temp_tmp);
            temp_tmp2->owner = newmeasure; // change owner!!!
            temp_tmp2->prev = temp_prev;
            if (temp_prev) // NOT the first chord
                temp_prev->next = temp_tmp2;
            else //first chord
                newmeasure->firsttempo = temp_tmp2;
            temp_prev = temp_tmp2;
            temp_tmp = temp_tmp->next;
        }
        if (temp_prev) {
            temp_prev->next = NULL;
            newmeasure->lasttempo = temp_prev;
        }
    }

    return newmeasure;
}


char check_notes_order(t_chord *chord)
{
    char changed = false;
    t_note *curr_nt = chord->firstnote;
    while(curr_nt && (curr_nt->next)) {
        if (curr_nt->next->midicents < curr_nt->midicents) { // we have to swap them
            if (curr_nt->prev){
                if (curr_nt->next->next) { // swap between two inner notes
                    t_note *temp1, *temp2, *temp3, *temp4;
                    temp1 = curr_nt->prev; temp2=curr_nt; temp3=curr_nt->next; temp4=curr_nt->next->next;
                    curr_nt->next->next->prev = temp2;
                    curr_nt->prev->next = temp3;
                    curr_nt->next->next = temp2;
                    curr_nt->next->prev = temp1;
                    curr_nt->next = temp4;
                    curr_nt->prev = temp3;
                    changed = true;
                } else { // swap between the last two notes
                    t_note *temp1, *temp2, *temp3, *temp4;
                    temp1 = curr_nt->prev; temp2=curr_nt; temp3=curr_nt->next; temp4=NULL;
                    curr_nt->prev->next = temp3;
                    curr_nt->next->next = temp2;
                    curr_nt->next->prev = temp1;
                    curr_nt->next = NULL;
                    curr_nt->prev = temp3;
                    chord->lastnote = temp2;
                    changed = true;
                }
            } else { // swap between 1st and 2nd note
                t_note *temp1, *temp2, *temp3, *temp4;
                temp1 = NULL; temp2=curr_nt; temp3=curr_nt->next; temp4=curr_nt->next->next;
                if (!(temp4)) // we have just 2 notes:
                    chord->lastnote = temp2;
                else
                    curr_nt->next->next->prev = temp2;
                curr_nt->next->next = temp2;
                curr_nt->next->prev = NULL;
                curr_nt->next = temp4;
                curr_nt->prev = temp3;
                chord->firstnote = temp3;
                changed = true;
            }
            //... and to restart to check from the beginning
            curr_nt = chord->firstnote;
        } else 
            curr_nt = curr_nt->next;
    }
    
    return changed;
}


void append_ledger_line(double ypos, double *ledger_y, int *num_ledger_lines)
{
    if (*num_ledger_lines < CONST_MAX_LEDGER_LINES) {
        for (long i = 0; i < *num_ledger_lines; i++) {
            if (ypos == ledger_y[i])
                return;
        }
        ledger_y[*num_ledger_lines] = ypos;
        (*num_ledger_lines)++;
    }
}

void get_ledger_lines(t_notation_obj *r_ob, t_voice *v_ob, long scaleposition, int *num_ledger_lines, double *ledger_y){
// fills *ledger_y with the list of y ledger lines for the position scaleposition, and *num_ledger_lines with the number of ledger_lines
// ledger_y must be sized at least CONST_MAX_LEDGER_LINES

    int clef = get_voice_clef(r_ob, v_ob);
    
    if (r_ob->show_ledger_lines == 0) {
        *num_ledger_lines = 0;
        return;
    }

    if (clef < 100){ // single clef, no combination
        if (clef == k_CLEF_PERCUSSION || clef == k_CLEF_NONE)
            clef = k_CLEF_G;
        if (scaleposition <= (- clef) - 2 + (v_ob->min_staff_line - 1) * 2) { // lower ledger lines
            if ((scaleposition + clef) % 2 != 0) 
                scaleposition += 1; // increase scale position if on a space
            while (scaleposition <= (- clef) - 2 + 2 * (v_ob->min_staff_line - 1)) { 
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }
        if (scaleposition >= (- clef) + 10 + (v_ob->max_staff_line - 5) * 2) { // higher ledger lines
            if ((scaleposition + clef) % 2 != 0) 
                scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= (- clef) + 10 + (v_ob->max_staff_line - 5) * 2)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
    } else if (clef == k_CLEF_FFGG) { 
        // ledger lines needed in scalepositions ranges: (0 0) (12 14) (26 inf) (-12 -14) (-26 -inf)
        if (scaleposition == 0) { // case of middleC 
            append_ledger_line(v_ob->middleC_y, ledger_y, num_ledger_lines);
        }
        if ((scaleposition >= 12 && scaleposition <= 14) || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == 14 || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition >= 26) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if ((scaleposition <= -12 && scaleposition >= -14) || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == -14 || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition <= -26) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= -26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }
    } else if (clef == k_CLEF_FFG) { 
        // ledger lines needed in scalepositions ranges: (0 0) (12 inf) (-12 -14) (-26 -inf)
        if (scaleposition == 0) { // case of middleC 
            append_ledger_line(v_ob->middleC_y, ledger_y, num_ledger_lines);
        }
        if (scaleposition >= 12) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 12)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if ((scaleposition <= -12 && scaleposition >= -14) || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == -14 || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition <= -26) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= -26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }    
    } else if (clef == k_CLEF_FGG) { 
        // ledger lines needed in scalepositions ranges: (0 0) (12 14) (26 inf) (-12 -inf)
        if (scaleposition == 0) { // case of middleC 
            append_ledger_line(v_ob->middleC_y, ledger_y, num_ledger_lines);
        }
        if ((scaleposition >= 12 && scaleposition <= 14) || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == 14 || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition >= 26) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if (scaleposition <= -12) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= -12)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }
    } else if (clef == k_CLEF_GG) { 
        // ledger lines needed in scalepositions ranges: (0 -inf) (12 14) (26 inf)
        if ((scaleposition >= 12 && scaleposition <= 14) || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == 14 || (scaleposition > 14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, 14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition >= 26) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if (scaleposition <= 0) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= 0)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }
    } else if (clef == k_CLEF_FG) { 
        // ledger lines needed in scalepositions ranges: (0 0) (12 inf) (-12 -inf)
        if (scaleposition == 0) { // case of middleC 
            append_ledger_line(v_ob->middleC_y, ledger_y, num_ledger_lines);
        }
        if (scaleposition >= 12) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 12)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if (scaleposition <= -12) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= -12)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }
    } else if (clef == k_CLEF_FF) { 
        // ledger lines needed in scalepositions ranges: (0 inf) (-12 -14) (-26 -inf)
        if (scaleposition >= 0) {    
            if (scaleposition % 2 != 0) scaleposition -= 1; // decrease scale position if on a space
            while (scaleposition >= 0)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition -= 2;
            }
        }
        if ((scaleposition <= -12 && scaleposition >= -14) || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -12, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition == -14 || (scaleposition < -14 && r_ob->show_ledger_lines == 2)) {    
            append_ledger_line(scaleposition_to_yposition(r_ob, -14, v_ob), ledger_y, num_ledger_lines);
        }
        if (scaleposition <= -26) {    
            if (scaleposition % 2 != 0) scaleposition += 1; // decrease scale position if on a space
            while (scaleposition <= -26)  { // higher ledger lines
                append_ledger_line(scaleposition_to_yposition(r_ob, scaleposition, v_ob), ledger_y, num_ledger_lines);
                scaleposition += 2;
            }
        }    
    } else {
        // wrong combination: no ledger lines
    }
}


// Middle C is 0, higher C will be 7
long scaleposition_to_midicents(long scaleposition){
    long res = 0;
    switch ((scaleposition + 70000) % 7) {
        case 0:
            res = 0;
            break;
        case 1:
            res = 200;
            break;
        case 2:
            res = 400;
            break;
        case 3:
            res = 500;
            break;
        case 4:
            res = 700;
            break;
        case 5:
            res = 900;
            break;
        case 6:
            res = 1100;
            break;
        default:
            res = 0;
            break;
    }
    return res + ((scaleposition + 70000) / 7 - 10000) * 1200 + 6000;
}

long midicents_to_diatsteps_from_middleC(t_notation_obj *r_ob, long midicents){
//from a precise natural note, it returns the "scale" position: middle c = C5=0, D5=1, E5=2, etc...
    long octave = floor(((double)midicents)/1200);
    switch ((midicents % 1200)/100) {
        case 0: //C
            return (octave-5)*7;
        case 2: case -10: //D
            return (octave-5)*7+1;
        case 4: case -8: //E
            return (octave-5)*7+2;
        case 5: case -7: //F
            return (octave-5)*7+3;
        case 7: case -5: //G
            return (octave-5)*7+4;
        case 9: case -3: //A
            return (octave-5)*7+5;
        case 11: case -1: //B
            return (octave-5)*7+6;
        default:
            if (r_ob)
                object_post((t_object *)r_ob, "Error!");
            return 0;
    }
    return (midicents/100);
}

long midicents_to_diatsteps_from_C0(t_notation_obj *r_ob, long midicents)
{
    //from a precise natural note, it returns the "scale" position: middle c = C5=0, D5=1, E5=2, etc...
    long octave = floor(((double)midicents)/1200);
    switch ((midicents % 1200)/100) {
        case 0: //C
            return octave*7;
        case 2: case -10: //D
            return octave*7+1;
        case 4: case -8: //E
            return octave*7+2;
        case 5: case -7: //F
            return octave*7+3;
        case 7: case -5: //G
            return octave*7+4;
        case 9: case -3: //A
            return octave*7+5;
        case 11: case -1: //B
            return octave*7+6;
        default:
            if (r_ob)
                object_post((t_object *)r_ob, "Error!");
            return 0;
    }
    return (midicents/100);
}


unicodeChar get_accidental_character(t_notation_obj *r_ob, t_rational accidental)
{
    if (rat_long_cmp(accidental, -1) <= 0) 
        return r_ob->accidentals_typo_preferences.unicode_binary_character[0];
    else if (rat_long_cmp(accidental, 1) >= 0) 
        return r_ob->accidentals_typo_preferences.unicode_binary_character[16];
    else {
        if ((r_ob->tone_division == 2) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=2)) { // semitone division
            t_rational div = rat_long_prod(accidental,2);
            if (div.r_den == 1)
                return r_ob->accidentals_typo_preferences.unicode_binary_character[8 + 4 * div.r_num];
            else
                return 0; // will be  mapped to bogus character!
        } else if ((r_ob->tone_division == 4) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=4)) { // quartertone division
            t_rational div = rat_long_prod(accidental,4);
            if (div.r_den == 1)
                return r_ob->accidentals_typo_preferences.unicode_binary_character[8 + 2 * div.r_num];
            else
                return 0;
        } else if ((r_ob->tone_division == 8) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=8)) { // eighttone division
            t_rational div = rat_long_prod(accidental,8);
            if (div.r_den == 1)
                return r_ob->accidentals_typo_preferences.unicode_binary_character[8 + div.r_num];
            else
                return 0;
        } else 
            return 0;
    }
}



double get_accidental_top_uextension(t_notation_obj *r_ob, t_rational accidental)
{
//returns the accidental_top_uextension in the BASE CASE (i.e. for the base_pt, e.g. Maestro 24, Sonora 40, ...)

    if (r_ob->accidentals_display_type == k_ACCIDENTALS_NO_DISPLAY)
        return 0;
    else if (r_ob->accidentals_display_type == k_ACCIDENTALS_CLASSICAL) { // classical
        // if the accidental is x, it's very tiny, so the top extension would be the top extension of a monesis or sharp or triesis
        if (rat_long_cmp(accidental, 1) >= 0) { 
            t_rational ratmod = rat_long_mod(accidental, 1, true);
            if (rat_long_cmp(ratmod, 0) == 0)
                accidental = long2rat(1);
            else
                accidental = ratmod; 
        }
        // E converso, if the accidental is bb, that doesn't bother us that much, since its top extension would always be the same as d, or b, or db
        
        if (rat_long_cmp(accidental, -1) <= 0)
            return r_ob->accidentals_typo_preferences.binary_top_uextension[0];
        else if (rat_long_cmp(accidental, 1) >= 0)    
            return r_ob->accidentals_typo_preferences.binary_top_uextension[16];
        else {
            if ((r_ob->tone_division == 2) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=2)) { // semitone division
                t_rational div = rat_long_prod(accidental,2);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_top_uextension[8 + 4 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_top_uextension;
            } else if ((r_ob->tone_division == 4) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=4)) { // quartertone division
                t_rational div = rat_long_prod(accidental,4);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_top_uextension[8 + 2 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_top_uextension;
            } else if ((r_ob->tone_division == 8) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=8)) { // eighttone division
                t_rational div = rat_long_prod(accidental,8);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_top_uextension[8 + div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_top_uextension;
            } else
                return r_ob->accidentals_typo_preferences.bogus_top_uextension;
        }

    } else if (r_ob->accidentals_display_type == k_ACCIDENTALS_FRACTION || r_ob->accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION) // fractions
        return 2.5;
    else if (r_ob->accidentals_display_type == k_ACCIDENTALS_CENTS) // cents
        return 2.5;
    else
        return 0;
}

double note_get_accidental_top_uextension(t_notation_obj *r_ob, t_note *note)
{
    if (note->num_accidentals > 0)
        return get_accidental_top_uextension(r_ob, note->pitch_displayed.p_alter) * (note->parent->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1.);
    else
        return 0;
}

double get_accidental_bottom_uextension(t_notation_obj *r_ob, t_rational accidental)
{
//returns the accidental_bottom_uextension in the BASE CASE (i.e. for the base_pt, e.g. Maestro 24, Sonora 40, ...)

    if (r_ob->accidentals_display_type == k_ACCIDENTALS_NO_DISPLAY)
        return 0;
    else if (r_ob->accidentals_display_type == k_ACCIDENTALS_CLASSICAL) { // classical
        // if the accidental is x, it's very tiny, so the top extension would be the top extension of a monesis or sharp or triesis
        if (rat_long_cmp(accidental, 1) >= 0) { 
            t_rational ratmod = rat_long_mod(accidental, 1, true);
            if (rat_long_cmp(ratmod, 0) == 0)
                accidental = long2rat(1);
            else
                accidental = ratmod; 
        }
        // E converso, if the accidental is bb, that doesn't bother us that much, since its top extension would always be the same as d, or b, or db
        
        if (rat_long_cmp(accidental, -1) <= 0)
            return r_ob->accidentals_typo_preferences.binary_bottom_uextension[0];
        else if (rat_long_cmp(accidental, 1) >= 0)    
            return r_ob->accidentals_typo_preferences.binary_bottom_uextension[16];
        else {
            if ((r_ob->tone_division == 2) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=2)) { // semitone division
                t_rational div = rat_long_prod(accidental,2);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_bottom_uextension[8 + 4 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_bottom_uextension;
            } else if ((r_ob->tone_division == 4) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=4)) { // quartertone division
                t_rational div = rat_long_prod(accidental,4);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_bottom_uextension[8 + 2 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_bottom_uextension;
            } else if ((r_ob->tone_division == 8) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=8)) { // eighttone division
                t_rational div = rat_long_prod(accidental,8);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_bottom_uextension[8 + div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_bottom_uextension;
            } else
                return r_ob->accidentals_typo_preferences.bogus_bottom_uextension;
        }

    } else if (r_ob->accidentals_display_type == k_ACCIDENTALS_FRACTION || r_ob->accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION) // fractions
        return 3.5;
    else if (r_ob->accidentals_display_type == k_ACCIDENTALS_CENTS) // cents
        return 3.5;
    else
        return 0;
}


double note_get_accidental_bottom_uextension(t_notation_obj *r_ob, t_note *note)
{
    if (note->num_accidentals > 0)
        return get_accidental_bottom_uextension(r_ob, note->pitch_displayed.p_alter) * (note->parent->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1.);
    else
        return 0;
}

double get_accidental_uwidth(t_notation_obj *r_ob, t_rational accidental, char always_classical_display){
//returns the accidental unscaled width in the BASE CASE (i.e. for the base_pt, e.g. Maestro 24, Sonora 40, ...)
    char accidentals_display_type = always_classical_display ? k_ACCIDENTALS_CLASSICAL : r_ob->accidentals_display_type;
    
    if (accidentals_display_type == k_ACCIDENTALS_NO_DISPLAY)
        return 0;
    else if (accidentals_display_type == k_ACCIDENTALS_CLASSICAL) { // classical
        // if the accidental is x, it's very tiny, so the top extension would be the top extension of a monesis or sharp or triesis
        if (rat_long_cmp(accidental, 1) >= 0) { 
            t_rational ratmod = rat_long_mod(accidental, 1, true);
            if (rat_long_cmp(ratmod, 0) == 0)
                accidental = long2rat(1);
            else
                accidental = ratmod; 
        }
        // E converso, if the accidental is bb, that doesn't bother us that much, since its top extension would always be the same as d, or b, or db
        
        if (rat_long_cmp(accidental, -1) <= 0)
            return r_ob->accidentals_typo_preferences.binary_uwidth[0];
        else if (rat_long_cmp(accidental, 1) >= 0)    
            return r_ob->accidentals_typo_preferences.binary_uwidth[16];
        else {
            if ((r_ob->tone_division == 2) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=2)) { // semitone division
                t_rational div = rat_long_prod(accidental,2);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_uwidth[8 + 4 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_uwidth;
            } else if ((r_ob->tone_division == 4) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=4)) { // quartertone division
                t_rational div = rat_long_prod(accidental,4);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_uwidth[8 + 2 * div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_uwidth;
            } else if ((r_ob->tone_division == 8) && (r_ob->accidentals_typo_preferences.binary_characters_depth>=8)) { // eighttone division
                t_rational div = rat_long_prod(accidental,8);
                if (div.r_den == 1)
                    return r_ob->accidentals_typo_preferences.binary_uwidth[8 + div.r_num];
                else
                    return r_ob->accidentals_typo_preferences.bogus_uwidth;
            } else
                return r_ob->accidentals_typo_preferences.bogus_uwidth;
        }

    } else if ((accidentals_display_type == k_ACCIDENTALS_FRACTION) || (accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION)) { // fractions
        t_jfont *jf_text_fractions;
        int num, den;
        char frac_text[20];
        double width, height;
        jf_text_fractions = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_TEXT_FRACTIONS_PT);
        num = rat_num(accidental);
        den = rat_den(accidental);
        if ((r_ob->accidentals_display_type == k_ACCIDENTALS_UNREDUCED_FRACTION) && (den < r_ob->tone_division)) {
            int factor = r_ob->tone_division / den;
            den *= factor; 
            num *= factor;
        }     
        if (num > 0) 
            snprintf_zero(frac_text, 20, "+%d/%d", num, den);
        else
            snprintf_zero(frac_text, 20, "-%d/%d", -num, den);
        jfont_text_measure(jf_text_fractions, frac_text, &width, &height); // we get how much space do we need
        jfont_destroy_debug(jf_text_fractions);
        return width + CONST_WIDTH_ADD_FRACTIONS;
    } else if (accidentals_display_type == k_ACCIDENTALS_CENTS) { // cents
        double floatacc, width, height;
        char cents_text[20];    
        t_jfont *jf_text_fractions;
        jf_text_fractions = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, CONST_TEXT_FRACTIONS_PT);
        floatacc = 200. * rat2double(accidental);
        
        if (floatacc > 0) 
            snprintf_zero(cents_text, 20, "+%dc", (int)floatacc); 
        else 
            snprintf_zero(cents_text, 20, "-%dc", (int)(-floatacc)); 
        
        jfont_text_measure(jf_text_fractions, cents_text, &width, &height); // we get how much space do we need
        jfont_destroy_debug(jf_text_fractions);
        return width + CONST_WIDTH_ADD_FRACTIONS;
    } else
        return 0;
}


void recompute_measure_r_onsets(t_notation_obj *r_ob, t_measure *measure) {
    t_chord *tmp_ch = measure->firstchord;
    t_rational r_sym_onset = long2rat(0);
    while (tmp_ch) {
        tmp_ch->r_sym_onset = r_sym_onset;
        if (!tmp_ch->is_grace_chord)
            r_sym_onset = rat_rat_sum(r_sym_onset, rat_abs(tmp_ch->r_sym_duration));
        tmp_ch = tmp_ch->next;
    }
}

char is_chord_a_whole_measure_rest(t_notation_obj *r_ob, t_chord *chord){
    if (chord == chord->parent->firstchord && chord == chord->parent->lastchord && chord->r_sym_duration.r_num < 0)
        return 1;
    else
        return 0;
}

void chord_insert_in_measure(t_notation_obj *r_ob, t_measure *measure, t_chord *chord_to_insert, t_chord *after_this_chord, unsigned long force_ID){
// insert an (already built) chord in a measure, at a given position. Automatically computes the r_sym_onset field.
    
    chord_to_insert->parent = measure;
    
    if (after_this_chord) { // not at the beginning
        if (after_this_chord->next) { // insert between these
            after_this_chord->next->prev = chord_to_insert;
            chord_to_insert->next = after_this_chord->next;
            chord_to_insert->prev = after_this_chord;
            after_this_chord->next = chord_to_insert;
        } else { // insert at the end
            chord_to_insert->next = NULL;
            chord_to_insert->prev = after_this_chord;
            after_this_chord->next = chord_to_insert;
            measure->lastchord = chord_to_insert;
        }
    } else { // at the beginning
        if (measure->firstchord) { // there's already a chord
            chord_to_insert->next = measure->firstchord;
            chord_to_insert->prev = NULL;
            measure->firstchord->prev = chord_to_insert;
            measure->firstchord = chord_to_insert;
        } else { // no chords in the voices yet
            chord_to_insert->next = NULL;
            chord_to_insert->prev = NULL;
            measure->firstchord = chord_to_insert;
            measure->lastchord = chord_to_insert;
        }    
    }
    
    if (force_ID > 0) {
        shashtable_insert_with_key(r_ob->IDtable, chord_to_insert, force_ID, 1);
        chord_to_insert->r_it.ID = force_ID;
    } else
        chord_to_insert->r_it.ID = shashtable_insert(r_ob->IDtable, chord_to_insert);
    
    recompute_measure_r_onsets(r_ob, measure); //recalculating the r_sym_onset for each chord
    
    measure->num_chords++;
    measure->r_total_content_duration = rat_rat_sum(measure->r_total_content_duration, rat_abs(chord_to_insert->r_sym_duration));
}

/*
char are_there_just_rests_in_measure(t_measure *measure) {
    t_chord *chord = measure->firstchord;
    while (chord) {
        if (chord->r_sym_duration.r_num > 0 && !chord->is_grace_chord)
            return false;
        chord = chord->next;
    }
    return true;
}*/

double rest_get_dummy_mc(t_notation_obj *r_ob, t_chord *rest) {
    double mc;
    rest_get_floating_yposition(r_ob, rest, &mc, NULL);
    return mc;
}

// also fills mc
double rest_get_nonfloating_yposition(t_notation_obj *r_ob, t_chord *rest, double *mc, long *steps)
{
    long clef = get_voice_clef(r_ob, (t_voice *)rest->parent->voiceparent);
    // first: we find a pivot chord which will tell us the staff on which the rest will be placed (we want to place the rest in the same staff of the pivot chord)
    t_chord *chord_which_gives_the_position = NULL;
    t_chord *prev_chord = rest->prev;
    t_chord *next_chord;
    t_measure *next_measure;
    while (prev_chord && (prev_chord->r_sym_duration.r_num < 0))
        prev_chord = prev_chord->prev;
    next_chord = rest->next;
    while (next_chord && (next_chord->r_sym_duration.r_num < 0))
        next_chord = next_chord->next;
    if (!prev_chord && !next_chord) { // just pauses in measure: let's see previous measures
        t_measure *prev_measure = rest->parent->prev;
        while (prev_measure && (!(prev_chord))) {
            t_chord *tmp_chord = prev_measure->lastchord;
            while (tmp_chord && (tmp_chord->r_sym_duration.r_num < 0))
                tmp_chord = tmp_chord->prev;
            if (tmp_chord) {
                prev_chord = tmp_chord;
                break;
            }
            prev_measure = prev_measure->prev;
        }
        next_measure = rest->parent->next;
        while (next_measure && !next_chord) {
            t_chord *tmp_chord = next_measure->lastchord;
            while (tmp_chord && (tmp_chord->r_sym_duration.r_num < 0))
                tmp_chord = tmp_chord->prev;
            if (tmp_chord) {
                next_chord = tmp_chord;
                break;
            }
            next_measure = next_measure->next;
        }
        if (!prev_chord && !next_chord) // still nothing to do.... we didn't find a single note in the [score]
            chord_which_gives_the_position = NULL;
        else if (prev_chord)
            chord_which_gives_the_position = prev_chord;
        else
            chord_which_gives_the_position = next_chord;
    } else if (prev_chord)
        chord_which_gives_the_position = prev_chord;
    else
        chord_which_gives_the_position = next_chord;
    
    long shift = get_clef_octave_shift(clef);
    if (!chord_which_gives_the_position) {
        double midicents;
        // we choose the topmost staff, except when it's G15, and in this case we chose the G staff
        switch (clef) {
            case k_CLEF_FFGG: 
                midicents = 7100; // was: 9500;
                break;
            case k_CLEF_FFG: 
                midicents = 7100; 
                break;
            case k_CLEF_FGG: 
                midicents = 7100; // was: 9500;
                break;
            case k_CLEF_FF: 
                midicents = 5000; 
                break;
            case k_CLEF_FG: 
                midicents = 7100; 
                break;
            case k_CLEF_GG: 
                midicents = 9500; 
                break;
            case k_CLEF_F: 
            case k_CLEF_F8va:
            case k_CLEF_F8vb:
            case k_CLEF_F15ma:
            case k_CLEF_F15mb:
                midicents = 5000 + shift * 1200;
                break;
            case k_CLEF_NONE: 
            case k_CLEF_G: 
            case k_CLEF_G8va:
            case k_CLEF_G8vb:
            case k_CLEF_G15ma:
            case k_CLEF_G15mb:
                midicents = 7100 + shift * 1200;
                break;
            case k_CLEF_SOPRANO:
                midicents = 6700; 
                break;
            case k_CLEF_MEZZO: 
                midicents = 6400; 
                break;
            case k_CLEF_ALTO: 
                midicents = 6000; 
                break;
            case k_CLEF_TENOR: 
                midicents = 5700; 
                break;
            case k_CLEF_BARYTONE: 
                midicents = 5300; 
                break;
            case k_CLEF_PERCUSSION: 
                midicents = 7100; 
                break;
            default: 
                midicents = 7100; 
                break;
        }
        if ((rest->parent->voiceparent->v_ob.max_staff_line < 4 && rat_rat_cmp(rest->figure, genrat(1, 1)) >= 0) ||
            (rest->parent->voiceparent->v_ob.max_staff_line < 3 && rat_rat_cmp(rest->figure, RAT_1OVER2) >= 0)) {
            long ds = midicents2diatonicstep(midicents);
            long octave = floor(midicents / 1200);
            ds -= ((rat_rat_cmp(rest->figure, genrat(1, 1)) >= 0 ? 4 : 3) - rest->parent->voiceparent->v_ob.max_staff_line) * 2;
            while (ds < 0){
                ds += 7;
                octave -= 1;
            }
            midicents = diatonicstep2midicents(ds, octave);
        }
        
        if (mc)
            *mc = midicents;
        
        if (steps)
            *steps = midicents_to_diatsteps_from_middleC(r_ob, midicents);

        return mc_to_yposition_in_scale(r_ob, midicents, &rest->parent->voiceparent->v_ob);
    } else {
        // we gotta find the staff in which the chord_which_gives_the_position is painted
        // first we calculate the "screen_note_average" of the chord
        double screen_note_average_mc = 0.;
        t_note *tmp_nt; long count = 0;
        long chosen_staff_middle_mc;
        for (tmp_nt = chord_which_gives_the_position->firstnote; tmp_nt; tmp_nt = tmp_nt->next) {
            screen_note_average_mc += note_get_screen_midicents(tmp_nt);
            count++;
        }
        if (count > 0) 
            screen_note_average_mc /= count;
        // then 
        if (screen_note_average_mc <= 3800)
            chosen_staff_middle_mc = 2600;
        else if (screen_note_average_mc <= 6000)
            chosen_staff_middle_mc = 5000;
        else if (screen_note_average_mc <= 8300)
            chosen_staff_middle_mc = 7100;
        else
            chosen_staff_middle_mc = 9500;
        switch (clef) {
            case k_CLEF_FFGG: 
                break;
            case k_CLEF_FFG:
            {
                if (chosen_staff_middle_mc >= 9500) chosen_staff_middle_mc = 7100;
                break;
            }
            case k_CLEF_FGG: 
            {
                if (chosen_staff_middle_mc <= 2600) chosen_staff_middle_mc = 5000;
                break;
            }
            case k_CLEF_FF:
            {
                if (chosen_staff_middle_mc >= 7100) chosen_staff_middle_mc = 5000;
                break;
            }
            case k_CLEF_FG:
            {
                if (chosen_staff_middle_mc <= 2600) chosen_staff_middle_mc = 5000;
                if (chosen_staff_middle_mc >= 9500) chosen_staff_middle_mc = 7100;
                break;
            }
            case k_CLEF_GG:
            {
                if (chosen_staff_middle_mc <= 5000) chosen_staff_middle_mc = 7100;
                break;
            }
            case k_CLEF_F: 
            case k_CLEF_F8va:
            case k_CLEF_F8vb:
            case k_CLEF_F15ma:
            case k_CLEF_F15mb:
            {
                chosen_staff_middle_mc = 5000 + shift * 1200;
                break;
            }
            case k_CLEF_G: 
            case k_CLEF_PERCUSSION: 
            case k_CLEF_NONE: 
            case k_CLEF_G8va:
            case k_CLEF_G8vb:
            case k_CLEF_G15ma:
            case k_CLEF_G15mb:
            {
                chosen_staff_middle_mc = 7100 + shift * 1200;
                break;
            }
            case k_CLEF_SOPRANO:
            {
                chosen_staff_middle_mc = 6700;
                break;
            }
            case k_CLEF_MEZZO: 
            {
                chosen_staff_middle_mc = 6400;
                break;
            }
            case k_CLEF_ALTO: 
            {
                chosen_staff_middle_mc = 6000;
                break;
            }
            case k_CLEF_TENOR: 
            {
                chosen_staff_middle_mc = 5700;
                break;
            }
            case k_CLEF_BARYTONE: 
            {
                chosen_staff_middle_mc = 5300;
                break;
            }
        }
        if ((rest->parent->voiceparent->v_ob.max_staff_line < 4 && rat_rat_cmp(rest->figure, genrat(1, 1)) >= 0) ||
            (rest->parent->voiceparent->v_ob.max_staff_line < 3 && rat_rat_cmp(rest->figure, RAT_1OVER2) >= 0)) {
            long ds = midicents2diatonicstep(chosen_staff_middle_mc);
            long octave = floor(chosen_staff_middle_mc / 1200.);
            ds -= ((rat_rat_cmp(rest->figure, genrat(1, 1)) >= 0 ? 4 : 3) - rest->parent->voiceparent->v_ob.max_staff_line) * 2;
            while (ds < 0){
                ds += 7;
                octave -= 1;
            }
            chosen_staff_middle_mc = diatonicstep2midicents(ds, octave);
        }
        if (mc)
            *mc = chosen_staff_middle_mc;

        if (steps)
            *steps = midicents_to_diatsteps_from_middleC(r_ob, chosen_staff_middle_mc);

        return mc_to_yposition_in_scale(r_ob, chosen_staff_middle_mc, &rest->parent->voiceparent->v_ob);
    }
}

double rest_get_floating_yposition(t_notation_obj *r_ob, t_chord *rest, double *mc, long *steps)
{
    long this_steps = 0;
    double ypos = rest_get_nonfloating_yposition(r_ob, rest, mc, &this_steps);
    this_steps += rest->float_steps;
    if (steps) *steps = this_steps;
    if (mc) *mc = scaleposition_to_midicents(this_steps);
    
    return ypos - rest->float_steps * r_ob->step_y;
}


long set_grace_flag_to_chords_fn(void *data, t_hatom *a, const t_llll *address){
    char val = *((char *)data);
    if (hatom_gettype(a) == H_OBJ)
        ((t_chord *)hatom_getobj(a))->is_grace_chord = val;
    return 0;
}

long set_grace_flag_to_chords_from_rhythmic_tree_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a))) {
        char val = 1;
        llll_funall(hatom_getllll(a), set_grace_flag_to_chords_fn, &val, 1, -1, FUNALL_ONLY_PROCESS_ATOMS);
        return 1;
    }
    return 0;
}

void set_grace_flag_to_chords_from_rhythmic_tree(t_notation_obj *r_ob, t_llll *tree){
    char val = 0;
    llll_funall(tree, set_grace_flag_to_chords_fn, &val, 1, -1, FUNALL_ONLY_PROCESS_ATOMS);
    llll_funall(tree, set_grace_flag_to_chords_from_rhythmic_tree_fn, NULL, 1, one_but_last_level(tree), FUNALL_SKIP_ATOMS);
}

t_tempo *find_sync_tempo(t_notation_obj *r_ob, t_tempo *sync_to_this_tempo, t_scorevoice *voice_to_search)
{
    if (!sync_to_this_tempo->owner) {
        dev_post("Warning! There's a tempo without owner!");
        return NULL;
    }
    
    t_measure *meas = nth_measure_of_scorevoice(voice_to_search, sync_to_this_tempo->owner->measure_number);
    if (meas) {
        t_tempo *temp;
        for (temp = meas->firsttempo; temp; temp = temp->next) {
            if (are_tempi_the_same_and_in_the_same_tp(temp, sync_to_this_tempo))
                return temp;
        }
    }
    return NULL;
}

// sync_tempi must be allocated with CONST_MAX_VOICES * sizeof(t_tempo *)
long get_synchronous_tempi(t_notation_obj *r_ob, t_tempo *this_tempo, t_tempo **sync_tempi)
{
    t_voice *voice;
    long num = 0;
    for (voice = r_ob->firstvoice; voice && num < CONST_MAX_VOICES; voice = voice_get_next(r_ob, voice)) {
        t_tempo *temp = find_sync_tempo(r_ob, this_tempo, (t_scorevoice *)voice);
        if (temp) 
            sync_tempi[num++] = temp;
    }
    return num;
}


void compute_note_approximations_for_measure(t_notation_obj *r_ob, t_measure *measure, char also_put_show_accidental_to_false){
    t_chord *temp_ch; t_note *temp_nt;
    for (temp_ch = measure->firstchord; temp_ch; temp_ch = temp_ch->next)
        for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next) {
            note_compute_approximation(r_ob, temp_nt);
            if (also_put_show_accidental_to_false)
                temp_nt->show_accidental = false;
        }
}

void compute_note_approximations_for_chord(t_notation_obj *r_ob, t_chord *chord, char also_put_show_accidental_to_false){
    t_note *temp_nt;
    for (temp_nt = chord->firstnote; temp_nt; temp_nt = temp_nt->next) {
        note_compute_approximation(r_ob, temp_nt);
        if (also_put_show_accidental_to_false)
            temp_nt->show_accidental = false;
    }
}

void validate_accidentals_for_measure(t_notation_obj *r_ob, t_measure *measure) {
// validates (= choose whether to show/to hide) the accidentals for the measure, depending on the choosen preferences (show/hide, accidental_tie_preferences...)
    t_chord *temp_ch; t_note *temp_nt;
    char key = measure->voiceparent->v_ob.key;
    t_rational *acc_pattern = measure->voiceparent->v_ob.acc_pattern;
    long curr_midicents, ds; 
    t_rational curr_accidental = long2rat(0); 
    t_chord *curr_parent = NULL;
    long clef = get_voice_clef(r_ob, (t_voice *)measure->voiceparent);
    
    if (clef == k_CLEF_PERCUSSION)
        return; // no accidentals will be shown
    
    for (temp_ch = measure->firstchord; temp_ch; temp_ch = temp_ch->next)
        for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next)
            temp_nt->r_it.flags = (e_bach_internal_notation_flags) (temp_nt->r_it.flags | k_FLAG_VALIDATEACCIDENTALS);

    for (temp_ch = measure->firstchord; temp_ch; temp_ch = temp_ch->next) {
        for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next) {
            if ((temp_ch->r_sym_duration.r_num > 0) && (temp_nt->r_it.flags & k_FLAG_VALIDATEACCIDENTALS)) {
                // we have still to validate the accidental: this means that we've not come across these screen_midicents yet
                t_chord *temp_ch2, *repeat_base; 
                t_note *temp_nt2; 
                long count_for_remind_cautionary_acc = 0; 
                long count_for_octave_cautionary_acc = 0; 
                char already_done_octave_cautionary_accidental = false;
                char already_postponed_accidental_on_next_untied_note = true;
                curr_midicents = note_get_screen_midicents(temp_nt);
                ds = midicents2diatonicstep(curr_midicents);
                // validating this note (first note within the position)
                
                if (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALL) {
                    temp_nt->show_accidental = true;
                    
                } else if (ds < 0 || (ds>=0 && rat_rat_cmp(acc_pattern[ds], note_get_screen_accidental(temp_nt)) == 0)) { // the note IS in the scale

                    if (note_get_screen_accidental(temp_nt).r_num != 0 &&
                        (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED || r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NOREPETITION || r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NONATURALS)) {
                        // we did say ALWAYS to accidentals show

                        temp_nt->show_accidental = true;
                    
                    } else {
                        temp_nt->show_accidental = false;
                        
                        if (r_ob->cautionary_accidentals > 0 && !temp_nt->tie_from) { // cautionary accidentals?
                            long j; t_chord *ch = temp_nt->parent;
                            for (j = 0; ch && (j < r_ob->cautionary_accidentals_decay); j++) {
                                ch = chord_get_prev(ch);
                                while (ch && (ch->r_sym_duration.r_num < 0)) 
                                    ch = chord_get_prev(ch);
                                if (ch) {
                                    t_note *nt = ch->firstnote;
                                    for (nt = ch->firstnote; nt; nt = nt->next){
                                        long ntds = midicents2diatonicstep(note_get_screen_midicents(nt));
                                        if (ntds >=0 && rat_rat_cmp(acc_pattern[ntds], note_get_screen_accidental(nt)) != 0) {
                                            if ((r_ob->cautionary_accidentals == 1 && note_get_screen_midicents(nt) == note_get_screen_midicents(temp_nt)) ||
                                                (r_ob->cautionary_accidentals == 2 && (note_get_screen_midicents(nt) - note_get_screen_midicents(temp_nt)) % 1200 == 0)){
                                                
                                                temp_nt->show_accidental = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (temp_nt->show_accidental) break;
                                }
                            }
                        }
                        if (temp_nt->show_accidental == true && (r_ob->show_accidentals_preferences == k_SHOW_ACC_NONE || // never show
                                                                 (temp_nt->tie_from && r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_NEVER) ||  // tied note (and we don't show accidentals upon ties)
                                                                 (temp_nt->tie_from && temp_nt->parent->prev && r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING)))  // tied note inside the measure (and we only show accidentals upon ties at the beginning of the measure)
                            temp_nt->show_accidental = false;
                    }
                    
                } else if ((temp_nt->tie_from && r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_NEVER) || // tied note (and we don't show accidentals upon ties)
                           (temp_nt->tie_from && temp_nt->parent->prev && r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING)) { // tied note inside the measure (and we only show accidentals upon ties at the beginning of the measure): fairly unlikely, however, for the first note!!!
                    temp_nt->show_accidental = false;
                    already_postponed_accidental_on_next_untied_note = false;

                } else if (r_ob->show_accidentals_preferences != k_SHOW_ACC_NONE) { // if we didn't say "never" to show accidentals
                    temp_nt->show_accidental = true;
                }
                curr_accidental = note_get_screen_accidental(temp_nt);
                curr_parent = temp_nt->parent;
                repeat_base = curr_parent;
                temp_nt->r_it.flags = (e_bach_internal_notation_flags) (temp_nt->r_it.flags & ~k_FLAG_VALIDATEACCIDENTALS);
                // validating the remaining notes in the same position
                temp_ch2 = temp_ch;
                while (temp_ch2){
                    temp_nt2 = (temp_ch2 == temp_ch) ? temp_nt->next : temp_ch2->firstnote;
                    while (temp_nt2) {
                        char cmp = rat_rat_cmp(curr_accidental, note_get_screen_accidental(temp_nt2));
                        if ((temp_nt2->r_it.flags & k_FLAG_VALIDATEACCIDENTALS) && (note_get_screen_midicents(temp_nt2) == curr_midicents)) {
                            already_done_octave_cautionary_accidental = false;
                            if (((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALL)) ||
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED) && (cmp != 0 || note_get_screen_accidental(temp_nt2).r_num != 0)) || // untied, need to show all accidentals, there's an accidental
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NONATURALS) && (note_get_screen_accidental(temp_nt2).r_num != 0)) || // untied, need to show all accidentals (no annulations), there's an accidental
//                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NOREPETITION) && curr_parent && (temp_nt2->parent != curr_parent->next) && (note_get_screen_accidental(temp_nt2).r_num != 0)) || // untied, need to show all accidentals (no repetition), chords are not near, there's an accidental
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NOREPETITION) && (note_get_screen_accidental(temp_nt2).r_num != 0) && (cmp != 0 || repeat_base != temp_nt2->parent->prev)) || // untied, need to show all accidentals (no repetition), chords are not near, there's an accidental
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED) && (cmp != 0) && (note_get_screen_accidental(temp_nt2).r_num == 0)) || // untied, need to show all accidentals, there's a return to the natural
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NOREPETITION) && (cmp != 0) && (note_get_screen_accidental(temp_nt2).r_num == 0)) || // untied, need to show all accidentals (no repetition), chords are not near, there's a return to the natural
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_CLASSICAL) && (cmp != 0)) || // untied, classical accidentals, accidental has changed (no matter how)
                                ((!temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_CLASSICAL) && !already_postponed_accidental_on_next_untied_note &&
                                    !(cmp == 0 && key != 0 && ds >= 0 && rat_rat_cmp(acc_pattern[ds], note_get_screen_accidental(temp_nt)) == 0))) { // prev note was tied so we gotta put the accidental
                                temp_nt2->show_accidental = true;
                                already_done_octave_cautionary_accidental = false;
                                count_for_octave_cautionary_acc = 0;
                                temp_nt2->r_it.flags = (e_bach_internal_notation_flags) (temp_nt2->r_it.flags & ~k_FLAG_VALIDATEACCIDENTALS);
                                curr_accidental = note_get_screen_accidental(temp_nt2);
                                curr_parent = temp_nt2->parent;
                                if (!already_postponed_accidental_on_next_untied_note) already_postponed_accidental_on_next_untied_note = true;
                            } else if  (((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_ALWAYS) && (note_get_screen_accidental(temp_nt2).r_num != 0)) || // tied, need to show all accidentals
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NONATURALS) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_ALWAYS) && (note_get_screen_accidental(temp_nt2).r_num != 0)) ||
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALL) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_ALWAYS) && (note_get_screen_accidental(temp_nt2).r_num != 0)) ||
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING) && (!(temp_nt2->parent->prev)) && (note_get_screen_accidental(temp_nt2).r_num != 0)) || // these three should NEVER be the case (beginning of the measure?!? that's not the first position-note!)
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALLALTERED_NONATURALS) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING) && (!(temp_nt2->parent->prev)) && (note_get_screen_accidental(temp_nt2).r_num != 0)) ||
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_ALL) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING) && (!(temp_nt2->parent->prev)) && (note_get_screen_accidental(temp_nt2).r_num != 0)) ||
                                        ((temp_nt2->tie_from) && (r_ob->show_accidentals_preferences == k_SHOW_ACC_CLASSICAL) && (r_ob->show_accidentals_tie_preferences == k_SHOW_ACC_TIES_MEASURE_BEGINNING) && (!(temp_nt2->parent->prev)) && (note_get_screen_accidental(temp_nt2).r_num != 0))) {
                                temp_nt2->show_accidental = true;
                                already_done_octave_cautionary_accidental = false;
                                count_for_octave_cautionary_acc = 0;
                                temp_nt2->r_it.flags = (e_bach_internal_notation_flags) (temp_nt2->r_it.flags & ~k_FLAG_VALIDATEACCIDENTALS);
                                curr_accidental = note_get_screen_accidental(temp_nt2);
                                curr_parent = temp_nt2->parent;
                            } else {
                                temp_nt2->r_it.flags = (e_bach_internal_notation_flags) (temp_nt2->r_it.flags & ~k_FLAG_VALIDATEACCIDENTALS);
                                temp_nt2->show_accidental = false;
                            }
                            repeat_base = temp_nt2->parent;
                        }

                        // need to reset things for cautionary accidentals?
                        if ((r_ob->cautionary_accidentals == 2) && ((note_get_screen_midicents(temp_nt2) - curr_midicents) % 1200 == 0) &&
                            (note_get_screen_accidental(temp_nt2).r_num == 0) && (curr_accidental.r_num != 0) && (count_for_octave_cautionary_acc < r_ob->cautionary_accidentals_decay)
                            && (!already_done_octave_cautionary_accidental) && (temp_nt2->r_it.flags & ~k_FLAG_VALIDATEACCIDENTALS))
                            already_done_octave_cautionary_accidental = true;
                        else if ((r_ob->cautionary_accidentals >= 1) && (note_get_screen_midicents(temp_nt2) == curr_midicents) &&
                            (note_get_screen_accidental(temp_nt2).r_num != 0) && (cmp == 0) &&
                            (count_for_remind_cautionary_acc <= r_ob->cautionary_accidentals_remind))
                            count_for_remind_cautionary_acc = 0; 
                        else if ((r_ob->cautionary_accidentals >= 1) && (note_get_screen_midicents(temp_nt2) == curr_midicents) && (cmp != 0))
                            count_for_remind_cautionary_acc = 0; // accidental has changed: reset count to 0!
                            
                        // cautionary accidentals?
                        if ((r_ob->cautionary_accidentals == 2) && ((note_get_screen_midicents(temp_nt2) - curr_midicents) % 1200 == 0) &&
                            (note_get_screen_accidental(temp_nt2).r_num == 0) && (curr_accidental.r_num != 0) && (count_for_octave_cautionary_acc < r_ob->cautionary_accidentals_decay)
                            && (!already_done_octave_cautionary_accidental)) { // cautionary naturals for octave jumps?
                            temp_nt2->show_accidental = true;
                            already_done_octave_cautionary_accidental = true;
                        } else if ((r_ob->cautionary_accidentals >= 1) && (note_get_screen_midicents(temp_nt2) == curr_midicents) &&
                            (note_get_screen_accidental(temp_nt2).r_num != 0) && (cmp == 0) && (count_for_remind_cautionary_acc > r_ob->cautionary_accidentals_remind)) { // cautionary accidental remind after a little while?
                            temp_nt2->show_accidental = true;
                            count_for_remind_cautionary_acc = 0;
                        }

                        temp_nt2 = temp_nt2->next;
                    }
                    if (temp_ch2->r_sym_duration.r_num >=0) { 
                        count_for_remind_cautionary_acc++; 
                        count_for_octave_cautionary_acc++; 
                    }
                    temp_ch2 = temp_ch2->next;
                }
            }
        }
    }
}

// is_entire_measure == 1 means that we ask for the width of an entire measure
// "gamma" is the "gamma" parameter in the function documentation, elsewhere called spacing_width
double get_default_uwidth(t_notation_obj *r_ob, t_rational density, t_rational symbolic_duration, 
                            double min_needed_uwidth, char is_entire_measure, double gamma) {
    double uwidth = gamma * min_needed_uwidth;
    if (is_entire_measure == 1 && r_ob->minimum_uwidth_for_measure > 0. && r_ob->minimum_uwidth_for_measure > uwidth)
        uwidth = r_ob->minimum_uwidth_for_measure;
    if (r_ob->minimum_uwidth_per_sym_unit_for_measure > 0. && r_ob->minimum_uwidth_per_sym_unit_for_measure * rat2double(symbolic_duration) > uwidth)
        uwidth = r_ob->minimum_uwidth_per_sym_unit_for_measure * rat2double(symbolic_duration);

    return uwidth; 
}



char notation_item_is_globally_locked(t_notation_obj *r_ob, t_notation_item *item){
    if (!item) 
        return 0;
    
    switch (item->type) {
        case k_VOICE:
            return ((t_voice *)item)->locked;
            break;
        case k_MEASURE:
            return (((t_measure *)item)->locked || ((t_measure *)item)->voiceparent->v_ob.locked);
            break;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_chord *)item)->locked || ((t_chord *)item)->voiceparent->v_ob.locked);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_chord *)item)->locked || ((t_chord *)item)->parent->locked || ((t_chord *)item)->parent->voiceparent->v_ob.locked);
            break;
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_note *)item)->locked || ((t_note *)item)->parent->locked || ((t_note *)item)->parent->voiceparent->v_ob.locked);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_note *)item)->locked || ((t_note *)item)->parent->locked || ((t_note *)item)->parent->parent->locked || ((t_note *)item)->parent->parent->voiceparent->v_ob.locked);
            break;
        default:
            break;
    }
    
    return 0;
}

char notation_item_is_globally_muted(t_notation_obj *r_ob, t_notation_item *item){
    if (!item) 
        return 0;
    
    switch (item->type) {
        case k_VOICE:
            return ((t_voice *)item)->muted;
            break;
        case k_MEASURE:
            return (((t_measure *)item)->muted || ((t_measure *)item)->voiceparent->v_ob.muted);
            break;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_chord *)item)->muted || ((t_chord *)item)->voiceparent->v_ob.muted);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_chord *)item)->muted || ((t_chord *)item)->parent->muted || ((t_chord *)item)->parent->voiceparent->v_ob.muted);
            break;
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_note *)item)->muted || ((t_note *)item)->parent->muted || ((t_note *)item)->parent->voiceparent->v_ob.muted);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_note *)item)->muted || ((t_note *)item)->parent->muted || ((t_note *)item)->parent->parent->muted || ((t_note *)item)->parent->parent->voiceparent->v_ob.muted);
            break;
        default:
            break;
    }
    
    return 0;
}


char is_solo_with_progeny(t_notation_obj *r_ob, t_notation_item *item)
{
    if (!item)
        return 0;
    
    switch (item->type) {
        case k_VOICE:
        {
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
                t_rollvoice *voice = (t_rollvoice *)item;
                if (voice->v_ob.solo)
                    return 1;
                t_chord *chord;
                t_note *note;
                for (chord = voice->firstchord; chord; chord = chord->next) {
                    if (chord->solo)
                        return 1;
                    for (note = chord->firstnote; note; note = note->next)
                        if (note->solo)
                            return 1;
                }
            } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_scorevoice *voice = (t_scorevoice *)item;
                if (voice->v_ob.solo)
                    return 1;
                t_measure *meas;
                t_chord *chord;
                t_note *note;
                for (meas = voice->firstmeasure; meas; meas = meas->next) {
                    if (meas->solo)
                        return 1;
                    for (chord = meas->firstchord; chord; chord = chord->next) {
                        if (chord->solo)
                            return 1;
                        for (note = chord->firstnote; note; note = note->next)
                            if (note->solo)
                                return 1;
                    }
                }
            }
        }
            break;
        case k_MEASURE:
        {
            if (((t_measure *)item)->solo)
                return 1;
            
            t_chord *chord;
            t_note *note;
            for (chord = ((t_measure *)item)->firstchord; chord; chord = chord->next) {
                if (chord->solo)
                    return 1;
                for (note = chord->firstnote; note; note = note->next)
                    if (note->solo)
                        return 1;
            }
        }
            break;
        case k_CHORD:
        {
            if (((t_chord *)item)->solo)
                return 1;
            
            t_note *note;
            for (note = ((t_chord *)item)->firstnote; note; note = note->next)
                if (note->solo)
                    return 1;
        }
            break;
        case k_NOTE:
            return ((t_note *)item)->solo;
            break;
        default:
            break;
    }
    
    return 0;
}


char notation_item_is_globally_solo(t_notation_obj *r_ob, t_notation_item *item){
    if (!item) 
        return 0;
    
    switch (item->type) {
        case k_VOICE:
            return ((t_voice *)item)->solo;
            break;
        case k_MEASURE:
            return (((t_measure *)item)->solo || ((t_measure *)item)->voiceparent->v_ob.solo);
            break;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_chord *)item)->solo || ((t_chord *)item)->voiceparent->v_ob.solo);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_chord *)item)->solo || ((t_chord *)item)->parent->solo || ((t_chord *)item)->parent->voiceparent->v_ob.solo);
            break;
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_note *)item)->solo || ((t_note *)item)->parent->solo || ((t_note *)item)->parent->voiceparent->v_ob.solo);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_note *)item)->solo || ((t_note *)item)->parent->solo || ((t_note *)item)->parent->parent->solo || ((t_note *)item)->parent->parent->voiceparent->v_ob.solo);
            break;
        default:
            break;
    }
    
    return 0;
}



char notation_item_is_globally_selected(t_notation_obj *r_ob, t_notation_item *item)
{
    if (!item) 
        return 0;
    
    switch (item->type) {
        case k_VOICE:
            return item->selected;
            break;
        case k_MEASURE:
            return (item->selected || ((t_measure *)item)->voiceparent->v_ob.r_it.selected);
            break;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_chord *)item)->r_it.selected || ((t_chord *)item)->voiceparent->v_ob.r_it.selected);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_chord *)item)->r_it.selected || ((t_chord *)item)->parent->r_it.selected || ((t_chord *)item)->parent->voiceparent->v_ob.r_it.selected);
            break;
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                return (((t_note *)item)->r_it.selected || ((t_note *)item)->parent->r_it.selected || ((t_note *)item)->parent->voiceparent->v_ob.r_it.selected);
            else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (((t_note *)item)->r_it.selected || ((t_note *)item)->parent->r_it.selected || ((t_note *)item)->parent->parent->r_it.selected || ((t_note *)item)->parent->parent->voiceparent->v_ob.r_it.selected);
        case k_MARKER:
            return item->selected;
            break;
        default:
            break;
    }
    
    return 0;
}

// supported element_types are chords and notes
char should_element_be_played(t_notation_obj *r_ob, t_notation_item *item){
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && item->type == k_CHORD &&
        !r_ob->play_rests && (!((t_chord *)item)->firstnote || ((t_chord *)item)->r_sym_duration.r_num < 0))
        return 0;    // it's a rest
    
    if (!r_ob->only_play_selection) {
        char elem_or_subelems_solo = notation_item_is_globally_solo(r_ob, item);
        if (!elem_or_subelems_solo) {
            if (item->type == k_CHORD) {
                t_chord *chord = (t_chord *) item;
                t_note *note;
                for (note = chord->firstnote; note; note = note->next) {
                    if (note->solo){
                        elem_or_subelems_solo = true;
                        break;
                    }
                }
            }
        }
        return !notation_item_is_globally_muted(r_ob, item) && (!r_ob->are_there_solos || elem_or_subelems_solo);
    } else {
        char elem_or_subelems_selected = notation_item_is_globally_selected(r_ob, item);
        char elem_or_subelems_solo = notation_item_is_globally_solo(r_ob, item);
        if (!elem_or_subelems_selected) {
            if (item->type == k_CHORD) {
                t_chord *chord = (t_chord *) item;
                t_note *note;
                for (note = chord->firstnote; note; note = note->next) {
                    if (notation_item_is_selected(r_ob, (t_notation_item *)note)){
                        elem_or_subelems_selected = true;
                        break;
                    }
                }
            }
        }
        if (!elem_or_subelems_solo) {
            if (item->type == k_CHORD) {
                t_chord *chord = (t_chord *) item;
                t_note *note;
                for (note = chord->firstnote; note; note = note->next) {
                    if (note->solo){
                        elem_or_subelems_solo = true;
                        break;
                    }
                }
            }
        }
        return (elem_or_subelems_selected && 
                !notation_item_is_globally_muted(r_ob, item) && (!r_ob->are_there_solos || elem_or_subelems_solo));
    }
    return true;
}


char lock_notation_item(t_notation_obj *r_ob, t_notation_item *item)
{
    if (item->type == k_NOTE)
        return lock_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return lock_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return lock_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return lock_voice(r_ob, (t_voice *)item);
    return 0;
}

char unlock_notation_item(t_notation_obj *r_ob, t_notation_item *item)
{
    if (item->type == k_NOTE)
        return unlock_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return unlock_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return unlock_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return unlock_voice(r_ob, (t_voice *)item);
    return 0;
}


char mute_notation_item(t_notation_obj *r_ob, t_notation_item *item)
{
    if (item->type == k_NOTE)
        return mute_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return mute_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return mute_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return mute_voice(r_ob, (t_voice *)item);
    return 0;
}

char unmute_notation_item(t_notation_obj *r_ob, t_notation_item *item)
{
    if (item->type == k_NOTE)
        return unmute_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return unmute_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return unmute_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return unmute_voice(r_ob, (t_voice *)item);
    return 0;
}

char solo_notation_item(t_notation_obj *r_ob, t_notation_item *item){
    if (item->type == k_NOTE)
        return solo_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return solo_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return solo_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return solo_voice(r_ob, (t_voice *)item);
    return 0;
}

char unsolo_notation_item(t_notation_obj *r_ob, t_notation_item *item){
    if (item->type == k_NOTE)
        return unsolo_note(r_ob, (t_note *)item);
    else if (item->type == k_CHORD)
        return unsolo_chord(r_ob, (t_chord *)item);
    else if (item->type == k_MEASURE)
        return unsolo_measure(r_ob, (t_measure *)item);
    else if (item->type == k_VOICE)
        return unsolo_voice(r_ob, (t_voice *)item);
    return 0;
}



char check_lock_mute_solo_compatibilities_for_chord_and_notes(t_notation_obj *r_ob, t_chord *ch)
{
    t_note *note;
    char res = 0;
    
    if (ch->firstnote) {
        char all_notes_muted = true;
        for (note = ch->firstnote; note; note = note->next)
            if (!note->muted) all_notes_muted = false;
        
        char all_notes_locked = true;
        for (note = ch->firstnote; note; note = note->next)
            if (!note->locked) all_notes_locked = false;
        
        char all_notes_solo = true;
        for (note = ch->firstnote; note; note = note->next)
            if (!note->solo) all_notes_solo = false;
        
        if (ch->muted != all_notes_muted) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->muted = all_notes_muted;
        }
        if (ch->locked != all_notes_locked) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->locked = all_notes_locked;
        }
        if (ch->solo != all_notes_solo) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->solo = all_notes_solo;
        }
    } else {
        // it's a rest: can't be solo/locked/muted!
        if (ch->muted) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->muted = false;
        }
        if (ch->locked) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->locked = false;
        }
        if (ch->solo) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
            ch->solo = false;
        }
    }
    return res;
}

                

char lock_note(t_notation_obj *r_ob, t_note *note){
    // checking if all notes in the note's chord are locked
    t_chord *ch = note->parent;
    char res = 0;
    t_note *temp; 
    char all_notes_locked = true;
    
    if (!note->locked) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }

    note->locked = true;
    
    for (temp = ch->firstnote; temp; temp = temp->next)
        if (!temp->locked) {
            all_notes_locked = false;
            break;
        }
        
    if (all_notes_locked) {
        if (!ch->locked) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        ch->locked = true;
    }
    return res;
}

char unlock_note(t_notation_obj *r_ob, t_note *note){
    char res = 0;

    if (note->locked || note->parent->locked) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    
    note->locked = false;
    note->parent->locked = false;
    
    if (note->parent->is_score_chord) {
        if (note->parent->parent->locked) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->parent->parent->locked = false;
    }
    return res;
}

char lock_unlock_note(t_notation_obj *r_ob, t_note *note){
    if (note->locked)
        unlock_note(r_ob, note);
    else
        lock_note(r_ob, note);
    return 1;
}

char lock_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;
    
    if (!chord->locked){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    chord->locked = true;
    for (note = chord->firstnote; note; note = note->next) {
        if (!note->locked) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
        }
        note->locked = true;
    }
    return res;
}

char unlock_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;
    
    if (chord->locked){
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        res = 1;
    }
    chord->locked = false;
    
    for (note = chord->firstnote; note; note = note->next){
        if (note->locked) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
            res = 1;
        }
        note->locked = false;
    }
    
    if (chord->is_score_chord) {
        if (chord->parent->locked) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord->parent, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        chord->parent->locked = false;
    }
    return res;
}

char lock_unlock_chord(t_notation_obj *r_ob, t_chord *chord){
    if (chord->locked)
        unlock_chord(r_ob, chord);
    else
        lock_chord(r_ob, chord);
    return 1;
}

char is_all_selection_locked(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && !((t_note *)curr_it)->locked) ||
            (curr_it->type == k_CHORD && !((t_chord *)curr_it)->locked) ||
            (curr_it->type == k_MEASURE && !((t_measure *)curr_it)->locked) ||
            (curr_it->type == k_VOICE && !((t_voice *)curr_it)->locked))
            return false;
    }
    return true;
}


char is_all_selection_rhythmic_tree_locked(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if (curr_it->type == k_MEASURE && !((t_measure *)curr_it)->lock_rhythmic_tree)
            return false;
    }
    return true;
}

char is_all_selection_rhythmic_tree_unlocked(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if (curr_it->type == k_MEASURE && ((t_measure *)curr_it)->lock_rhythmic_tree)
            return false;
    }
    return true;
}

char is_all_selection_unlocked(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && ((t_note *)curr_it)->locked) ||
            (curr_it->type == k_CHORD && ((t_chord *)curr_it)->locked) ||
            (curr_it->type == k_MEASURE && ((t_measure *)curr_it)->locked) ||
            (curr_it->type == k_VOICE && ((t_voice *)curr_it)->locked))
            return false;
    }
    return true;
}



char lock_measure(t_notation_obj *r_ob, t_measure *meas){
    t_chord *tmp;
    char res = 0;
    if (meas && !meas->locked){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        meas->locked = true;
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= lock_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    return res;
}

char lock_voice(t_notation_obj *r_ob, t_voice *voice){
    char res = 0;
    if (!voice->locked) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->locked = true;
    return res;
}

char lock_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_lock)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= lock_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= lock_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= lock_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= lock_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= lock_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else
                res |= lock_voice(r_ob, (t_voice *)curr_it);
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


char unlock_measure(t_notation_obj *r_ob, t_measure *meas)
{
    t_chord *tmp;
    char res = 0;
    if (meas && meas->locked) { 
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        meas->locked = false;
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= unlock_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    
    return res;
}

char unlock_voice(t_notation_obj *r_ob, t_voice *voice)
{
    char res = 0;
    if (voice->locked) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->locked = false;
    return res;
}

char unlock_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_lock)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= unlock_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= unlock_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= unlock_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unlock_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= unlock_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unlock_voice(r_ob, (t_voice *)curr_it);
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


void lock_unlock_measure(t_notation_obj *r_ob, t_measure *meas)
{
    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    if (meas) {
        if (meas->locked) {
            t_chord *tmp;
            meas->locked = false;
            tmp = meas->firstchord;
            while (tmp) {
                unlock_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        } else {
            t_chord *tmp;
            meas->locked = true;
            tmp = meas ? meas->firstchord : NULL;
            while (tmp) {
                lock_unlock_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        }
    }
}

char lock_unlock_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_lock)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res = 1;
            lock_unlock_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res = 1;
            lock_unlock_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            res = 1;
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        lock_unlock_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                lock_unlock_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res = 1;
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)temp, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                    temp->locked = (temp->locked ? 0 : 1);
                    if (temp == last)
                        break;
                }
            } else {
                res = 1;
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                ((t_voice *)curr_it)->locked = (((t_voice *)curr_it)->locked ? 0 : 1);
            }
        } else if (curr_it->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = ((t_measure_end_barline *)curr_it)->owner;
            if (meas && meas->tuttipoint_reference && !(meas->tuttipoint_reference->flag & k_FLAG_MODIFIED)) {
                res = 1;
                fix_unfix_measure_width(r_ob, meas);
                meas->tuttipoint_reference->flag |= k_FLAG_MODIFIED;
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


char lock_rhythmic_trees_in_selection(t_notation_obj *r_ob){ 
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_MEASURE || curr_it->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = curr_it->type == k_MEASURE_END_BARLINE ? ((t_measure_end_barline *)curr_it)->owner : (t_measure *)curr_it;
            if (!meas->lock_rhythmic_tree) {
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
                meas->lock_rhythmic_tree = 1;
                recompute_all_for_measure(r_ob, meas, true);
                res = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}

char unlock_rhythmic_trees_in_selection(t_notation_obj *r_ob){ 
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_MEASURE || curr_it->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = curr_it->type == k_MEASURE_END_BARLINE ? ((t_measure_end_barline *)curr_it)->owner : (t_measure *)curr_it;
            if (meas->lock_rhythmic_tree) {
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
                meas->lock_rhythmic_tree = 0;
                recompute_all_for_measure(r_ob, meas, true);
                res = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


char lock_unlock_rhythmic_trees_in_selection(t_notation_obj *r_ob){ 
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_MEASURE || curr_it->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = curr_it->type == k_MEASURE_END_BARLINE ? ((t_measure_end_barline *)curr_it)->owner : (t_measure *)curr_it;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
            meas->lock_rhythmic_tree = (meas->lock_rhythmic_tree ? 0 : 1);
            recompute_all_for_measure(r_ob, meas, true);
            res = 1;
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}

char fix_unfix_barlines_in_selection(t_notation_obj *r_ob){ 
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_MEASURE || curr_it->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = curr_it->type == k_MEASURE_END_BARLINE ? ((t_measure_end_barline *)curr_it)->owner : (t_measure *)curr_it;
            if (meas && meas->tuttipoint_reference && !(meas->tuttipoint_reference->flag & k_FLAG_MODIFIED)) {
                res = 1;
                fix_unfix_measure_width(r_ob, meas);
                meas->tuttipoint_reference->flag |= k_FLAG_MODIFIED;
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


char mute_note(t_notation_obj *r_ob, t_note *note){
    t_chord *ch = note->parent;
    char res = 0;
    t_note *temp; 
    char all_notes_muted = true;
    
    if (!note->muted){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    note->muted = true;

    // checking if all notes in the note's chord are muted
    for (temp = ch->firstnote; temp; temp = temp->next)
        if (!temp->muted) {
            all_notes_muted = false;
            break;
        }
    if (all_notes_muted) {
        if (!ch->muted){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        ch->muted = true;
    }
    return res;
}

char unmute_note(t_notation_obj *r_ob, t_note *note){
    char res = 0;
    
    if (note->muted || note->parent->muted) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }

    note->muted = false;
    note->parent->muted = false;
    
    if (note->parent->is_score_chord) {
        if (note->parent->parent->muted) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->parent->parent->muted = false;
    }
    return res;
}

char mute_unmute_note(t_notation_obj *r_ob, t_note *note){
    if (note->muted)
        unmute_note(r_ob, note);
    else
        mute_note(r_ob, note);
    return 1;
}

char mute_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;
    
    if (!chord->muted){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    
    if (chord->is_score_chord && chord->r_sym_duration.r_num < 0) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        chord->muted = false;
        return res;
    }
    
    chord->muted = true;
    for (note = chord->firstnote; note; note = note->next) {
        if (!note->muted){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->muted = true;
    }
    return res;
}

char unmute_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;
    
    if (chord->muted){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    chord->muted = false;
    
    for (note = chord->firstnote; note; note = note->next) {
        if (note->muted) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->muted = false;
    }
    if (chord->is_score_chord) {
        if (chord->parent->muted) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        chord->parent->muted = false;
    }
    return res;
}

char mute_unmute_chord(t_notation_obj *r_ob, t_chord *chord){
    if (chord->muted)
        unmute_chord(r_ob, chord);
    else
        mute_chord(r_ob, chord);
    return 1;
}

char is_all_selection_muted(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && !((t_note *)curr_it)->muted) ||
            (curr_it->type == k_CHORD && !((t_chord *)curr_it)->muted) ||
            (curr_it->type == k_MEASURE && !((t_measure *)curr_it)->muted) ||
            (curr_it->type == k_VOICE && !((t_voice *)curr_it)->muted))
            return false;
    }
    return true;
}

char is_all_selection_unmuted(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && ((t_note *)curr_it)->muted) ||
            (curr_it->type == k_CHORD && ((t_chord *)curr_it)->muted) ||
            (curr_it->type == k_MEASURE && ((t_measure *)curr_it)->muted) ||
            (curr_it->type == k_VOICE && ((t_voice *)curr_it)->muted))
            return false;
    }
    return true;
}


char mute_measure(t_notation_obj *r_ob, t_measure *meas){
    t_chord *tmp;
    char res = 0;
    if (meas && !meas->muted){
        res = 1;
        meas->muted = true;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= mute_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    return res;
}

char mute_voice(t_notation_obj *r_ob, t_voice *voice){
    char res = 0;
    if (!voice->muted){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->muted = true;
    return res;
}

char mute_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0; 
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_mute)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= mute_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= mute_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= mute_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= mute_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= mute_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else {
                res |= mute_voice(r_ob, (t_voice *)curr_it);
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


char unmute_measure(t_notation_obj *r_ob, t_measure *meas){
    t_chord *tmp;
    char res = 0;
    if (meas && meas->muted) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        meas->muted = false;
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= unmute_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    
    return res;
}

char unmute_voice(t_notation_obj *r_ob, t_voice *voice){
    char res = 0;
    if (voice->muted){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->muted = false;
    return res;
}


char unmute_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_mute)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= unmute_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= unmute_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= unmute_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unmute_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= unmute_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unmute_voice(r_ob, (t_voice *)curr_it);
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}


void mute_unmute_measure(t_notation_obj *r_ob, t_measure *meas)
{
    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    if (meas) {
        if (meas->muted) {
            t_chord *tmp;
            meas->muted = false;
            tmp = meas->firstchord;
            while (tmp) {
                unmute_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        } else {
            t_chord *tmp;
            meas->muted = true;
            tmp = meas->firstchord;
            while (tmp) {
                mute_unmute_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        }
    }
}

char mute_unmute_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_mute)
        return 0;
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res = 1;
            mute_unmute_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res = 1;
            mute_unmute_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            res = 1;
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        mute_unmute_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                mute_unmute_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res = 1;
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)temp, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                    temp->muted = (temp->muted ? 0 : 1);
                    if (temp == last)
                        break;
                }
            } else {
                res = 1;
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                ((t_voice *)curr_it)->muted = (((t_voice *)curr_it)->muted ? 0 : 1);
            }
        }
        curr_it = curr_it->next_selected;
    }
    return res;
}

char no_muted(t_notation_obj *r_ob){
    t_voice *voice;
    for (voice = (t_voice *) r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = (t_voice *) voice_get_next(r_ob, voice)){
        voice->muted = false;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            t_chord *chord;
            for (chord = ((t_rollvoice *)voice)->firstchord; chord; chord = chord->next){
                t_note *nt;
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
                chord->muted = false;
                for (nt = chord->firstnote; nt; nt = nt->next)
                    nt->muted = false;
            }
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            t_measure *meas;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next){
                t_chord *chord;
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                meas->muted = false;
                for (chord = meas->firstchord; chord; chord = chord->next){
                    t_note *nt;
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
                    chord->muted = false;
                    for (nt = chord->firstnote; nt; nt = nt->next)
                        nt->muted = false;
                }
            }
        }
    }
    return false;
}

// SOLOS

char solo_note(t_notation_obj *r_ob, t_note *note){
    t_chord *ch = note->parent;
    char res = 0;
    t_note *temp; 
    char all_notes_solo = true;
    
    if (!note->solo){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    note->solo = true;
    
    // checking if all notes in the note's chord are solo
    for (temp = ch->firstnote; temp; temp = temp->next)
        if (!temp->solo) {
            all_notes_solo = false;
            break;
        }
    if (all_notes_solo) {
        if (!ch->solo){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        ch->solo = true;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    
    return res;
}

char unsolo_note(t_notation_obj *r_ob, t_note *note){
    char res = 0;
    
    if (note->solo || note->parent->solo) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }

    note->solo = false;
    note->parent->solo = false;
    
    if (note->parent->is_score_chord) {
        if (note->parent->parent->solo) {
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->parent->parent->solo = false;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char solo_unsolo_note(t_notation_obj *r_ob, t_note *note){
    if (note->solo)
        unsolo_note(r_ob, note);
    else
        solo_note(r_ob, note);
    r_ob->are_there_solos = are_there_solos(r_ob);
    return 1;
}

char solo_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;
        
    if (!chord->solo){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }

    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && chord->r_sym_duration.r_num < 0) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        chord->solo = false;
        return res;
    }

    chord->solo = true;
    for (note = chord->firstnote; note; note = note->next){
        if (!note->solo){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->solo = true;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char unsolo_chord(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    char res = 0;

    if (chord->solo){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    chord->solo = false;
    
    for (note = chord->firstnote; note; note = note->next) {
        if (note->solo){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        note->solo = false;
    }
    
    if (chord->is_score_chord) {
        if (chord->parent->solo){
            res = 1;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        }
        chord->parent->solo = false;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char solo_unsolo_chord(t_notation_obj *r_ob, t_chord *chord){
    if (chord->solo)
        unsolo_chord(r_ob, chord);
    else
        solo_chord(r_ob, chord);
    r_ob->are_there_solos = are_there_solos(r_ob);
    return 1;
}

char is_all_selection_solo(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && !((t_note *)curr_it)->solo) ||
            (curr_it->type == k_CHORD && !((t_chord *)curr_it)->solo) ||
            (curr_it->type == k_MEASURE && !((t_measure *)curr_it)->solo) ||
            (curr_it->type == k_VOICE && !((t_voice *)curr_it)->solo))
            return false;
    }
    return true;
}

char is_all_selection_unsolo(t_notation_obj *r_ob){
    t_notation_item *curr_it;
    for (curr_it  = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected){
        if ((curr_it->type == k_NOTE && ((t_note *)curr_it)->solo) ||
            (curr_it->type == k_CHORD && ((t_chord *)curr_it)->solo) ||
            (curr_it->type == k_MEASURE && ((t_measure *)curr_it)->solo) ||
            (curr_it->type == k_VOICE && ((t_voice *)curr_it)->solo))
            return false;
    }
    return true;
}


char solo_measure(t_notation_obj *r_ob, t_measure *meas){
    t_chord *tmp;
    char res = 0;
    if (meas && !meas->solo) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        meas->solo = true;
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= solo_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char solo_voice(t_notation_obj *r_ob, t_voice *voice){
    char res = 0;
    if (!voice->solo){
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->solo = true;
    return res;
}

char solo_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;

    if (!r_ob->allow_solo)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= solo_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= solo_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= solo_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= solo_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= solo_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else {
                res |= solo_voice(r_ob, (t_voice *)curr_it);
            }
        }
        curr_it = curr_it->next_selected;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char unsolo_measure(t_notation_obj *r_ob, t_measure *meas){
    t_chord *tmp;
    char res = 0;
    if (meas && meas->solo){
        meas->solo = false;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    tmp = meas ? meas->firstchord : NULL;
    while (tmp) {
        res |= unsolo_chord(r_ob, tmp);
        tmp = tmp->next;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}

char unsolo_voice(t_notation_obj *r_ob, t_voice *voice){
    char res = 0;
    if (voice->solo) {
        res = 1;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    }
    voice->solo = false;
    return res;
}

char unsolo_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    if (!r_ob->allow_solo)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res |= unsolo_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res |= unsolo_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                        res |= unsolo_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unsolo_measure(r_ob, (t_measure *)curr_it);
            }
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res |= unsolo_voice(r_ob, temp);
                    if (temp == last)
                        break;
                }
            } else {
                res |= unsolo_voice(r_ob, (t_voice *)curr_it);
            }
        }
        curr_it = curr_it->next_selected;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}


void solo_unsolo_measure(t_notation_obj *r_ob, t_measure *meas)
{
    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
    if (meas) {
        if (meas->solo) {
            t_chord *tmp;
            meas->solo = false;
            tmp = meas->firstchord;
            while (tmp) {
                unsolo_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        } else {
            t_chord *tmp;
            meas->solo = true;
            tmp = meas->firstchord;
            while (tmp) {
                solo_unsolo_chord(r_ob, tmp);
                tmp = tmp->next;
            }
        }
    }
}

char solo_unsolo_selection(t_notation_obj *r_ob, char whole_voiceensembles)
{
    char res = 0;
    t_notation_item *curr_it = r_ob->firstselecteditem;
    
    if (!r_ob->allow_solo)
        return 0;

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) {
            res = 1;
            solo_unsolo_note(r_ob, (t_note *)curr_it);
        } else if (curr_it->type == k_CHORD) {
            res = 1;
            solo_unsolo_chord(r_ob, (t_chord *)curr_it);
        } else if (curr_it->type == k_MEASURE) {
            if (whole_voiceensembles) {
                t_voice *voice = (t_voice *)(((t_measure *)curr_it)->voiceparent);
                t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
                t_voice *temp;
                long measure_num = ((t_measure *)curr_it)->measure_number;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
                    if (m)
                       solo_unsolo_measure(r_ob, m);
                    if (temp == last)
                        break;
                }
            } else {
                solo_unsolo_measure(r_ob, (t_measure *)curr_it);
            }
            res = 1;
        } else if (curr_it->type == k_VOICE) {
            if (whole_voiceensembles) {
                t_voice *first = voiceensemble_get_firstvoice(r_ob, (t_voice *)curr_it);
                t_voice *last = voiceensemble_get_lastvoice(r_ob, (t_voice *)curr_it);
                t_voice *temp;
                for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
                    res = 1;
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)temp, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                    temp->solo = (temp->solo ? 0 : 1);
                    if (temp == last)
                        break;
                }
            } else {
                res = 1;
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                ((t_voice *)curr_it)->solo = (((t_voice *)curr_it)->solo ? 0 : 1);
            }
        }
        curr_it = curr_it->next_selected;
    }
    r_ob->are_there_solos = are_there_solos(r_ob);
    return res;
}


char no_solo(t_notation_obj *r_ob){
    t_voice *voice;
    for (voice = (t_voice *) r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = (t_voice *) voice_get_next(r_ob, voice)){
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)voice, k_VOICE, k_UNDO_MODIFICATION_CHANGE_FLAG);
        voice->solo = false;
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            t_chord *chord;
            for (chord = ((t_rollvoice *)voice)->firstchord; chord; chord = chord->next){
                t_note *nt;
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
                chord->solo = false;
                for (nt = chord->firstnote; nt; nt = nt->next)
                    nt->solo = false;
            }
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            t_measure *meas;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next){
                t_chord *chord;
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE_FLAG);
                meas->solo = false;
                for (chord = meas->firstchord; chord; chord = chord->next){
                    t_note *nt;
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_FLAG);
                    chord->solo = false;
                    for (nt = chord->firstnote; nt; nt = nt->next)
                        nt->solo = false;
                }
            }
        }
    }
    r_ob->are_there_solos = false;
    return true;
}


void check_mute_solo_flags_for_rests(t_notation_obj *r_ob){
    t_voice *voice;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        for (voice = (t_voice *) r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = (t_voice *) voice_get_next(r_ob, voice)){
            t_measure *meas;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next){
                t_chord *chord;
                for (chord = meas->firstchord; chord; chord = chord->next){
                    if (chord->r_sym_duration.r_num < 0){
                        chord->solo = false;
                        chord->muted = false;
                    }
                }
            }
        }
    }
}

char are_there_solos(t_notation_obj *r_ob){
    t_voice *voice;
    for (voice = (t_voice *) r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = (t_voice *) voice_get_next(r_ob, voice)){
        if (voice->solo) 
            return true;
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            t_chord *chord;
            for (chord = ((t_rollvoice *)voice)->firstchord; chord; chord = chord->next){
                t_note *nt;
                if (chord->solo) 
                    return true;
                for (nt = chord->firstnote; nt; nt = nt->next)
                    if (nt->solo) 
                        return true;
            }
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            t_measure *meas;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next){
                t_chord *chord;
                if (meas->solo) 
                    return true;
                for (chord = meas->firstchord; chord; chord = chord->next){
                    t_note *nt;
                    if (chord->solo) 
                        return true;
                    for (nt = chord->firstnote; nt; nt = nt->next)
                        if (nt->solo) 
                            return true;
                }
            }
        }
    }
    return false;
}


void quick_notation_obj_recompute_all_chord_parameters(t_notation_obj *r_ob){
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < CONST_MAX_VOICES; voice = voice_get_next(r_ob, voice)){
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            t_chord *ch;
            for (ch = ((t_rollvoice *)voice)->firstchord; ch; ch = ch->next)
                ch->need_recompute_parameters = true;
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
            t_measure *meas;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next)
                recompute_all_for_measure(r_ob, meas, false);
        }
    }
}




void tie_chord(t_chord *chord){
    t_note *note;
    for (note = chord->firstnote; note; note = note->next) 
        tie_note(note);
}

void untie_chord(t_chord *chord){
    t_note *note;
    for (note = chord->firstnote; note; note = note->next) 
        untie_note(note);
}

void tie_untie_chord(t_chord *chord){
    t_note *note;
    for (note = chord->firstnote; note; note = note->next) 
        tie_untie_note(note);
}

void tie_note(t_note *note){
    note->tie_to = (t_note *) WHITENULL;
}


void tie_note_from(t_note *note)
{
    if (note->parent && note->parent->is_score_chord) {
        t_chord *ch = note->parent;
        t_chord *prev = chord_get_prev(ch);
        if (prev) {
            t_note *nt;
            for (nt = prev->firstnote; nt; nt = nt->next) {
                if (rat_rat_cmp(note_get_screen_midicents_with_accidental(nt), note_get_screen_midicents_with_accidental(note)) == 0) {
                    tie_note(nt);
                    note->tie_from = (t_note *)WHITENULL;
                    break;
                }
            }
        }
    }
}



void untie_note(t_note *note)
{
    note->tie_to = NULL;
}

void tie_untie_note(t_note *note)
{
    // wait: we compute
    if (note->tie_to)
        note->tie_to = NULL;
    else
        note->tie_to = (t_note *) WHITENULL;
}

t_chord *chord_get_first_in_tieseq(t_chord *chord)
{
    t_chord *outchord = chord;
    while (outchord && chord_is_all_tied_from(outchord, false))
        outchord = chord_get_prev(outchord);
    return outchord;
}

t_chord *chord_get_last_in_tieseq(t_chord *chord)
{
    t_chord *outchord = chord;
    while (outchord && chord_is_all_tied_to(NULL, outchord, false, NULL))
        outchord = chord_get_next(outchord);
    return outchord;
}


// get the duration for a tied sequence for any chord included in such sequence
t_rational chord_get_tieseq_symduration(t_chord *chord)
{
    t_chord *tmp = chord_get_first_in_tieseq(chord);
    t_rational dur = rat_abs(tmp->r_sym_duration);
    while (tmp && chord_is_all_tied_to(NULL, tmp, false, NULL)) {
        tmp = chord_get_next(tmp);
        if (tmp)
            dur = dur + rat_abs(tmp->r_sym_duration);
    }
    return dur;
}


t_note *note_get_first_in_tieseq(t_note *note)
{
    t_note *outnote = note;
    while (outnote && (outnote->tie_from) && (outnote->tie_from != (t_note *) WHITENULL_llll))
        outnote = outnote->tie_from;
    return outnote;
}

t_note *note_get_last_in_tieseq(t_note *note)
{
    t_note *outnote = note;
    while (outnote && (outnote->tie_to) && (outnote->tie_to != (t_note *) WHITENULL_llll))
        outnote = outnote->tie_to;
    return outnote;
}


// get the duration for a tied sequence for any note included in such sequence
t_rational note_get_tieseq_symduration(t_note *note)
{
    t_note *tmp = note_get_first_in_tieseq(note);
    t_rational dur = rat_abs(tmp->parent->r_sym_duration);
    while (tmp && (tmp->tie_to) && (tmp->tie_to != (t_note *) WHITENULL_llll)) {
        tmp = tmp->tie_to;
        if (tmp)
            dur = dur + rat_abs(tmp->parent->r_sym_duration);
    }
    return dur;
}


t_note *note_get_first_selected_in_tieseq(t_notation_obj *r_ob, t_note *note)
{
    t_note *outnote = note;
    while (outnote && (outnote->tie_from) && (outnote->tie_from != (t_note *) WHITENULL_llll) &&
           notation_item_is_globally_selected(r_ob, (t_notation_item *)outnote->tie_from))
        outnote = outnote->tie_from;
    return outnote;
}

t_note *note_get_last_selected_in_tieseq(t_notation_obj *r_ob, t_note *note)
{
    t_note *outnote = note;
    while (outnote && (outnote->tie_to) && (outnote->tie_to != (t_note *) WHITENULL_llll) &&
           notation_item_is_globally_selected(r_ob, (t_notation_item *)outnote->tie_to))
        outnote = outnote->tie_to;
    return outnote;
}


t_chord *last_all_tied_chord(t_chord *chord, char within_measure){
    t_chord *outchord = chord;
    while (outchord && chord_is_all_tied_to(NULL, outchord, 0, NULL) && (!within_measure || outchord->next))
        outchord = chord_get_next(outchord);
    return outchord;
}

t_chord *first_all_tied_chord(t_chord *chord, char within_measure){
    t_chord *outchord = chord;
    while (outchord && chord_is_all_tied_from(outchord, 0) && (!within_measure || outchord->prev))
        outchord = chord_get_prev(outchord);
    return outchord;
}

t_chord *rest_get_last_in_seq(t_chord *chord, char within_measure){
    t_chord *nextch, *outchord = chord;
    if (chord->r_sym_duration.r_num >= 0) 
        return NULL;
    while (outchord && (nextch = chord_get_next(outchord)) && outchord->r_sym_duration.r_num < 0 && nextch->r_sym_duration.r_num < 0 && (!within_measure || outchord->next))
        outchord = nextch;
    return outchord;
}

t_chord *rest_get_first_in_seq(t_chord *chord, char within_measure){
    t_chord *prevch, *outchord = chord;
    if (chord->r_sym_duration.r_num >= 0) 
        return NULL;
    while (outchord && (prevch = chord_get_prev(outchord)) && outchord->r_sym_duration.r_num < 0 && prevch->r_sym_duration.r_num < 0 && (!within_measure || outchord->prev))
        outchord = prevch;
    return outchord;
}

t_rational get_all_tied_chord_sequence_abs_r_duration(t_chord *chord, char within_measure)
{
    t_chord *first = first_all_tied_chord(chord, within_measure); 
    t_chord *last = last_all_tied_chord(chord, within_measure); 
    t_chord *temp;
    t_rational tot_duration = long2rat(0);
    for (temp = first; temp; temp = chord_get_next(temp)) {
        tot_duration = rat_rat_sum(tot_duration, rat_abs(temp->r_sym_duration));
        if (temp == last)
            break;
    }
    return tot_duration;
}

double get_all_tied_chord_sequence_duration_ms(t_chord *chord, char within_measure)
{
    t_chord *first = first_all_tied_chord(chord, within_measure);
    t_chord *last = last_all_tied_chord(chord, within_measure);
    t_chord *temp;
    double tot_duration = 0;
    for (temp = first; temp; temp = chord_get_next(temp)) {
        tot_duration += temp->duration_ms;
        if (temp == last)
            break;
    }
    return tot_duration;
}

double get_all_tied_note_sequence_duration_ms(t_note *nt)
{
    t_note *first = note_get_first_in_tieseq(nt);
    t_note *last = note_get_last_in_tieseq(nt);
    t_note *temp;
    double tot_duration = 0;
    for (temp = first; temp && temp != WHITENULL; temp = temp->tie_to) {
        tot_duration += temp->parent->duration_ms;
        if (temp == last)
            break;
    }
    return tot_duration;
}

void check_ties_around_measure(t_measure *measure){
    measure->need_check_ties = true;
    if (measure->prev) measure->prev->need_check_ties = true;
    if (measure->next) measure->next->need_check_ties = true;
}
 
t_rational measure_get_content_sym_duration(t_measure *measure){
    t_rational res = long2rat(0);
    t_chord *chord;
    for (chord = measure->firstchord; chord; chord = chord->next){
        if (!chord->is_grace_chord)
            res = rat_rat_sum(res, rat_abs(chord->r_sym_duration));
    }
    return res;
}

void check_measure_ties(t_notation_obj *r_ob, t_measure *measure, long ties_assign_pitches, char nullify_incorrect_ties_if_needed) {
    // translate the WHITENULL tie_to fields of each chord, into note tie_to fields, if possible. Otherwise in NULL fields.
    t_chord *chord; t_note *note, *tmpnt;
    
    char measure_filling = rat_rat_cmp(measure_get_content_sym_duration(measure), measure_get_sym_duration(measure)); // we can't rely on the measure->measure_filling field, since it is NOT already computed...
    
    char need_nullify_ties = (nullify_incorrect_ties_if_needed == 2) ? true : (nullify_incorrect_ties_if_needed ? r_ob->nullify_incorrect_ties : false);
    for (chord = measure->firstchord; chord; chord = chord->next) {
        t_chord *nextchord = chord_get_next(chord);
        
        // unset k_FLAG_MODIFIED for each note of nextchord
        if (nextchord) 
            for (tmpnt = nextchord->firstnote; tmpnt; tmpnt = tmpnt->next)
                tmpnt->r_it.flags = (e_bach_internal_notation_flags) (tmpnt->r_it.flags & ~k_FLAG_MODIFIED);
        
        for (note = chord->firstnote; note; note = note->next) {
            note->tie_direction = 0;
            if (note->tie_from && need_nullify_ties) {
                if (note->tie_from == WHITENULL || !note->tie_from->tie_to || 
                    !((note_get_screen_midicents(note->tie_from) == note_get_screen_midicents(note)) && (rat_rat_cmp(note_get_screen_accidental(note->tie_from), note_get_screen_accidental(note)) == 0))) {
                    note->tie_from = NULL;
                }
            }
            
            if (note->tie_to) {
                if (nextchord && measure_filling >= 0) {    
                    t_note *note2 = nextchord->firstnote;
                    if (need_nullify_ties)
                        note->tie_to = NULL;
                    while (note2) {
                        if ((note_get_screen_midicents(note2) == note_get_screen_midicents(note)) &&
                            (rat_rat_cmp(note_get_screen_accidental(note2), note_get_screen_accidental(note)) == 0) &&
                            !(note2->r_it.flags & k_FLAG_MODIFIED)) {    
                            note->tie_to = note2;
                            note2->tie_from = note;
                            note2->r_it.flags = (e_bach_internal_notation_flags) (note2->r_it.flags | k_FLAG_MODIFIED);
                            if (ties_assign_pitches > 0) 
                                note2->midicents = note->midicents; // if flag is > 0, we assign the same pitch to the graphically tied notes
                            break;
                        }
                        note2 = note2->next;
                    }
                }
            }
        }
        
        if (nextchord)
            for (tmpnt = nextchord->firstnote; tmpnt; tmpnt = tmpnt->next)
                tmpnt->r_it.flags = (e_bach_internal_notation_flags) (tmpnt->r_it.flags & ~k_FLAG_MODIFIED);
    }
    
    // deciding tie directions
    char force_direction = 0;
    if (voiceensemble_get_numparts(r_ob, (t_voice *)measure->voiceparent) > 1)
        force_direction = (measure->voiceparent->v_ob.part_index % 2 == 0 ? 1 : -1);
    
    for (chord = measure->firstchord; chord; chord = chord->next) {
        long num_tied_notes = 0, count_tied_notes = 0;
        for (note = chord->firstnote; note; note = note->next)
            if (note->tie_to) num_tied_notes++;
        for (note = chord->firstnote; note; note = note->next)
            if (note->tie_to) {
                count_tied_notes++;
                if (force_direction)
                    note->tie_direction = force_direction;
                else if (num_tied_notes == 1)
                    note->tie_direction = -chord->direction;
                else {
                    if (count_tied_notes <= num_tied_notes/2.)
                        note->tie_direction = -1;
                    else
                        note->tie_direction = 1;
                }
            }
    }
}

long get_num_tied_to_notes(t_chord *chord){
    t_note *note;
    long num_tied_notes = 0;
    if (!chord->is_score_chord) 
        return -1;
    for (note = chord->firstnote; note; note = note->next)
        if (note->tie_to) 
            num_tied_notes++;
    return num_tied_notes;
}

long get_num_tied_from_notes(t_chord *chord){
    t_note *note;
    long num_tied_from_notes = 0;
    if (!chord->is_score_chord) return -1;
    for (note = chord->firstnote; note; note = note->next)
        if (note->tie_from && note->tie_from->tie_to == note) 
            num_tied_from_notes++;
    return num_tied_from_notes;
}


t_note* note_get_first_non_tiedfrom(t_chord *chord){
    t_note *note;
    if (!chord->is_score_chord) return NULL;
    for (note = chord->firstnote; note; note = note->next)
        if (!(note->tie_from && note->tie_from->tie_to == note))
            return note;
    return NULL;
}

// gets the beaming boxes of a given time signature, and returns the division figure if a rational is passed through input
// BEWARE: division_for_PWGL can be wrong, just needed for PWGL...
// r_ob can be NULL
t_llll *ts_to_beaming_boxes(t_notation_obj *r_ob, t_timesignature *ts, t_rational *division_for_PWGL, t_rational *division) {
    t_llll *boxes = llll_get(); // this will be filled with the "beaming" boxes; e.g. (1/4 1/4 1/4 1/4) for the 4/4 standard time signature
    long num_box_elements = ts->numerator;
    
    if (num_box_elements > CONST_MAX_TS_NUMERATOR_ELEMENTS) 
        num_box_elements = CONST_MAX_TS_NUMERATOR_ELEMENTS;
    
    if (ts->num_numerator_elements > 1) { // composite numerator, easy case
        long i;
        num_box_elements = ts->num_numerator_elements;
        for (i = 0; i < ts->num_numerator_elements; i++)
            llll_appendrat(boxes, genrat(ts->numerator_elements[i], ts->denominator), 0, WHITENULL_llll);
        if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);
        if (division) *division = genrat(1, ts->denominator);
    } else {
        // simple time signature. Let's do some cases!
        long perf_log = perfect_log2(ts->denominator);
        if (perf_log >= 0 && perf_log <= 2) { // time signature (n/4) or (n/2) or (n/1) : (1/4, 1/4....)
            long i; 
            num_box_elements = ts->numerator;
            for (i = 0; i < ts->numerator; i++)
                llll_appendrat(boxes, genrat(1, ts->denominator), 0, WHITENULL_llll);
            if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);
            if (division) *division = genrat(1, ts->denominator);
        } else if (perf_log > 2) { // time signature (n/(2^k)), k>2. let's suppose k=3, 2^k=8
            if (ts->numerator % 3 == 0) { // (3n/8): (3/8, 3/8....)
                long i; 
                num_box_elements = ts->numerator / 3;
                for (i = 0; i < ts->numerator / 3; i++)
                    llll_appendrat(boxes, genrat(3, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(3, ts->denominator);
            } else if (ts->numerator % 4 == 0) { // (4n/8): (2/8, 2/8, .......)
                long i; 
                num_box_elements = ts->numerator / 2;
                for (i = 0; i < ts->numerator / 2; i++)
                    llll_appendrat(boxes, genrat(2, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(2, ts->denominator); 
            } else if (ts->numerator == 2) { // (2/8): (1/8 1/8)
                num_box_elements = 2;
                llll_appendrat(boxes, genrat(1, ts->denominator), 0, WHITENULL_llll);
                llll_appendrat(boxes, genrat(1, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator); 
                if (division) *division = genrat(1, ts->denominator);
            } else if (ts->numerator % 3 == 2) { // ((3n+2)/8): (3/8, 3/8...., 2/8)
                long i; 
                num_box_elements = (ts->numerator + 1) / 3;
                for (i = 0; i < (ts->numerator - 2) / 3; i++)
                    llll_appendrat(boxes, genrat(3, ts->denominator), 0, WHITENULL_llll);
                llll_appendrat(boxes, genrat(2, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(3, ts->denominator);
            } else if (ts->numerator == 1) { // (1/8): (1/8)
                num_box_elements = 1;
                llll_appendrat(boxes, genrat(1, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator); 
                if (division) *division = genrat(1, ts->denominator);
            } else { // ((3n+1)/8): (3/8, 3/8...., 4/8)
                long i; 
                num_box_elements = (ts->numerator - 1) / 3 + 1;
                for (i = 0; i < ((ts->numerator - 1) / 3) - 1; i++)
                    llll_appendrat(boxes, genrat(3, ts->denominator), 0, WHITENULL_llll);
                llll_appendrat(boxes, genrat(4, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator); 
                if (division) *division = genrat(1, ts->denominator);
            }
        } else { // TO DO: Complete! with different time signatures!: e.g. / 10... /

            // if time signature is 17/10, we take 10 = 2*5, we remove al the 2^k part, and we get 5,
            // thus we split the time signature into the boxes 5/10 + 5/10 + 5/10 + 2/10, all of whiches are "classical" except for the last one.
            long i, den_removed_2_powers = ts->denominator;
            while (den_removed_2_powers && den_removed_2_powers % 2 == 0)
                den_removed_2_powers /= 2;

            num_box_elements = (long) ceil(ts->numerator / ((double)den_removed_2_powers));
            for (i = 0; i < num_box_elements - 1; i++)
                llll_appendrat(boxes, genrat(den_removed_2_powers, ts->denominator), 0, WHITENULL_llll);
            llll_appendrat(boxes, genrat(ts->numerator % den_removed_2_powers == 0 ? den_removed_2_powers : ts->numerator % den_removed_2_powers, ts->denominator), 0, WHITENULL_llll);
            if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator); 
            if (division) *division = genrat(1, ts->denominator);

/*
            if (ts->numerator % 4 == 0) { // (4n/q): (4/q, 4/q, .......)
                long i; 
                num_box_elements = ts->numerator / 4;
                for (i = 0; i < ts->numerator / 4; i++)
                    llll_appendrat(boxes, genrat(4, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(4, ts->denominator); 
            } else if (ts->numerator % 2 == 0) { // (2n/q): (2/q, 2/q, .......)
                long i; 
                num_box_elements = ts->numerator / 2;
                for (i = 0; i < ts->numerator / 2; i++)
                    llll_appendrat(boxes, genrat(2, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(2, ts->denominator); 
            } else if (ts->numerator % 3 == 0) { // (3n/q): (3/q, 3/q....)
                long i; 
                num_box_elements = ts->numerator / 3;
                for (i = 0; i < ts->numerator / 3; i++)
                    llll_appendrat(boxes, genrat(3, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator);  // wrong, but needed for PWGL
                if (division) *division = genrat(3, ts->denominator);
            } else { // ((4n+s)/q): (4/q, 4/q...., s/q)
                long i; 
                num_box_elements = (ts->numerator / 4) + 1;
                for (i = 0; i < num_box_elements - 1; i++)
                    llll_appendrat(boxes, genrat(4, ts->denominator), 0, WHITENULL_llll);
                llll_appendrat(boxes, genrat(ts->numerator % 4, ts->denominator), 0, WHITENULL_llll);
                if (division_for_PWGL) *division_for_PWGL = genrat(1, ts->denominator); 
                if (division) *division = genrat(1, ts->denominator);
            } */
        }
    }
    return boxes;
}


t_symbol *notationitemflag2symbol(long flag)
{
    char buf[32];
    long cur = 0;
    if (flag & k_FLAG_ELEMENT_LOCKED)
        buf[cur++] = 'l';
    if (flag & k_FLAG_ELEMENT_MUTED)
        buf[cur++] = 'm';
    if (flag & k_FLAG_ELEMENT_SOLO)
        buf[cur++] = 's';
    if (flag & k_FLAG_ELEMENT_BEAMING_TREE_LOCKED)
        buf[cur++] = 'b';

    buf[cur++] = 0;
    return buf[0] ? gensym(buf) : NULL;
}


long symbol2notationitemflag(t_symbol *sym)
{
    long res = 0;
    
    if (!sym)
        return res;
    
    char *cur = sym->s_name;
    while (cur && *cur) {
        switch (*cur) {
            case 'l':
                res += k_FLAG_ELEMENT_LOCKED;
                break;
                
            case 'm':
                res += k_FLAG_ELEMENT_MUTED;
                break;
                
            case 's':
                res += k_FLAG_ELEMENT_SOLO;
                break;
                
            case 'b':
                res += k_FLAG_ELEMENT_BEAMING_TREE_LOCKED;
                break;
                
            default:
                break;
        }
        cur++;
    }
    
    return res;
}






// RHYTHMIC TREES


t_symbol *leveltype2symbol(long leveltype)
{
    char buf[32];
    long cur = 0;
    if (leveltype & k_RHYTHM_LEVEL_ORIGINAL)
        buf[cur++] = 'o';
    if (leveltype & k_RHYTHM_LEVEL_ADDED)
        buf[cur++] = 'a';
    if (leveltype & k_RHYTHM_LEVEL_DISPLAY_ONLY)
        buf[cur++] = 'd';
    if (leveltype & k_RHYTHM_LEVEL_TS_BOX)
        buf[cur++] = 'b';
    if (leveltype & k_RHYTHM_LEVEL_TUPLET)
        buf[cur++] = 't';
    if (leveltype & k_RHYTHM_LEVEL_GRACE)
        buf[cur++] = 'g';
    if (leveltype & k_RHYTHM_LEVEL_IGNORE)
        buf[cur++] = 'i';
    if (leveltype & k_RHYTHM_LEVEL_KEEP)
        buf[cur++] = 'k';
    if (leveltype & k_RHYTHM_LEVEL_FORCE_TUPLET)
        buf[cur++] = 'f';
    buf[cur++] = 0;
    return buf[0] ? gensym(buf) : NULL;
}


long symbol2leveltype(t_symbol *sym)
{
    long res = 0;

    if (!sym)
        return res;
    
    char *cur = sym->s_name;
    while (cur && *cur) {
        switch (*cur) {
            case 'o':
                res += k_RHYTHM_LEVEL_ORIGINAL;
                break;

            case 'a':
                res += k_RHYTHM_LEVEL_ADDED;
                break;

            case 'd':
                res += k_RHYTHM_LEVEL_DISPLAY_ONLY;
                break;

            case 'b':
                res += k_RHYTHM_LEVEL_TS_BOX;
                break;

            case 't':
                res += k_RHYTHM_LEVEL_TUPLET;
                break;

            case 'g':
                res += k_RHYTHM_LEVEL_GRACE;
                break;

            case 'i':
                res += k_RHYTHM_LEVEL_IGNORE;
                break;

            case 'k':
                res += k_RHYTHM_LEVEL_KEEP;
                break;

            case 'f':
                res += k_RHYTHM_LEVEL_FORCE_TUPLET;
                break;

            default:
                break;
        }
        cur++;
    }
    
    return res;
}




long substitute_chords_with_rduration_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    char hack_ties = *((char *) ((void **)data)[1]);
    if (hatom_gettype(a) == H_OBJ){
        t_chord *ch = (t_chord *)hatom_getobj(a);
        hatom_setrational(a, ch->r_sym_duration);
        if (hack_ties && chord_is_all_tied_to(r_ob, ch, true, NULL)){
            a->h_w.w_rat.r_num *= -1;
            a->h_w.w_rat.r_den *= -1;
        }
    }
    return 0;
}

// don't ever use use_ties_hack; it makes both num and den negatives when the chord is all tied to the next, it's a LOW LEVEL HACK to save code...
t_llll *rhythmic_tree_to_duration_tree(t_notation_obj *r_ob, t_llll *rhythmic_tree, char clone_rhythm_level_properties, char use_ties_hack){
    char hack_ties = use_ties_hack;
    void *data[2];
    data[0] = r_ob;
    data[1] = &hack_ties;
    
//    llll_check(rhythmic_tree);

    t_llll *duration_tree = llll_clone_extended(rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties ? clone_rhythm_level_properties_fn : ignore_l_thing_fn);
    
    llll_funall(duration_tree, substitute_chords_with_rduration_fn, data, 1, -1, 0);
    return duration_tree;
}

long get_rduration_before_beaming_element_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational *tot = (t_rational *) ((void **)data)[0];
    t_hatom *before_this_hatom = (t_hatom *) ((void **)data)[1];
    char *done = (char *)((char **)data)[2];
    char *ignore_grace_levels = (char *)((char **)data)[3];
    
    if (a == before_this_hatom)
        *done = true;
    
    if (!(*done)){
        if (hatom_gettype(a) == H_OBJ){
            t_chord *ch = (t_chord *)hatom_getobj(a);
            *tot = rat_rat_sum(*tot, rat_abs(ch->r_sym_duration));
        } else if (hatom_gettype(a) == H_LLLL && ignore_grace_levels && is_level_grace(hatom_getllll(a)))
            return 1; // don't enter
    }
    return 0;
}

t_rational get_rduration_before_beaming_element(t_llll *level, t_llllelem *before_this_elem, char ignore_grace_levels){
    void *data[4];
    t_rational res = long2rat(0);
    char done = false;
    char ignoregrace = ignore_grace_levels;
    data[0] = &res;
    data[1] = &before_this_elem->l_hatom;
    data[2] = &done;
    data[3] = &ignoregrace;
    llll_funall(level, get_rduration_before_beaming_element_fn, data, 1, -1, ignore_grace_levels ? FUNALL_PROCESS_WHOLE_SUBLISTS : 0);
    return res;
}

t_rational get_leaf_rduration(t_notation_obj *r_ob, t_llllelem *leaf, char return_0_if_grace, char ignore_internal_grace_levels, char change_force_tuplet_levels_to_sum){
    if (hatom_gettype(&leaf->l_hatom) == H_LLLL)
        return get_level_rduration(r_ob, hatom_getllll(&leaf->l_hatom), return_0_if_grace, ignore_internal_grace_levels, change_force_tuplet_levels_to_sum, false);
        
    if (hatom_gettype(&leaf->l_hatom) == H_OBJ)
        return rat_abs(((t_chord *)hatom_getobj(&leaf->l_hatom))->r_sym_duration);
        
    return long2rat(0);
}

long clear_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0 && is_level_grace(hatom_getllll(a))) {
        llll_flat(hatom_getllll(a), 0, 0, 0, LLLL_FREETHING_MEM);
        llll_clear(hatom_getllll(a));
    }
    return 0;
}


long change_force_tuplet_levels_to_the_complete_tuplet_duration(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0 && is_level_tuplet(hatom_getllll(a))) {
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj;
        if (prop->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET) {
            t_rational sum = prop->tupletinfo.tuplet_sym_duration;
            llll_free_freethings(hatom_change_to_rat(a, sum), LLLL_FREETHING_MEM);
        }
    }
    return 0;
}


t_rational get_level_rduration(t_notation_obj *r_ob, t_llll *level_rhythmic_tree, char return_0_if_grace, char ignore_internal_grace_levels, char change_force_tuplet_levels_to_sum, char level_is_durations)
{
    t_rational total_sum;
    t_llll *rdurs; 
    t_llll *summed;
    
    if (level_is_durations) {
        rdurs = llll_clone_extended(level_rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
    } else
        rdurs = rhythmic_tree_to_duration_tree(r_ob, level_rhythmic_tree, true, false);
    
    if (return_0_if_grace && is_level_grace(level_rhythmic_tree)) {
        llll_free_freethings(rdurs, LLLL_FREETHING_MEM);
        return long2rat(0);
    } else if (ignore_internal_grace_levels) {
        llll_funall(rdurs, clear_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
    }

    if (change_force_tuplet_levels_to_sum)
        llll_funall(rdurs, change_force_tuplet_levels_to_the_complete_tuplet_duration, NULL, 1, -1, FUNALL_SKIP_ATOMS);

    llll_abs(rdurs);
    summed = llll_dx2x_of_rat_llll(rdurs, long2rat(0), &total_sum);
    
    llll_free_freethings(rdurs, LLLL_FREETHING_MEM);
    llll_free(summed);

    return total_sum;
}

// calculates the total duration of a rational tree as (1/2 (1/8 1/16))
t_rational get_total_element_rduration(t_hatom *a, char ignore_grace_levels){
    t_rational res = long2rat(0);
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *cloned = llll_clone_extended(hatom_getllll(a), WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
        
        if (ignore_grace_levels)
            llll_funall(cloned, clear_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
        
        llll_abs(cloned);
        
        t_llll *summed = llll_dx2x_of_rat_llll(cloned, long2rat(0), &res);

        llll_free_freethings(cloned, LLLL_FREETHING_MEM);
        llll_free(summed);
    } else if (hatom_gettype(a) == H_RAT || hatom_gettype(a) == H_LONG) {
        res = rat_abs(hatom_getrational(a));
    }
    return force_standard_rational(res);
}


void selected_chords_and_measures_to_selected_rhythmic_tree_nodes(t_notation_obj *r_ob, long *num_nodes, t_llllelem ***nodes, t_measure ***node_measures){
    long i, j;
    char changed;
    long n;
    t_notation_item *curr_it;
    long size = r_ob->num_selecteditems;

    for (curr_it = r_ob->firstselecteditem, i = 0; curr_it && i < r_ob->num_selecteditems; curr_it = curr_it->next_selected){
        if (curr_it->type == k_MEASURE)
            size += ((t_measure *)curr_it)->num_chords - 1;
    }
    
    *nodes = (t_llllelem **)bach_newptr(size * sizeof(t_llllelem *)); // we cannot need more than this!  
    *node_measures = (t_measure **)bach_newptr(size * sizeof(t_measure *));   
    *num_nodes = 0;
    
    // setting first elements
    for (curr_it = r_ob->firstselecteditem, i = 0; curr_it && i < size; curr_it = curr_it->next_selected){
        if (curr_it->type == k_CHORD){
            (*nodes)[i] = ((t_chord *)curr_it)->rhythmic_tree_elem;
            (*node_measures)[i] = ((t_chord *)curr_it)->parent;
            i++;
        } else if (curr_it->type == k_NOTE){
            (*nodes)[i] = ((t_note *)curr_it)->parent->rhythmic_tree_elem;
            (*node_measures)[i] = ((t_note *)curr_it)->parent->parent;
            i++;
        } else if (curr_it->type == k_MEASURE){
            t_chord *ch;
            for (ch = ((t_measure *)curr_it)->firstchord; ch && i < size; ch = ch->next){
                (*nodes)[i] = ch->rhythmic_tree_elem;
                (*node_measures)[i] = (t_measure *)curr_it;
                i++;
            }
        }
    }
    n = i; // current number of notes
    
    // reducing elements on completed levels
    changed = true;
    while (changed){
        changed = false;
        for (i = 0; i < n; i++){
            t_llllelem *pivot = (*nodes)[i];
            if (pivot && pivot != WHITENULL_llllelem){
                t_llll *parent = pivot->l_parent;
                if (true) { //pivot->l_parent->l_owner){
                    t_llllelem *test;
                    long *found_idx = (long *)bach_newptr(parent->l_size * sizeof(long));
                    char all_found = true;
                    long found_i = 0;
                    for (test = parent->l_head; test; test = test->l_next){
                        char this_found = false;
                        if (test == pivot) {
                            if (found_i < (long)parent->l_size) // should always be true
                                found_idx[found_i++] = i;
                            continue;
                        }
                        for (j = i + 1; j < n; j++){    // (*nodes)[1]
                            if ((*nodes)[j] == test){
                                if (found_i < (long)parent->l_size) { // should always be true
                                    found_idx[found_i++] = j;
                                    this_found = true;
                                }
                                break;
                            }
                        }
                        if (!this_found){
                            all_found = false;
                            break;
                        }
                    }
                    if (all_found && found_i > 0 && found_i == (long)parent->l_size) {
                        changed = true;
                        (*nodes)[CLAMP(found_idx[0], 0, n - 1)] = (!parent->l_owner ? WHITENULL_llllelem : parent->l_owner);
                        for (j = 1; j < (long)parent->l_size; j++)
                            (*nodes)[CLAMP(found_idx[j], 0, n - 1)] = NULL;
                    }
                    bach_freeptr(found_idx);
                }
            }
        }
    }
    
    // Now we have a list like 
    // elem1 elem2 NULL elem4 NULL NULL elem7...
    // and we need to delete NULLS
    i = 0;
    while (i < n){
        if ((*nodes)[i] == NULL){
            if (i < n - 1) {
                sysmem_copyptr(&((*nodes)[i+1]), &((*nodes)[i]), (n - i - 1) * sizeof(t_llllelem *));
                sysmem_copyptr(&((*node_measures)[i+1]), &((*node_measures)[i]), (n - i - 1) * sizeof(t_measure *));
            }
            n--;
        } else 
            i++;
    }

    *num_nodes = n;
}



/*
long get_beam_number_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_OBJ){
        t_chord *ch = (t_chord *)hatom_getobj(a);
        if (ch->r_sym_duration.r_num > 0){
            long this_num_beams = get_num_beams_from_figure(ch->figure);
            if (this_num_beams < *((long *)data))
                *((long *)data) = this_num_beams;
        } else if (rat_rat_cmp(ch->figure, RAT_1OVER8) > 0)
            *((long *)data) = 0;
    }
    return 0;
}*/

/*
long correct_beam_number_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    long *num_beam = (long *)data;
    if (address->l_size > 0) {
        if (hatom_gettype(a) == H_LLLL && hatom_getllll(a) && hatom_getllll(a)->l_size > 1 && hatom_getllll(a)->l_thing.w_obj){
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *) hatom_getllll(a)->l_thing.w_obj;
            if (prop->max_beam_number <= *num_beam)
                *num_beam = MAX(0, prop->beam_number - 1);
        }
    }
    return 0;
}

*/


// if get_max_beam_number == 1 it returns the maximum tolerable beam number over the level is under another beam
long get_default_beam_number_for_level(t_notation_obj *r_ob, t_llll *level, char get_max_beam_number_if_level_is_under_beam, char zero_if_single_chord){
    t_llll *flattened_level;
    long num = 0;
    long rest_force_num = -1;    // -1 = undefined
    
    t_llllelem *elem;
    t_llllelem *first_nonrest_elem;
    t_llllelem *last_nonrest_elem;

    flattened_level = llll_clone_extended(level, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);

    delete_grace_levels(flattened_level); // we don't care about internal grace levels!

    llll_flat(flattened_level, 0, 0, 0, LLLL_FREETHING_MEM);
    
    if (zero_if_single_chord && flattened_level->l_size <= 1) {
        llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
        return 0;
    }
    
    // analyzing rests inside beaming
    first_nonrest_elem = flattened_level->l_head;
    while (first_nonrest_elem && hatom_gettype(&first_nonrest_elem->l_hatom) == H_OBJ &&
           ((t_chord *)hatom_getobj(&first_nonrest_elem->l_hatom))->r_sym_duration.r_num < 0){
        if (r_ob->rests_within_beaming == k_REST_IN_BEAM_NEVER || r_ob->rests_within_beaming == k_REST_IN_BEAM_IF_INTERNAL){
            if (!get_max_beam_number_if_level_is_under_beam) {
                llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
                return 0;
            }
        } else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY)
            rest_force_num = (rest_force_num < 0) ? 1 : MIN(rest_force_num, 1);
        else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE){
            char this_num_beams = get_num_beams_from_figure(((t_chord *)hatom_getobj(&first_nonrest_elem->l_hatom))->figure);
            rest_force_num = (rest_force_num < 0) ? this_num_beams : MIN(rest_force_num, this_num_beams);
        }
        first_nonrest_elem = first_nonrest_elem->l_next;
    }

    if (!first_nonrest_elem) { 
        // all rest level!
        llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
        return get_max_beam_number_if_level_is_under_beam ? CONST_MAX_BEAMS : 0;
    }

    last_nonrest_elem = flattened_level->l_tail;
    while (last_nonrest_elem && hatom_gettype(&last_nonrest_elem->l_hatom) == H_OBJ &&
           ((t_chord *)hatom_getobj(&last_nonrest_elem->l_hatom))->r_sym_duration.r_num < 0){
        if (r_ob->rests_within_beaming == k_REST_IN_BEAM_NEVER || r_ob->rests_within_beaming == k_REST_IN_BEAM_IF_INTERNAL){
            if (!get_max_beam_number_if_level_is_under_beam) {
                llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
                return 0;
            }
        } else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY)
            rest_force_num = (rest_force_num < 0) ? 1 : MIN(rest_force_num, 1);
        else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE){
            char this_num_beams = get_num_beams_from_figure(((t_chord *)hatom_getobj(&last_nonrest_elem->l_hatom))->figure);
            rest_force_num = (rest_force_num < 0) ? this_num_beams : MIN(rest_force_num, this_num_beams);
        }
        last_nonrest_elem = last_nonrest_elem->l_prev;
    }

    num = (rest_force_num < 0) ? get_num_beams_from_figure(((t_chord *)hatom_getobj(&first_nonrest_elem->l_hatom))->figure) : rest_force_num;
    for (elem = first_nonrest_elem; elem; elem = elem->l_next){
        t_chord *ch = (t_chord *)hatom_getobj(&elem->l_hatom);
        if (ch->r_sym_duration.r_num > 0){
            long this_num_beams = get_num_beams_from_figure(ch->figure);
            if (this_num_beams < num)
                num = this_num_beams;
        } else {
            if (rat_rat_cmp(ch->figure, RAT_1OVER8) <= 0) {
                if (r_ob->rests_within_beaming == k_REST_IN_BEAM_NEVER){
                    llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
                    return 0;
                } else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY) {
                    if (num > 1)
                        num = 1;
                } else if (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE){
                    char this_num_beams = get_num_beams_from_figure(ch->figure);
                    if (num > this_num_beams)
                        num = this_num_beams;
                }
            } else {
                llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
                return 0;
            }
        }
        if (elem == last_nonrest_elem)
            break;
    }

    llll_free_freethings(flattened_level, LLLL_FREETHING_MEM);
    return num;

}

long get_min_rational_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational *curr = (t_rational *)data;
    if (hatom_gettype(a) == H_OBJ && rat_rat_cmp(((t_chord *)hatom_getobj(a))->r_sym_duration, *curr) < 0)
        *curr = ((t_chord *)hatom_getobj(a))->r_sym_duration;
    return 0;
}

long is_level_an_all_rests_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_OBJ && ((t_chord *)hatom_getobj(a))->r_sym_duration.r_num > 0)
        *((char *)data) = false;
    return 0;
}

char is_level_an_all_rests_level(t_notation_obj *r_ob, t_llll *box, t_rational *minimum_figure){
    char res = true;
    *minimum_figure = long2rat(0);
    llll_funall(box, is_level_an_all_rests_level_fn, &res, 1, -1, 0);
    if (res)
        llll_funall(box, get_min_rational_fn, minimum_figure, 1, -1, 0);
    return res;
}



long fix_level_type_flag_for_level_as_ignore_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        if (!hatom_getllll(a)->l_thing.w_obj) {
            hatom_getllll(a)->l_thing.w_obj = build_rhythm_level_properties();
            ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type = k_RHYTHM_LEVEL_IGNORE;
            *((char *) data) = true;
        } else if (!(((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)){
            ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_FORCE_TUPLET; // we remove the force tuplet flag!
            ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type |= k_RHYTHM_LEVEL_IGNORE;
            *((char *) data) = true;
        }
    }
    return 0;
}



char rebeam_level(t_notation_obj *r_ob, t_measure *meas, t_llllelem *level, char also_destroy_tuplets, char force_autoparse, long flags)
{
    if (!level || !meas)
        return 0;
    
    t_llll *llll = NULL;
    
    if (level == WHITENULL_llllelem && meas)
        llll = meas->rhythmic_tree;
    else if (level != WHITENULL_llllelem && hatom_gettype(&level->l_hatom) == H_LLLL)
        llll = hatom_getllll(&level->l_hatom);
    else
        llll = NULL;
    
    if (llll && meas) {
        char this_changed = 0;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
        
        verbose_post_rhythmic_tree(r_ob, meas, gensym("Tab Pressed1"), 1);
        if (llll) {
            llll_funall(llll, fix_level_type_flag_for_level_as_ignore_fn, &this_changed, 1, -1, FUNALL_SKIP_ATOMS);
            if (this_changed && !also_destroy_tuplets)
                set_tuplet_levels_as_keep_levels(llll);
        }
        verbose_post_rhythmic_tree(r_ob, meas, gensym("Tab Pressed2"), 1);
        
        if (are_all_chords_in_measure_selected(r_ob, meas)){
            this_changed |= (!meas->rhythmic_tree->l_thing.w_obj || ((t_rhythm_level_properties *)meas->rhythmic_tree->l_thing.w_obj)->level_type != k_RHYTHM_LEVEL_IGNORE);
            if (this_changed) {
                llll_funall(meas->rhythmic_tree, fix_level_type_flag_for_level_as_ignore_fn, &this_changed, 1, -1, FUNALL_SKIP_ATOMS);
                if (!also_destroy_tuplets)
                    set_tuplet_levels_as_keep_levels(meas->rhythmic_tree);
            }
        }
        
        if (this_changed)
            recompute_all_for_measure(r_ob, meas, true);
        
        verbose_post_rhythmic_tree((t_notation_obj *) x, meas, gensym("Tab Pressed"), 1);
        
        return this_changed;
    }
    
    return 0;
}



// returns 1 if changed, 0 if unchanged
// if only_additional_refining == 1, this function will NOT involve
char refine_beams_for_level_once(t_notation_obj *r_ob, t_llll *box, char for_sublllls_use_max_beam_number_if_under_beam, 
                                    char strictly_forbid_noninternal_rests, char only_additional_refining, char max_number_of_beams_for_refined_lllls,
                                    char recursively_refine_added_levels){
    t_llllelem *box_elem = box->l_head;
    t_rational eight = RAT_1OVER8;
    t_llllelem *start_beam_elem = NULL;
    long curr_num_beams = 0;
    char changed = false;
    t_rhythm_level_properties *box_prop = ((t_rhythm_level_properties *)box->l_thing.w_obj);
    long box_num_beams = box_prop->beam_number;
    
    #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf = NULL;
        llll_to_text_buf(box, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
        bach_freeptr(buf);
    #endif
    
    while (box_elem) {
        t_llllelem *next_box_elem = box_elem->l_next;
        t_rational this_figure = RAT_1OVER4;
        long this_num_beams = 0;
        char is_rest = false;
        char is_llll = false;
        char can_incorporate_llll = false;
        char is_grace_level = false;
        
        if (hatom_gettype(&box_elem->l_hatom) == H_OBJ) {
            t_chord *this_chord = (t_chord *)hatom_getobj(&box_elem->l_hatom);
            this_figure = this_chord->figure;
            this_num_beams = get_num_beams_from_figure(rat_abs(this_figure));
            is_rest = (this_chord->r_sym_duration.r_num < 0);
            if (is_rest && this_num_beams > 0 && r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY)
                this_num_beams = 1;
            if (is_rest && strictly_forbid_noninternal_rests){
                if (!start_beam_elem)
                    this_num_beams = 0;
                else if (box_elem == box->l_tail)
                    this_num_beams = 0;
            }
        } else if (hatom_gettype(&box_elem->l_hatom) == H_LLLL) {
            t_llll *this_llll = hatom_getllll(&box_elem->l_hatom);
            t_rhythm_level_properties *prop;
            prop = (t_rhythm_level_properties *)this_llll->l_thing.w_obj;
            is_llll = true;
            
            can_incorporate_llll = false;

            if (prop->max_beam_number_if_under_beam < 0)
                prop->max_beam_number_if_under_beam = get_default_beam_number_for_level(r_ob, this_llll, true, false);
            
            is_rest = false;
            
            this_num_beams = for_sublllls_use_max_beam_number_if_under_beam ? prop->max_beam_number_if_under_beam : prop->beam_number;
            
            if (prop->level_type & k_RHYTHM_LEVEL_GRACE) {
                can_incorporate_llll = true;
                is_grace_level = true;
            } else if (only_additional_refining && prop->level_type & k_RHYTHM_LEVEL_TS_BOX) {
                can_incorporate_llll = false;
            } else if (only_additional_refining && this_num_beams <= box_num_beams + 1) {
                can_incorporate_llll = false;
            } else if (strictly_forbid_noninternal_rests) {    // this is just to handle a very particular case: when checking again beamings "backwards"
                t_chord *start = get_level_start_chord(this_llll, true);
                t_chord *end = get_level_end_chord(this_llll, true);
                if (!start || !end)
                    can_incorporate_llll = false;
                else if (start->r_sym_duration.r_num < 0 && !start_beam_elem)
                    can_incorporate_llll = false;
                else if (end->r_sym_duration.r_num < 0 && box_elem == box->l_tail)
                    can_incorporate_llll = false;
                else
                    can_incorporate_llll = true;
            } else if (!(prop->level_type & k_RHYTHM_LEVEL_TS_BOX) && (prop->level_type & k_RHYTHM_LEVEL_ADDED || prop->level_type & k_RHYTHM_LEVEL_DISPLAY_ONLY 
                                                                   || prop->level_type & k_RHYTHM_LEVEL_IGNORE || prop->level_type & k_RHYTHM_LEVEL_KEEP || 
                                                                   r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_PROCESS)){
                if (this_num_beams > curr_num_beams)
                    can_incorporate_llll = true;
                else {
                    long possible_new_curr_num_beams = this_num_beams - 1;
                    if (possible_new_curr_num_beams > box_num_beams && possible_new_curr_num_beams < curr_num_beams) {
                        curr_num_beams = possible_new_curr_num_beams;
                        can_incorporate_llll = true;
                    } else
                        can_incorporate_llll = false;
                }
            }
        }
        
        if ((!is_llll || can_incorporate_llll) && (!is_rest || r_ob->rests_within_beaming == k_REST_IN_BEAM_ALWAYS ||
                                                   (r_ob->rests_within_beaming == k_REST_IN_BEAM_IF_INTERNAL && box_num_beams >= 1))
            && !start_beam_elem && this_num_beams > box_num_beams && (!only_additional_refining || !is_llll || this_num_beams > box_num_beams + 1)) { // note < box beam figure
            // a new beam starts
            curr_num_beams = max_number_of_beams_for_refined_lllls > 0 ? MIN(max_number_of_beams_for_refined_lllls, this_num_beams) : this_num_beams;
            start_beam_elem = box_elem;
        } else if ((!is_llll || can_incorporate_llll) && (!is_rest || r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE || r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY) && 
                   start_beam_elem && this_num_beams > box_num_beams && this_num_beams < curr_num_beams
                   && (!only_additional_refining || !is_llll || this_num_beams > box_num_beams + 1)) { // note, with less beams than the current value
            // we decrease the number of beams
            curr_num_beams = this_num_beams;
        } else if ((is_rest && rat_rat_cmp(this_figure, eight) <= 0 && 
                    (r_ob->rests_within_beaming == k_REST_IN_BEAM_ALWAYS || (r_ob->rests_within_beaming == k_REST_IN_BEAM_IF_INTERNAL && box_elem->l_prev && box_elem->l_next)) &&
                    (r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_ALWAYS || 
                     ((r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE || r_ob->extend_beams_over_rests == k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY)
                      && this_num_beams >= curr_num_beams && (!only_additional_refining || !is_llll || this_num_beams > box_num_beams + 1)))) ||  // rest which keeps the group going
                   ((!is_llll || can_incorporate_llll) && !is_rest && (this_num_beams >= curr_num_beams || is_grace_level))) {    // note with equal or more beams than the current value
            // nothing to do: we keep the previous group going
        } else if (start_beam_elem && box_elem != start_beam_elem) { // we stop the beaming
            t_llllelem *end_beam_elem = box_elem->l_prev;
            if (r_ob->rests_within_beaming != k_REST_IN_BEAM_ALWAYS && this_num_beams == 0){
                while (end_beam_elem && end_beam_elem != start_beam_elem && 
                        ((hatom_gettype(&end_beam_elem->l_hatom) == H_OBJ && ((t_chord *)hatom_getobj(&end_beam_elem->l_hatom))->r_sym_duration.r_num < 0) ||
                        (hatom_gettype(&end_beam_elem->l_hatom) == H_LLLL && is_level_grace(hatom_getllll(&end_beam_elem->l_hatom)))))
                    end_beam_elem = end_beam_elem->l_prev;
            }
            if (end_beam_elem != start_beam_elem){
                t_llll *new_ll = llll_wrap_element_range(start_beam_elem, end_beam_elem);
                set_level_type_flag_for_level(new_ll, (box_prop->level_type & k_RHYTHM_LEVEL_IGNORE || box_prop->level_type & k_RHYTHM_LEVEL_KEEP ? k_RHYTHM_LEVEL_IGNORE : 0) +
                                              (box_prop->level_type & k_RHYTHM_LEVEL_KEEP ? k_RHYTHM_LEVEL_ORIGINAL :
                                               (r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_REFINE_ONLY_GRAPHICALLY ? k_RHYTHM_LEVEL_DISPLAY_ONLY : k_RHYTHM_LEVEL_ADDED)));
                set_all_default_beam_numbers(r_ob, new_ll, false);
                set_beam_number_for_level(new_ll, curr_num_beams);
                changed = true;
                
                if (recursively_refine_added_levels)
                    refine_beams_for_level_once(r_ob, new_ll, for_sublllls_use_max_beam_number_if_under_beam, strictly_forbid_noninternal_rests, 
                                                only_additional_refining, max_number_of_beams_for_refined_lllls, recursively_refine_added_levels);
            }
            start_beam_elem = NULL;
        }
        
        box_elem = next_box_elem;
    }
    if (start_beam_elem){
        t_chord *ch1 = get_level_start_chord(box, true);
        t_chord *ch2 = get_level_end_chord(box, true);
        if (start_beam_elem == box->l_head && ch1 != ch2) {
            if (!only_additional_refining){
                // there's already a list with (...)
                changed = 0;
                if (curr_num_beams > box_num_beams) {    // need more beams than the ones it has
                    changed = 1;
                    set_beam_number_for_level(box, curr_num_beams);
                } else {
                    changed = (!box->l_thing.w_obj || ((t_rhythm_level_properties *) box->l_thing.w_obj)->beam_number != 0);
                    set_beam_number_for_level(box, 0); //was: curr_num_beams);
                }
            }
        } else if (start_beam_elem && start_beam_elem != box->l_tail){
            t_llllelem *end_beam_elem = box->l_tail;
            t_llll *new_ll = llll_wrap_element_range(start_beam_elem, end_beam_elem);
            set_level_type_flag_for_level(new_ll, (box_prop->level_type & k_RHYTHM_LEVEL_IGNORE || box_prop->level_type & k_RHYTHM_LEVEL_KEEP ? k_RHYTHM_LEVEL_IGNORE : 0) +
                                          (box_prop->level_type & k_RHYTHM_LEVEL_KEEP ? k_RHYTHM_LEVEL_ORIGINAL :
                                           (r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_REFINE_ONLY_GRAPHICALLY ? k_RHYTHM_LEVEL_DISPLAY_ONLY : k_RHYTHM_LEVEL_ADDED)));
            set_all_default_beam_numbers(r_ob, new_ll, false);
            set_beam_number_for_level(new_ll, curr_num_beams);
            changed = true;

            if (recursively_refine_added_levels)
                refine_beams_for_level_once(r_ob, new_ll, for_sublllls_use_max_beam_number_if_under_beam, strictly_forbid_noninternal_rests, 
                                            only_additional_refining, max_number_of_beams_for_refined_lllls, recursively_refine_added_levels);
        }
    }

    
    #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf2 = NULL;
        llll_to_text_buf(box, &buf2, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
        bach_freeptr(buf2);
    #endif    
    
    return changed;
}


char are_all_notes_in_chord_selected(t_notation_obj *r_ob, t_chord *ch)
{
    t_note *note;
    
    if (notation_item_is_selected(r_ob, (t_notation_item *)ch))
        return true;
    
    if (!ch || !ch->firstnote)
        return false;
    
    for (note = ch->firstnote; note; note = note->next)
        if (!notation_item_is_selected(r_ob, (t_notation_item *)note))
            return false;
    
    return true;
}

char are_all_chords_in_measure_selected(t_notation_obj *r_ob, t_measure *meas)
{
    t_chord *chord;
    
    if (notation_item_is_selected(r_ob, (t_notation_item *)meas))
        return true;
        
    if (!meas || !meas->firstchord)
        return false;
    
    for (chord = meas->firstchord; chord; chord = chord->next)
        if (!notation_item_is_selected(r_ob, (t_notation_item *)chord))
            return false;
    
    return true;
}

char* try_try_try(t_hatom *h){
    if (hatom_gettype(h) == H_OBJ) {
        char *out = (char *)bach_newptr(5 * sizeof(char));
        out[0] = 0;
        t_llllelem *elem = (t_llllelem *)hatom_getobj(h);
        snprintf_zero(out, 5, "%d", hatom_gettype(&elem->l_hatom));
        return out;
    }
    return NULL;
}


long get_rat_gcd_up_to_tuplet_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_rational *gcd = (t_rational *) ((void **)data)[1];
    
    if (hatom_gettype(a) == H_OBJ) {
        t_rational this_dur = rat_abs(((t_chord *)hatom_getobj(a))->r_sym_duration);
//        t_rational this_dur = get_all_tied_chord_sequence_abs_r_duration((t_chord *)hatom_getobj(a), true);
        if (rat_rat_div(this_dur, *gcd).r_den != 1)
            *gcd = rat_gcd(*gcd, this_dur);
    } else if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *ll = hatom_getllll(a);
        if (ll && is_level_grace(ll))
            return 1;
        else if (ll && is_level_tuplet(ll)) {
            t_rational this_dur = get_level_rduration(r_ob, ll, false, true, true, false);
            if (rat_rat_div(this_dur, *gcd).r_den != 1)
                *gcd = rat_gcd(*gcd, this_dur);
            return 1;    // don't enter
        }
    }
    return 0;
}

/*
void correct_tuplets_units_and_multiplier_for_level(t_notation_obj *r_ob, t_llll *box) {
    t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
    t_rational tuplet_unit = prop->tupletinfo.tuplet_unit;
    t_rational min_unit = tuplet_unit;
    t_llllelem *elem;
    void *data[2]; 
    data[0] = r_ob;
    data[1] = &min_unit;
    
    // Correcting unit with respect to the gcd of the inner units
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL){
            t_llll *subll = hatom_getllll(&elem->l_hatom);
            if (subll && !is_level_grace(subll) && !is_level_tuplet(subll))
                llll_funall(subll, get_rat_gcd_up_to_tuplet_fn, data, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
        }
    }
    if (rat_rat_cmp(min_unit, tuplet_unit) < 0){
        t_rational rapp = rat_rat_div(tuplet_unit, min_unit);
        if (rapp.r_den == 1 && rapp.r_num > 1){
            prop->tupletinfo.tuplet_multiplier = rat_long_prod(prop->tupletinfo.tuplet_multiplier, rapp.r_num);
            prop->tupletinfo.tuplet_graphical_unit = rat_long_div(prop->tupletinfo.tuplet_graphical_unit, rapp.r_num);
            prop->tupletinfo.tuplet_unit = rat_long_div(prop->tupletinfo.tuplet_unit, rapp.r_num);
        }
    }
} */

void correct_tuplets_units_and_multiplier_for_level(t_notation_obj *r_ob, t_measure *measure, t_llll *box, char just_take_sublllls_as_their_full_duration) {
    t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
    t_rational tuplet_unit = prop->tupletinfo.tuplet_unit;
    t_rational min_unit = prop->tupletinfo.is_tuplet_completed ? prop->tupletinfo.tuplet_sym_duration : prop->tupletinfo.tuplet_unit;
    t_llllelem *elem;
    void *data[2]; 
    data[0] = r_ob;
    data[1] = &min_unit;
            
    // Correcting unit with respect to the gcd of the inner units
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL){
            t_llll *subll = hatom_getllll(&elem->l_hatom);
            if (subll && !is_level_grace(subll)) {
                if (just_take_sublllls_as_their_full_duration) {
                    // we consider the llll as its full duration, and that's the end of it.
                    // this is something we want to do usually when we call this function right away while detecting tuplets:
                    // we just care about the current rhythmic level, and consider the inner ones as their sum.
                    min_unit = rat_gcd(min_unit, get_level_rduration(r_ob, subll, true, true, true, false));
                } else {
                    // we go further, and have a look to what's inside the llll.
                    // this is something we want to do usually when we correct the tuplets w.r. to inner levels which might have
                    // been created by beamings, but which might not necessarily be tuplet levels 
                    if (is_level_tuplet(subll)) {
                        min_unit = rat_gcd(min_unit, ((t_rhythm_level_properties *)subll->l_thing.w_obj)->tupletinfo.tuplet_sym_duration);
                    } else
                        llll_funall(subll, get_rat_gcd_up_to_tuplet_fn, data, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
                }
            }
        } else if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
            t_rational this_duration = rat_abs(((t_chord *)hatom_getobj(&elem->l_hatom))->r_sym_duration);
//             t_rational this_duration = get_all_tied_chord_sequence_abs_r_duration((t_chord *)hatom_getobj(&elem->l_hatom), true);
             min_unit = rat_gcd(min_unit, this_duration);
        }
    }
    
    if (rat_rat_cmp(min_unit, tuplet_unit) != 0){
        t_rational rapp = rat_rat_div(tuplet_unit, min_unit);
        
        t_rational old_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
        
        prop->tupletinfo.tuplet_multiplier = rat_rat_prod(prop->tupletinfo.tuplet_multiplier, rapp);
        prop->tupletinfo.tuplet_local_unit = rat_rat_div(prop->tupletinfo.tuplet_local_unit, rapp);
        fill_tupletinfo_fields(r_ob, &prop->tupletinfo, prop->tupletinfo.tuplet_local_unit, prop->tupletinfo.tuplet_pregressed_ratio, prop->tupletinfo.tuplet_sym_duration);
        t_rational overall_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
        t_rational multiplier = rat_rat_div(overall_ratio, old_ratio);
        llll_funall(box, multiply_tuplet_overall_ratio_for_level_chords_fn, &multiplier, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
        llll_funall(box, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
        
        if (r_ob->allow_beaming) {
            llll_funall(box, reset_beam_number_for_level_fn, NULL, 1, one_but_last_level(box), FUNALL_SKIP_ATOMS);
            assign_default_beam_numbers_and_refine_beams(r_ob, measure, box, false, true);
            llll_funall(box, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
        }
        
//        flatten_singleton_levels(r_ob, measure, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET);  // CAN't BE HERE: we might delete the list we're funalling :-))
        
        // TO DO: RATIOS MIGHT HAVE CHANGED, AND THUS PREGRESSED RATIO OF INNER TUPLETS MIGHT NOW BE WRONG!!!
    }
    
}


long regroup_tuplets_into_larger_multipliers_for_level_fn(void *data, t_hatom *a, const t_llll *address) {
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *measure = (t_measure *) ((void **)data)[1];

    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *buf = NULL;
            llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
            bach_freeptr(buf);
        #endif
            
        if (!is_level_locked(measure, box)) {
            t_llllelem *boxelem = box->l_head;
            t_llll *subbox;
            t_llllelem *firstpivotelem = NULL;
            t_llllelem *lastpivotelem = NULL;
            t_rational pregressed_ratio = long2rat(1), tuplet_local_unit = long2rat(0), tuplet_sym_duration = long2rat(0);
            long num_beams = 0;
            
            while (boxelem) {
                char break_existing_sequence = false;
                t_llllelem *nextel = boxelem->l_next;
                
                if (node_is_good_for_processing_tuplets(r_ob, boxelem, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_KEEP | k_RHYTHM_LEVEL_ORIGINAL, false)) {
                    subbox = hatom_getllll(&boxelem->l_hatom);
                    t_tupletinfo *info = &((t_rhythm_level_properties *)subbox->l_thing.w_obj)->tupletinfo;
                    
                    if (!firstpivotelem) {
                        firstpivotelem = lastpivotelem = subbox->l_owner;
                        pregressed_ratio = info->tuplet_pregressed_ratio;
                        tuplet_local_unit = info->tuplet_local_unit;
                        tuplet_sym_duration = info->tuplet_sym_duration;
                        num_beams = ((t_rhythm_level_properties *)subbox->l_thing.w_obj)->beam_number;
                    } else if (rat_rat_cmp(info->tuplet_pregressed_ratio, pregressed_ratio) == 0 && 
                               rat_rat_cmp(info->tuplet_local_unit, tuplet_local_unit) == 0){
                        lastpivotelem = subbox->l_owner;
                        tuplet_sym_duration = rat_rat_sum(tuplet_sym_duration, info->tuplet_sym_duration);
                        if (((t_rhythm_level_properties *)subbox->l_thing.w_obj)->beam_number < num_beams) 
                            num_beams = ((t_rhythm_level_properties *)subbox->l_thing.w_obj)->beam_number;
                    } else {
                        break_existing_sequence = true;
                    }
                } else {
                    break_existing_sequence = true;
                }

                if (!nextel)
                    break_existing_sequence = true;
                    
                if (break_existing_sequence && firstpivotelem) {
                    if (firstpivotelem != lastpivotelem){
                        // modifying structure
                        t_llll *newlevel = llll_wrap_element_range(firstpivotelem, lastpivotelem);
                        set_level_type_flag_for_level(newlevel, k_RHYTHM_LEVEL_ADDED + k_RHYTHM_LEVEL_TUPLET + k_RHYTHM_LEVEL_FORCE_TUPLET);
                        ((t_rhythm_level_properties *)newlevel->l_thing.w_obj)->is_tuplet = true;
                        fill_tupletinfo_fields(r_ob, &((t_rhythm_level_properties *)newlevel->l_thing.w_obj)->tupletinfo, tuplet_local_unit, pregressed_ratio, tuplet_sym_duration);
//                        ((t_rhythm_level_properties *)newlevel->l_thing.w_obj)->beam_number = num_beams;
//                        ((t_rhythm_level_properties *)newlevel->l_thing.w_obj)->max_beam_number = num_beams;
//                        ((t_rhythm_level_properties *)newlevel->l_thing.w_obj)->max_beam_number_if_under_beam = num_beams;
                        if (r_ob->allow_beaming) 
                            set_all_default_beam_numbers(r_ob, newlevel, false);

                        t_llllelem *temp = firstpivotelem;
                        while (temp){
                            t_llllelem *nextel = temp->l_next;
                            t_llll *temp_llll = hatom_getllll(&temp->l_hatom);
                            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)temp_llll->l_thing.w_obj;
                            prop->level_type &= ~k_RHYTHM_LEVEL_TUPLET;
                            prop->is_tuplet = false;
                            fill_tupletinfo_fields(r_ob, &prop->tupletinfo, long2rat(1), long2rat(1), long2rat(1));
                            
                            if (prop->beam_number == 0 || num_beams == prop->beam_number)
                                llll_splatter(temp, LLLL_FREETHING_MEM);
                            
                            if (temp == lastpivotelem)
                                break;
                            temp = nextel;
                        }
                        
                        if (r_ob->allow_beaming) {
                            refine_beams_for_level_once(r_ob, newlevel, false, false, true, 0, false);
                            re_check_beams_for_lower_levels(r_ob, measure, newlevel);
                        }
                    }
                    firstpivotelem = lastpivotelem = NULL;
                }
                    
                boxelem = nextel;
            }
        }
    }
    return 0;
}

char node_is_good_for_processing_tuplets(t_notation_obj *r_ob, t_llllelem *boxelem, long no_good_level_types, char orig_and_keep_together_is_good){
    t_llll *subbox; 
    t_rhythm_level_properties *prop;

    if (hatom_gettype(&boxelem->l_hatom) != H_LLLL)
        return 0;
    
    if (!(subbox = hatom_getllll(&boxelem->l_hatom)) || !subbox->l_thing.w_obj)
        return 0;

    prop = (t_rhythm_level_properties *)subbox->l_thing.w_obj;
    
    if (!is_level_tuplet(subbox))
        return 0;

    if (orig_and_keep_together_is_good && prop->level_type & k_RHYTHM_LEVEL_ORIGINAL && prop->level_type & (k_RHYTHM_LEVEL_KEEP | k_RHYTHM_LEVEL_IGNORE))
        return 1;
    
    if (no_good_level_types & prop->level_type)
        return 0;
        
    if (r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED)
        return 0;

    return 1;
}


// when a rational has negative both the num and den, it means that it'll be tied to the next duration (it's a dirty hack)
void gather_rests_and_all_tied_chords_in_hacked_rdurs_llll(t_llll *llll){
    t_llllelem *tempel = llll->l_head;
    while (tempel && tempel->l_next){
        if (is_hatom_number(&tempel->l_hatom) && is_hatom_number(&tempel->l_next->l_hatom)) {
            if (tempel->l_hatom.h_w.w_rat.r_den < 0 && tempel->l_next->l_hatom.h_w.w_rat.r_den * tempel->l_next->l_hatom.h_w.w_rat.r_den > 0) {
                char next_hacked = tempel->l_next->l_hatom.h_w.w_rat.r_den < 0;
                hatom_setrational(&tempel->l_hatom, rat_rat_sum(hatom_getrational(&tempel->l_hatom), hatom_getrational(&tempel->l_next->l_hatom)));
                if (next_hacked) {
                    tempel->l_hatom.h_w.w_rat.r_den *= -1;
                    tempel->l_hatom.h_w.w_rat.r_num *= -1;
                }
                llll_destroyelem(tempel->l_next);
            } else if (tempel->l_hatom.h_w.w_rat.r_num < 0 && tempel->l_next->l_hatom.h_w.w_rat.r_num < 0 && tempel->l_next->l_hatom.h_w.w_rat.r_den > 0){
                hatom_setrational(&tempel->l_hatom, rat_rat_sum(hatom_getrational(&tempel->l_hatom), hatom_getrational(&tempel->l_next->l_hatom)));
                llll_destroyelem(tempel->l_next);
            } else
                tempel = tempel->l_next;
        } else
            tempel = tempel->l_next;
    }
}


void cpost_llll_rt(t_llll *ll, const char *pre)
{
#ifdef BACH_RHYTHMIC_TREE_DEBUG
    char *buf = NULL;
    llll_to_text_buf(ll, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1); //buf+150
    cpost("%s: %s", pre, buf);
    bach_freeptr(buf);
#endif
}

void cpost_llllelem_rt(t_llllelem *llel, const char *pre)
{
#ifdef BACH_RHYTHMIC_TREE_DEBUG
    char *buf = NULL;
    if (hatom_gettype(&llel->l_hatom) == H_LLLL) {
        llll_to_text_buf(hatom_getllll(&llel->l_hatom), &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1); //buf+150
        cpost("%s (llll): %s", pre, buf);
    } else {
        t_llll *ll = llll_get();
        llll_appendhatom_clone(ll, &llel->l_hatom);
        llll_to_text_buf(ll, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1); //buf+150
        cpost("%s (single elem): %s", pre, buf);
        llll_free(ll);
    }
    bach_freeptr(buf);
#endif
}


long simplify_tuplets_for_level_fn(void *data, t_hatom *a, const t_llll *address) {
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *measure = (t_measure *) ((void **)data)[1];
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);

        cpost_llll_rt(box, "Testing box");
        
        if (!is_level_locked(measure, box)) {
            t_llll *rdurs = rhythmic_tree_to_duration_tree(r_ob, box, true, true); // hack ties!
            
            t_llllelem *boxelem = box->l_head;
            t_llllelem *durselem = rdurs->l_head;
            t_llll *subbox;
            
            while (boxelem && durselem) {
//                char break_existing_sequence = false;
                t_llllelem *nextel = boxelem->l_next;
                t_llllelem *nextdursel = durselem->l_next;
                
/*                cpost_llllelem_rt(boxelem, "Boxelem");
                cpost_llllelem_rt(durselem, "Durselem");

                cpost_llllelem_rt(boxelem->l_prev, "Boxelemprev");
                cpost_llllelem_rt(durselem->l_prev, "Durselemprev");
*/
                if (hatom_gettype(&boxelem->l_hatom) == H_LLLL && (subbox = hatom_getllll(&boxelem->l_hatom)) &&
                    is_level_tuplet(subbox) && node_is_good_for_processing_tuplets(r_ob, boxelem, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_ORIGINAL, true)){
                    t_tupletinfo *info = &((t_rhythm_level_properties *)subbox->l_thing.w_obj)->tupletinfo;
                    t_rational tuplet_local_unit = info->tuplet_local_unit;
                    t_rational pregressed_ratio = info->tuplet_pregressed_ratio;
                    t_rational sym_duration = info->tuplet_sym_duration;
                    t_chord *startch, *endch;
                    
                    // we perform the algorithm twice; the first one with only_accept_tuplets_inside_wrapped_level = false, 
                    // the second one with only_accept_tuplets_inside_wrapped_level = true (only if no solution was found in the previous case)
                    long i;
                    for (i = 1; i <= 2; i++) {
                        char only_accept_tuplets_inside_wrapped_level = (i == 1 ? false : true);
                        
                        long num_beams = ((t_rhythm_level_properties *)subbox->l_thing.w_obj)->beam_number;
                        t_llllelem *leftstart = boxelem, *rightend = boxelem;
                        t_llllelem *leftstartdur = durselem, *rightenddur = durselem;
                        
                        while (rightend && rightend->l_next && (node_is_good_for_processing_tuplets(r_ob, rightend, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_ORIGINAL, true) || hatom_gettype(&rightend->l_hatom) == H_OBJ) &&
                               (endch = get_leaf_end_chord(rightend, false)) && chord_is_all_tied_to(r_ob, endch, true, NULL) &&
                               (!only_accept_tuplets_inside_wrapped_level || (node_is_good_for_processing_tuplets(r_ob, rightend->l_next, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_ORIGINAL, true)))){
                            rightend = rightend->l_next;
                            rightenddur = rightenddur->l_next;
                            if ((hatom_gettype(&rightend->l_hatom) == H_LLLL) && ((t_rhythm_level_properties *)hatom_getllll(&rightend->l_hatom)->l_thing.w_obj)->beam_number < num_beams)
                                num_beams = ((t_rhythm_level_properties *)hatom_getllll(&rightend->l_hatom)->l_thing.w_obj)->beam_number;
                        }
                        while (leftstart && leftstart->l_prev && (node_is_good_for_processing_tuplets(r_ob, leftstart, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_ORIGINAL, true) || hatom_gettype(&leftstart->l_hatom) == H_OBJ) &&
                               (startch = get_leaf_start_chord(leftstart, false)) && chord_is_all_tied_from(startch, true) &&
                               (!only_accept_tuplets_inside_wrapped_level || (node_is_good_for_processing_tuplets(r_ob, leftstart->l_prev, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_ORIGINAL, true)))){
                            leftstart = leftstart->l_prev;
                            leftstartdur = leftstartdur->l_prev;
                            if ((hatom_gettype(&leftstart->l_hatom) == H_LLLL) && ((t_rhythm_level_properties *)hatom_getllll(&leftstart->l_hatom)->l_thing.w_obj)->beam_number < num_beams)
                                num_beams = ((t_rhythm_level_properties *)hatom_getllll(&leftstart->l_hatom)->l_thing.w_obj)->beam_number;
                        }
                        
/*                        cpost_llllelem_rt(leftstart, "Leftstart");
                        cpost_llllelem_rt(rightend, "Rightend");

                        cpost_llllelem_rt(leftstartdur, "Leftstartdur");
                        cpost_llllelem_rt(rightenddur, "Rightenddur");
*/
                        if (rightend && leftstart && rightenddur && leftstartdur && rightend != leftstart){
                            t_llll *temp = llll_wrap_element_range(leftstartdur, rightenddur);
                            t_llll *wrapped = llll_clone_extended(temp, WHITENULL_llll, 0, clone_rhythm_level_properties_fn); 
                            // we test the new tuplet

                            if (temp->l_owner)
                                llll_splatter(temp->l_owner, LLLL_FREETHING_MEM);
                            
                            llll_flat(wrapped, 0, 1, 0, LLLL_FREETHING_MEM); // FLAT UNTIL TUPLET???

                            cpost_llll_rt(wrapped, "Testing simplified solution");
                            
                            gather_rests_and_all_tied_chords_in_hacked_rdurs_llll(wrapped);
                            
                            t_rational gcd = llll_gcd_of_rat_llll_until_tuplet(r_ob, wrapped); // llll_gcd_on_first_level_in_rdurations_rhythmic_tree(wrapped);
                            t_rational ratio = rat_rat_div(gcd, info->tuplet_unit);
                            
                            t_rational tot_sym_dur = get_level_rduration(r_ob, wrapped, false, true, true, true);
                            t_rational sym_ratio = rat_rat_div(tot_sym_dur, sym_duration);
                            
                            t_tupletinfo try_info;
                            fill_tupletinfo_fields(r_ob, &try_info, rat_long_prod(tuplet_local_unit, ratio.r_num), pregressed_ratio, tot_sym_dur);
                            
                            if (gcd.r_num > 0 && ratio.r_den == 1 && ratio.r_num > 1 && sym_ratio.r_den == 1 && sym_ratio.r_num > 1 && try_info.is_tuplet_completed){
                                // ok, we can gather
                                nextel = rightend->l_next;
                                nextdursel = rightenddur->l_next;
                                
                                t_rational new_tuplet_local_unit = rat_long_prod(tuplet_local_unit, ratio.r_num);
                                t_llll *newlevel = llll_wrap_element_range(leftstart, rightend);
                                
                                set_level_type_flag_for_level(newlevel, k_RHYTHM_LEVEL_ADDED + k_RHYTHM_LEVEL_TUPLET);
                                t_rhythm_level_properties *newprop = (t_rhythm_level_properties *)newlevel->l_thing.w_obj;
                                newprop->is_tuplet = true;

                                fill_tupletinfo_fields(r_ob, &newprop->tupletinfo, new_tuplet_local_unit, pregressed_ratio, tot_sym_dur);
                                newprop->beam_number = num_beams;
                                newprop->max_beam_number = num_beams;
                                newprop->max_beam_number_if_under_beam = num_beams;

                                char changed = false;
                                
                                t_llllelem *temp = leftstart;
                                while (temp){
                                    t_llllelem *tempnextel = temp->l_next;
                                    char must_break = false;
                                    
                                    if (temp == rightend)
                                        must_break = true;
                                        
                                    if (hatom_gettype(&temp->l_hatom) == H_LLLL) {
                                        t_llll *temp_llll = hatom_getllll(&temp->l_hatom);
                                        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)temp_llll->l_thing.w_obj;
                                        prop->level_type &= ~k_RHYTHM_LEVEL_TUPLET;
                                        prop->is_tuplet = false;
                                        fill_tupletinfo_fields(r_ob, &prop->tupletinfo, long2rat(1), long2rat(1), long2rat(1));
                                        
                                        //                                    if (prop->beam_number == 0 || num_beams == prop->beam_number)
                                        llll_splatter(temp, LLLL_FREETHING_MEM);
                                    }
                                    
                                    if (must_break)
                                        break;
                                    
                                    temp = tempnextel;
                                }
                                
                                merge_rests_and_alltied_chords_one_step(r_ob, measure, &changed, newlevel, NULL, k_MERGE_WHEN_DRAWABLE);
                                get_rhythm_drawable_one_step(r_ob, newlevel, false);
                                
                                verbose_post_rhythmic_tree(r_ob, measure, gensym("step4f"), 2);
                                
                                t_rational overall_ratio = rat_rat_prod(newprop->tupletinfo.tuplet_local_ratio, newprop->tupletinfo.tuplet_pregressed_ratio);
                                llll_funall(newlevel, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, 0);
                                
                                // we have to check again ALL internal levels for tuplets
                                char changed2 = false;
                                
                                merge_rests_and_alltied_chords_one_step(r_ob, measure, &changed2, newlevel, NULL, k_MERGE_WHEN_DRAWABLE);
                                
                                llll_funall(measure->rhythmic_tree, get_rhythm_drawable_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                                
                                void *datanew[4];
                                char only_correct_existing_inner_tuplets = false;
                                char take_rhythmic_tree_levels_for_granted = true;
                                datanew[0] = r_ob;
                                datanew[1] = measure;
                                datanew[2] = &only_correct_existing_inner_tuplets;
                                datanew[3] = &take_rhythmic_tree_levels_for_granted;
                                
                                llll_funall(newlevel, find_tuplets_for_level_fn, datanew, 1, -1, FUNALL_SKIP_ATOMS);
                                llll_funall(newlevel, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                                
                                if (r_ob->allow_beaming) {
                                    llll_funall(newlevel, reset_beam_number_for_level_fn, NULL, 1, one_but_last_level(newlevel), FUNALL_SKIP_ATOMS);
                                    assign_default_beam_numbers_and_refine_beams(r_ob, measure, newlevel, false, true);
                                    llll_funall(newlevel, find_tuplets_for_level_fn, datanew, 1, -1, FUNALL_SKIP_ATOMS);
                                    
                                    // something might have changed in the inner tuplets, that's why we need to compute the chord figures
                                    llll_funall(newlevel, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                                    
                                    // ...then reset beamings (I repeat: something might have changed in the tuplet structure, thus all figures might have changed)
                                    llll_funall(newlevel, reset_beam_number_for_level_fn, NULL, 1, one_but_last_level(newlevel), FUNALL_SKIP_ATOMS);

                                    // ...and reassign them
                                    assign_default_beam_numbers_and_refine_beams(r_ob, measure, newlevel, false, true);
                                }
                                
                                correct_tuplets_units_and_multiplier_for_level(r_ob, measure, newlevel, false);
                                
//                                flatten_singleton_levels(r_ob, measure, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET); // CAN't BE HERE: we might delete the list we're funalling :-))

                                llll_free_freethings(wrapped, LLLL_FREETHING_MEM);
                                
                                // box has changed, then rdurs must also change
                                llll_free_freethings(rdurs, LLLL_FREETHING_MEM);
                                rdurs = rhythmic_tree_to_duration_tree(r_ob, box, true, true); // hack ties!
                                t_llllelem *tmpboxel, *tmpdursel;
                                for (tmpboxel = box->l_head, tmpdursel = rdurs->l_head; tmpboxel && tmpdursel; tmpboxel = tmpboxel->l_next, tmpdursel = tmpdursel->l_next)
                                    if (tmpboxel == nextel)
                                        nextdursel = tmpdursel;
                                break;
                            } else 
                                llll_free_freethings(wrapped, LLLL_FREETHING_MEM);
                        }
                    }
                    
                }
                
                cpost_llll_rt(box, "New box");
                
                boxelem = nextel;
                durselem = nextdursel;
            }
                
            llll_free_freethings(rdurs, LLLL_FREETHING_MEM);
                
        }
    }
    return 0;
}


void correct_tuplets(t_notation_obj *r_ob, t_measure *measure, char beaming_calculation_flags)
{
    void *data[4];
    t_llll *scanned = llll_scan(measure->rhythmic_tree, true);
    t_llllelem *scannedelem;
    char flag = true;
    char bcf = beaming_calculation_flags;

    llll_flatten(scanned, 1, 0);

    data[0] = r_ob;
    data[1] = measure;
    data[2] = &flag;
    data[3] = &bcf;
    
    #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf = NULL;
        llll_to_text_buf(measure->rhythmic_tree, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
        bach_freeptr(buf);
    #endif
    
    // 1. Correcting unit with respect to the gcd of the inner units – e.g. {tu:1/12}(1/12 (1/24 1/24) 1/12) ---> {tu:1/24}(1/12 (1/24 1/24) 1/12) 
    for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
        if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
            t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *this_llll = hatom_getllll(&elem->l_hatom);
                if (this_llll->l_thing.w_obj && ((t_rhythm_level_properties *)this_llll->l_thing.w_obj)->is_tuplet)
                    correct_tuplets_units_and_multiplier_for_level(r_ob, measure, this_llll, false);
            }
        }
    }
    llll_free(scanned);
    
    #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf2 = NULL;
        llll_to_text_buf(measure->rhythmic_tree, &buf2, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
        bach_freeptr(buf2);
    #endif
    
    // finally: whole list
    if (measure->rhythmic_tree->l_thing.w_obj && ((t_rhythm_level_properties *)measure->rhythmic_tree->l_thing.w_obj)->is_tuplet)
        correct_tuplets_units_and_multiplier_for_level(r_ob, measure, measure->rhythmic_tree, false);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4d"), 2);

    // 2. Trying to joining tuplets in larger multipliers, if we can – e.g. ((1/24 1/24 1/24) (1/24 1/24 1/24)) ---> (1/24 1/24 1/24 1/24 1/24 1/24) 
    if (r_ob->try_to_join_tuplets && !(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS))
        llll_funall(measure->rhythmic_tree, regroup_tuplets_into_larger_multipliers_for_level_fn, data, 1, two_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4e"), 2);

    // 3. Gathering tuplets – e.g. (1/6 1/12 t) (1/12 1/6) ---> (1/6 1/6 1/6) 
    if (r_ob->try_to_make_tuplets_simple && !beaming_calculation_flags)
        llll_funall(measure->rhythmic_tree, simplify_tuplets_for_level_fn, data, 1, two_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4g"), 2);
}


void set_all_default_beam_numbers(t_notation_obj *r_ob, t_llll *level, char only_if_undefined){

    if (!only_if_undefined || !level->l_thing.w_obj || ((t_rhythm_level_properties *)level->l_thing.w_obj)->beam_number < 0) {
        long beam_num = get_default_beam_number_for_level(r_ob, level, false, true);
        set_beam_number_for_level(level, beam_num);
    }
    
    if (!only_if_undefined || !level->l_thing.w_obj || ((t_rhythm_level_properties *)level->l_thing.w_obj)->max_beam_number < 0){ // beam_number < 0: to be accounted
        long beam_num = get_default_beam_number_for_level(r_ob, level, false, false);
        set_max_beam_number_for_level(level, beam_num);
    }
    if (!only_if_undefined || !level->l_thing.w_obj || ((t_rhythm_level_properties *)level->l_thing.w_obj)->max_beam_number_if_under_beam < 0) {
        long max_beam_number_if_under_beam = get_default_beam_number_for_level(r_ob, level, true, false);
        set_max_beam_number_if_under_beam_for_level(level, max_beam_number_if_under_beam);
    }
}


void assign_default_beam_numbers_and_refine_beams(t_notation_obj *r_ob, t_measure *measure, t_llll *box, char only_assign_default_beams, char only_if_beams_are_not_defined){
    char changed;
    while (1){
        t_llll *scanned = llll_scan(box, true);
        t_llllelem *scannedelem;
        llll_flatten(scanned, 1, 0);
        
        changed = 0;
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *buf = NULL;
            llll_to_text_buf(box, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
            bach_freeptr(buf);
        #endif

        for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
            if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
                t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *this_llll = hatom_getllll(&elem->l_hatom);
                    
                    #ifdef BACH_RHYTHMIC_TREE_DEBUG
                        char *buf = NULL;
                        llll_to_text_buf(this_llll, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
                        bach_freeptr(buf);
                    #endif
                    
                    set_all_default_beam_numbers(r_ob, this_llll, only_if_beams_are_not_defined);
                    
                    if (!only_assign_default_beams)
                        if ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(measure, this_llll)) || 
                            ((t_rhythm_level_properties *) this_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE || 
                            ((t_rhythm_level_properties *) this_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP)
//                            || (((t_rhythm_level_properties *) this_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TS_BOX && !is_level_locked(measure, this_llll)))
                            changed |= refine_beams_for_level_once(r_ob, this_llll, true, false, false, 0, false);
                }
            }
        }
        llll_free(scanned);
        
        // finally: whole list
        set_all_default_beam_numbers(r_ob, box, only_if_beams_are_not_defined);

        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *buf2 = NULL;
            llll_to_text_buf(box, &buf2, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
            bach_freeptr(buf2);
        #endif
        
        if (!only_assign_default_beams)
            if ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(measure, box)) || 
                ((t_rhythm_level_properties *) box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE ||
                ((t_rhythm_level_properties *) box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP)
                // || (((t_rhythm_level_properties *) box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TS_BOX && !is_level_locked(measure, box)))
                changed |= refine_beams_for_level_once(r_ob, box, true, false, false, 0, false);
        
        if (!changed)
            break;
    }
}


t_rhythm_level_properties *build_rhythm_level_properties(){
    t_rhythm_level_properties *prop = (t_rhythm_level_properties *) bach_newptrclear(sizeof(t_rhythm_level_properties));
    prop->is_tuplet = 0;
    prop->is_grace = 0;
    prop->beam_number = -1;
    prop->max_beam_number = -1;
    prop->max_beam_number_if_under_beam = -1;
    prop->direction = 0;
    prop->beam_slope = 0;
    prop->level_type = k_RHYTHM_LEVEL_ORIGINAL;
    return prop;
}



void set_max_beam_number_for_level(t_llll *box, char max_beam_number){
    if (!box->l_thing.w_obj){
        t_rhythm_level_properties *prop = build_rhythm_level_properties();
        prop->max_beam_number = max_beam_number;
        box->l_thing.w_obj = prop;
    } else {
        // already had a l_thing.w_obj information
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
        prop->max_beam_number = max_beam_number;
    }
}

void set_max_beam_number_if_under_beam_for_level(t_llll *box, char max_beam_number_if_under_beam){
    if (!box->l_thing.w_obj){
        t_rhythm_level_properties *prop = build_rhythm_level_properties();
        prop->max_beam_number_if_under_beam = max_beam_number_if_under_beam;
        box->l_thing.w_obj = prop;
    } else {
        // already had a l_thing.w_obj information
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
        prop->max_beam_number_if_under_beam = max_beam_number_if_under_beam;
    }
}




void set_beam_number_for_level(t_llll *box, char beam_number){
    if (!box->l_thing.w_obj){
        t_rhythm_level_properties *prop = build_rhythm_level_properties();
        prop->beam_number = beam_number;
        box->l_thing.w_obj = prop;
    } else {
        // already had a l_thing.w_obj information
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
        prop->beam_number = beam_number;
    }
}

long reset_beam_number_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        set_beam_number_for_level(hatom_getllll(a), -1);
        set_max_beam_number_for_level(hatom_getllll(a), -1);
        set_max_beam_number_if_under_beam_for_level(hatom_getllll(a), -1);
    }
    return 0;
}

long set_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *box = hatom_getllll(a);
        char direction = *((char *)data);
        if (!box->l_thing.w_obj){
            t_rhythm_level_properties *prop = build_rhythm_level_properties();
            prop->direction = direction;
            box->l_thing.w_obj = prop;
        } else {
            // already had a l_thing.w_obj information
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
            prop->direction = direction;
        }
    }
    return 0;
}

void set_direction_for_level(t_llll *box, char direction){
    char this_direction = direction;
    llll_funall(box, set_direction_for_level_fn, &this_direction, 1, -1, FUNALL_SKIP_ATOMS);
}


long set_beam_slope_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *box = hatom_getllll(a);
        double slope = *((double *)data);
        if (!box->l_thing.w_obj){
            t_rhythm_level_properties *prop = build_rhythm_level_properties();
            prop->beam_slope = slope;
            box->l_thing.w_obj = prop;
        } else {
            // already had a l_thing.w_obj information
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
            prop->beam_slope = slope;
        }
    }
    return 0;
}


void set_beam_slope_for_level(t_llll *box, double slope){
    double this_slope = slope;
    llll_funall(box, set_beam_slope_for_level_fn, &this_slope, 1, -1, FUNALL_SKIP_ATOMS);
}


void set_level_type_flag_for_level(t_llll *box, long level_type){
    t_rhythm_level_properties *prop;
    if (!box->l_thing.w_obj){
        prop = build_rhythm_level_properties();
        prop->level_type = level_type;
        box->l_thing.w_obj = prop;
    } else {
        // already had a l_thing.w_obj information
        prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
        prop->level_type = level_type;
    }
    if (prop->level_type & k_RHYTHM_LEVEL_TUPLET || prop->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET)
        prop->is_tuplet = true;
    if (prop->level_type & k_RHYTHM_LEVEL_GRACE)
        prop->is_grace = true;
}

void add_level_type_flag_for_level(t_llll *box, long level_type){
    if (!box->l_thing.w_obj)
        set_level_type_flag_for_level(box, level_type);
    else
        set_level_type_flag_for_level(box, ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type | level_type);
}

void get_rhythm_drawable_one_step(t_notation_obj *r_ob, t_llll *box, char only_compute_chord_figures)
{
    t_rational cursor = long2rat(0); 
    t_rational box_length = get_level_rduration(r_ob, box, false, true, false, false);
    t_llllelem *boxelem;
    
    for (boxelem = box->l_head; boxelem; boxelem = boxelem->l_next) {
        if (hatom_gettype(&boxelem->l_hatom) == H_OBJ) { // it is a chord
            t_chord *this_chord = (t_chord *) hatom_getobj(&boxelem->l_hatom);
            
            if (this_chord->parent && is_measure_single_whole_rest(r_ob, this_chord->parent) && rat_rat_cmp(this_chord->r_sym_duration, rat_opp(box_length)) == 0) {
                if (r_ob->whole_rests_in_empty_measures)
                    this_chord->figure = long2rat(1);
                else
                    this_chord->figure = rat_abs(this_chord->r_sym_duration);
                break; // full measure rest, nothing to do
            }
        
            long rhythm_elem_display_sign;
            t_rational rhythm_elem_display, rhythm_elem_display_abs;    // will be the overall displayed duration. For instance a dotted tuplet quaver will have this as 3/16, and so on.
            t_rational overall_tuplet_ratio = long2rat(1);
            t_llll *innermost_tuplet_level = get_innermost_tuplet_level(box->l_head);
            char is_tuplet = innermost_tuplet_level ? 1 : 0;
            
            if (is_tuplet) { // there's a tuplet for the given chord
                t_tupletinfo *tupletinfo = &((t_rhythm_level_properties *)innermost_tuplet_level->l_thing.w_obj)->tupletinfo;
                rhythm_elem_display = rat_rat_prod(rat_rat_div(this_chord->r_sym_duration, tupletinfo->tuplet_unit), tupletinfo->tuplet_graphical_unit);
                overall_tuplet_ratio = rat_rat_prod(tupletinfo->tuplet_local_ratio, tupletinfo->tuplet_pregressed_ratio);
            } else 
                rhythm_elem_display = this_chord->r_sym_duration;
            rhythm_elem_display_sign = (rhythm_elem_display.r_num > 0 ? 1 : (rhythm_elem_display.r_num == 0 ? 0 : -1));
            rhythm_elem_display_abs = rat_abs(rhythm_elem_display);
            
            
            if (rhythm_elem_display_abs.r_num == 0 || perfect_log2(rhythm_elem_display_abs.r_num) >= 0 || only_compute_chord_figures) { // if the numerator is 0,1,2,4,8...
                // nothing to do
                this_chord->overall_tuplet_ratio = overall_tuplet_ratio;
                compute_chord_figure(r_ob, this_chord, true);
                cursor = rat_rat_sum(cursor, rat_rat_prod(rhythm_elem_display_abs, overall_tuplet_ratio));
            } else {
                t_llllelem *elem;
                t_llll *drawablellll = get_duration_drawable(rhythm_elem_display_abs, cursor, box_length, r_ob->max_dots, 1, is_tuplet);
                llll_flatten(drawablellll, 0, 0);
                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                char *buf = NULL;
                llll_to_text_buf(drawablellll, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
                #endif 
                // We filter the zeros which might have appeared via the recursion of get_duration_drawable (and the negatives, which - in turn - should never appear)
                llll_filter_zeros_and_negatives(drawablellll);
                
                // We try to gather things
                llll_gather_if_drawable(drawablellll, r_ob->max_dots);
                
                // We refill the elements
                if (drawablellll->l_head) {
                    t_chord *lastchord_for_insertion = this_chord;
                    t_llll *chords_to_tie = llll_get();
                    t_rational thisdur = rat_long_prod(hatom_getrational(&drawablellll->l_head->l_hatom), rhythm_elem_display_sign);
                    this_chord->r_sym_duration = rat_rat_prod(thisdur, overall_tuplet_ratio);
                    this_chord->overall_tuplet_ratio = overall_tuplet_ratio;
                    compute_chord_figure(r_ob, this_chord, true);
                    for (elem = drawablellll->l_head->l_next; elem; elem = elem->l_next) {
                        t_chord *new_ch = clone_chord_without_lyrics(r_ob, this_chord, k_CLONE_FOR_SPLIT);
/*                        if (new_ch->firstnote && !new_ch->firstnote->parent) {
                            char foo = 7;
                            foo++;
                        }*/
                        thisdur = rat_long_prod(hatom_getrational(&elem->l_hatom), rhythm_elem_display_sign);
                        new_ch->r_sym_duration = rat_rat_prod(thisdur, overall_tuplet_ratio);
                        new_ch->overall_tuplet_ratio = overall_tuplet_ratio;
                        compute_chord_figure(r_ob, new_ch, true);
                        boxelem = new_ch->rhythmic_tree_elem = llll_insertobj_after(new_ch, boxelem, 0, WHITENULL_llll);
                        chord_insert_in_measure(r_ob, this_chord->parent, new_ch, lastchord_for_insertion, 0);
                        lastchord_for_insertion = new_ch;
                        llll_appendobj(chords_to_tie, new_ch->prev, 0, WHITENULL_llll);
                        
                        if (notation_item_is_selected(r_ob, (t_notation_item *)this_chord))
                            notation_item_add_to_selection(r_ob, (t_notation_item *)new_ch);
                    }
                    for (elem = chords_to_tie->l_head; elem; elem = elem->l_next)
                        tie_chord((t_chord *)hatom_getobj(&elem->l_hatom));
                    llll_free(chords_to_tie);
                }
                
                llll_free(drawablellll);
                cursor = rat_rat_sum(cursor, rat_rat_prod(rhythm_elem_display_abs, overall_tuplet_ratio));
            }
            
        } else if (hatom_gettype(&boxelem->l_hatom) == H_LLLL){
            // update cursor
            t_rational this_level_dur = get_level_rduration(r_ob, hatom_getllll(&boxelem->l_hatom), true, true, true, false);
            cursor = rat_rat_sum(cursor, this_level_dur);
        }
    }
}

long get_rhythm_drawable_for_level_fn(void *data, t_hatom *beam_tree, const t_llll *address){
    if (hatom_gettype(beam_tree) == H_LLLL) {
        t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
        char beaming_calculation_flags = *((char *) ((void **)data)[3]);

        t_llll *box = hatom_getllll(beam_tree);
        
        get_rhythm_drawable_one_step(r_ob, box, (beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS) > 0);
    }
    return 0;
}




t_llll *get_innermost_tuplet_level(t_llllelem *leaf){
    t_llll *temp;
    
    if (!leaf)
        return NULL;
        
    temp = leaf->l_parent;
    while (temp){
        if (is_level_tuplet(temp))
            return temp;
        else if (is_level_grace(temp))
            return NULL;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return NULL;
}

t_llll *get_innermost_tuplet_level_for_chord(t_chord *chord){
    return get_innermost_tuplet_level(chord->rhythmic_tree_elem);
}


t_chord *get_tuplet_start_chord(t_chord *generic_chord_inside_the_tuplet){
    t_llll *level = get_innermost_tuplet_level_for_chord(generic_chord_inside_the_tuplet);
    if (level)
        return get_level_start_chord(level, true);
        
    return NULL;
}

t_chord *get_tuplet_end_chord(t_chord *generic_chord_inside_the_tuplet){
    t_llll *level = get_innermost_tuplet_level_for_chord(generic_chord_inside_the_tuplet);
    if (level)
        return get_level_end_chord(level, true);
        
    return NULL;
}

char is_level_locked(t_measure *measure, t_llll *level){
    char res = (measure->lock_rhythmic_tree && (!level->l_thing.w_obj || 
                            (!(((t_rhythm_level_properties *)level->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE) && 
                             !(((t_rhythm_level_properties *)level->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP))));
    return res;
}

/*
long merge_rests_and_alltied_chords_across_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *box = hatom_getllll(a);
        t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
        t_measure *meas = (t_measure *) ((void **)data)[1];
        
        if (box && box->l_size > 0 && (!is_level_locked(meas, box) && r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED)) {
            if (hatom_gettype(&box->l_tail->l_hatom) == H_OBJ){
                t_chord *last_chord = hatom_getobj(&box->l_tail->l_hatom);
                if (last_chord->next && !is_level_locked(meas, last_chord->next->rhythmic_tree_elem->l_parent)){ 
                    if (last_chord->r_sym_duration.r_num < 0){
                    } 
                }
            }
        }
    
    }
}*/

void transfer_selection_and_cursor(t_notation_obj *r_ob, t_chord *from, t_chord *to){
    if (notation_item_is_selected(r_ob, (t_notation_item *)from) && !notation_item_is_selected(r_ob, (t_notation_item *)to))
        notation_item_add_to_preselection(r_ob, (t_notation_item *)to);
    if (r_ob->notation_cursor.chord == from)
        r_ob->notation_cursor.chord = to;
    move_preselecteditems_to_selection(r_ob, k_SELECTION_MODE_FORCE_SELECT, false, false);
}


char can_merge(t_notation_obj *r_ob, t_rational dur1, t_rational dur2, e_merge_when merge_when)
{
    if (merge_when == k_MERGE_WHEN_ALWAYS)
        return true;
    
    if ((dur1.r_den % dur2.r_den == 0) || (dur2.r_den % dur1.r_den == 0))
        return true;

    return false;
}

void chord_transfer_slots_before_deletion(t_notation_obj *r_ob, t_chord *giver, t_chord *receiver)
{
    t_llll *which_slots = llll_get();
    llll_appendsym(which_slots, _sym_all);
    if (giver->firstnote) {
        t_note *n1, *n2;
        for (n1 = giver->firstnote, n2 = receiver->firstnote; n1 && n2; n1 = n1->next, n2 = n2->next)
            notation_item_copy_slots(r_ob, (t_notation_item *)n1, (t_notation_item *)n2, which_slots, false);
    } else {
        notation_item_copy_slots(r_ob, (t_notation_item *)giver, (t_notation_item *)receiver, which_slots, false);
    }
    llll_free(which_slots);
}


void merge_rests_and_alltied_chords_one_step(t_notation_obj *r_ob, t_measure *meas, char *changed, t_llll *box, t_chord **ref_chord, e_merge_when merge_when)
{
    if (merge_when == k_MERGE_WHEN_NEVER)
        return;
    
    if (box && box->l_size > 0 && !is_level_locked(meas, box) && 
        (r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED || (box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)))) {
        // we initialize the general lllls
        t_llllelem *box_elem = box->l_head;

#ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf = NULL, *buf2 = NULL;
        llll_to_text_buf(box, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL); //buf2 + 90
        llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
#endif

        while (box_elem && box_elem->l_next) { // cycle on the rhythm
            t_llllelem *next_box_elem = box_elem->l_next;
            
            char is_simple_chord = (hatom_gettype(&box_elem->l_hatom) == H_OBJ); // 1 if the element is a simple chord duration and not a branch of durations
            t_chord *this_chord = is_simple_chord ? (t_chord *)hatom_getobj(&box_elem->l_hatom) : NULL;
            t_rational rhythm_elem_rat = is_simple_chord ? this_chord->r_sym_duration : long2rat(0);
            long rhythm_elem_sign = isign(rhythm_elem_rat.r_num);
            
            if (is_simple_chord && rhythm_elem_sign < 0 && box_elem->l_next && hatom_gettype(&box_elem->l_next->l_hatom) == H_OBJ && 
                ((t_chord *)hatom_getobj(&box_elem->l_next->l_hatom))->r_sym_duration.r_num < 0) {

                // Two rests in a row
                if (can_merge(r_ob, rhythm_elem_rat, this_chord->next->r_sym_duration, merge_when) ) {
                    this_chord->next->r_sym_duration = rat_rat_sum(this_chord->next->r_sym_duration, rhythm_elem_rat);
                    transfer_selection_and_cursor(r_ob, this_chord, this_chord->next);
                    chord_transfer_slots_before_deletion(r_ob, this_chord, this_chord->next);
                    if (ref_chord && *ref_chord == this_chord)
                        *ref_chord = this_chord->next;
                    chord_delete_from_measure(r_ob, this_chord, false);
                    
                    *changed = true;
                }
            } else if (is_simple_chord && rhythm_elem_sign > 0 && box_elem->l_next && hatom_gettype(&box_elem->l_next->l_hatom) == H_OBJ &&
                       chord_is_all_tied_to(r_ob, this_chord, 1, this_chord->next)) {
                // An all-tied-chord sequence
                if (can_merge(r_ob, rhythm_elem_rat, this_chord->next->r_sym_duration, merge_when) ) {
                    // We are deleting the LEFT chord because we need to keep the right chord reference "in place" for the next boxelem.
                    // but in doing so we need to be sure we're transferring the slot information
                    this_chord->next->r_sym_duration = rat_rat_sum(this_chord->next->r_sym_duration, rhythm_elem_rat);
                    transfer_selection_and_cursor(r_ob, this_chord, this_chord->next);
                    chord_transfer_slots_before_deletion(r_ob, this_chord, this_chord->next);
                    if (ref_chord && *ref_chord == this_chord)
                        *ref_chord = this_chord->next;
                    chord_delete_from_measure(r_ob, this_chord, false);
 
                    
                    *changed = true;
                }
            }
            box_elem = next_box_elem;
        }
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
        bach_freeptr(buf);
        bach_freeptr(buf2);
        #endif
    } 
}


// (a (b (c d e f)))    ->  <elem> = d    ->   (a (b (c d ))) ((( e f )))
// returns the pointer to the left abyss element, in this example to (a (b (c d )))
t_llllelem *llllelem_create_abyss(t_llllelem *elem, long abyss_base_depth){
    t_llllelem *elem_to_use = elem, *temp;
    t_llll *ll;
    long num_levels_to_add = 0, i;
    
    while (!elem_to_use->l_next && elem_to_use->l_parent->l_owner)
        elem_to_use = elem_to_use->l_parent->l_owner;
    
    if (!elem_to_use->l_parent->l_owner)
        return elem_to_use; // element is at first level, nothing to do
    
    temp = elem_to_use;
    while (temp && temp->l_parent->l_owner) {
        num_levels_to_add++;
        temp = temp->l_parent->l_owner;
    }
    
    // (a (b (c d e f)))  ->  (a (b (c d ) ( e f )))  ->  (a (b (c d )) (( e f)))  ->  (a (b (c d ))) ((( e f )))
    ll = elem_to_use->l_parent;
    for (i = num_levels_to_add; i > 0 + abyss_base_depth; i--){
        // we find the index of the element_to_use
        long idx = 0;
        t_llllelem *tmpelem = elem_to_use;
        while (tmpelem){
            tmpelem = tmpelem->l_prev;
            idx++;
        }
        
        t_llll *right_slice = llll_slice(ll, idx);

        if (right_slice){
            llll_insertllll_after(right_slice, ll->l_owner, 0, WHITENULL_llll);
            if (ll->l_thing.w_obj) {
                right_slice->l_thing.w_obj = build_rhythm_level_properties();
                *((t_rhythm_level_properties *)right_slice->l_thing.w_obj) = *((t_rhythm_level_properties *)ll->l_thing.w_obj);
            }
        }
        
        elem_to_use = ll->l_owner;

        if (!elem_to_use)
            return NULL;
        
        ll = elem_to_use->l_parent;
    }
    return elem_to_use;
}




long merge_rests_and_alltied_chords_for_level_fn(void *data, t_hatom *a, const t_llll *address)
{
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *box = hatom_getllll(a);
        t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
        t_measure *meas = (t_measure *) ((void **)data)[1];
        char *changed = (char *) ((void **)data)[2];

        merge_rests_and_alltied_chords_one_step(r_ob, meas, changed, box, NULL, k_MERGE_WHEN_DRAWABLE);
    }
    return 0;
}


long stop_to_splitting_elem_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational *curr_dur = (t_rational *) ((void **)data)[0];
    t_rational *dur_to_achieve = (t_rational *) ((void **)data)[1];
    t_llll *box = (t_llll *) ((void **)data)[2];
    t_llllelem **elem = (t_llllelem **) ((void **)data)[3];
    
    if (hatom_gettype(a) == H_OBJ && rat_rat_cmp(*curr_dur, *dur_to_achieve) < 0){
        t_rational this_dur = rat_abs(((t_chord *)hatom_getobj(a))->r_sym_duration);
        t_llllelem *thiselem = llll_nth_one(box, (t_llll *)address);
        *curr_dur = rat_rat_sum(*curr_dur, this_dur);
        *elem = thiselem;
    } else if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)))
        return 1;    // don't enter!    
    
    return 0;
}

long there_is_level_type_inside_llll_fn(void *data, t_hatom *a, const t_llll *address){
    long level_type = *((long *) ((void **)data)[0]);
    char *res = (char *) ((void **)data)[1];
    
    if (*res)
        return 1;
    else if (hatom_gettype(a) == H_LLLL && hatom_getllll(a)->l_thing.w_obj){
        if (((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & level_type) {
            *res = true;
            return 1;
        }
    }
    return 0;
}

char there_is_level_type_inside_llll(t_notation_obj *r_ob, t_llll *ll, long level_type){
    char res = false;
    void *data[2];
    data[0] = &level_type;
    data[1] = &res;
    llll_funall(ll, there_is_level_type_inside_llll_fn, data, 1, -1, FUNALL_SKIP_ATOMS);
    return res;
}


// FROM PROFILING: THIS FUNCTION IS A BOTTLENECK!!!!
char there_is_level_in_llll_range(t_notation_obj *r_ob, t_llll *ll, t_rational start_dur, t_rational end_dur, long level_type, char only_across_range, t_llll *root_durs)
{
    t_llllelem *elem, *durelem;
    t_rational cursor = long2rat(0);
    for (elem = ll->l_head, durelem = root_durs ? root_durs->l_head : NULL; elem; elem = elem->l_next, durelem = durelem ? durelem->l_next : NULL) {
        t_rational this_dur;
        
        if (durelem)
            this_dur = hatom_getrational(&durelem->l_hatom);
        else
            this_dur = (hatom_gettype(&elem->l_hatom) == H_LLLL ? get_level_rduration(r_ob, hatom_getllll(&elem->l_hatom), true, true, false, false) : rat_abs(((t_chord *)hatom_getobj(&elem->l_hatom))->r_sym_duration));
        
        t_rational sum = rat_rat_sum(cursor, this_dur);
        if (rat_rat_cmp(cursor, end_dur) >= 0)
            return 0;
        else if (rat_rat_cmp(sum, start_dur) <= 0)
            cursor = rat_rat_sum(cursor, this_dur);
        else if (hatom_gettype(&elem->l_hatom) == H_LLLL &&  
                    there_is_level_type_inside_llll(r_ob, hatom_getllll(&elem->l_hatom), level_type) &&
                   (!only_across_range || ((rat_rat_cmp(cursor, start_dur) < 0 && rat_rat_cmp(sum, start_dur) > 0) || (rat_rat_cmp(cursor, end_dur) < 0 && rat_rat_cmp(sum, end_dur) > 0))))
            return 1;
        else
            cursor = rat_rat_sum(cursor, this_dur);
    }
    return 0;
}


char has_chord_at_least_one_tie(t_chord *ch){
    t_note *nt = ch->firstnote;
    while (nt) {
        if (nt->tie_to)
            return 1;
        nt = nt->next;
    }
    return 0; 
}


char can_wrap_level_for_ts(t_notation_obj *r_ob, t_measure *measure, t_rational start_wrap_onset, t_rational end_wrap_onset, char only_wrap_ignore_levels){
    // For efficiency reasons we build a durations list
    t_llll *root_durs = llll_get();
    t_llllelem *elem;
    for (elem = measure->rhythmic_tree->l_head; elem; elem = elem->l_next) {
        t_rational this_dur = (hatom_gettype(&elem->l_hatom) == H_LLLL ? get_level_rduration(r_ob, hatom_getllll(&elem->l_hatom), true, true, false, false) : rat_abs(((t_chord *)hatom_getobj(&elem->l_hatom))->r_sym_duration));
        llll_appendrat(root_durs, this_dur);
    }

    // Then we proceed
    char there_is_ignore_level_in_range = there_is_level_in_llll_range(r_ob, measure->rhythmic_tree, start_wrap_onset, end_wrap_onset, k_RHYTHM_LEVEL_IGNORE, false, root_durs)
                                            || (measure->rhythmic_tree->l_thing.w_obj && ((t_rhythm_level_properties *)measure->rhythmic_tree->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE);
    char there_is_forcetuplet_or_keep_level_across_range = there_is_level_in_llll_range(r_ob, measure->rhythmic_tree, start_wrap_onset, end_wrap_onset, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_KEEP, true, root_durs);
    if (only_wrap_ignore_levels)
        return there_is_ignore_level_in_range && !there_is_forcetuplet_or_keep_level_across_range;
    else  {
        char there_is_forcetuplet_or_keep_level_in_range = there_is_level_in_llll_range(r_ob, measure->rhythmic_tree, start_wrap_onset, end_wrap_onset, k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_KEEP, false, root_durs);
        char there_is_tuplet_level_across_range = there_is_level_in_llll_range(r_ob, measure->rhythmic_tree, start_wrap_onset, end_wrap_onset, k_RHYTHM_LEVEL_TUPLET, true, root_durs);
        return (!there_is_forcetuplet_or_keep_level_across_range && (there_is_ignore_level_in_range || (!there_is_forcetuplet_or_keep_level_in_range && !there_is_tuplet_level_across_range)));
    }
}

// if (only_wrap_ignore_levels), it only put a (...) around TS LEVELS if there's an IGNORE level inside it 
void split_first_level_according_to_boxes(t_notation_obj *r_ob, t_measure *measure, t_llll *boxes, char only_wrap_ignore_levels, char cant_split_chords){
    if (!boxes || !boxes->l_head)
        return;
    
    long new_level_type;  
    t_llllelem *elem = measure->rhythmic_tree->l_head;
    t_rational tree_box_cursor = long2rat(0);
    t_llllelem *this_ts_box_elem = boxes->l_head;
    t_rational next_ts_box_cursor = hatom_getrational(&this_ts_box_elem->l_hatom);
    t_llllelem *leftelem = measure->rhythmic_tree->l_head;
    char can_wrap = can_wrap_level_for_ts(r_ob, measure, long2rat(0), next_ts_box_cursor, only_wrap_ignore_levels);
        
    
    llll_check(measure->rhythmic_tree);
    
    if ((measure->rhythmic_tree->l_thing.w_obj && ((t_rhythm_level_properties *)measure->rhythmic_tree->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)) 
        new_level_type = k_RHYTHM_LEVEL_IGNORE + k_RHYTHM_LEVEL_TS_BOX;
    else 
        new_level_type = k_RHYTHM_LEVEL_TS_BOX;
    
    #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf = NULL;
        llll_check(measure->rhythmic_tree);
        llll_to_text_buf(measure->rhythmic_tree, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0); //buf + 50
        bach_freeptr(buf);
    #endif
    
    while (elem){
        char type = hatom_gettype(&elem->l_hatom);
        t_llllelem *nextelem = elem->l_next;
        t_rational this_box_dur;
        
        if (type == H_LLLL) 
            this_box_dur = get_level_rduration(r_ob, hatom_getllll(&elem->l_hatom), true, true, false, false);
        else
            this_box_dur = ((t_chord *)hatom_getobj(&elem->l_hatom))->is_grace_chord ? long2rat(0) : rat_abs(((t_chord *)hatom_getobj(&elem->l_hatom))->r_sym_duration);

        char cmp = rat_rat_cmp(rat_rat_sum(tree_box_cursor, this_box_dur), next_ts_box_cursor);

        if (cmp == 0) {
            t_rational new_next_ts_box_cursor = next_ts_box_cursor;
            
            if (can_wrap) {
                t_llll *newllll = llll_wrap_element_range(leftelem, elem);
                set_level_type_flag_for_level(newllll, new_level_type);
            }

            if (this_ts_box_elem->l_next) {
                new_next_ts_box_cursor = rat_rat_sum(next_ts_box_cursor, hatom_getrational(&this_ts_box_elem->l_next->l_hatom));
                can_wrap = can_wrap_level_for_ts(r_ob, measure, next_ts_box_cursor, new_next_ts_box_cursor, only_wrap_ignore_levels);
            }
            
            this_ts_box_elem = this_ts_box_elem->l_next;
            if (!this_ts_box_elem)
                break;
            
            next_ts_box_cursor = new_next_ts_box_cursor;
            tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
            
            leftelem = nextelem;
        } else if (cmp == -1) {
            tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
        
        } else if (type == H_OBJ) {
            t_chord *thisch = (t_chord *) hatom_getobj(&elem->l_hatom);
            t_rational new_next_ts_box_cursor = this_ts_box_elem->l_next ? rat_rat_sum(next_ts_box_cursor, hatom_getrational(&this_ts_box_elem->l_next->l_hatom)) : next_ts_box_cursor;
            char can_wrap_next = can_wrap_level_for_ts(r_ob, measure, next_ts_box_cursor, new_next_ts_box_cursor, only_wrap_ignore_levels);

            if (thisch->dont_split_for_ts_boxes)
                can_wrap = can_wrap_next = false;
                
            if (cant_split_chords)
                can_wrap = can_wrap_next = false;
                
            if (can_wrap || can_wrap_next) {
                t_rational diff = rat_rat_diff(rat_rat_sum(tree_box_cursor, this_box_dur), next_ts_box_cursor);
                t_chord *new_ch = clone_chord_without_lyrics(r_ob, thisch, k_CLONE_FOR_SPLIT);
                char sign = thisch->r_sym_duration.r_num >= 0 ? 1 : -1;
                t_llll *newllll;
                
                chord_insert_in_measure(r_ob, measure, new_ch, thisch, 0);
                tie_chord(thisch);
                whitenull_tie_from(chord_get_next(new_ch));
                thisch->r_sym_duration = rat_long_prod(rat_rat_diff(rat_abs(thisch->r_sym_duration), diff), sign);
                new_ch->r_sym_duration = rat_long_prod(diff, sign);
                new_ch->rhythmic_tree_elem = llll_insertobj_after(new_ch, elem, 0, WHITENULL_llll);

                if (notation_item_is_selected(r_ob, (t_notation_item *)thisch))
                    notation_item_add_to_selection(r_ob, (t_notation_item *)new_ch);

                if (can_wrap) {
                    newllll = llll_wrap_element_range(leftelem, elem);
                    set_level_type_flag_for_level(newllll, new_level_type);
                }
                
                leftelem = nextelem = new_ch->rhythmic_tree_elem;
                tree_box_cursor = next_ts_box_cursor;
            } else
                tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
            
            can_wrap = can_wrap_next;
            this_ts_box_elem = this_ts_box_elem->l_next;
            if (!this_ts_box_elem)
                break;
            
            next_ts_box_cursor = new_next_ts_box_cursor;

            leftelem = nextelem;
        } else if (type == H_LLLL) {
            t_rational new_next_ts_box_cursor = this_ts_box_elem->l_next ? rat_rat_sum(next_ts_box_cursor, hatom_getrational(&this_ts_box_elem->l_next->l_hatom)) : next_ts_box_cursor;
            char can_wrap_next = can_wrap_level_for_ts(r_ob, measure, next_ts_box_cursor, new_next_ts_box_cursor, only_wrap_ignore_levels);

            if (can_wrap || can_wrap_next) {
                t_llll *this_box_level = hatom_getllll(&elem->l_hatom);
                t_llllelem *splitelem = get_first_non_llll_elem(this_box_level);
                t_rational curr_duration = long2rat(0);
                t_rational duration_to_achieve = rat_rat_diff(next_ts_box_cursor, tree_box_cursor);
                t_llllelem *leftabysselem;
                void *data[4];
                data[0] = &curr_duration;
                data[1] = &duration_to_achieve;
                data[2] = this_box_level;
                data[3] = &splitelem;
                
                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                    char *buf = NULL;
                    llll_to_text_buf(this_box_level, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
                    llll_to_text_buf(measure->rhythmic_tree, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
                    llll_print_named(this_box_level, gensym("funall"), 0, 0, get_strings_for_rhythmic_tree_elements_verbosity0);
                    llll_check(measure->rhythmic_tree);
                    bach_freeptr(buf);
                #endif
                
                llll_funall(this_box_level, stop_to_splitting_elem_fn, data, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
                
                if (!splitelem || hatom_gettype(&splitelem->l_hatom) != H_OBJ){
                    object_warn((t_object *) r_ob, "Warning: weird rhythmic tree");
                    tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
                } else {
                    t_chord *splitchord = (t_chord *) hatom_getobj(&splitelem->l_hatom);
                    char cmp = rat_rat_cmp(curr_duration, duration_to_achieve);
                    
                    if (!splitchord || splitchord->dont_split_for_ts_boxes || (cmp > 0 && cant_split_chords)) {
                        can_wrap = can_wrap_next = false;
                        tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
                    } else {
                        // dividing splitting element
                        if (cmp > 0) {
//                            t_chord *splitchord = (t_chord *) hatom_getobj(&splitelem->l_hatom);
                            char sign = isign(splitchord->r_sym_duration.r_num);
                            t_rational right_dur = rat_long_prod(rat_rat_diff(curr_duration, duration_to_achieve), sign);
                            t_rational left_dur = rat_long_prod(rat_rat_diff(rat_abs(splitchord->r_sym_duration), rat_abs(right_dur)), sign);
                            
                            t_chord *new_ch = clone_chord_without_lyrics(r_ob, splitchord, k_CLONE_FOR_SPLIT);
                            
                            chord_insert_in_measure(r_ob, measure, new_ch, splitchord, 0);
                            tie_chord(splitchord);
                            whitenull_tie_from(chord_get_next(new_ch));
                            new_ch->r_sym_duration = right_dur;
                            splitchord->r_sym_duration = left_dur;
                            new_ch->rhythmic_tree_elem = llll_insertobj_after(new_ch, splitelem, 0, WHITENULL_llll);
                            
                            if (notation_item_is_selected(r_ob, (t_notation_item *)splitchord))
                                notation_item_add_to_selection(r_ob, (t_notation_item *)new_ch);
                        }
                        
                        // creating brackets ..))((..   "abyss"
                        leftabysselem = llllelem_create_abyss(splitelem, 0);
                        nextelem = leftabysselem->l_next;    // gotta do this now, before llll_wrap_element_range, otherwise the ->l_next will be NULL
                        
                        if (nextelem && hatom_gettype(&nextelem->l_hatom) == H_LLLL){
                            t_llll *nextll = hatom_getllll(&nextelem->l_hatom);
                            long type = 0;
                            
                            if (hatom_gettype(&leftabysselem->l_hatom) == H_LLLL && hatom_getllll(&leftabysselem->l_hatom)->l_thing.w_obj) {
                                type = ((t_rhythm_level_properties *)hatom_getllll(&leftabysselem->l_hatom)->l_thing.w_obj)->level_type;
                                type &= ~k_RHYTHM_LEVEL_FORCE_TUPLET;    // in any case...
                                type &= ~k_RHYTHM_LEVEL_TUPLET;            // in any case...
                            }
                            
                            type &= ~k_RHYTHM_LEVEL_ORIGINAL; // it is by no means original, we've split it!
                            
                            set_level_type_flag_for_level(nextll, type | k_RHYTHM_LEVEL_ADDED);
                        }
                        
                        if (leftabysselem && hatom_gettype(&leftabysselem->l_hatom) == H_LLLL && hatom_getllll(&leftabysselem->l_hatom)->l_thing.w_obj) {
                            ((t_rhythm_level_properties *)hatom_getllll(&leftabysselem->l_hatom)->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_ORIGINAL; // it is by no means original.
                            ((t_rhythm_level_properties *)hatom_getllll(&leftabysselem->l_hatom)->l_thing.w_obj)->level_type |= k_RHYTHM_LEVEL_ADDED; 
                        }
                        
                        if (leftelem->l_parent != leftabysselem->l_parent)
                            object_warn((t_object *) r_ob, "Warning: weird rhythmic tree.");
                        
                        if (can_wrap && leftelem->l_parent == leftabysselem->l_parent) {
                            t_llll *newllll = llll_wrap_element_range(leftelem, leftabysselem);
                            set_level_type_flag_for_level(newllll, new_level_type);
                        }
                        tree_box_cursor = next_ts_box_cursor;
                    }
                }
                
                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                    char *buf2 = NULL;
                    llll_to_text_buf(this_box_level, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                    bach_freeptr(buf2);
                #endif
            } else
                tree_box_cursor = rat_rat_sum(tree_box_cursor, this_box_dur);
            
            can_wrap = can_wrap_next;

            new_next_ts_box_cursor = next_ts_box_cursor;
            t_llllelem *elem = this_ts_box_elem->l_next;
            while (elem && rat_rat_cmp(tree_box_cursor, new_next_ts_box_cursor) >= 0) {
                new_next_ts_box_cursor = rat_rat_sum(new_next_ts_box_cursor, hatom_getrational(&elem->l_hatom)); 
                elem = elem->l_next;
             }

            this_ts_box_elem = this_ts_box_elem->l_next;
            if (!this_ts_box_elem)
                break;

            next_ts_box_cursor = new_next_ts_box_cursor;

            can_wrap = can_wrap_level_for_ts(r_ob, measure, next_ts_box_cursor, new_next_ts_box_cursor, only_wrap_ignore_levels);
            
            leftelem = nextelem;
        }
        
        elem = nextelem;
     }
}

long flatten_level_if_graphical_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        if (box->l_thing.w_obj && ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_DISPLAY_ONLY)
            llll_flat(box, 0, 0, 0, LLLL_FREETHING_MEM);
    }
    return 0;
}


void compatibilize_rhythm_level_properties_before_flatting(t_notation_obj *r_ob, t_llll *external, t_llll *internal){
    if (external && internal && (external->l_thing.w_obj || internal->l_thing.w_obj)){
        if (!external->l_thing.w_obj){
            t_rhythm_level_properties *prop = build_rhythm_level_properties();
            *prop = *((t_rhythm_level_properties *)internal->l_thing.w_obj);
            external->l_thing.w_obj = prop;
        } else if (!internal->l_thing.w_obj){
            t_rhythm_level_properties *prop = build_rhythm_level_properties();
            *prop = *((t_rhythm_level_properties *)external->l_thing.w_obj);
            internal->l_thing.w_obj = prop;
        } else {
            t_rhythm_level_properties *prop1 = (t_rhythm_level_properties *)external->l_thing.w_obj;
            t_rhythm_level_properties *prop2 = (t_rhythm_level_properties *)internal->l_thing.w_obj;
            t_rhythm_level_properties cprop;
            
            cprop.is_grace = (prop1->is_grace || prop2->is_grace);
            cprop.is_tuplet = (prop1->is_tuplet || prop2->is_tuplet);
            if (prop1->is_tuplet)
                cprop.tupletinfo = prop1->tupletinfo;
            else if (prop2->is_tuplet)
                cprop.tupletinfo = prop2->tupletinfo;
            else
                fill_tupletinfo_fields(r_ob, &cprop.tupletinfo, long2rat(1), long2rat(1), long2rat(0));
            
            if (!external->l_owner) {
                // we're flatting to base level: we cannot give the external llll a beam!!!
                cprop.beam_number = 0;
                cprop.beam_slope = 0;
                cprop.direction = 0;
            } else if (prop1->beam_number > prop2->beam_number){
                cprop.beam_slope = prop1->beam_slope;
                cprop.beam_number = prop1->beam_number;
                cprop.direction = prop1->direction;
            } else {
                cprop.beam_slope = prop2->beam_slope;
                cprop.beam_number = prop2->beam_number;
                cprop.direction = prop2->direction;
            }

            cprop.max_beam_number = MIN(prop1->max_beam_number, prop2->max_beam_number);
            cprop.max_beam_number_if_under_beam = MIN(prop1->max_beam_number_if_under_beam, prop2->max_beam_number_if_under_beam);
            
            cprop.level_type = 0;
            
            if (prop1->level_type & k_RHYTHM_LEVEL_ORIGINAL || prop2->level_type & k_RHYTHM_LEVEL_ORIGINAL)
                cprop.level_type = k_RHYTHM_LEVEL_ORIGINAL;
            else if (prop1->level_type & k_RHYTHM_LEVEL_ADDED || prop2->level_type & k_RHYTHM_LEVEL_ADDED)
                cprop.level_type = k_RHYTHM_LEVEL_ADDED;
            else if (prop1->level_type & k_RHYTHM_LEVEL_DISPLAY_ONLY && prop2->level_type & k_RHYTHM_LEVEL_DISPLAY_ONLY)
                cprop.level_type = k_RHYTHM_LEVEL_DISPLAY_ONLY;
            
            if (prop1->level_type & k_RHYTHM_LEVEL_TS_BOX || prop2->level_type & k_RHYTHM_LEVEL_TS_BOX)
                cprop.level_type |= k_RHYTHM_LEVEL_TS_BOX;

            if (prop1->level_type & k_RHYTHM_LEVEL_TUPLET || prop2->level_type & k_RHYTHM_LEVEL_TUPLET)
                cprop.level_type |= k_RHYTHM_LEVEL_TUPLET;

            if (prop1->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET || prop2->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET)
                cprop.level_type |= k_RHYTHM_LEVEL_FORCE_TUPLET;
            
            if (prop1->level_type & k_RHYTHM_LEVEL_GRACE || prop2->level_type & k_RHYTHM_LEVEL_GRACE)
                cprop.level_type |= k_RHYTHM_LEVEL_GRACE;

            if (prop1->level_type & k_RHYTHM_LEVEL_IGNORE || prop2->level_type & k_RHYTHM_LEVEL_IGNORE)
                cprop.level_type |= k_RHYTHM_LEVEL_IGNORE;

            if (prop1->level_type & k_RHYTHM_LEVEL_KEEP || prop2->level_type & k_RHYTHM_LEVEL_KEEP)
                cprop.level_type |= k_RHYTHM_LEVEL_KEEP;

            *prop1 = cprop;
            *prop2 = cprop;
        }
    }
}

void flatten_level_if_singleton(t_notation_obj *r_ob, t_llll *box, t_measure *measure, long except_for_these_levels){
    t_rhythm_level_properties *prop;
     if (box){
        while (box->l_size == 1 && hatom_gettype(&box->l_head->l_hatom) == H_LLLL) {
            // level of type ((...))
            t_llll *inner = hatom_getllll(&box->l_head->l_hatom);
            if (inner->l_thing.w_obj && !is_level_grace(inner) && (!is_level_tuplet(inner) || !is_level_tuplet(box)) && 
                (!is_level_original(box) || r_ob->always_reduce_tree_idle_levels)){
                compatibilize_rhythm_level_properties_before_flatting(r_ob, box, inner);

                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                    char *buf = NULL;
                    char *buf2 = NULL;
                    llll_to_text_buf(measure->rhythmic_tree, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
                    llll_to_text_buf(box, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
                    bach_freeptr(buf);
                    bach_freeptr(buf2);
                    llll_check(measure->rhythmic_tree);
                #endif
                
                llll_flat(box, 0, 1, 0, LLLL_FREETHING_MEM);
                
                rhythmic_tree_debug_post((t_object *) r_ob, "An element has been flattened");
            } else 
                break;
        }
        
        
        prop = box->l_thing.w_obj ? (t_rhythm_level_properties *) box->l_thing.w_obj : NULL;
        
        if (!box->l_head && ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(measure, box)) || (r_ob->always_reduce_tree_idle_levels || !is_level_original(box)))) {
            llll_free_all_l_things(box);
            llll_destroyelem(box->l_owner);
            
        } else if (box->l_size == 1 && prop && box->l_owner && !is_level_grace(box) && // !is_level_tuplet(box) &&
                    !(is_level_tuplet(box) && box->l_owner->l_parent->l_size > 1) &&
                   ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(measure, box)) ||
                   (r_ob->always_reduce_tree_idle_levels || !is_level_original(box)))) {
            // level of type (H_OBJ) 
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
            if (!is_level_original(box) || r_ob->always_reduce_tree_idle_levels) {
                if (!(prop->level_type & except_for_these_levels)) {
                    verbose_post_rhythmic_tree(r_ob, ((t_scorevoice *)r_ob->firstvoice)->firstmeasure, NULL, 1);
                    
                    // deleting tuplet information before compatibilizing level properties
                    prop->level_type &= ~k_RHYTHM_LEVEL_FORCE_TUPLET;
                    prop->level_type &= ~k_RHYTHM_LEVEL_TUPLET;
                    prop->is_tuplet = 0;
                    
                    compatibilize_rhythm_level_properties_before_flatting(r_ob, box->l_owner->l_parent, box);
                    
                    llll_splatter(box->l_owner, LLLL_FREETHING_MEM);
                    
                    rhythmic_tree_debug_post((t_object *) r_ob, "An element has been splattered");
                    verbose_post_rhythmic_tree(r_ob, ((t_scorevoice *)r_ob->firstvoice)->firstmeasure, NULL, 1);
                }
            }
        }
    }
}

void flatten_singleton_levels(t_notation_obj *r_ob, t_measure *measure, long except_for_these_levels){
    t_llll *tree = measure->rhythmic_tree;
    t_llll *scanned = llll_scan(tree, true);
    t_llllelem *scannedelem;
    llll_flatten(scanned, 1, 0);

    for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
        if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
            t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                    char *buf = NULL;
                    llll_check(tree);
                    bach_freeptr(buf);
                #endif
                
                flatten_level_if_singleton(r_ob, hatom_getllll(&elem->l_hatom), measure, except_for_these_levels);
            }
        }
    }
    llll_free(scanned);
}



long modify_beam_number_if_box_contain_boxes_with_smaller_beam_number_or_ts_boxes_fn(void *data, t_hatom *a, const t_llll *address){
    if (address->l_size > 0 && hatom_gettype(a) == H_LLLL){
        char *original_beam_number = (char *) data;
        t_llll *box = hatom_getllll(a);
        t_rhythm_level_properties *prop = box->l_thing.w_obj ? (t_rhythm_level_properties *)box->l_thing.w_obj : NULL;
        if (!prop || prop->level_type & k_RHYTHM_LEVEL_TS_BOX || prop->beam_number <= *original_beam_number){
            *original_beam_number = 0;
            return 1;
        }
    }
    return 0;
}


long fix_level_type_flag_for_level_as_original_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        if (!hatom_getllll(a)->l_thing.w_obj || ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type != k_RHYTHM_LEVEL_ORIGINAL){
            set_level_type_flag_for_level(hatom_getllll(a), k_RHYTHM_LEVEL_ORIGINAL);
            *((char *) data) = true;
        }
    }
    return 0;
}

long turn_ignore_and_keep_levels_into_original_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        if (!hatom_getllll(a)->l_thing.w_obj || (((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE || 
                                           ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP)){
            long tuplet = ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TUPLET;
            long orig = ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_ORIGINAL;
            long ts = ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TS_BOX;
            long grace = ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE;
            long force_tupled = ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET;
            set_level_type_flag_for_level(hatom_getllll(a), tuplet + grace + ts + force_tupled + (ts ? orig : k_RHYTHM_LEVEL_ORIGINAL));
            *((char *) data) = true;
        }
    }
    return 0;
}

long convert_ignore_and_keep_levels(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        char changed = 0;
        t_rhythm_level_properties *prop = box->l_thing.w_obj ? (t_rhythm_level_properties *)box->l_thing.w_obj : NULL;
        if (prop && (prop->level_type & k_RHYTHM_LEVEL_IGNORE || prop->level_type & k_RHYTHM_LEVEL_KEEP))
            llll_funall(box, turn_ignore_and_keep_levels_into_original_levels_fn, &changed, 1, -1, FUNALL_SKIP_ATOMS);
    }
    return 0;
}

/*
long splatter_llll_until_grace_fn(void *data, t_hatom *a, const t_llll *address){
    e_freething_modes freething = *((e_freething_modes *)data);
    if (hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        t_llllelem *elem = ll->l_head;
        while (elem) {
            t_llllelem *nextelem = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL){
                t_llll *subll = hatom_getllll(&elem->l_hatom);
                if (subll->l_thing.w_obj && (((t_rhythm_level_properties *)subll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE))
                    return 1;
                else if (subll->l_owner)
                    llll_splatter(subll->l_owner, freething);
            }
            elem = nextelem;
        }
    }
    return 0;
}
 */

void flat_preserving_leveltypes(t_llll *box, long mindepth, long maxdepth, e_rhythm_level_types leveltypes, e_freething_modes freething, void *data){
    t_llllelem *elem = box->l_head;
    while (elem) {
        t_llllelem *nextelem = elem->l_next;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL){
            t_llll *subll = hatom_getllll(&elem->l_hatom);
            char need_to_keep = (subll->l_thing.w_obj && (((t_rhythm_level_properties *)subll->l_thing.w_obj)->level_type & leveltypes));
            flat_preserving_leveltypes(subll, mindepth <= 0 ? mindepth : mindepth -1, maxdepth <= 0 ? maxdepth : maxdepth -1, leveltypes, freething, data);
            if (!need_to_keep)
                llll_splatter(subll->l_owner, freething);
        }
        elem = nextelem;
    }
}

long flat_inner_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    e_freething_modes freething = *((e_freething_modes *)data);
    if (address->l_size > 0 && hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        if (ll->l_thing.w_obj && (((t_rhythm_level_properties *)ll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE))
            llll_flat(ll, 0, 0, 0, freething);
    }
    return 0;
}

void flat_inner_grace_levels(t_llll *box, long mindepth, long maxdepth, e_freething_modes freething){
    llll_funall(box, flat_inner_grace_levels_fn, &freething, mindepth, maxdepth, FUNALL_SKIP_ATOMS);
}


void flat_up_to_level_starting_with_g(t_llll *box){
    if (box) {
        t_llllelem *elem = NULL;
        for (elem = box->l_head; elem; elem = elem->l_next) {
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *ll = hatom_getllll(&elem->l_hatom);
                if (ll && ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_SYM && hatom_getsym(&ll->l_head->l_hatom) == _llllobj_sym_g) {
                    llll_flatten(ll, 0, 0);
                } else {
                    flat_up_to_level_starting_with_g(ll);
                    llll_splatter(elem, LLLL_FREETHING_DONT);
                }
            }
        }
    }
}


long delete_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        t_llllelem *elem = ll->l_head;
        
        while (elem){
            t_llllelem *nextelem = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *subll = hatom_getllll(&elem->l_hatom);
                if (subll->l_thing.w_obj && (((t_rhythm_level_properties *)subll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE)) {
                    llll_free_all_l_things(subll);
                    llll_destroyelem(elem);
                }
            }
            elem = nextelem;
        }
    }
    return 0;
}

void delete_grace_levels(t_llll *box){ 
    llll_funall(box, delete_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
}


long delete_all_rests_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        t_llllelem *elem = ll->l_head;
        while (elem){
            t_llllelem *nextelem = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *subll = hatom_getllll(&elem->l_hatom);
                t_chord *ch1 = get_level_start_chord(subll, true);
                t_chord *ch2 = get_level_end_chord(subll, true);
                t_chord *ch;
                char all_rests = true;
                for (ch = ch1; ch; ch = ch->next){
                    if (ch->r_sym_duration.r_num > 0) {
                        all_rests = false;
                        break;
                    }
                    if (ch == ch2)
                        break;
                }
                if (all_rests) {
                    llll_free_all_l_things(subll);
                    llll_destroyelem(elem);
                }
            }
            elem = nextelem;
        }
    }
    return 0;
}

void delete_all_rests_levels(t_llll *box){
    llll_funall(box, delete_all_rests_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
}

long are_there_tuplets_level_fn(void *data, t_hatom *a, const t_llll *address){
    char *res = (char *)data;
    if (!(*res) && hatom_gettype(a) == H_LLLL && address->l_size > 0){
        t_llll *ll = hatom_getllll(a);
        if (ll->l_thing.w_obj && (((t_rhythm_level_properties *)ll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TUPLET))
            *res = true;
    }
    return 0;
}

char are_there_tuplets_inside_level(t_llll *box){
    char res = false;
    llll_funall(box, are_there_tuplets_level_fn, &res, 1, -1, FUNALL_SKIP_ATOMS);
    return res;
}


long tidy_up_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *meas = (t_measure*) ((void **)data)[1];

    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        t_rhythm_level_properties *prop = box->l_thing.w_obj ? (t_rhythm_level_properties *)box->l_thing.w_obj : NULL;
        if (prop && prop->level_type & k_RHYTHM_LEVEL_GRACE) {
            prop->is_grace = true;
            flat_inner_grace_levels(box, 1, -1, LLLL_FREETHING_MEM);
        }
        
        // we try to beam the grace sequences
        if (r_ob->try_to_beam_grace_sequences && (r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED || r_ob->notation_cursor.measure == meas)) {
            t_llllelem *elem, *startpivot = NULL, *endpivot = NULL;
            for (elem = box->l_head; elem; elem = elem->l_next){
                if (hatom_gettype(&elem->l_hatom) == H_LLLL && is_level_grace(hatom_getllll(&elem->l_hatom))) {
                    if (!startpivot)
                        startpivot = endpivot = elem;
                    else
                        endpivot = elem;
                } else {
                    if (startpivot && endpivot && startpivot != endpivot){
                        t_llllelem *temp;
                        t_llll *new_level;
                        for (temp = startpivot; temp; temp = temp->l_next){
                            ((t_rhythm_level_properties *)hatom_getllll(&temp->l_hatom)->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_GRACE;
                            if (temp == endpivot)
                                break;
                        }
                        
                        new_level = llll_wrap_element_range(startpivot, endpivot);
                        set_level_type_flag_for_level(new_level, k_RHYTHM_LEVEL_GRACE + k_RHYTHM_LEVEL_ADDED);
                    }
                    startpivot = endpivot = NULL;
                }
            }
            if (startpivot && endpivot && startpivot != endpivot){
                t_llllelem *temp;
                t_llll *new_level;
                for (temp = startpivot; temp; temp = temp->l_next){
                    ((t_rhythm_level_properties *)hatom_getllll(&temp->l_hatom)->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_GRACE;
                    if (temp == endpivot)
                        break;
                }
                
                new_level = llll_wrap_element_range(startpivot, endpivot);
                set_level_type_flag_for_level(new_level, k_RHYTHM_LEVEL_GRACE + k_RHYTHM_LEVEL_ADDED);
            }
        }
    }
    return 0;
}

long flatten_ignore_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        t_rhythm_level_properties *prop = box->l_thing.w_obj ? (t_rhythm_level_properties *)box->l_thing.w_obj : NULL;

        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *buf = NULL;
            llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1); //buf +50
            bach_freeptr(buf);
        #endif

        if (prop && prop->level_type & k_RHYTHM_LEVEL_IGNORE) {
            flat_preserving_leveltypes(box, 0, 0, (e_rhythm_level_types) (k_RHYTHM_LEVEL_KEEP | k_RHYTHM_LEVEL_GRACE), LLLL_FREETHING_MEM, data);

            #ifdef BACH_RHYTHMIC_TREE_DEBUG
                char *buf = NULL;
                llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                bach_freeptr(buf);
            #endif
            
//            if (box->l_owner && box->l_owner->l_parent && box->l_owner->l_parent->l_thing.w_obj &&
//                !(((t_rhythm_level_properties *)box->l_owner->l_parent->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP) &&
//                !(((t_rhythm_level_properties *)box->l_owner->l_parent->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE))
//                llll_splatter(box->l_owner, LLLL_FREETHING_MEM);
        }
    }
    return 0;
}


long set_tuplet_levels_as_keep_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        if (box && box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TUPLET)) {
            ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_IGNORE;
            ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type |= k_RHYTHM_LEVEL_KEEP;
        }
    }
    return 0;
}

void set_tuplet_levels_as_keep_levels(t_llll *tree){
    llll_funall(tree, set_tuplet_levels_as_keep_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
}



long remove_force_tuplet_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);

#ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf2 = NULL;
        llll_to_text_buf(box, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
        rhythmic_tree_debug_post(NULL, "Removing force tuplet levels: ", buf2);
        bach_freeptr(buf2);
#endif

        if (box && box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET))
            ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_FORCE_TUPLET;
    }
    return 0;
}

void re_check_beams_for_lower_levels(t_notation_obj *r_ob, t_measure *meas, t_llll *dad){
    t_rhythm_level_properties *dad_prop = (t_rhythm_level_properties *)dad->l_thing.w_obj;
    if (dad_prop->beam_number == 0) {
        t_llllelem *sonelem;
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *buf2 = NULL;
            llll_to_text_buf(dad, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
            rhythmic_tree_debug_post((t_object *) r_ob, "  > Wait: DAD %s is UNBEAMED, so we check if some inner beamings change", buf2);
            bach_freeptr(buf2);
        #endif
        
        for (sonelem = dad->l_head; sonelem; sonelem = sonelem->l_next){
            if (hatom_gettype(&sonelem->l_hatom) == H_LLLL) {
                t_llll *sonll = hatom_getllll(&sonelem->l_hatom);
                t_rhythm_level_properties *son_prop = (t_rhythm_level_properties *)sonll->l_thing.w_obj;
                char reduced = 0;
                long prev_son_beam_number = son_prop->beam_number;
                
                if (r_ob->rests_within_beaming == k_REST_IN_BEAM_NEVER || r_ob->rests_within_beaming == k_REST_IN_BEAM_IF_INTERNAL) {
                    t_chord *start = get_level_start_chord(sonll, true);
                    t_chord *end = get_level_end_chord(sonll, true);
                    if (son_prop->beam_number > 0 && start && end && (start->r_sym_duration.r_num < 0 || end->r_sym_duration.r_num < 0)){
                        son_prop->beam_number = son_prop->max_beam_number = 0;
                        reduced = 1;
                    }
                }
                if (!reduced && son_prop->max_beam_number != son_prop->max_beam_number_if_under_beam) {
                    if (son_prop->beam_number > son_prop->max_beam_number) {
                        son_prop->beam_number = MAX(0, son_prop->max_beam_number);    // reduce number!
                        reduced = 2;
                    }
                }
                
                if (reduced){

                    #ifdef BACH_RHYTHMIC_TREE_DEBUG
                        char *buf2 = NULL;
                        llll_to_text_buf(sonll, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                        rhythmic_tree_debug_post((t_object *) r_ob, "  > Wait: indeed SON %s beam number has been changed to %d", buf2, son_prop->max_beam_number);
                        bach_freeptr(buf2);
                    #endif
                    
                    verbose_post_rhythmic_tree(r_ob, meas, gensym("part"), 1);
                    
                    if ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(meas, sonll)) || 
                        ((t_rhythm_level_properties *) sonll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE || 
                        ((t_rhythm_level_properties *) sonll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP||
                        (((t_rhythm_level_properties *) sonll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TS_BOX && !is_level_locked(meas, sonll)))
                        refine_beams_for_level_once(r_ob, sonll, false, reduced == 1, true, prev_son_beam_number, false);
                    
                    // HERE WE HAD FOUND A BUG, but it could be that the list was wrongly formed?
                    re_check_beams_for_lower_levels(r_ob, meas, sonll); //< Recursion!
                }
            }
        }
    }
    
}

long get_depth_ignoring_grace_levels(t_notation_obj *r_ob, t_llll *box){
    long d = 1;
    t_llll *cloned = llll_clone_extended(box, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);

    delete_grace_levels(cloned);
    d = cloned->l_depth;
    llll_free_freethings(cloned, LLLL_FREETHING_MEM);
    return d;
}

long get_num_chords_ignoring_grace_levels(t_notation_obj *r_ob, t_llll *box){
    long num_ch = 0;
    t_llll *cloned = llll_clone_extended(box, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);

    delete_grace_levels(cloned);
    llll_flat(cloned, 0, 0, 0, LLLL_FREETHING_MEM);
    num_ch = cloned->l_size;
    llll_free_freethings(cloned, LLLL_FREETHING_MEM);
    return num_ch;
}


long get_depth_ignoring_grace_levels_and_all_rests_levels(t_notation_obj *r_ob, t_llll *box){
    long d = 1;
    t_llll *cloned = llll_clone_extended(box, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);

    delete_grace_levels(cloned);
    delete_all_rests_levels(cloned);
    d = cloned->l_depth;
    llll_free_freethings(cloned, LLLL_FREETHING_MEM);
    return d;
}

char is_level_all_rests_level(t_notation_obj *r_ob, t_llll *box){
    t_chord *ch1 = get_level_start_chord(box, true), *ch2 = get_level_end_chord(box, true), *ch;
    for (ch = ch1; ch; ch = ch->next){
        if (ch->r_sym_duration.r_num > 0)
            return false;
        if (ch == ch2)
            return true;
    }
    return true;
}

void check_correct_beaming(t_notation_obj *r_ob, t_measure *meas){

    if (meas && meas->rhythmic_tree){
        t_llll *scanned = llll_scan(meas->rhythmic_tree, true);
        t_llllelem *scannedelem;
        llll_flatten(scanned, 1, 0);
        
        llll_prependobj(scanned, WHITENULL_llll, 0, WHITENULL_llll); // hack, to treat the root list

        for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
            if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
                t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
                
                if (elem == WHITENULL || hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *dad_llll = (elem == WHITENULL_llllelem) ? meas->rhythmic_tree : hatom_getllll(&elem->l_hatom);
                    long depth_ignore_grace_levels = get_depth_ignoring_grace_levels_and_all_rests_levels(r_ob, dad_llll);

                    if (depth_ignore_grace_levels == 1) { // dad is just a collection of plain chords!
                        char allrests = is_level_all_rests_level(r_ob, dad_llll);
                        
                        if (!dad_llll->l_thing.w_obj)
                            dad_llll->l_thing.w_obj = build_rhythm_level_properties();
                        t_rhythm_level_properties *littlest_son_prop = (t_rhythm_level_properties *)dad_llll->l_thing.w_obj;
                        
                        // setting beam number as the maximum possible beam number
                        littlest_son_prop->beam_number = MAX(0, allrests ? 0 : (!dad_llll->l_owner ? (r_ob->always_break_first_level_beams ? 0 : littlest_son_prop->max_beam_number) : littlest_son_prop->max_beam_number_if_under_beam));
                        
                        #ifdef BACH_RHYTHMIC_TREE_DEBUG
                            char *buf1 = NULL;
                            llll_to_text_buf(dad_llll, &buf1, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                            rhythmic_tree_debug_post((t_object *) r_ob, "Setting to LEAST SON %s beam_number %d", buf1, littlest_son_prop->beam_number);
                            verbose_post_rhythmic_tree(r_ob, meas, gensym("step - partial"), 2);
                            bach_freeptr(buf1);
                        #endif
                        
                    } else if (depth_ignore_grace_levels > 1) { // level has "sons"
                        if (!dad_llll->l_thing.w_obj)
                            dad_llll->l_thing.w_obj = build_rhythm_level_properties();
                        
                        t_rhythm_level_properties *dad_prop = (t_rhythm_level_properties *)dad_llll->l_thing.w_obj;
                        t_llllelem *sonelem;
                        
                        #ifdef BACH_RHYTHMIC_TREE_DEBUG
                            char *buf1 = NULL;
                            llll_to_text_buf(dad_llll, &buf1, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                            rhythmic_tree_debug_post((t_object *) r_ob, "Analyzing DAD %s", buf1); //buf1 + 70
                            bach_freeptr(buf1);
                        #endif
                        
                        long max_beam_number_because_of_sons = 32000; // means: to define
                        long prev_dad_beam_number = dad_prop->beam_number;
                        
                        for (sonelem = dad_llll->l_head; sonelem; sonelem = sonelem->l_next){
                            if (hatom_gettype(&sonelem->l_hatom) == H_LLLL) {
                                t_llll *sonll = hatom_getllll(&sonelem->l_hatom);
                                t_rhythm_level_properties *son_prop = (t_rhythm_level_properties *)sonll->l_thing.w_obj;
                                
                                if (is_level_grace(sonll))
                                    continue;
                                
                                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                                    char *buf2 = NULL;
                                    llll_to_text_buf(sonll, &buf2, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                                    rhythmic_tree_debug_post((t_object *) r_ob, "  - SON %s has beam_number %d", buf2, son_prop->beam_number);
                                    bach_freeptr(buf2);
                                #endif
                                
                                if (!(son_prop->level_type & k_RHYTHM_LEVEL_TS_BOX) && 
                                    (r_ob->tree_to_beaming_correspondence == k_TREE2BEAM_LEVELS_CAN_SHARE_BEAMS ||
                                     (r_ob->tree_to_beaming_correspondence == k_TREE2BEAM_BREAK_BEAMS_AROUND_TUPLETS && !son_prop->is_tuplet)))
                                    max_beam_number_because_of_sons = MAX(0, MIN(max_beam_number_because_of_sons, son_prop->beam_number));
                                else if (son_prop->level_type & k_RHYTHM_LEVEL_TS_BOX)
                                    max_beam_number_because_of_sons = 0;
                                else
                                    max_beam_number_because_of_sons = MAX(0, MIN(max_beam_number_because_of_sons, son_prop->beam_number - 1));
                            }
                        }
                        
                        if (!dad_llll->l_owner && r_ob->always_break_first_level_beams)
                            dad_prop->beam_number = 0;
                        else if (max_beam_number_because_of_sons == 32000)    // no beaming inside (might happen with grace notes)
                            dad_prop->beam_number = 0; //dad_prop->max_beam_number_if_under_beam;
                        else
                            dad_prop->beam_number = MIN(dad_prop->max_beam_number_if_under_beam, max_beam_number_because_of_sons);
                        
                        rhythmic_tree_debug_post((t_object *) r_ob, "  > DAD will have beam number %d", dad_prop->beam_number);
                        
                        if (prev_dad_beam_number != dad_prop->beam_number && !(!dad_llll->l_owner && r_ob->always_break_first_level_beams)) {
                            if ((r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(meas, dad_llll)) || 
                                ((t_rhythm_level_properties *) dad_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE || 
                                ((t_rhythm_level_properties *) dad_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP||
                                (((t_rhythm_level_properties *) dad_llll->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TS_BOX && !is_level_locked(meas, dad_llll)))
                                refine_beams_for_level_once(r_ob, dad_llll, false, false, true, 0, false);
                        }
                        
                        #ifdef BACH_RHYTHMIC_TREE_DEBUG
                            char *buf3 = NULL;
                            llll_to_text_buf(dad_llll, &buf3, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                            rhythmic_tree_debug_post((t_object *) r_ob, "After further refining DAD is %s", buf3);
                            bach_freeptr(buf3);
                        #endif

                        // we check again inner levels before going on
                        re_check_beams_for_lower_levels(r_ob, meas, dad_llll);
                        
                    }
                }
            }
        }

        llll_free(scanned);
    }
}

char is_level_grace(t_llll *box){
    if (box && box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_GRACE))
        return true;
    return false;
}


char is_level_grace_or_inside_grace(t_llll *box){
    t_llll *temp = box;
    if (is_level_grace(box))
        return true;
    
    while (temp && temp->l_owner) {
        if (is_level_grace(temp->l_owner->l_parent))
            return true;
        temp = temp->l_owner->l_parent;
    }
    
    return false;
}

char is_level_original(t_llll *box){
    if (!box->l_thing.w_obj || (box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_ORIGINAL)))
        return true;
    return false;
}

char is_level_tuplet(t_llll *box){
    if (box->l_thing.w_obj && (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_TUPLET))
        return true;
    return false;
}

long level_contains_tuplet_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && is_level_tuplet(hatom_getllll(a))){
        *((char *)data) = 1;
        return 1;
    }
    return 0;
}

char level_contains_tuplet(t_llll *box){
    char res = 0;
    
    if (is_level_tuplet(box))
        return 1;
        
    llll_funall(box, level_contains_tuplet_fn, &res, 1, -1, FUNALL_SKIP_ATOMS);
    return res;
}

long level_contains_nongrace_tuplet_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        if (is_level_grace(hatom_getllll(a))) {
            return 1; // don't enter
        } else if (is_level_tuplet(hatom_getllll(a))) {
            *((char *)data) = 1;
            return 1;
        }
    }
    return 0;
}

char level_contains_nongrace_tuplet(t_llll *box){
    char res = 0;
    
    if (is_level_tuplet(box) && !is_level_grace(box))
        return 1;
    
    llll_funall(box, level_contains_nongrace_tuplet_fn, &res, 1, -1, FUNALL_SKIP_ATOMS);
    return res;
}


long llll_gcd_of_rat_llll_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_RAT || hatom_gettype(a) == H_LONG)
        *((t_rational *)data) = rat_gcd(*((t_rational *)data), hatom_getrational(a));
    return 0;
}

t_rational llll_gcd_of_rat_llll(t_llll *rationals){
    t_rational gcd = long2rat(1);
    llll_funall(rationals, llll_gcd_of_rat_llll_fn, &gcd, 1, -1, 0);
    return gcd;
}

long llll_gcd_of_rat_llll_until_tuplet_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *)((void **)data)[0];
    t_rational *gcd = (t_rational *)((void **)data)[1];

    if (hatom_gettype(a) == H_RAT || hatom_gettype(a) == H_LONG) {
        t_rational r = rat_abs(hatom_getrational(a));
        if (gcd->r_num < 0)
            *gcd = r;
        else {
//            bach_breakpoint((*gcd).r_num != 0 && r.r_num != 0 && (*gcd).r_den != 0 && r.r_den != 0);
            *gcd = rat_gcd(rat_abs(*gcd), r);
        }
    } else if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        if (is_level_tuplet(hatom_getllll(a))) {
            t_rational this_dur = get_level_rduration(r_ob, hatom_getllll(a), false, true, false, false);
//            bach_breakpoint((*gcd).r_num != 0 && this_dur.r_num != 0 && (*gcd).r_den != 0 && this_dur.r_den != 0);
            *gcd = rat_gcd(rat_abs(*gcd), this_dur);
            return 1;
        } else if (is_level_grace(hatom_getllll(a))) {
            return 1;
        }
    }
    return 0;
}

t_rational llll_gcd_of_rat_llll_until_tuplet(t_notation_obj *r_ob, t_llll *rationals){
    t_rational gcd = long2rat(-1); // still to be defined
    void *data[2];
    data[0] = r_ob;
    data[1] = &gcd;
    
    llll_funall(rationals, llll_gcd_of_rat_llll_until_tuplet_fn, data, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);

    if (gcd.r_num < 0)
        gcd = long2rat(1);
    return gcd;
}


long llll_sum_abs_of_rat_llll_until_grace_and_forcetuplets_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)))
        return 1;
    else if (hatom_gettype(a) == H_LLLL && (((t_rhythm_level_properties *)hatom_getllll(a))->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET)) {
        *((t_rational *)data) = rat_rat_sum(*((t_rational *)data), ((t_rhythm_level_properties *)hatom_getllll(a)->l_thing.w_obj)->tupletinfo.tuplet_sym_duration);
        return 1;
    } else if (hatom_gettype(a) == H_LONG || hatom_gettype(a) == H_RAT)
        *((t_rational *)data) = rat_rat_sum(*((t_rational *)data), rat_abs(hatom_getrational(a)));
    return 0;
}

long llll_sum_abs_of_rat_llll_until_grace_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)))
        return 1;
    else if (hatom_gettype(a) == H_LONG || hatom_gettype(a) == H_RAT)
        *((t_rational *)data) = rat_rat_sum(*((t_rational *)data), rat_abs(hatom_getrational(a)));
    return 0;
}

t_rational llll_sum_abs_of_rat_llll_until_grace(t_llll *rationals, char consider_forcetuplets_with_their_total_duration){
    t_rational sum = long2rat(0);
    if (rationals)
        llll_funall(rationals, consider_forcetuplets_with_their_total_duration ? llll_sum_abs_of_rat_llll_until_grace_and_forcetuplets_fn : llll_sum_abs_of_rat_llll_until_grace_fn, &sum, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
    return sum;
}


t_rational llll_gcd_on_first_level_in_rdurations_rhythmic_tree(t_llll *rationals, char consider_forcetuplets_with_their_total_duration){
    t_rational gcd = long2rat(-1);
    t_llllelem *elem;
    for (elem = rationals->l_head; elem; elem = elem->l_next){
        t_rational this_dur;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
            if (is_level_grace(hatom_getllll(&elem->l_hatom)))
                this_dur = long2rat(0);
            else if (consider_forcetuplets_with_their_total_duration && ((t_rhythm_level_properties *)hatom_getllll(&elem->l_hatom)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET)
                this_dur = ((t_rhythm_level_properties *)hatom_getllll(&elem->l_hatom)->l_thing.w_obj)->tupletinfo.tuplet_sym_duration;
            else
                this_dur = llll_sum_abs_of_rat_llll_until_grace(hatom_getllll(&elem->l_hatom), consider_forcetuplets_with_their_total_duration);
        } else
            this_dur = hatom_getrational(&elem->l_hatom);
        if (this_dur.r_num != 0)
            gcd = gcd.r_num < 0 ? rat_abs(this_dur) : rat_gcd(gcd, rat_abs(this_dur));
    }
    
    if (gcd.r_num < 0)
        gcd = long2rat(1);
    
    return gcd;
}


t_rational llll_gcd_on_first_level(t_llll *rationals){
    t_rational gcd = long2rat(-1);
    t_llllelem *elem;
    for (elem = rationals->l_head; elem; elem = elem->l_next){
        t_rational this_dur;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL)
            this_dur = llll_sum_abs_of_rat_llll(hatom_getllll(&elem->l_hatom));
        else
            this_dur = hatom_getrational(&elem->l_hatom);
        if (this_dur.r_num != 0)
            gcd = gcd.r_num < 0 ? rat_abs(this_dur) : rat_gcd(gcd, rat_abs(this_dur));
    }
    
    if (gcd.r_num < 0)
        gcd = long2rat(1);
    
    return gcd;
}




t_rational tuplet_unit_to_tuplet_graphical_unit(t_notation_obj *r_ob, t_rational tuplet_local_unit, char allow_dotted_tuplets){
    if (allow_dotted_tuplets) {
        t_rational supposed = genrat(tuplet_local_unit.r_num, iexp2(floor(log2(tuplet_local_unit.r_den))));
        t_rational screen_dur;
        char num_dots;
//        if (is_duration_drawable_with_tuplet_info(r_ob, supposed, &screen_dur, &num_dots, long2rat(1), long2rat(0)))
        if (is_duration_drawable(r_ob, supposed, &screen_dur, &num_dots))
            return supposed;
    }
            
    return genrat(1, iexp2(floor(log2(tuplet_local_unit.r_den/tuplet_local_unit.r_num))));
}


t_rational get_overall_tuplet_ratio_for_outer_levels_and_this_level(t_llll *box){
    t_rational res = long2rat(1);
    if (is_level_tuplet(box))
        res = ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_local_ratio;
    return rat_rat_prod(res, get_overall_tuplet_ratio_for_outer_levels(box));
}

t_rational get_overall_tuplet_ratio_for_outer_levels(t_llll *box){
    t_llll *temp = box->l_owner ? box->l_owner->l_parent : NULL;
    t_rational res = long2rat(1);
    if (is_level_grace(box))
        return res;
    while (temp){
        if (is_level_tuplet(temp))
            res = rat_rat_prod(res, ((t_rhythm_level_properties *)temp->l_thing.w_obj)->tupletinfo.tuplet_local_ratio);
        if (is_level_grace(temp))
            return res;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return res;
}

long rat_multiply_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational mult = *((t_rational *) data);
    if (hatom_gettype(a) == H_RAT)
        hatom_setrational(a, rat_rat_prod(hatom_getrational(a), mult));
    else if (hatom_gettype(a) == H_LONG)
        hatom_setrational(a, rat_long_prod(mult, hatom_getlong(a)));
    return 0;
}



long compute_chord_figure_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *)data;
    if (hatom_gettype(a) == H_OBJ)
        compute_chord_figure(r_ob, (t_chord *)hatom_getobj(a), true);
    return 0;
}


long multiply_tuplet_overall_ratio_for_level_chords_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational ratio = *((t_rational *)data);
    if (hatom_gettype(a) == H_OBJ) 
        ((t_chord *)hatom_getobj(a))->overall_tuplet_ratio = rat_rat_prod(((t_chord *)hatom_getobj(a))->overall_tuplet_ratio, ratio);
    else if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)))
        return 1;
    return 0;
}

long set_tuplet_overall_ratio_for_level_chords_fn(void *data, t_hatom *a, const t_llll *address){
    t_rational overall_ratio = *((t_rational *)data);
    if (hatom_gettype(a) == H_OBJ) 
        ((t_chord *)hatom_getobj(a))->overall_tuplet_ratio = overall_ratio;
    else if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)))
        return 1;
    return 0;
}

long fix_nontuplets_for_level_fn(void *data, t_hatom *a, const t_llll *address)
{
/*    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *meas = (t_measure *) ((void **)data)[1];
    char only_correct_existing_inner_tuplets = *((char *)((void **)data)[2]);
    char take_rhythmic_tree_levels_for_granted = (*((char *)((void **)data)[3]) & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS);
  */
    if (hatom_gettype(a) == H_LLLL){
        // tuplets variables
        t_llll *box = hatom_getllll(a);
        if (box->l_thing.w_obj) {
            t_rhythm_level_properties *prop;
            prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
            
            if (prop->is_tuplet && rat_long_cmp(prop->tupletinfo.tuplet_local_ratio, 1) == 0) {
                prop->is_tuplet = false;
            }
        }
    }
    
    return 0;
}


long find_tuplets_for_level_fn(void *data, t_hatom *a, const t_llll *address)
{
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *meas = (t_measure *) ((void **)data)[1];
    char only_correct_existing_inner_tuplets = *((char *)((void **)data)[2]);
    char take_rhythmic_tree_levels_for_granted = (*((char *)((void **)data)[3]) & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS);
    
    if (only_correct_existing_inner_tuplets && address->l_size == 0) {
        return 0;
    }
    
    if (hatom_gettype(a) == H_LLLL){
        // tuplets variables
        t_llll *box = hatom_getllll(a);
        t_llll *r_durations = rhythmic_tree_to_duration_tree(r_ob, box, true, false);
        t_rational orig_box_duration = get_level_rduration(r_ob, box, false, true, true, false);
        t_rational box_duration;
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
        {
            char *buf = NULL;
            object_post((t_object *) r_ob, "    --------- ");
            llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1); // buf +60
            object_post((t_object *) r_ob, "Scanning for tuplet box: %s", buf);
            bach_freeptr(buf);
        }
        #endif

        // rescaling according to the already present tuplet ration (for nested tuplets!)
        t_rational pregresse_ratio = get_overall_tuplet_ratio_for_outer_levels(box);
        t_rational inv_pregresse_ratio = rat_inv(pregresse_ratio);
        t_rational overall_ratio = pregresse_ratio;
        
        llll_funall(r_durations, rat_multiply_fn, &inv_pregresse_ratio, 1, -1, 0);    //rescaling durations
        box_duration = rat_rat_prod(orig_box_duration, inv_pregresse_ratio);    // rescaling box duration
        
        // is it a standard/nonstandard level?
        long boxduration_log2 = perfect_log2(box_duration.r_den); //e.g. 4/12: the perfect_log2 function returns -1
        char box_is_standard = (boxduration_log2 >= 0) ? true : false; // for our example: NO
        
        if (!box->l_thing.w_obj)
            box->l_thing.w_obj = build_rhythm_level_properties();    // this should never happen, all boxes should already have the l_thing.w_obj field
        
        t_rhythm_level_properties *prop;
        prop = (t_rhythm_level_properties *)box->l_thing.w_obj;

        if (only_correct_existing_inner_tuplets || r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED || is_level_locked(meas, box) || 
            prop->level_type & k_RHYTHM_LEVEL_KEEP || prop->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET || take_rhythmic_tree_levels_for_granted){
            // we take the tuplet level for granted: that's what we have!
            
            if (!only_correct_existing_inner_tuplets && prop->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET){    
                // we are forcing a tuplet, typically via the speedy edit, thus we keep the unit 
                
                t_rational forced_local_unit = ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_local_unit;
                t_rational forced_duration = ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_sym_duration;

                fill_tupletinfo_fields(r_ob, &prop->tupletinfo, forced_local_unit, pregresse_ratio, forced_duration);
                correct_tuplets_units_and_multiplier_for_level(r_ob, meas, box, true);

                prop->is_tuplet = true;
                prop->level_type |= k_RHYTHM_LEVEL_TUPLET;
                if (rat_rat_cmp(box_duration, forced_duration) >= 0 && r_ob->notation_cursor.measure)
                    prop->level_type &= ~k_RHYTHM_LEVEL_FORCE_TUPLET; // no more need to force the tuplet!
                
                overall_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
                llll_funall(box, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
                
            } else {
//                long try1 = 55, try2 = -45;
//                long gcd1 = long_long_reduce(&try1, &try2);
                t_rational gcd = llll_gcd_on_first_level_in_rdurations_rhythmic_tree(r_durations, r_ob->is_linear_editing);

                // if we take_rhythmic_tree_levels_for_granted, that means that there's a tuplet ONLY IF the level was already marked as tuplet
                // otherwise we don't put any tuplet!!!
            
                if (perfect_log2(gcd.r_den) < 0 && 
                    (!take_rhythmic_tree_levels_for_granted || 
                     (take_rhythmic_tree_levels_for_granted && prop->level_type & (k_RHYTHM_LEVEL_FORCE_TUPLET | k_RHYTHM_LEVEL_TUPLET)))){
                        
                        prop->is_tuplet = true;
                        prop->level_type |= k_RHYTHM_LEVEL_TUPLET;
                        fill_tupletinfo_fields(r_ob, &prop->tupletinfo, genrat(1, gcd.r_den), pregresse_ratio, orig_box_duration);
                        correct_tuplets_units_and_multiplier_for_level(r_ob, meas, box, true);

                        overall_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
                        llll_funall(box, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
                        
                        //                llll_funall(box, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                    } else  {
                        prop->is_tuplet = false;
                        prop->level_type &= ~k_RHYTHM_LEVEL_TUPLET;
                        
                        // set ratios to the pregressed ratio
                        llll_funall(box, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
                        
                        //                llll_funall(box, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                    }
            }
            
            llll_free_freethings(r_durations, LLLL_FREETHING_MEM);
            
            return 0;
            
        } else {
            // we need to reconstruct (refine) the tuplet tree for this level
            
            t_rational start_tuplet_box_onset = long2rat(0);

            t_llllelem *rhythm_elem = r_durations->l_head;
            t_llllelem *chord_elem = box->l_head;
            t_llllelem *start_tuplet_duration_elem = NULL; // pivot element for tuplets (rational, from the r_durations llll)
            t_llllelem *start_tuplet_chord_elem = NULL; // pivot element for tuplets (as H_OBJ or H_LLLL) (t_chord *)0x1f456ca0
            
            long count = 0, count_rhythm_elem = 0, count_stay_inside = 0;
            char restart = false;
            char gotta_complete_a_tuplet = false;
            t_rational curr_tuplet_ratio = long2rat(1); 
            t_rational curr_tuplet_sym_dur = long2rat(0);
            t_rational curr_tuplet_complete_sym_dur = long2rat(0); 
            t_rational curr_tuplet_unit = long2rat(0); 
            t_rational curr_tuplet_unit_figure = long2rat(0);
            t_rational rhythm_elem_rat;
            t_rational box_onset = long2rat(0);
            long curr_tuplet_multiplier = 1; 
            long exit_in_completeness_cycle = false;
            
            ((t_rhythm_level_properties *)box->l_thing.w_obj)->is_tuplet = false;
            ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_TUPLET;

            // set ratios to the pregressed ratio
            llll_funall(box, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
//            llll_funall(box, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);

            while (rhythm_elem) { // cycle on the rhythm
                long rhythm_elem_sign;
                char stay_inside = true;    
                char is_rhythm_elem_llll = (hatom_gettype(&rhythm_elem->l_hatom) == H_LLLL);
                
                t_llllelem *next_rhythm_elem = rhythm_elem->l_next;
                t_llllelem *next_chord_elem = chord_elem->l_next;
                
                count_rhythm_elem++;
                if (count_rhythm_elem > 100000) { // something's wrong... tuplet too hard...
                    object_warn((t_object *)r_ob, "Warning: tuplet could not be parsed.");
                    break;
                }
                
                if (restart) 
                    restart = false;

                if (is_rhythm_elem_llll)
                    rhythm_elem_rat = is_level_grace(hatom_getllll(&chord_elem->l_hatom)) ? long2rat(0) : get_total_element_rduration(&rhythm_elem->l_hatom, true);
                else
                    rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom);
                rhythm_elem_sign = isign(rhythm_elem_rat.r_num);
                
                count_stay_inside = 0;
                while (stay_inside && (rhythm_elem_sign != 0)) { // if it is a grace level, we just go on
                    t_rational rhythm_elem_rat_abs = rat_abs(rhythm_elem_rat);
                    
                    count_stay_inside ++;
                    if (count_stay_inside > 100) { // something's wrong... tuplet too hard...
                        object_warn((t_object *)r_ob, "Warning: wrong tuplet parsing.");
                        break;
                    }
                    
                    char check_overflow = false;
                    
                    rhythmic_tree_debug_post((t_object *) r_ob, "- Analyzing element: %ld/%ld", rhythm_elem_rat.r_num, rhythm_elem_rat.r_den);
                    
                    if (gotta_complete_a_tuplet) {
                        
                        // there's a tuplet to complete
                        t_rational this_natural_unit = rhythm_elem_rat_abs;
                        
                        // t_rational this_natural_unit_figure = genrat(rhythm_elem_rat_abs.r_num, round(pow(2, floor(log2(rhythm_elem_rat_abs.r_den)))));
                        t_rational unit_ratio = rat_rat_div(this_natural_unit, curr_tuplet_unit);
                        
                        rhythmic_tree_debug_post((t_object *) r_ob, "  There's a tuplet to complete. The unit ratio is %ld/%ld.", unit_ratio.r_num, unit_ratio.r_den);
                        
                        if (unit_ratio.r_den == 1) { 
                        
                            rhythmic_tree_debug_post((t_object *) r_ob, "  The ratio is ok, we go on with ratio: %ld/%ld, tuplet_unit: %ld/%ld, tuplet_unit_figure: %ld/%ld.", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den);
                            
                            count++;
                            // everything is pretty much ok. we might have 1/12 and now 1/6, still we can go on with the same tuplet type.
                        
                        } else { // quite bad; we gotta change tuplet type, diminishing the unit
                            
                            t_rational new_tuplet_complete_sym_dur;
                            t_rational new_unit = rat_gcd(this_natural_unit, curr_tuplet_unit);
                            t_rational new_unit_figure = genrat(new_unit.r_num, round(pow(2, floor(log2(new_unit.r_den)))));
                            // t_rational new_ratio = rat_rat_div(new_unit, new_unit_figure);
                            
                            curr_tuplet_unit = new_unit;
                            curr_tuplet_unit_figure = new_unit_figure;
                            curr_tuplet_ratio = rat_rat_div(new_unit, new_unit_figure);
                            
                            rhythmic_tree_debug_post((t_object *) r_ob, "  Ratio NOT ok: we change the parameters. Now ratio: %ld/%ld, tuplet_unit: %ld/%ld, tuplet_unit_figure: %ld/%ld", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den);
                            
                            new_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            
                            if (rat_rat_cmp(curr_tuplet_sym_dur, new_tuplet_complete_sym_dur) >= 0) { // our cursor would alredy trespass new duration: we change the multiplier
                                curr_tuplet_multiplier = rat_rat_div(curr_tuplet_complete_sym_dur, new_tuplet_complete_sym_dur).r_num;
                                rhythmic_tree_debug_post((t_object *) r_ob, "  Since the duration we had is >= than the new supposed duration (%ld/%ld >= %ld/%ld) we change the multiplier to: %ld", curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den, new_tuplet_complete_sym_dur.r_num, new_tuplet_complete_sym_dur.r_den, curr_tuplet_multiplier);
                            } else {
                                rhythmic_tree_debug_post((t_object *) r_ob, "  Since the duration we had is < than the new supposed duration (%ld/%ld < %ld/%ld) we keep the multiplier: %ld", curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den, new_tuplet_complete_sym_dur.r_num, new_tuplet_complete_sym_dur.r_den, curr_tuplet_multiplier);
                            } 
                            
                            curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            rhythmic_tree_debug_post((t_object *) r_ob, "  This gives a new complete_sym_dur: %ld/%ld", curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                            
                            // ok, we start again with this new unit and ratio, and see what happens
                            restart = true;
                            rhythm_elem = start_tuplet_duration_elem;
                            chord_elem = start_tuplet_chord_elem;
                            
                            box_onset = start_tuplet_box_onset;
                            curr_tuplet_sym_dur = long2rat(0);
                            break;
                        }
                        curr_tuplet_sym_dur = rat_rat_sum(curr_tuplet_sym_dur, rhythm_elem_rat_abs);
                        check_overflow = true;
                        
                    } else {
                        
                        // there's no tuplet to complete
                        long thislog2 = perfect_log2(rhythm_elem_rat_abs.r_den); 
                        
                        if (thislog2 >= 0) {
                            // no tuplet needed    
                            rhythmic_tree_debug_post((t_object *) r_ob, "  There's no tuplet to complete, and the element is regular (not tupled). Just append and go on.");
                            start_tuplet_duration_elem = NULL;
                            start_tuplet_chord_elem = NULL;
                            start_tuplet_box_onset = box_onset;
                            count = 0;
                            
                        } else {
                            // start a new tuplet

                            rhythmic_tree_debug_post((t_object *) r_ob, "  There's no tuplet to complete, but the element is irregular (tupled). We start a tuplet group.");
                            
                            count = 1; 
                            curr_tuplet_multiplier = 1;
                            start_tuplet_duration_elem = rhythm_elem; // pivot element
                            start_tuplet_chord_elem = chord_elem;
                            start_tuplet_box_onset = box_onset;
                            exit_in_completeness_cycle = false;

                            curr_tuplet_unit = rhythm_elem_rat_abs;
                            curr_tuplet_unit_figure = tuplet_unit_to_tuplet_graphical_unit(r_ob, curr_tuplet_unit, r_ob->admit_dotted_tuplets);
                            curr_tuplet_ratio = rat_rat_div(curr_tuplet_unit, curr_tuplet_unit_figure);
                            curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            
                            while (!exit_in_completeness_cycle && (rat_rat_cmp(rat_rat_sum(curr_tuplet_complete_sym_dur, box_onset), box_duration) > 0)) {
                                char can_be_incompleted = false; 
                                t_rational how_many_units_in_the_remaining_box_duration;
                                
                                if (!box_is_standard) { // first we handle the case of nonstandard timesignatures, such as 4/12...
                                    // box is nonstandard
                                    how_many_units_in_the_remaining_box_duration = rat_rat_div(rat_rat_diff(box_duration, box_onset), curr_tuplet_unit);
                                    if (how_many_units_in_the_remaining_box_duration.r_den == 1)
                                        can_be_incompleted = true;
                                }
                                
                                if (can_be_incompleted) {
                                    exit_in_completeness_cycle = true;
                                    curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit, how_many_units_in_the_remaining_box_duration.r_num);
                                } else if (curr_tuplet_unit.r_num > 1) { // on the other hand, if the time signature is standard: if the curr_tuplet_complete_sym_dur 
                                    // is > then the box duration, we try to fit it in the box
                                    long num = curr_tuplet_unit.r_num;
                                    curr_tuplet_unit = rat_long_div(curr_tuplet_unit, num);
                                    curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, num);
                                    curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                                } else if (rat_rat_cmp(rat_rat_sum(rat_long_div(curr_tuplet_complete_sym_dur, 3), box_onset), box_duration) == 0) {
                                    curr_tuplet_unit = rat_long_div(curr_tuplet_unit, 3);
                                    curr_tuplet_unit_figure = tuplet_unit_to_tuplet_graphical_unit(r_ob, curr_tuplet_unit, r_ob->admit_dotted_tuplets);
//                                    curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, 2); // was this
                                    curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                                } else {
                                    curr_tuplet_unit = rat_long_div(curr_tuplet_unit, 2);
                                    curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, 2);
                                    curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                                }
                            }
                            curr_tuplet_sym_dur = rhythm_elem_rat_abs;
                            
                            rhythmic_tree_debug_post((t_object *) r_ob, "  This group has ratio: %ld/%ld, unit: %ld/%ld, unit_figure: %ld/%ld, complete_sym_dur: %ld/%ld.", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den, curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                            
                            check_overflow = true;
                        }
                    }
                    
                    
                    // tuplet has overflown from its global duration?
                    stay_inside = false;
                    if (check_overflow) { 
                        t_rational diff = rat_rat_diff(curr_tuplet_complete_sym_dur, curr_tuplet_sym_dur); // how much is left to achieve the tuplet?

                        rhythmic_tree_debug_post((t_object *) r_ob, "  To achieve the tuplet we need complete_sym_dur: %ld/%ld. With this element we have sym_dur: %ld/%ld", curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den, curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den);
                        
                        if (diff.r_num > 0) { 
                            // tuplet is not ended yet, there's not much to do, just continue
                            rhythmic_tree_debug_post((t_object *) r_ob, "    We still need %ld/%ld to complete the tuplet: we consider another element.", diff.r_num, diff.r_den);
                            gotta_complete_a_tuplet = true;
                            box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                        
                        } else if (diff.r_num < 0 && hatom_gettype(&rhythm_elem->l_hatom) == H_LLLL) {
                            // overflowing, but the overflowing element is a llll! We have to start over, with a finer subdivision...
                            restart = true;
                            gotta_complete_a_tuplet = true;    
                            curr_tuplet_multiplier ++;
                            rhythm_elem = start_tuplet_duration_elem;
                            rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom);
                            chord_elem = start_tuplet_chord_elem;
                            box_onset = start_tuplet_box_onset;
                            curr_tuplet_sym_dur = long2rat(0);
                            curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            
                            rhythmic_tree_debug_post((t_object *) r_ob, "    Tuplet has overflown, but actually we can't split a level, so we modify the multiplier to %ld and restart!", curr_tuplet_multiplier);
                            
                        } else {
                            // tuplet has ended. we write the llll-things
                            
//                            char falsetuplet = (count == 1 && perfect_log2(curr_tuplet_complete_sym_dur.r_den) >= 0);    // unused for now, that's ok
                            t_llll *tuplet_level_durs = NULL;
                            t_llll *tuplet_level_chords = NULL;
                            t_rhythm_level_properties *prop = NULL;
                            
                            if (!start_tuplet_duration_elem->l_prev && !rhythm_elem->l_next && diff.r_num == 0) { // tuplet covers the whole level
                                if (!box->l_thing.w_obj){
                                    prop = build_rhythm_level_properties();
                                    box->l_thing.w_obj = prop;
                                    prop->level_type = k_RHYTHM_LEVEL_ORIGINAL + k_RHYTHM_LEVEL_TUPLET;
                                } else {
                                    prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
                                    prop->level_type |= k_RHYTHM_LEVEL_TUPLET;
                                }
                                tuplet_level_durs = r_durations;
                                tuplet_level_chords = box;
                                rhythmic_tree_debug_post((t_object *) r_ob, "    Tuplet group has ended: it was the whole box. Ratio: %ld/%ld, unit: %ld/%ld, unit_figure: %ld/%ld, multiplier: %ld, complete_sym_dur: %ld/%ld.", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den, curr_tuplet_multiplier, curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                            } else {
                                prop = build_rhythm_level_properties();
                                tuplet_level_durs = llll_wrap_element_range(start_tuplet_duration_elem, rhythm_elem);    // this is just to keep the symmetry between the two rationals and H_OBJs lllls
                                tuplet_level_chords = llll_wrap_element_range(start_tuplet_chord_elem, chord_elem);
                                tuplet_level_chords->l_thing.w_obj = prop;
                                prop->level_type = k_RHYTHM_LEVEL_ADDED + k_RHYTHM_LEVEL_TUPLET;
                                if (box && box->l_thing.w_obj && ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)
                                    prop->level_type |= k_RHYTHM_LEVEL_IGNORE;
                                if (box && box->l_thing.w_obj && ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_KEEP)
                                    prop->level_type |= k_RHYTHM_LEVEL_KEEP;
                                rhythmic_tree_debug_post((t_object *) r_ob, "    Tuplet group has ended. Ratio: %ld/%ld, unit: %ld/%ld, unit_figure: %ld/%ld, multiplier: %ld, complete_sym_dur: %ld/%ld.", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den, curr_tuplet_multiplier, curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                            }

                            // TODO: use <falsetuplet>!!!
                            prop->is_tuplet = true;
                            
                            fill_tupletinfo_fields(r_ob, &prop->tupletinfo, curr_tuplet_unit, pregresse_ratio, rat_rat_prod(curr_tuplet_complete_sym_dur, pregresse_ratio));
                            correct_tuplets_units_and_multiplier_for_level(r_ob, meas, tuplet_level_chords, true);

                            overall_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
                            llll_funall(tuplet_level_chords, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
//                            llll_funall(tuplet_level_chords, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                            
                            if (diff.r_num < 0) { // overflowing!
                                // gotta split the last chord...
                                t_rational old_element_dur = rat_long_prod(rat_rat_diff(rhythm_elem_rat_abs, rat_abs(diff)), rhythm_elem_sign);
                                t_rational new_element_dur = rat_long_prod(rat_abs(diff), rhythm_elem_sign);
                                t_chord *old_ch = (t_chord *)hatom_getobj(&chord_elem->l_hatom);
                                
                                stay_inside = true;
                                
                                rhythmic_tree_debug_post((t_object *) r_ob, "    Tuplet has overflown. We split %ld/%ld = %ld/%ld + %ld/%ld and we continue considering this last element.", rhythm_elem_rat.r_num, rhythm_elem_rat.r_den, old_element_dur.r_num, old_element_dur.r_den, new_element_dur.r_num, new_element_dur.r_den);
                                
                                old_ch->r_sym_duration = rat_rat_prod(old_element_dur, pregresse_ratio);
                                
                                t_chord *new_ch = clone_chord_without_lyrics(r_ob, old_ch, k_CLONE_FOR_SPLIT);
                                new_ch->r_sym_duration = rat_rat_prod(new_element_dur, pregresse_ratio);
                                new_ch->overall_tuplet_ratio = pregresse_ratio;
                                compute_chord_figure(r_ob, new_ch, false);
                                chord_elem = new_ch->rhythmic_tree_elem = llll_insertobj_after(new_ch, tuplet_level_chords->l_owner, 0, WHITENULL_llll);
                                next_chord_elem = chord_elem->l_next;
                                chord_insert_in_measure(r_ob, old_ch->parent, new_ch, old_ch, 0);
                                tie_chord(new_ch->prev);
                                whitenull_tie_from(chord_get_next(new_ch));

                                rhythm_elem = llll_insertrat_after(new_element_dur, tuplet_level_durs->l_owner, 0, WHITENULL_llll);
                                next_rhythm_elem = rhythm_elem->l_next;
                                rhythm_elem_rat = new_element_dur;
                                
                                if (notation_item_is_selected(r_ob, (t_notation_item *)old_ch))
                                    notation_item_add_to_selection(r_ob, (t_notation_item *)new_ch);

                                box_onset = rat_rat_diff(rat_rat_sum(box_onset, rhythm_elem_rat_abs), rat_abs(diff));
                            } else {
                                rhythmic_tree_debug_post((t_object *) r_ob, "    Tuplet is exactly ended. We consider the next element (without needing to complete a tuplet).", diff.r_num, diff.r_den);
                                box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                            }
                            gotta_complete_a_tuplet = false;
                        }
                    } else { 
                        // there was no tuplet
                        box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                    }
                }
                
                if (restart) 
                    continue;
                
                rhythm_elem = next_rhythm_elem;
                chord_elem = next_chord_elem;
            }
        }
        
        llll_free_freethings(r_durations, LLLL_FREETHING_MEM);
        
     }

    return 0;
}

t_rational figure_and_dots_to_figure_sym_duration(t_rational figure, char num_dots){

    figure = rat_abs(figure);
    t_rational res = figure;
    long i, dot_value;
    for (i = 0, dot_value = 2; i < num_dots; i++, dot_value *= 2) {
        res = rat_rat_sum(res, rat_long_div(figure, dot_value));
    }
    return res;
    
/*    
    t_rational res = rat_abs(figure);
    long i;
    for (i = 0; i < num_dots; i++)
        res = rat_rat_sum(res, rat_long_div(res, 2));
    return res; */
}


char are_left_and_right_durations_ok_for_syncopation(t_notation_obj *r_ob, t_chord *left, t_chord *right, t_rational syncopation_position, char left_llll_has_unique_element, t_rational measure_division){
    t_rational left_dur = rat_abs(left->r_sym_duration), right_dur = rat_abs(right->r_sym_duration);
    // gotta make it better: we'll just consider syncopes last-first elem, ignoring the fact that they might be tied to something!
    // rational important parameters to decide whether to accept/refuse a syncopation
    t_rational left_right_ratio = rat_rat_div(rat_abs(left_dur), rat_abs(right_dur));
    if (rat_long_cmp(left_right_ratio, 1) == -1) 
        left_right_ratio = rat_inv(left_right_ratio);
    t_rational pos_dur_ratio = rat_rat_div(genrat(1, syncopation_position.r_den), rat_abs(left_dur)); // 1/2 / (1/4) = 2.; (1/2) / (1/8) = 4.
    
    if (left_right_ratio.r_den != 0 && pos_dur_ratio.r_den != 0 &&
        ((left_llll_has_unique_element && (perfect_log2(rat_rat_div(right_dur, left_dur).r_den) >= 0 ||
                                           rat_rat_div(rat_rat_sum(right_dur, left_dur), measure_division).r_den == 1)) ||
                                            // i.e. it's not a "real" syncopation: it starts on the beginning of this box.
                                            // This should never happen: singleton should be deleted from the tree!
         (rat_double_cmp(left_right_ratio, r_ob->syncopation_asym_ratio, 0.01) <= 0 &&
          rat_double_cmp(pos_dur_ratio, r_ob->syncopation_pos_dur_ratio, 0.01) <= 0 && // ratio is admissible
          get_num_dots(r_ob, right_dur + left_dur) <= r_ob->syncopation_max_dots))) { // maxdots is admissible
            return true;
    }
    return false;
}

// return non-zero if changed
char scan_single_box_for_syncopations(t_notation_obj *r_ob, t_measure *measure, t_llll *box){
    t_llllelem *elem = box->l_head;
    char changed = false;
    t_rational measure_division = ts_to_division(r_ob, &measure->timesignature);
    long box_orig_size = box->l_size;

    // four cases under analysis:
    // a b  --> try to merge a b
    // a (b c)  -> try to merge a b
    // (a b) c  -> try to merge b c
    // (a b) (c d) -> try to merge b c
    
    // we tackle all cases here:
    elem = box->l_head;
    while (elem && elem->l_next){
        t_llllelem *next_elem = elem->l_next;
        char can_retranscribe = false;
        char left_is_obj = (hatom_gettype(&elem->l_hatom) == H_OBJ); 
        char right_is_obj = (hatom_gettype(&elem->l_next->l_hatom) == H_OBJ); 
 
     #ifdef BACH_RHYTHMIC_TREE_DEBUG
        char *buf = NULL;
        llll_to_text_buf(box, &buf, 0, 0, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
        bach_freeptr(buf);
    #endif
    
        if (r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_IGNORE || r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_PROCESS) {
            can_retranscribe = true;
            if (!left_is_obj && (is_level_grace(hatom_getllll(&elem->l_hatom)) || level_contains_nongrace_tuplet(hatom_getllll(&elem->l_hatom)) || is_level_locked(measure, (hatom_getllll(&elem->l_hatom)))))
                can_retranscribe = false;
            else if (!right_is_obj && (is_level_grace(hatom_getllll(&elem->l_next->l_hatom)) || level_contains_nongrace_tuplet(hatom_getllll(&elem->l_next->l_hatom)) || is_level_locked(measure, (hatom_getllll(&elem->l_next->l_hatom)))))
                can_retranscribe = false;
        } else if ((r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_REFINE_ONLY_GRAPHICALLY || r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_REFINE)){
            char left_is_breakable_llll = false; 
            char right_is_breakable_llll = false; 
            if (hatom_gettype(&elem->l_hatom) == H_LLLL){
                t_llll *left = hatom_getllll(&elem->l_hatom);
                if (!is_level_original(left) && !is_level_grace(left) && !level_contains_nongrace_tuplet(left) && !is_level_locked(measure, left))
                    left_is_breakable_llll = true;
            }
            if (hatom_gettype(&elem->l_next->l_hatom) == H_LLLL){
                t_llll *right = hatom_getllll(&elem->l_next->l_hatom);
                if (!is_level_original(right) && !is_level_grace(right) && !level_contains_nongrace_tuplet(right) && !is_level_locked(measure, right))
                    right_is_breakable_llll = true;
            }
            if ((left_is_obj && right_is_obj) || (left_is_breakable_llll && right_is_obj) || (left_is_obj && right_is_breakable_llll) || (left_is_breakable_llll && right_is_breakable_llll))
                can_retranscribe = true;
        }
        
        if (can_retranscribe) {
            
            if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
                
                t_chord *left = (t_chord *) hatom_getobj(&elem->l_hatom);
                if (hatom_gettype(&elem->l_next->l_hatom) == H_OBJ){
                    t_chord *right = (t_chord *) hatom_getobj(&elem->l_next->l_hatom);
                    if (rat_rat_cmp(right->overall_tuplet_ratio, left->overall_tuplet_ratio) == 0 &&            // < should always be true, elements are in the same level!
                        ((left->r_sym_duration.r_num > 0 && right->r_sym_duration.r_num > 0 && chord_is_all_tied_to(r_ob, left, true, NULL)) ||
                         (left->r_sym_duration.r_num < 0 && right->r_sym_duration.r_num < 0))) {
                        t_rational sum = rat_rat_sum(rat_abs(left->r_sym_duration), rat_abs(right->r_sym_duration));
                        t_rational sum_figure = rat_rat_sum(figure_and_dots_to_figure_sym_duration(left->figure, left->num_dots), figure_and_dots_to_figure_sym_duration(right->figure, right->num_dots));
                        t_rational screendur;
                        char numdots;
                        is_duration_drawable(r_ob, sum_figure, &screendur, &numdots);
                        
                        if (numdots >= 0 && numdots <= r_ob->max_dots) {
                            
/*                            char sign = isign(right->r_sym_duration.r_num);
                            right->r_sym_duration = rat_long_prod(sum, sign);
                            transfer_tie_from(left, right);
                            chord_delete_from_measure(r_ob, left, false);
                            compute_chord_figure(r_ob, right, true);
*/
                            
                            char sign = isign(left->r_sym_duration.r_num);
                            left->r_sym_duration = rat_long_prod(sum, sign);

//                            notation_obj_check_force(r_ob, false);

                            transfer_tie_to(right, left);
                            chord_delete_from_measure(r_ob, right, false);
                            compute_chord_figure(r_ob, left, true);
                             
//                            notation_obj_check_force(r_ob, false);
                            
                            if (r_ob->allow_beaming) {
                                set_all_default_beam_numbers(r_ob, box, false);
                                refine_beams_for_level_once(r_ob, box, false, false, true, 0, false);
                                re_check_beams_for_lower_levels(r_ob, measure, box);
                            }

                            changed = true;
                        }
                    }
                } else if (hatom_gettype(&elem->l_next->l_hatom) == H_LLLL) {
                    t_llll *next_llll = hatom_getllll(&elem->l_next->l_hatom);
                    t_chord *right = get_level_start_chord(next_llll, false);
                    t_chord *right_nograce = get_level_start_chord(next_llll, true);

                    if (next_llll && next_llll->l_head && right && right_nograce && right == right_nograce && !is_level_tuplet(next_llll)) {
                        if (rat_rat_cmp(right->overall_tuplet_ratio, left->overall_tuplet_ratio) == 0 &&
                            ((left->r_sym_duration.r_num > 0 && right->r_sym_duration.r_num > 0 && chord_is_all_tied_to(r_ob, left, true, NULL)) ||
                             (left->r_sym_duration.r_num < 0 && right->r_sym_duration.r_num < 0)) &&
                            (!next_llll->l_thing.w_obj || !(((t_rhythm_level_properties *)next_llll->l_thing.w_obj)->is_tuplet))) {
                            t_rational sum = rat_rat_sum(rat_abs(left->r_sym_duration), rat_abs(right->r_sym_duration));
                            t_rational sum_figure = rat_rat_sum(figure_and_dots_to_figure_sym_duration(left->figure, left->num_dots), figure_and_dots_to_figure_sym_duration(right->figure, right->num_dots));
                            t_rational screendur;
                            char numdots;
                            char sign = isign(right->r_sym_duration.r_num);

                            is_duration_drawable(r_ob, sum_figure, &screendur, &numdots);
                            
                            if (numdots >= 0 && numdots <= r_ob->max_dots &&
                                are_left_and_right_durations_ok_for_syncopation(r_ob, left, right, get_rduration_before_beaming_element(measure->rhythmic_tree, elem->l_next, true), false, measure_division)) {

                                // splatter first element of next_llll until it is a list
                                while (hatom_gettype(&next_llll->l_head->l_hatom) == H_LLLL)
                                    llll_splatter(next_llll->l_head, LLLL_FREETHING_MEM);
                                
                                t_llll *new_ll = llll_wrap_element_range(elem, elem->l_next);
                                set_level_type_flag_for_level(new_ll, k_RHYTHM_LEVEL_ADDED);

                                llll_splatter(elem->l_next, LLLL_FREETHING_MEM);

/*                                right->r_sym_duration = rat_long_prod(sum, sign);
                                transfer_tie_from(left, right);
                                chord_delete_from_measure(r_ob, left, false);
                                compute_chord_figure(r_ob, right, true);
*/

//                                notation_obj_check_force(r_ob, false);

                                left->r_sym_duration = rat_long_prod(sum, sign);
                                transfer_tie_to(right, left);
                                chord_delete_from_measure(r_ob, right, false);
                                compute_chord_figure(r_ob, left, true);

//                                notation_obj_check_force(r_ob, false);

                                 verbose_post_rhythmic_tree(r_ob, measure, gensym("step5aa1"), 2);
                                if (r_ob->allow_beaming) {
                                    set_all_default_beam_numbers(r_ob, new_ll, false);
                                    refine_beams_for_level_once(r_ob, new_ll, false, true, true, 0, true);
                                }
                                verbose_post_rhythmic_tree(r_ob, measure, gensym("step5aa2"), 2);

                                next_elem = new_ll->l_owner;
                                changed = true;
                            }
                        }
                        
                    }
                }

            } else if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *this_llll = hatom_getllll(&elem->l_hatom);

                t_chord *left = get_level_end_chord(this_llll, true);
                t_chord *left_nograce = get_level_end_chord(this_llll, false);
                if (this_llll && this_llll->l_tail && left && left_nograce && left == left_nograce && !is_level_tuplet(this_llll)) {
                    
                    if (hatom_gettype(&elem->l_next->l_hatom) == H_OBJ){
                        t_chord *right = (t_chord *) hatom_getobj(&elem->l_next->l_hatom);
                        if (rat_rat_cmp(right->overall_tuplet_ratio, left->overall_tuplet_ratio) == 0 &&
                            ((left->r_sym_duration.r_num > 0 && right->r_sym_duration.r_num > 0 && chord_is_all_tied_to(r_ob, left, true, NULL)) ||
                             (left->r_sym_duration.r_num < 0 && right->r_sym_duration.r_num < 0)) &&
                            (!this_llll->l_thing.w_obj || !(((t_rhythm_level_properties *)this_llll->l_thing.w_obj)->is_tuplet))) {
                            t_rational sum = rat_rat_sum(rat_abs(left->r_sym_duration), rat_abs(right->r_sym_duration));
                            t_rational sum_figure = rat_rat_sum(figure_and_dots_to_figure_sym_duration(left->figure, left->num_dots), figure_and_dots_to_figure_sym_duration(right->figure, right->num_dots));
                            t_rational screendur;
                            char numdots;
                            char sign = isign(right->r_sym_duration.r_num);

                            is_duration_drawable_with_tuplet_info(r_ob, sum_figure, &screendur, &numdots, long2rat(0), long2rat(0));
                            
                            if (numdots >= 0 && numdots <= r_ob->max_dots &&
                                are_left_and_right_durations_ok_for_syncopation(r_ob, left, right, get_rduration_before_beaming_element(measure->rhythmic_tree, elem->l_next, true), this_llll->l_size == 1, measure_division)) {

                                while (hatom_gettype(&this_llll->l_tail->l_hatom) == H_LLLL)
                                    llll_splatter(this_llll->l_tail, LLLL_FREETHING_MEM);


                                t_llll *new_ll = llll_wrap_element_range(elem, elem->l_next);
                                set_level_type_flag_for_level(new_ll, k_RHYTHM_LEVEL_ADDED);
                                llll_splatter(elem, LLLL_FREETHING_MEM);

                                left->r_sym_duration = rat_long_prod(sum, sign);

//                                notation_obj_check_force(r_ob, false);

                                transfer_tie_to(right, left);
                                chord_delete_from_measure(r_ob, right, false);
                                compute_chord_figure(r_ob, left, true);

//                                notation_obj_check_force(r_ob, false);

/*                              right->r_sym_duration = rat_long_prod(sum, sign);
                                transfer_tie_from(left, right);
                                chord_delete_from_measure(r_ob, left, false);
                                compute_chord_figure(r_ob, right, true);
*/
                                if (r_ob->allow_beaming) {
                                    set_all_default_beam_numbers(r_ob, new_ll, false);
                                    refine_beams_for_level_once(r_ob, new_ll, false, true, true, 0, true);
                                }
                                
                                next_elem = new_ll->l_owner;
                                changed = true;
                            }
                        }
                        
                    } else if (hatom_gettype(&elem->l_next->l_hatom) == H_LLLL) {
                        t_llll *next_llll = hatom_getllll(&elem->l_next->l_hatom);
                        t_chord *right = get_level_start_chord(next_llll, false);
                        t_chord *right_nograce = get_level_start_chord(next_llll, true);
                        
//                        if (next_llll && next_llll->l_head && hatom_gettype(&next_llll->l_head->l_hatom) == H_OBJ && !is_level_tuplet(next_llll)) {
//                            t_chord *right = (t_chord *) hatom_getobj(&next_llll->l_head->l_hatom);

                        if (next_llll && next_llll->l_head && right && right_nograce && right == right_nograce && !is_level_tuplet(next_llll)) {
                            
                            if (rat_rat_cmp(right->overall_tuplet_ratio, left->overall_tuplet_ratio) == 0 &&
                                ((left->r_sym_duration.r_num > 0 && right->r_sym_duration.r_num > 0 && chord_is_all_tied_to(r_ob, left, true, NULL)) ||
                                 (left->r_sym_duration.r_num < 0 && right->r_sym_duration.r_num < 0)) &&
                                (!this_llll->l_thing.w_obj || !(((t_rhythm_level_properties *)this_llll->l_thing.w_obj)->is_tuplet)) &&
                                (!next_llll->l_thing.w_obj || !(((t_rhythm_level_properties *)next_llll->l_thing.w_obj)->is_tuplet))) {
                                t_rational sum = rat_rat_sum(rat_abs(left->r_sym_duration), rat_abs(right->r_sym_duration));
                                t_rational sum_figure = rat_rat_sum(rat_rat_prod(left->overall_tuplet_ratio, rat_abs(left->r_sym_duration)), rat_rat_prod(right->overall_tuplet_ratio, rat_abs(right->r_sym_duration)));
                                t_rational screendur;
                                char numdots;
                                char sign = isign(left->r_sym_duration.r_num);

                                is_duration_drawable(r_ob, sum_figure, &screendur, &numdots);
                                
                                if (numdots >= 0 && numdots <= r_ob->max_dots &&
                                    are_left_and_right_durations_ok_for_syncopation(r_ob, left, right, 
                                            get_rduration_before_beaming_element(measure->rhythmic_tree, elem->l_next, true), 
                                            get_num_chords_ignoring_grace_levels(r_ob, this_llll) == 1, measure_division)) { // this_llll->l_size == 1)) {

                                        // splatter first element of next_llll until it is a list
                                        while (hatom_gettype(&next_llll->l_head->l_hatom) == H_LLLL)
                                            llll_splatter(next_llll->l_head, LLLL_FREETHING_MEM);
                                        
                                        // splatter last element of next_llll until it is a list
                                        while (hatom_gettype(&this_llll->l_tail->l_hatom) == H_LLLL)
                                            llll_splatter(this_llll->l_tail, LLLL_FREETHING_MEM);
                                        
                                        t_llll *new_ll = llll_wrap_element_range(elem, elem->l_next);
                                        set_level_type_flag_for_level(new_ll, k_RHYTHM_LEVEL_ADDED);
                                        
                                        t_llllelem *nextel = elem->l_next;
                                        llll_splatter(elem, LLLL_FREETHING_MEM);
                                        llll_splatter(nextel, LLLL_FREETHING_MEM);
                                        
/*                                        right->r_sym_duration = rat_long_prod(sum, sign);
                                        transfer_tie_from(left, right);
                                        chord_delete_from_measure(r_ob, left, false);
                                        compute_chord_figure(r_ob, right, true);
*/

                                        left->r_sym_duration = rat_long_prod(sum, sign);
                                        
//                                        notation_obj_check_force(r_ob, false);

                                        transfer_tie_to(right, left);
                                        chord_delete_from_measure(r_ob, right, false);
                                        compute_chord_figure(r_ob, left, true);
                                        
//                                        notation_obj_check_force(r_ob, false);

                                        if (r_ob->allow_beaming) {
                                            if (sign < 0) {
                                                set_max_beam_number_if_under_beam_for_level(new_ll, 0);
                                                set_max_beam_number_for_level(new_ll, 0);
                                                set_beam_number_for_level(new_ll, 0);
                                            } else {
                                                set_all_default_beam_numbers(r_ob, new_ll, false);
                                            }
                                            
                                            refine_beams_for_level_once(r_ob, new_ll, false, true, true, 0, true);
                                        }
                                        
                                        next_elem = new_ll->l_owner;
                                        changed = true;
                                }
                            }
                            
                        }
                    }
                }
            }
        }
        elem = next_elem;
    }
    
    if (box->l_size == 1 && is_level_tuplet(box) && box_orig_size > 1) {
        // we have deleted the tuplet!
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj;
        prop->is_tuplet = false;
        prop->tupletinfo.tuplet_local_ratio = long2rat(1);
    }
    
    return changed;
}



void handle_tree_syncopations(t_notation_obj *r_ob, t_measure *measure){
    t_llll *scanned = llll_scan(measure->rhythmic_tree, true);
    t_llllelem *scannedelem;
    char changed = false;
    
    llll_flatten(scanned, 1, 0);
    
    llll_prependobj(scanned, WHITENULL_llll, 0, WHITENULL_llll); // hack, to treat the root list
    
    for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
        if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
            t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
            
            if (elem == WHITENULL || hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *box = (elem == WHITENULL_llllelem) ? measure->rhythmic_tree : hatom_getllll(&elem->l_hatom);
                if (box->l_depth > 0 && r_ob->tree_handling != k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED && !is_level_locked(measure, box)) {
                    changed |= scan_single_box_for_syncopations(r_ob, measure, box);
                }
            }
        }
    }
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step5aa"), 2);
    check_correct_beaming(r_ob, measure);
    
    llll_free(scanned);
}




long get_average_scaleposition_point_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    double *curr_val = (double *) ((void **)data)[1];
    long *curr_count = (long *) ((void **)data)[2];
    if (hatom_gettype(a) == H_OBJ){
        t_chord *this_chord = (t_chord *)hatom_getobj(a);
        if (this_chord->r_sym_duration.r_num > 0){
            t_note *temp_note;
            for (temp_note = this_chord->firstnote; temp_note; temp_note = temp_note->next) {
                note_compute_approximation(r_ob, temp_note);
                *curr_val += midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(temp_note));
                (*curr_count)++;
            }
        }
    } else if (hatom_gettype(a) == H_LLLL && address->l_size > 0 && is_level_grace(hatom_getllll(a)))
        return 1;
    
    return 0;
}

double get_average_scaleposition_point_for_level(t_notation_obj *r_ob, t_llll *box){
    void *data[3];
    double curr_val = 0;
    long curr_count = 0;
    data[0] = r_ob;
    data[1] = &curr_val;
    data[2] = &curr_count;
    llll_funall(box, get_average_scaleposition_point_for_level_fn, data, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
    return curr_val/curr_count;
}

long impose_chord_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    char direction = *((char *)data);
    if (hatom_gettype(a) == H_OBJ){
        t_chord *this_chord = (t_chord *)hatom_getobj(a);
        this_chord->imposed_direction = direction;
        this_chord->need_recompute_parameters = true;
    }
    return 0;
}


// ignoring beamings!!! as if the chord was NOT beamed
char chord_get_default_stem_direction(t_notation_obj *r_ob, t_chord *ch)
{
    long count;
    double avg;
    t_note *note;
    
    if (voiceensemble_get_numparts(r_ob, (t_voice *)ch->parent->voiceparent) > 1)
        return ch->parent->voiceparent->v_ob.part_index % 2 == 0 ? 1 : -1;
    
    for (avg = 0, count = 0, note = ch->firstnote; note; note = note->next, count++)
        avg += midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(note));
    avg /= count;
    
    if (avg >= get_middle_scaleposition(r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? get_voice_clef(r_ob, (t_voice *)ch->parent->voiceparent) : get_voice_clef(r_ob, (t_voice *)ch->voiceparent)))
        return -1;
    else
        return 1;
}

long decide_beaming_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_measure *measure = (t_measure *) ((void **)data)[1];
    char grace_only = *((char *) ((void **)data)[2]);
    
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        if (box && box->l_thing.w_obj){
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *) box->l_thing.w_obj;
            if ((!grace_only && (prop->beam_number > 0 || prop->is_tuplet))
                       || (grace_only && prop->is_grace)){
                
                double average_scaleposition = get_average_scaleposition_point_for_level(r_ob, box);
                char beaming_direction = (average_scaleposition >= get_middle_scaleposition(get_voice_clef(r_ob, (t_voice *)measure->voiceparent)) ? -1 : 1);
                char in_voiceensemble = (voiceensemble_get_numparts(r_ob, (t_voice *)measure->voiceparent) > 1);

                if (grace_only && r_ob->reverse_grace_chord_direction) {
                    t_llllelem *lastelem = get_last_non_llll_elem(box);
                    t_chord *last_chord = lastelem ? (t_chord *)hatom_getobj(&lastelem->l_hatom) : NULL;
                    if (last_chord) {
                        t_chord *temp = last_chord->next;
                        while (temp && temp->is_grace_chord)
                            temp = temp->next;
                        if (temp) 
                            beaming_direction = temp->imposed_direction ? -temp->imposed_direction : -chord_get_default_stem_direction(r_ob, temp);
                    }
                }

                if (in_voiceensemble)
                    beaming_direction = measure->voiceparent->v_ob.part_index % 2 == 0 ? 1 : -1;
                
                if (prop->beam_number == 0 && prop->is_tuplet){
                    // setting new direction information for the unbeamed tuplet (gotta reverse the beaming, unless we are in a voice ensemble)
                    ((t_rhythm_level_properties *) box->l_thing.w_obj)->direction = (in_voiceensemble ? beaming_direction : -beaming_direction);
                    return 0;
                } else {
                    // imposing direction to all chords (so that the future calculate_chord_parameters() will take it into account)
                    llll_funall(box, impose_chord_direction_for_level_fn, &beaming_direction, 1, -1, 0);
                    
                    // setting new direction information
                    ((t_rhythm_level_properties *) box->l_thing.w_obj)->direction = beaming_direction;
                    set_direction_for_level(box, beaming_direction);
                    return 1; // STOP, don't go further in depth with the iteration!
                }
            }
        }
    }
    return 0;
}

void decide_beaming_direction(t_notation_obj *r_ob, t_measure *measure){
    void *data[3];
    char grace_only = false;
    data[0] = r_ob;
    data[1] = measure;
    data[2] = &grace_only;
    
    llll_funall(measure->rhythmic_tree, decide_beaming_direction_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);    

    grace_only = true;
    llll_funall(measure->rhythmic_tree, decide_beaming_direction_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);    
}


long get_num_tuplets_outside_level(t_llll *level){
    long count = 0;
    t_llll *temp = level->l_owner ? level->l_owner->l_parent : NULL;
    while (temp){
        t_rhythm_level_properties *prop = temp->l_thing.w_obj ? (t_rhythm_level_properties *)temp->l_thing.w_obj : NULL;
        if (prop && prop->is_tuplet > 0)
            count++;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return count;
}

long get_num_tuplets_inside_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0){
        t_llll *box = hatom_getllll(a);
        if (box && box->l_thing.w_obj && ((t_rhythm_level_properties *)box->l_thing.w_obj)->is_tuplet > 0)
            *((long *)data) = *((long *)data) + 1;
    }
    return 0;
}

long get_num_tuplets_inside_level(t_llll *level){
    long count = 0;
    llll_funall(level, get_num_tuplets_inside_level_fn, &count, 1, -1, FUNALL_SKIP_ATOMS);
    return count;
}


t_llll *find_largest_beam_containing_level(t_llll *level){
    t_llll *temp;
    t_llllelem *elem = level->l_owner;
    t_llll *res = NULL;
    t_llllelem *tempelem = elem;
    
    if (level->l_thing.w_obj && ((t_rhythm_level_properties *)level->l_thing.w_obj)->beam_number > 0)
        res = level;
    
    if (!elem)
        return res;
    
    temp = elem->l_parent;
    while (temp){
        t_rhythm_level_properties *prop = temp->l_thing.w_obj ? (t_rhythm_level_properties *)temp->l_thing.w_obj : NULL;
        if (prop && prop->beam_number > 0)
            res = temp;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    
    if (!res){
        // isn't the largest beam coinciding with the level and INSIDE the level
        while (hatom_gettype(&tempelem->l_hatom) == H_LLLL){
            t_llll *inner = hatom_getllll(&tempelem->l_hatom);
            if (inner->l_size == 1 && hatom_gettype(&inner->l_head->l_hatom) == H_LLLL) {
                t_llll *this_ll = hatom_getllll(&inner->l_head->l_hatom);
                t_rhythm_level_properties *prop = this_ll->l_thing.w_obj ? (t_rhythm_level_properties *)this_ll->l_thing.w_obj : NULL;
                if (prop && prop->beam_number > 0)
                    return this_ll;
                tempelem = inner->l_head;
            } else
                break;
        }
    }
    
    return res;
}

t_llll *find_first_tuplet_level_containing_element(t_llllelem *elem){
    t_llll *temp = elem->l_parent;
    while (temp){
        t_rhythm_level_properties *prop = temp->l_thing.w_obj ? (t_rhythm_level_properties *)temp->l_thing.w_obj : NULL;
        if (prop && prop->is_tuplet > 0)
            return temp;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return NULL;
}

long decide_tuplet_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    char is_in_voiceensemble = *((char *)data);
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        if (box && box->l_thing.w_obj){
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *) box->l_thing.w_obj;
            if (prop->is_tuplet) {
                t_llll *rootbeamlevel = find_largest_beam_containing_level(box);
                if (rootbeamlevel){
                    t_chord *root_start_ch = get_level_start_chord(rootbeamlevel, true);
                    t_chord *root_end_ch = get_level_end_chord(rootbeamlevel, true);
                    t_chord *box_start_ch = get_level_start_chord(box, true);
                    t_chord *box_end_ch = get_level_end_chord(box, true);
                    prop->tupletinfo.is_over_beam = true;
                    if (is_in_voiceensemble || (root_end_ch == box_end_ch && root_start_ch == box_start_ch)){
                        prop->tupletinfo.is_completely_on_solitary_beam_level = true;
                        prop->direction = ((t_rhythm_level_properties *)rootbeamlevel->l_thing.w_obj)->direction;
                    } else {
                        prop->direction = -((t_rhythm_level_properties *)rootbeamlevel->l_thing.w_obj)->direction;
                        prop->tupletinfo.is_completely_on_solitary_beam_level = false;
                    }
                } else {
                    prop->tupletinfo.is_completely_on_solitary_beam_level = false;
                    prop->tupletinfo.is_over_beam = false;
                    // ...and we leave the direction untouched
                }
            }
        }
    }
    return 0;
}

// BEWARE: ignores the ancestors of length 1!
t_llll *get_first_ancestor_having_a_beam(t_notation_obj *r_ob, t_llllelem *elem){
    t_llll *parent = elem->l_parent;
    while (parent){
        if (parent->l_thing.w_obj && ((t_rhythm_level_properties *)parent->l_thing.w_obj)->beam_number > 0 && parent->l_size > 1 && get_num_chords_ignoring_grace_levels(r_ob, parent) > 1)
            return parent;
        parent = parent->l_owner ? parent->l_owner->l_parent : NULL;
    }
    return NULL;
}

// BEWARE: ignores the ancestors of length 1!
char get_highest_ancestor_beam_number(t_llllelem *elem, char stop_to_grace_levels){
    t_llll *parent = elem->l_parent;
    char res = 0;
    while (parent){
        if (parent->l_thing.w_obj && ((t_rhythm_level_properties *)parent->l_thing.w_obj)->beam_number > res && level_size_except_for_grace(parent) > 1)
            res = ((t_rhythm_level_properties *)parent->l_thing.w_obj)->beam_number;
        if (stop_to_grace_levels && is_level_grace(parent))
            return res;
        parent = parent->l_owner ? parent->l_owner->l_parent : NULL;
    }
    return res;
}


void set_beams_depth_to_chords(t_notation_obj *r_ob, t_measure *measure){
    t_chord *chord;
    for (chord = measure->firstchord; chord; chord = chord->next){
        char parent_beam_number = get_highest_ancestor_beam_number(chord->rhythmic_tree_elem, true);
        char chord_num_beams = 0;
        if (parent_beam_number > 0 && (chord_num_beams = get_num_beams_from_figure(chord->figure)) > parent_beam_number && chord->r_sym_duration.r_num > 0)
            chord->beams_depth = chord_num_beams;    // it'll be a tick: it's a higher beam requested inside a lower (nonnull) beam 
        else 
            chord->beams_depth = parent_beam_number;
    }
}

char* get_strings_for_rhythmic_tree_elements_verbosity3(t_hatom *h, long maxdecimals){
    return get_strings_for_rhythmic_tree_elements_options(h, 3);
}

char* get_strings_for_rhythmic_tree_elements_verbosity2(t_hatom *h, long maxdecimals){
    return get_strings_for_rhythmic_tree_elements_options(h, 2);
}

char* get_strings_for_rhythmic_tree_elements_verbosity1(t_hatom *h, long maxdecimals){
    return get_strings_for_rhythmic_tree_elements_options(h, 1);
}

char* get_strings_for_rhythmic_tree_elements_verbosity0(t_hatom *h, long maxdecimals){
    return get_strings_for_rhythmic_tree_elements_options(h, 0);
}

// *string must be already sized of at least 21 chars!
void level_type_to_level_string(long level_type, char *string){
    char is_ts = ((level_type & k_RHYTHM_LEVEL_TS_BOX) > 0);
    char is_tuplet = ((level_type & k_RHYTHM_LEVEL_TUPLET) > 0);
    char is_ignore = ((level_type & k_RHYTHM_LEVEL_IGNORE) > 0);
    char is_grace = ((level_type & k_RHYTHM_LEVEL_GRACE) > 0);
    char is_keep = ((level_type & k_RHYTHM_LEVEL_KEEP) > 0);
    char is_force_tuplet = ((level_type & k_RHYTHM_LEVEL_FORCE_TUPLET) > 0);
    snprintf_zero(string, 21, "??");
    if (level_type & k_RHYTHM_LEVEL_ORIGINAL)
        snprintf_zero(string, 21, "OR%s%s%s%s%s%s", is_ts ? "+TS" : "", is_tuplet ? "+TU" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_TS_BOX)
        snprintf_zero(string, 21, "TS%s%s%s%s%s", is_tuplet ? "+TU" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_ADDED)
        snprintf_zero(string, 21, "AD%s%s%s%s%s%s", is_ts ? "+TS" : "", is_tuplet ? "+TU" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_DISPLAY_ONLY)
        snprintf_zero(string, 21, "DI%s%s%s%s%s%s", is_ts ? "+TS" : "", is_tuplet ? "+TU" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_TUPLET)
        snprintf_zero(string, 21, "TU%s%s%s%s%s", is_ts ? "+TS" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_IGNORE)
        snprintf_zero(string, 21, "IG%s%s%s%s%s", is_ts ? "+TS" : "", is_tuplet ? "+TU" : "", is_keep ? "+KE" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_KEEP)
        snprintf_zero(string, 21, "KE%s%s%s%s%s", is_ts ? "+TS" : "", is_tuplet ? "+TU" : "", is_ignore ? "+IG" : "", is_grace ? "+GR" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_GRACE)
        snprintf_zero(string, 21, "GR%s%s%s%s%s", is_ts ? "+TS" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_tuplet ? "+TU" : "", is_force_tuplet ? "+FT" : "");
    else if (level_type & k_RHYTHM_LEVEL_FORCE_TUPLET)
        snprintf_zero(string, 21, "FT%s%s%s%s%s", is_ts ? "+TS" : "", is_ignore ? "+IG" : "", is_keep ? "+KE" : "", is_tuplet ? "+TU" : "", is_grace ? "+GR" : "");
}

char* get_strings_for_rhythmic_tree_elements_options(t_hatom *h, char verbosity_level){
    char *out;
    if (hatom_gettype(h) == H_OBJ) {
        t_chord *chord = (t_chord *)hatom_getobj(h);
        out = (char *)bach_newptr(21 * sizeof(char));
        #ifdef BACH_POST_IDS_IN_RHYTHMIC_TREE_DEBUG // also print IDs
        if (verbosity_level == 3)
            snprintf_zero(out, 20, chord_is_all_tied_to(NULL, chord, false, NULL) ? "id%ld.%ld/%ld.%p t" : "id%ld.%ld/%ld.%p", chord->r_it.ID, chord->r_sym_duration.r_num, chord->r_sym_duration.r_den, chord->rhythmic_tree_elem);
        else
            snprintf_zero(out, 20, chord_is_all_tied_to(NULL, chord, false, NULL) ? "id%ld.%ld/%ld t" : "id%ld.%ld/%ld", chord->r_it.ID, chord->r_sym_duration.r_num, chord->r_sym_duration.r_den);
        #else
        if (verbosity_level == 3)
            snprintf_zero(out, 20, chord_is_all_tied_to(NULL, chord, false, NULL) ? "%ld/%ld.%p t" : "%ld/%ld.%p", chord->r_sym_duration.r_num, chord->r_sym_duration.r_den, chord->rhythmic_tree_elem);
        else
            snprintf_zero(out, 20, chord_is_all_tied_to(NULL, chord, false, NULL) ? "%ld/%ld t" : "%ld/%ld", chord->r_sym_duration.r_num, chord->r_sym_duration.r_den);
        #endif
        return out;
    } else if (hatom_gettype(h) == H_LLLL && hatom_getllll(h)->l_thing.w_obj) {
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *) hatom_getllll(h)->l_thing.w_obj;
        char tuplet_string[140];
        if (verbosity_level == 0) {
            out = (char *)bach_newptr(15 * sizeof(char));    
            snprintf_zero(out, 14, "{}"); 
        } else {
            char level_string[25];
            level_type_to_level_string(prop->level_type, level_string);
            if (prop->is_tuplet){
                snprintf_zero(tuplet_string, 139, "<r%ld/%ld u%ld/%ld gu%ld/%ld d%ld/%ld m%ld c%d>", prop->tupletinfo.tuplet_local_ratio.r_num, prop->tupletinfo.tuplet_local_ratio.r_den, 
                              prop->tupletinfo.tuplet_unit.r_num, prop->tupletinfo.tuplet_unit.r_den, prop->tupletinfo.tuplet_graphical_unit.r_num, prop->tupletinfo.tuplet_graphical_unit.r_den,
                              prop->tupletinfo.tuplet_sym_duration.r_num, prop->tupletinfo.tuplet_sym_duration.r_den, prop->tupletinfo.tuplet_multiplier, (int) prop->tupletinfo.is_tuplet_completed);
            } else {
                snprintf_zero(tuplet_string, 139, "<>");
            }
            out = (char *)bach_newptr(250 * sizeof(char));
            if (verbosity_level == 1 || (prop->beam_number == 0 && verbosity_level != 4 && !prop->is_grace && !prop->is_tuplet))
                snprintf_zero(out, 250, "{ty%s be%d ut%d ut_%d}", level_string, (int) prop->beam_number, (int) prop->max_beam_number, (int) prop->max_beam_number_if_under_beam);
            else
                snprintf_zero(out, 250, "{ty%s be%d ut%d ut_%d dir%s sl%.1f gr%d, tu%s}", level_string, (int) prop->beam_number, (int) prop->max_beam_number,  (int) prop->max_beam_number_if_under_beam
                              , prop->direction == 1 ? "^" : (prop->direction == -1 ? "v" : "-"), prop->beam_slope,
                              (int) prop->is_grace, tuplet_string);
        }
        return out;
    }
    
    return NULL;
}

void* ignore_l_thing_fn(void *x){
    return NULL;
}

void* clone_rhythm_level_properties_fn(void *x){
    t_rhythm_level_properties *prop;
    
    if (!x) 
        return NULL;
    
    prop = build_rhythm_level_properties();
    *prop = *((t_rhythm_level_properties *)x);

    return prop;
}

long check_tree_1_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_OBJ) {
        t_chord *ch = (t_chord *)hatom_getobj(a);
        if (!ch->rhythmic_tree_elem)
            dev_post("TREE IS WRONG!");
        if (ch->r_sym_duration.r_den == 0)
            dev_post("TREE IS WRONG!");
    }
    return 0;
}

void post_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure, t_symbol *frontsymbol, char verbosity_level){
//    char measnum[100];
//        sprintf(measnum, "m%ld, v%ld", measure->measure_number + 1, measure->voiceparent->v_ob.number + 1);

    if (measure && measure->rhythmic_tree){
        llll_post_named(measure->rhythmic_tree, 0, 1, 0, frontsymbol,
                   verbosity_level == 3 ? get_strings_for_rhythmic_tree_elements_verbosity3 : 
                   (verbosity_level == 2 ? get_strings_for_rhythmic_tree_elements_verbosity2 : 
                    (verbosity_level == 0 ? get_strings_for_rhythmic_tree_elements_verbosity0 : get_strings_for_rhythmic_tree_elements_verbosity1)));

        llll_funall(measure->rhythmic_tree, check_tree_1_fn, NULL, 1, -1, 0);

        // check leaves
        t_chord *ch;
        if (measure->num_chords == 0 && measure->rhythmic_tree->l_size > 0)
            dev_post("Weird tree!");
        
        for (ch = measure->firstchord; ch; ch = ch->next)
            if (!ch->rhythmic_tree_elem || llllelem_root(ch->rhythmic_tree_elem) != measure->rhythmic_tree)
                dev_post("Chord with no beaming tree elem or wrong");
    }
}


long one_but_last_level(t_llll *llll){
    return llll->l_depth > 1 ? -2 : -1;
}

long two_but_last_level(t_llll *llll){
    return llll->l_depth > 2 ? -3 : (llll->l_depth > 1 ? -2 : -1);
}

char there_is_a_ignore_level_at_first_level(t_llll *tree){
    t_llllelem *elem;
    if (tree->l_thing.w_obj && ((t_rhythm_level_properties *)tree->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)
        return 1;
    for (elem = tree->l_head; elem; elem = elem->l_next)
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && hatom_getllll(&elem->l_hatom)->l_thing.w_obj &&
            ((t_rhythm_level_properties *)hatom_getllll(&elem->l_hatom)->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_IGNORE)
            return 1;
    return 0;
}


long mark_levels_with_no_lthing_as_original_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        if (ll && !ll->l_thing.w_obj){
            t_rhythm_level_properties *prop = build_rhythm_level_properties();
            prop->level_type = k_RHYTHM_LEVEL_ORIGINAL;
            ll->l_thing.w_obj = prop;
        }
    }
    return 0;
}

long set_is_grace_flag_to_all_chords_fn(void *data, t_hatom *a, const t_llll *address){
    char val = *((char *) data); 
    if (hatom_gettype(a) == H_OBJ)
        ((t_chord *)hatom_getobj(a))->is_grace_chord = val;
    else if (hatom_gettype(a) == H_LLLL && val == 0 && is_level_grace(hatom_getllll(a)))
        return 1;
    return 0;
}

long set_is_grace_flag_to_chords_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *ll = hatom_getllll(a);
        if (is_level_grace(ll)) {
            char val = true;
            llll_funall(ll, set_is_grace_flag_to_all_chords_fn, &val, 1, -1, 0);
            return 1;
        } else {
            char val = false;
            llll_funall(ll, set_is_grace_flag_to_all_chords_fn, &val, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
            return 0;
        }
    }
    return 0;
}

void whitenull_tie_from(t_chord *ch)
{
    t_note *nt1;
    if (!ch)
        return;
    for (nt1 = ch->firstnote; nt1; nt1 = nt1->next)
        if (nt1->tie_from) 
            nt1->tie_from = (t_note *) WHITENULL;
}

void transfer_tie_from(t_chord *from, t_chord *to)
{
    t_note *nt1, *nt2;
    for (nt1 = from->firstnote, nt2 = to->firstnote; nt1 && nt2; nt1 = nt1->next, nt2 = nt2->next)
        nt2->tie_from = nt1->tie_from;
}

void transfer_tie_to(t_chord *from, t_chord *to)
{
    t_note *nt1, *nt2;
    for (nt1 = from->firstnote, nt2 = to->firstnote; nt1 && nt2; nt1 = nt1->next, nt2 = nt2->next)
        nt2->tie_to = nt1->tie_to;
}


// Process the rhythmic tree
void process_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure, long beaming_calculation_flags)
{
    t_chord *tmp_chord;
    t_rational division;
    void *data[5];
    char changed_flag = false;
    char all_flattened = false;
    char is_in_voiceensemble = (voiceensemble_get_numparts(r_ob, (t_voice *)measure->voiceparent) > 1);
    data[0] = r_ob;
    data[1] = measure;    
    data[2] = &changed_flag;
    data[3] = &beaming_calculation_flags;
    data[4] = &all_flattened;
    
/*    
    t_llll *debug = llll_from_text_buf(" ( 1/12 1/12 1/12 1/12 ) (-1/8 1/8) ( 1/12 1/12 1/12 ) 1/44 ");
    llll_check(debug);
    llll_funall(debug, foo_fn, NULL, 1, -2, FUNALL_SKIP_ATOMS);    
    llll_free(debug);
*/    
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step0"), 1);

    #ifdef BACH_RHYTHMIC_TREE_DEBUG
    char *buff = NULL, *buff2 = NULL;
    llll_to_text_buf(measure->rhythmic_tree, &buff, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
    llll_to_text_buf(measure->rhythmic_tree, &buff2, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity0);
    bach_freeptr(buff);
    bach_freeptr(buff2);
    #endif
    
//    notation_obj_check_force(r_ob, false);

    // Don't impose any direction to the chords
    for (tmp_chord = measure->firstchord; tmp_chord; tmp_chord = tmp_chord->next) 
        tmp_chord->imposed_direction = 0; // By default, we don't impose any direction! 

    llll_check(measure->rhythmic_tree);
    
    if (!measure->lock_rhythmic_tree && (!r_ob->allow_beaming || r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_IGNORE)
        && !(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS)) { // ignoring any beam? Starting from scratch!
        flat_preserving_leveltypes(measure->rhythmic_tree, 0, 0, k_RHYTHM_LEVEL_GRACE, LLLL_FREETHING_MEM, r_ob);
        all_flattened = true;
    }

    llll_check(measure->rhythmic_tree);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step1"), 1);

    // flattening the ignore levels
    if (!(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_DELETE_LEVELS))
        llll_funall(measure->rhythmic_tree, flatten_ignore_levels_fn, r_ob, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    llll_check(measure->rhythmic_tree);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step1b"), 1);

    // set <is_grace_flag> to grace levels, and avoids double grace levels
    if (!(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_DELETE_LEVELS))
        llll_funall(measure->rhythmic_tree, tidy_up_grace_levels_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    llll_check(measure->rhythmic_tree);
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step1c"), 1);

    llll_funall(measure->rhythmic_tree, mark_levels_with_no_lthing_as_original_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    llll_check(measure->rhythmic_tree);
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step1d"), 1);

    llll_check(measure->rhythmic_tree);

    // splitting according to time signature
    if (r_ob->autoparse_rhythms && !(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS)) {
        
        // We get the standard boxes
        t_llll *boxes;
        
        if (measure->custom_boxing) {
            t_rational sum, meas_sym_dur = measure_get_sym_duration(measure), diff;
            boxes = llll_clone(measure->boxes);
            sum = llll_sum_abs_of_rat_llll(boxes);
            diff = rat_rat_div(meas_sym_dur, sum);
            if (rat_long_cmp(diff, 0) < 0)
                llll_appendrat(boxes, diff, 0, WHITENULL_llll);
            division = llll_gcd_of_rat_llll(boxes);
        } else 
            boxes = ts_to_beaming_boxes(r_ob, &measure->timesignature, NULL, &division);
        
        llll_check(measure->rhythmic_tree);

        if (((t_rhythm_level_properties *) measure->rhythmic_tree->l_thing.w_obj)->level_type == k_RHYTHM_LEVEL_IGNORE ||
            (!measure->lock_rhythmic_tree && (r_ob->make_tree_compatible_with_ts || r_ob->tree_handling == k_RHYTHMIC_TREE_HANDLING_IGNORE)))
            split_first_level_according_to_boxes(r_ob, measure, boxes, false, (beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS) > 0);
        else if (there_is_a_ignore_level_at_first_level(measure->rhythmic_tree))
            split_first_level_according_to_boxes(r_ob, measure, boxes, true, (beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS) > 0);
        llll_free(boxes);
    }
    

    llll_check(measure->rhythmic_tree);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step2"), 1);

    if (r_ob->autoparse_rhythms && !(beaming_calculation_flags & (k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS | k_BEAMING_CALCULATION_DONT_CHANGE_TIES))) {
        changed_flag = true;
        while (changed_flag) {
            changed_flag = false;
            llll_check(measure->rhythmic_tree);
            llll_funall(measure->rhythmic_tree, merge_rests_and_alltied_chords_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
            llll_check(measure->rhythmic_tree);
            flatten_singleton_levels(r_ob, measure, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET);
            llll_check(measure->rhythmic_tree);
        }
    }    
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step2a"), 1);

    llll_check(measure->rhythmic_tree); 

    // find the tuplets and add the info in the structure
    changed_flag = 0; // < Abuse: this is used NOT to force existing tuplets
    llll_funall(measure->rhythmic_tree, find_tuplets_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    // TODO: see if we can gather tuplets into larger groups
    // which was the properly_retranscribe_tuplet() task

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step2b"), 2);

    // make rhythm drawable in each level
    llll_funall(measure->rhythmic_tree, get_rhythm_drawable_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step3"), 2);
    
    // we reset the beam number for all levels, we'll calculate them again later
    llll_funall(measure->rhythmic_tree, reset_beam_number_for_level_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step3b"), 1);

    // we refine the beamings
    if (r_ob->allow_beaming)
        assign_default_beam_numbers_and_refine_beams(r_ob, measure, measure->rhythmic_tree, beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_ADD_LEVELS, true);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4"), 1);

    // We remove singletons and multiple brackets: no such things as (a), (b), ((a b)) or (((b c))), except if there's a single tick!! (as octave. sixteenth)
    if (!(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_DELETE_LEVELS))
        flatten_singleton_levels(r_ob, measure, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4b"), 2);
    
    // Check if the tuplets are correct. This step is due to the fact that, for instance, if we had as durations 
    // ((1/12 1/24 1/24 1/12) ...)
    correct_tuplets(r_ob, measure, beaming_calculation_flags);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4w"), 2);
    
    // then we fix the tuplets which are NOT tuplets any longer (to avoid weird 1's around the score)
    llll_funall(measure->rhythmic_tree, fix_nontuplets_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step4z"), 2);
    
    // This function ALSO checks the correct number of beamings per level. E.g. {be2}({be2}(1/8 1/16 1/16) 1/16 1/16) will either be set to {be1}({be2}(1/8 1/16 1/16) {be2}(1/16 1/16))
    // or {be1}({be2}(1/8 1/16 1/16) 1/16 1/16) i.e. the external list will have just a single beam, and the two single 1/6 will have a 2nd-beam-tick. 
    // Also we'll have cases such {be1} : {be1}(...) {be0}(...) {be1}(...) where the first global list will have to be {be0}
    check_correct_beaming(r_ob, measure);

//    notation_obj_check_force(r_ob, false);  // THIS ONE DOESN'T
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step5a"), 2);
    
    // We deal with syncopations
    // starting from the innermost levels, we try to gather levels if tye are k_RHYTHM_LEVEL_ADDED or k_RHYTHM_LEVEL_DISPLAY_ONLY, and if syncopations apply, 
    // or if things can be written with dots (e.g. q. p instead of q ^ p p)
    if (r_ob->autoparse_rhythms && !(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS) && !(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS))
            handle_tree_syncopations(r_ob, measure);
    
//    notation_obj_check_force(r_ob, false);  // THIS ONE CRASHES

    validate_accidentals_for_measure(r_ob, measure); // after the syncopations accidentals might have changed
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step5b"), 2);

    // we convert all the k_RHYTHM_LEVEL_IGNORE and k_RHYTHM_LEVEL_KEEP levels into k_RHYTHM_LEVEL_ADDED levels. The ignore-levels are only used when the user
    // asks for automatic recomputation of the tree.
    llll_funall(measure->rhythmic_tree, convert_ignore_and_keep_levels, r_ob, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step6"), 2);
    
    // remove singleton again
    if (!(beaming_calculation_flags & k_BEAMING_CALCULATION_DONT_DELETE_LEVELS))
        flatten_singleton_levels(r_ob, measure, k_RHYTHM_LEVEL_TS_BOX | k_RHYTHM_LEVEL_FORCE_TUPLET);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step7"), 2);

    // set <is_grace> to flag to chords in grace levels (and take it out to non-grace chords)
    llll_funall(measure->rhythmic_tree, set_is_grace_flag_to_chords_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

//    notation_obj_check_force(r_ob, false); // THIS ONE CRASHES
    
    // deciding beaming direction
    decide_beaming_direction(r_ob, measure);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step8"), 2);

    // deciding tuplet direction
    llll_funall(measure->rhythmic_tree, decide_tuplet_direction_for_level_fn, &is_in_voiceensemble, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    verbose_post_rhythmic_tree(r_ob, measure, gensym("step8b"), 1);

    // set to all chords its number of beamings
    set_beams_depth_to_chords(r_ob, measure);
    
    verbose_post_rhythmic_tree(r_ob, measure, gensym("step9"), 2);

    // Now we're done with the "hardcore" first part of the thing, and we do some "postproduction" stuff
    
    // We check again the measure ties
    check_measure_ties(r_ob, measure, r_ob->tie_assign_pitch, false);
    
    // For every chord, we calculate its r_measure_onset_sec
    calculate_chords_and_tempi_measure_onsets(r_ob, measure);
    
    // We erase the topmost_y and bottommost_y chord values  
    t_chord *curr_ch;
    for (curr_ch = measure->firstchord; curr_ch; curr_ch = curr_ch->next){
        curr_ch->topmost_y = -1;
        curr_ch->bottommost_y = -1;
        curr_ch->beam_y = -1;
        curr_ch->topmost_y_noacc = -1;
        curr_ch->bottommost_y_noacc = -1;
        curr_ch->topmost_stafftop_uy = curr_ch->bottommost_stafftop_uy = curr_ch->topmost_stafftop_uy_noacc = curr_ch->bottommost_stafftop_uy_noacc = -32000;
    }
    
    // We update the num_chords field of the measure. This might NOT be needed, if we used the chord_insert_in_measure() function, but we'll keep it for now.
    update_measure_chordnumbers(measure);
    
    // We recompute all the chord figures. This should NOT be needed as well (we should have already done it), but we'll keep it for now.
    compute_measure_chords_figure(r_ob, measure); 

    // We recompute the symbolic onsets of element in the measure
    recompute_measure_r_onsets(r_ob, measure);
    r_ob->need_recompute_chords_double_onset = true;
}


t_chord *get_level_start_chord(t_llll *level, char ignore_grace_levels){
    t_llll *temp = level;
    t_llllelem *elem = level->l_head;
    while (temp && elem && hatom_gettype(&elem->l_hatom) == H_LLLL) {
        if (ignore_grace_levels && is_level_grace(hatom_getllll(&elem->l_hatom)))
            elem = elem->l_next;
        else {
            temp = hatom_getllll(&elem->l_hatom);
            elem = temp ? temp->l_head : NULL;
        }
    }
    if (elem && hatom_gettype(&elem->l_hatom) == H_OBJ)
        return (t_chord *)hatom_getobj(&elem->l_hatom);
    return NULL;
}

t_chord *get_leaf_end_chord(t_llllelem *leaf, char ignore_grace_levels){
    if (hatom_gettype(&leaf->l_hatom) == H_LLLL)
        return get_level_end_chord(hatom_getllll(&leaf->l_hatom), ignore_grace_levels);
    else
        return (t_chord *)hatom_getobj(&leaf->l_hatom);
}

t_chord *get_leaf_start_chord(t_llllelem *leaf, char ignore_grace_levels){
    if (hatom_gettype(&leaf->l_hatom) == H_LLLL)
        return get_level_start_chord(hatom_getllll(&leaf->l_hatom), ignore_grace_levels);
    else
        return (t_chord *)hatom_getobj(&leaf->l_hatom);
}

t_chord *get_level_end_chord(t_llll *level, char ignore_grace_levels){
    t_llll *temp = level;
    t_llllelem *elem = level->l_tail;
    while (temp && elem && hatom_gettype(&elem->l_hatom) == H_LLLL) {
        if (ignore_grace_levels && is_level_grace(hatom_getllll(&elem->l_hatom)))
            elem = elem->l_prev;
        else {
            temp = hatom_getllll(&elem->l_hatom);
            elem = temp ? temp->l_tail : NULL;
        }
    }
    if (elem && hatom_gettype(&elem->l_hatom) == H_OBJ)
        return (t_chord *)hatom_getobj(&elem->l_hatom);
    return NULL;
}


long get_level_start_chord_no_rest_fn(void *data, t_hatom *a, const t_llll *address){
    if (!(*((t_chord **)data)) && hatom_gettype(a) == H_OBJ) {
        t_chord *ch = (t_chord *)hatom_getobj(a);
        if (ch && ch->r_sym_duration.r_num > 0 && ch->firstnote)
            *((t_chord **)data) = ch;
    } else if (hatom_gettype(a) == H_LLLL && address->l_size > 0 && is_level_grace(hatom_getllll(a)))
        return 1;
    return 0;
}

t_chord *get_level_start_chord_no_rest(t_llll *level){
    t_chord *res = NULL;
    llll_funall(level, get_level_start_chord_no_rest_fn, &res, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
    return res;
}

long get_level_end_chord_no_rest_fn(void *data, t_hatom *a, const t_llll *address){
    if (!(*((t_chord **)data)) && hatom_gettype(a) == H_OBJ) {
        t_chord *ch = (t_chord *)hatom_getobj(a);
        if (ch && ch->r_sym_duration.r_num > 0 && ch->firstnote)
            *((t_chord **)data) = ch;
    } else if (hatom_gettype(a) == H_LLLL && address->l_size > 0 && is_level_grace(hatom_getllll(a)))
        return 1;
    return 0;
}

t_chord *get_level_end_chord_no_rest(t_llll *level){
    t_chord *res = NULL;
    t_llll *cloned = llll_clone_extended(level, WHITENULL_llll, 0, ignore_l_thing_fn);
    llll_rev(cloned, 0, 0);
    llll_funall(cloned, get_level_end_chord_no_rest_fn, &res, 1, -1, FUNALL_PROCESS_WHOLE_SUBLISTS);
    llll_free(cloned);
    return res;
}


long get_beam_depth_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        char curr_depth = *((char *)data);
        if (box && box->l_thing.w_obj){
            char this_depth = ((t_rhythm_level_properties *)box->l_thing.w_obj)->beam_number;
            if (this_depth > curr_depth)
                *((char *)data) = this_depth;
        }
    }
    return 0;
}


char get_max_beam_depth_inside_level(t_llll *level){
    char this_depth = 0;
    if (level && level->l_thing.w_obj)
        this_depth = ((t_rhythm_level_properties *)level->l_thing.w_obj)->beam_number;
    llll_funall(level, get_beam_depth_for_level_fn, &this_depth, 1, -1, FUNALL_SKIP_ATOMS);
    return this_depth;
}

char get_max_depth_outside_level(t_llll *level){
    char this_depth = 0;
    t_llll *temp;
    if (level && level->l_thing.w_obj)
        this_depth = ((t_rhythm_level_properties *)level->l_thing.w_obj)->beam_number;
    
    temp = level->l_owner ? level->l_owner->l_parent : NULL;
    while (temp){
        if (temp && temp->l_thing.w_obj) {
            long temp2 = ((t_rhythm_level_properties *)temp->l_thing.w_obj)->beam_number;
            if (temp2 > this_depth)
                this_depth = temp2;
        }
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return this_depth;
}


char get_max_depth_for_level(t_llll *level){
    return MAX(get_max_beam_depth_inside_level(level), get_max_depth_outside_level(level));
}


long build_lower_beams_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    double first_ux_pos = *(double *) ((void **)data)[0];
    double last_ux_pos = *(double *) ((void **)data)[1];
    double first_uy_pos = *(double *) ((void **)data)[2];
    double last_uy_pos = *(double *) ((void **)data)[3];
    char dir = *(char *) ((void **)data)[4];
    char grace = *(char *) ((void **)data)[5];
    double grace_ratio = grace ? CONST_GRACE_CHORD_SIZE : 1.;
    
    if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a)) && address && address->l_size > 0){
        return 1;
    } else if (hatom_gettype(a) == H_LLLL && address && address->l_size > 0){ // we exclude the first list
        t_llll *box = hatom_getllll(a);
        if (box && box->l_thing.w_obj && box->l_owner && box->l_size > 1){
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj; 
            if (prop->beam_number > 0 && box->l_owner->l_parent->l_thing.w_obj) {
                char prev_num_beams = ((t_rhythm_level_properties *) box->l_owner->l_parent->l_thing.w_obj)->beam_number;
                if (prop->beam_number > prev_num_beams){
                    t_chord *start_ch = get_level_start_chord(box, true);
                    t_chord *end_ch = get_level_end_chord(box, true);
                    t_measure *measure = start_ch->parent;
                    long i;
                    double start_ch_uy_pos = rescale(start_ch->stem_offset_ux, first_ux_pos, last_ux_pos, first_uy_pos, last_uy_pos); // this is the start uy of the BASE beam (the octave beam), the correct beam position will be computed within few lines
                    double end_ch_uy_pos = rescale(end_ch->stem_offset_ux, first_ux_pos, last_ux_pos, first_uy_pos, last_uy_pos);
                    for (i = prev_num_beams + 1; i <= prop->beam_number; i++) { 
                        t_beam *beam = build_beam(start_ch, end_ch);
                        beam->depth = i;
                        beam->has_beam_line = true;
                        beam->is_tick = false;
                        beam->slope = prop->beam_slope;
                        beam->grace = grace;
                        beam->beam_start_uy = start_ch_uy_pos + dir * (i - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                        beam->beam_end_uy = end_ch_uy_pos + dir * (i - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                        beam->direction = dir;
                        append_beam(measure, beam);
                    }
                }
            }
        }
    }
    return 0;
}


char all_chords_in_range_have_the_same_lowest_screen_representation(t_chord *start, t_chord *end){
    t_chord *ch;
    char still_undefined = true;
    double mc = 0;
    t_rational acc = long2rat(0);
    for (ch = start; ch; ch = ch->next){
//        if (!ch->firstnote)
//            bach_breakpoint(0);
        if (ch->r_sym_duration.r_num > 0 && ch->firstnote) {
            if (still_undefined) {
                mc = note_get_screen_midicents(ch->firstnote);
                acc = note_get_screen_accidental(ch->firstnote);
                still_undefined = false;
            } else if (note_get_screen_midicents(ch->firstnote) != mc || rat_rat_cmp(note_get_screen_accidental(ch->lastnote), acc) != 0)
                return 0;
        }
        if (ch == end)
            return !still_undefined;
    }
    
    return !still_undefined;
}

char all_chords_in_range_have_the_same_highest_screen_representation(t_chord *start, t_chord *end){
    t_chord *ch;
    char still_undefined = true;
    double mc = 0;
    t_rational acc = long2rat(0);
    for (ch = start; ch; ch = ch->next){
        if (ch->r_sym_duration.r_num > 0 && ch->lastnote) {
            if (still_undefined) {
                mc = note_get_screen_midicents(ch->lastnote);
                acc = note_get_screen_accidental(ch->lastnote);
                still_undefined = false;
            } else if (note_get_screen_midicents(ch->lastnote) != mc || rat_rat_cmp(note_get_screen_accidental(ch->lastnote), acc) != 0)
                return 0;
        }
        if (ch == end)
            return !still_undefined;
    }
    
    return !still_undefined;
}

void correct_straight_line_positioning_for_middle_chords(t_notation_obj *r_ob, t_chord *start_ch, t_chord *end_ch, 
                                                         double first_ux_pos, double end_ux_pos,
                                                         double *start_uy_pos, double *end_uy_pos, char beaming_direction,
                                                         char used_for_beamings, char rests_can_float, char force_slope, double forced_slope, 
                                                         double additional_uthreshold, char correct_for_midicents, char is_grace){
    double first_uy_pos = *start_uy_pos;
    double last_uy_pos = *end_uy_pos;
    double original_first_uy_pos = *start_uy_pos;
    double original_last_uy_pos = *end_uy_pos;
    double hinge_ux = -1, hinge_uy = -1, max_hinge_uy = -1;
    char used_hinges = false;
    t_chord *temp_ch;
    double octave_stem_ulength = 7 * CONST_STEP_UY;
    t_voice *voice = (t_voice *)start_ch->parent->voiceparent;
    double staff_top = get_staff_top_y(r_ob, voice, false);
    double best = -32000, flat_uy;
    double forced_diff = forced_slope * (end_ux_pos - first_ux_pos);
    char is_voiceensemble = (start_ch && voiceensemble_get_numparts(r_ob, (t_voice *)start_ch->parent->voiceparent) > 1 ? 1 : 0);

    
    for (temp_ch = start_ch; temp_ch && (!temp_ch->prev || temp_ch->prev != end_ch); temp_ch = temp_ch->next) {
        double beam_uy_pos, temp_nt_uy_real, minimum_uy_pos;
        t_note *reference_nt = (beaming_direction == 1) ? temp_ch->lastnote : temp_ch->firstnote;

        // uy position of the first beaming over the current chord, if the beam goes along the given uy_positions 
        beam_uy_pos = rescale(temp_ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos);

        if (!used_for_beamings) {
        
            if (temp_ch == start_ch)
                minimum_uy_pos = (beaming_direction == 1 ? temp_ch->topmost_stafftop_uy_noacc - additional_uthreshold : temp_ch->bottommost_stafftop_uy_noacc + additional_uthreshold);
            else
                minimum_uy_pos = (beaming_direction == 1 ? temp_ch->topmost_stafftop_uy - additional_uthreshold : temp_ch->bottommost_stafftop_uy + additional_uthreshold);
        
        } else {
            double this_grace_ratio = is_grace ? CONST_GRACE_CHORD_SIZE : 1.;
            char this_direction = (temp_ch->is_grace_chord && !is_grace) ? temp_ch->direction : beaming_direction;
            char ch_beams_depth;
            
            if (temp_ch->is_grace_chord) {
                ch_beams_depth = get_max_depth_for_level(temp_ch->rhythmic_tree_elem->l_parent);
            } else
                ch_beams_depth = temp_ch->beams_depth;
            
            temp_nt_uy_real = ((reference_nt ? mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(reference_nt), voice) : rest_get_floating_yposition(r_ob, temp_ch, NULL, NULL)) - staff_top)/r_ob->zoom_y;
            
            // uy position of the first beaming over the current chord, under (or over) which we CANNOT go!  
            if (reference_nt) { 
                // chord
                if (this_direction != beaming_direction) {
                    minimum_uy_pos = (this_direction == 1 ? temp_ch->bottommost_stafftop_uy : temp_ch->topmost_stafftop_uy) + (CONST_GRACE_CHORD_VERTICALUSPACE_FROM_BEAM + ch_beams_depth * CONST_BEAMINGS_UDISTANCE * this_grace_ratio) * this_direction;
                } else {
                    if (this_direction == 1)
                        minimum_uy_pos = temp_nt_uy_real - octave_stem_ulength * this_grace_ratio + (ch_beams_depth > 1) * CONST_SECOND_BEAM_UY_SHIFT * this_grace_ratio - (ch_beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * this_grace_ratio;
                    else
                        minimum_uy_pos = temp_nt_uy_real + octave_stem_ulength * this_grace_ratio - (ch_beams_depth > 1) *  CONST_SECOND_BEAM_UY_SHIFT * this_grace_ratio + (ch_beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * this_grace_ratio;
                }
            } else {
                // rest
                char num_beams = get_max_depth_for_level(temp_ch->rhythmic_tree_elem->l_parent);
                if (this_direction == 1)
                    minimum_uy_pos = temp_nt_uy_real - rest_get_top_extension_in_steps(r_ob, temp_ch->figure) * CONST_STEP_UY * this_grace_ratio - MAX(num_beams - 1, 0) * CONST_BEAMINGS_UDISTANCE * this_grace_ratio * (this_direction == beaming_direction) - CONST_VERTICAL_USEPARATION_RESTS_FROM_BEAM;
                else
                    minimum_uy_pos = temp_nt_uy_real + rest_get_bottom_extension_in_steps(r_ob, temp_ch->figure) * CONST_STEP_UY * this_grace_ratio + MAX(num_beams - 1, 0) * CONST_BEAMINGS_UDISTANCE * this_grace_ratio * (this_direction == beaming_direction) + CONST_VERTICAL_USEPARATION_RESTS_FROM_BEAM;
            }
        }
        
        // OLD CODE: using differences. But why?
/*        // calculating hinge
        if (beaming_direction == 1) {
            double delta = beam_uy_pos - minimum_uy_pos;
            if (minimum_uy_pos < beam_uy_pos && delta > best) {
                long num_float_steps = (!reference_nt && rests_can_float ? MIN(r_ob->max_rest_floating_steps, ceil(delta / CONST_STEP_UY)) : 0);
                if (!reference_nt && is_voiceensemble) {
                    if (start_ch->parent->voiceparent->v_ob.part_index % 2 == 0 && num_float_steps > 0)
                        num_float_steps = 0;
                    else if (start_ch->parent->voiceparent->v_ob.part_index % 2 != 0 && num_float_steps < 0)
                        num_float_steps = 0;
                }
                double float_delta_part = num_float_steps * CONST_STEP_UY;
                if (float_delta_part < delta && delta - float_delta_part > best) {
                    best = delta - float_delta_part;
                    hinge_ux = temp_ch->stem_offset_ux;
                    hinge_uy = minimum_uy_pos + float_delta_part;
                    if (hinge_uy < max_hinge_uy || !used_hinges) 
                        max_hinge_uy = hinge_uy;
                    used_hinges = true;
                }
            }
        } else {
            if (minimum_uy_pos > beam_uy_pos && minimum_uy_pos - beam_uy_pos > best)  {
                double delta = minimum_uy_pos - beam_uy_pos;
                long num_float_steps = (!reference_nt && rests_can_float ? -MIN(r_ob->max_rest_floating_steps, ceil(delta / CONST_STEP_UY)) : 0);
                if (is_voiceensemble) {
                    if (start_ch->parent->voiceparent->v_ob.part_index % 2 == 0 && num_float_steps > 0)
                        num_float_steps = 0;
                    else if (start_ch->parent->voiceparent->v_ob.part_index % 2 != 0 && num_float_steps < 0)
                        num_float_steps = 0;
                }
                double float_delta_part = -num_float_steps * CONST_STEP_UY;
                if (float_delta_part < delta && delta - float_delta_part > best){
                    best = delta - float_delta_part;
                    hinge_ux = temp_ch->stem_offset_ux;
                    hinge_uy = minimum_uy_pos - float_delta_part;
                    if (hinge_uy > max_hinge_uy || !used_hinges) 
                        max_hinge_uy = hinge_uy;
                    used_hinges = true;
                }
            }
        } */
        
        // calculating hinge
        if (beaming_direction == 1) {
            double delta = beam_uy_pos - minimum_uy_pos;
            if (minimum_uy_pos < beam_uy_pos && (!used_hinges || minimum_uy_pos < best)) {
                long num_float_steps = (!reference_nt && rests_can_float ? MIN(r_ob->max_rest_floating_steps, ceil(delta / CONST_STEP_UY)) : 0);
                if (!reference_nt && is_voiceensemble) {
                    if (start_ch->parent->voiceparent->v_ob.part_index % 2 == 0 && num_float_steps > 0)
                        num_float_steps = 0;
                    else if (start_ch->parent->voiceparent->v_ob.part_index % 2 != 0 && num_float_steps < 0)
                        num_float_steps = 0;
                }
                double float_delta_part = num_float_steps * CONST_STEP_UY;
                if (float_delta_part < delta && (!used_hinges || minimum_uy_pos - float_delta_part < best)) {
                    best = minimum_uy_pos - float_delta_part;
                    hinge_ux = temp_ch->stem_offset_ux;
                    hinge_uy = minimum_uy_pos + float_delta_part;
                    if (hinge_uy < max_hinge_uy || !used_hinges)
                        max_hinge_uy = hinge_uy;
                    used_hinges = true;
                }
            }
        } else {
            double delta = minimum_uy_pos - beam_uy_pos;
            if (minimum_uy_pos > beam_uy_pos && (!used_hinges || minimum_uy_pos > best))  {
                long num_float_steps = (!reference_nt && rests_can_float ? -MIN(r_ob->max_rest_floating_steps, ceil(delta / CONST_STEP_UY)) : 0);
                if (is_voiceensemble) {
                    if (start_ch->parent->voiceparent->v_ob.part_index % 2 == 0 && num_float_steps > 0)
                        num_float_steps = 0;
                    else if (start_ch->parent->voiceparent->v_ob.part_index % 2 != 0 && num_float_steps < 0)
                        num_float_steps = 0;
                }
                double float_delta_part = -num_float_steps * CONST_STEP_UY;
                if (float_delta_part < delta && (!used_hinges || minimum_uy_pos - float_delta_part > best)) {
                    best = minimum_uy_pos - float_delta_part;
                    hinge_ux = temp_ch->stem_offset_ux;
                    hinge_uy = minimum_uy_pos - float_delta_part;
                    if (hinge_uy > max_hinge_uy || !used_hinges)
                        max_hinge_uy = hinge_uy;
                    used_hinges = true;
                }
            }
        }
    }                    
    
    if (beaming_direction == -1)
        flat_uy = MAX(MAX(max_hinge_uy, original_first_uy_pos), original_last_uy_pos);
    else
        flat_uy = MIN(MIN(max_hinge_uy, original_first_uy_pos), original_last_uy_pos);
    
    // gotta fix things, with respect to the hinge
    if (used_hinges) {
        if (beaming_direction == 1) {
            if (original_first_uy_pos > original_last_uy_pos) {
                if (max_hinge_uy >= original_last_uy_pos && max_hinge_uy <= original_first_uy_pos) { // we can slightly rotate the beaming
                    double new_diff = MIN(r_ob->max_beam_delta_y * CONST_STEP_UY, end_ux_pos == hinge_ux ? hinge_uy - original_last_uy_pos : (hinge_uy - original_last_uy_pos) * (end_ux_pos - first_ux_pos) / (end_ux_pos - hinge_ux));
                    if (r_ob->constraint_beam_start_end_in_spaces) {
                        new_diff = floor(new_diff/CONST_STEP_UY) * CONST_STEP_UY;
                        last_uy_pos = floor(original_last_uy_pos/CONST_STEP_UY) * CONST_STEP_UY;
                    }
                    if (force_slope)
                        new_diff = forced_diff;
                    first_uy_pos = last_uy_pos + new_diff;
                } else { // flat beaming
                    first_uy_pos = last_uy_pos = (r_ob->constraint_beam_start_end_in_spaces ? floor(flat_uy/CONST_STEP_UY) * CONST_STEP_UY : flat_uy);
                }
            } else {
                if (max_hinge_uy >= original_first_uy_pos && max_hinge_uy <= last_uy_pos) { // we can slightly rotate the beaming
                    double new_diff = MIN(r_ob->max_beam_delta_y * CONST_STEP_UY, first_ux_pos == hinge_ux ? hinge_uy - original_first_uy_pos : (hinge_uy - original_first_uy_pos) * (end_ux_pos - first_ux_pos) / (hinge_ux - first_ux_pos));
                    if (r_ob->constraint_beam_start_end_in_spaces) {
                        new_diff = floor(new_diff/CONST_STEP_UY) * CONST_STEP_UY;
                        first_uy_pos = floor(original_first_uy_pos/CONST_STEP_UY) * CONST_STEP_UY;
                    }
                    if (force_slope)
                        new_diff = forced_diff;
                    last_uy_pos = first_uy_pos + new_diff; 
                } else { // flat beaming
                    first_uy_pos = last_uy_pos = (r_ob->constraint_beam_start_end_in_spaces ? floor(flat_uy/CONST_STEP_UY) * CONST_STEP_UY : flat_uy);
                }
            }
        } else {
            if (original_first_uy_pos < original_last_uy_pos) {
                if ((max_hinge_uy >= original_first_uy_pos) && (max_hinge_uy <= original_last_uy_pos)) { // we can slightly rotate the beaming
                    double new_diff = MIN(r_ob->max_beam_delta_y * CONST_STEP_UY, end_ux_pos == hinge_ux ? original_last_uy_pos - hinge_uy :  (original_last_uy_pos - hinge_uy) * (end_ux_pos - first_ux_pos) / (end_ux_pos - hinge_ux));
                    if (r_ob->constraint_beam_start_end_in_spaces) {
                        new_diff = floor((new_diff + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                        last_uy_pos = ceil((original_last_uy_pos - CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                    }
                    if (force_slope)
                        new_diff = forced_diff;
                    first_uy_pos = last_uy_pos - new_diff; 
                } else { // flat beaming
                    first_uy_pos = last_uy_pos = (r_ob->constraint_beam_start_end_in_spaces ? ceil(flat_uy/CONST_STEP_UY) * CONST_STEP_UY : flat_uy);
                }
            } else {
                if ((max_hinge_uy >= original_last_uy_pos) && (max_hinge_uy <= original_first_uy_pos)) { // we can slightly rotate the beaming
                    double new_diff = MIN(r_ob->max_beam_delta_y * CONST_STEP_UY, first_ux_pos == hinge_ux ? original_first_uy_pos - hinge_uy : (original_first_uy_pos - hinge_uy) * (end_ux_pos - first_ux_pos) / (hinge_ux - first_ux_pos));
                    if (r_ob->constraint_beam_start_end_in_spaces){
                        new_diff = floor((new_diff + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                        first_uy_pos = ceil((original_first_uy_pos - CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                    }
                    if (force_slope)
                        new_diff = forced_diff;
                    last_uy_pos = first_uy_pos - new_diff; 
                } else { // flat beaming
                    first_uy_pos = last_uy_pos = (r_ob->constraint_beam_start_end_in_spaces ? ceil(flat_uy/CONST_STEP_UY) * CONST_STEP_UY : flat_uy);
                }
            }
        }
    } else {
        // hinge unused. We only have to verify the slope
        if (beaming_direction == 1) {
            if (fabs(original_first_uy_pos - original_last_uy_pos) > r_ob->max_beam_delta_y * CONST_STEP_UY){
                double new_diff = MIN(fabs(original_first_uy_pos - original_last_uy_pos), r_ob->max_beam_delta_y * CONST_STEP_UY);
                if (r_ob->constraint_beam_start_end_in_spaces)
                    new_diff = floor((new_diff + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                if (force_slope)
                    new_diff = forced_diff;
                if (original_first_uy_pos < original_last_uy_pos)
                    last_uy_pos = original_first_uy_pos + new_diff; 
                else
                    first_uy_pos = original_last_uy_pos + new_diff; 
            } else if (r_ob->constraint_beam_start_end_in_spaces){
                first_uy_pos = floor((first_uy_pos + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                last_uy_pos = floor((last_uy_pos + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
            }
        } else {
            if (fabs(original_first_uy_pos - original_last_uy_pos) > r_ob->max_beam_delta_y * CONST_STEP_UY){
                double new_diff = MIN(fabs(original_first_uy_pos - original_last_uy_pos), r_ob->max_beam_delta_y * CONST_STEP_UY);
                if (r_ob->constraint_beam_start_end_in_spaces)
                    new_diff = floor((new_diff + CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                if (force_slope)
                    new_diff = forced_diff;
                if (original_first_uy_pos < original_last_uy_pos)
                    first_uy_pos = original_last_uy_pos - new_diff; 
                else
                    last_uy_pos = original_first_uy_pos - new_diff; 
            } else if (r_ob->constraint_beam_start_end_in_spaces){
                first_uy_pos = ceil((first_uy_pos - CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
                last_uy_pos = ceil((last_uy_pos - CONST_EPSILON1)/CONST_STEP_UY) * CONST_STEP_UY;
            }
        }
    }        

    if (correct_for_midicents){
        // particular cases!
        if (beaming_direction == 1 && last_uy_pos > first_uy_pos && start_ch->r_sym_duration.r_num > 0 && 
            end_ch->r_sym_duration.r_num > 0 && end_ch->lastnote && start_ch->lastnote && end_ch->lastnote->midicents >= start_ch->lastnote->midicents)
            last_uy_pos = first_uy_pos;
        else if (beaming_direction == 1 && last_uy_pos < first_uy_pos && start_ch->r_sym_duration.r_num > 0 &&
                 end_ch->r_sym_duration.r_num > 0 && end_ch->lastnote && start_ch->lastnote && end_ch->lastnote->midicents <= start_ch->lastnote->midicents)
            first_uy_pos = last_uy_pos;
        else if (beaming_direction == -1 && last_uy_pos > first_uy_pos && start_ch->r_sym_duration.r_num > 0 &&
                 end_ch->r_sym_duration.r_num > 0 && end_ch->firstnote && start_ch->firstnote && end_ch->firstnote->midicents >= start_ch->firstnote->midicents)
            first_uy_pos = last_uy_pos;
        else if (beaming_direction == -1 && last_uy_pos < first_uy_pos && start_ch->r_sym_duration.r_num > 0 &&
                 end_ch->r_sym_duration.r_num > 0 &&  end_ch->firstnote && start_ch->firstnote && end_ch->firstnote->midicents <= start_ch->firstnote->midicents)
            last_uy_pos = first_uy_pos;
        else if (beaming_direction == 1 && used_for_beamings && 
                 all_chords_in_range_have_the_same_lowest_screen_representation(start_ch, end_ch))
            last_uy_pos = first_uy_pos = MAX(last_uy_pos, first_uy_pos);
        else if (beaming_direction == -1 && used_for_beamings && 
                 all_chords_in_range_have_the_same_highest_screen_representation(start_ch, end_ch))
            last_uy_pos = first_uy_pos = MAX(last_uy_pos, first_uy_pos);
    }
    
    *start_uy_pos = first_uy_pos;
    *end_uy_pos = last_uy_pos;
}

long level_size_except_for_grace(t_llll *box){
    long count = 0;
    t_llllelem *elem;
    for (elem = box->l_head; elem; elem = elem->l_next)
        if (hatom_gettype(&elem->l_hatom) != H_LLLL || !is_level_grace(hatom_getllll(&elem->l_hatom)))
            count++;
    return count;
}

char is_level_inside_a_grace_level(t_llll *box){
    t_llll *temp = box;
    while (temp) {
        if (is_level_grace(temp))
            return true;
        temp = temp->l_owner ? temp->l_owner->l_parent : NULL;
    }
    return false;
}


long build_measure_beams_for_level_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    char only_grace = *((char *) ((void **)data)[1]);    // if this is 1 it only accounts the grace levels, if this is 0 it ignores them
    
    if (hatom_gettype(a) == H_LLLL){
        t_llll *box = hatom_getllll(a);
        
        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            char *foo = NULL;
            llll_to_text_buf(box, &foo, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
            bach_freeptr(foo);
        #endif
        
        if (box && box->l_thing.w_obj && ((only_grace && is_level_grace_or_inside_grace(box)) || (!only_grace && !is_level_grace_or_inside_grace(box))) && level_size_except_for_grace(box) > 1){
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)box->l_thing.w_obj; 
            char is_level_inside_grace = is_level_inside_a_grace_level(box);
            double grace_ratio = is_level_inside_grace ? CONST_GRACE_CHORD_SIZE : 1.;
            
            if (prop->beam_number > 0){
                t_chord *start_ch = get_level_start_chord(box, true);
                t_chord *end_ch = get_level_end_chord(box, true);
                if (start_ch && end_ch) {
                    t_chord *start_ch_no_rest = get_level_start_chord_no_rest(box);
                    t_chord *end_ch_no_rest = get_level_end_chord_no_rest(box);
                    t_measure *measure = start_ch->parent;
                    t_voice *voice = (t_voice *)measure->voiceparent;
                    double octave_stem_ulength = 7 * CONST_STEP_UY;
                    double staff_top = get_staff_top_y(r_ob, voice, false);
                    double num_staff_steps = get_num_steps_in_staff(r_ob, voice);
                    
                    if (start_ch_no_rest == end_ch_no_rest){
                        if (start_ch_no_rest != start_ch)
                            start_ch_no_rest = start_ch;
                        else
                            end_ch_no_rest = end_ch;
                    }
                    
                    if (start_ch_no_rest && end_ch_no_rest){
                        t_chord *temp_ch;
                        char beaming_direction = prop->direction ? prop->direction : 1;
                        double slope = 0; // we need to decide the beam slope
                        double first_ux_pos = start_ch_no_rest->stem_offset_ux, end_ux_pos = end_ch_no_rest->stem_offset_ux;
                        double first_uy_pos, last_uy_pos, original_first_uy_pos, original_last_uy_pos;
                        double start_ch_firstnote_mc = start_ch->firstnote ? note_get_screen_midicents(start_ch->firstnote) : rest_get_dummy_mc(r_ob, start_ch);
                        double start_ch_lastnote_mc = start_ch->lastnote ? note_get_screen_midicents(start_ch->lastnote) : rest_get_dummy_mc(r_ob, start_ch);
                        double end_ch_firstnote_mc = end_ch->firstnote ? note_get_screen_midicents(end_ch->firstnote) : rest_get_dummy_mc(r_ob, end_ch);
                        double end_ch_lastnote_mc = end_ch->lastnote ? note_get_screen_midicents(end_ch->lastnote) : rest_get_dummy_mc(r_ob, end_ch);
                        
                        // todo: check that the topmost/bottommost_uy stuff take into account accidentals as well
                        
                        // getting starting and ending y points
                        if (beaming_direction == 1) {
                            first_uy_pos = (start_ch_no_rest->firstnote ? 
                                            MIN(num_staff_steps * CONST_STEP_UY - CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, (mc_to_yposition_in_scale(r_ob, start_ch_no_rest->lastnote->midicents, voice) - staff_top)/r_ob->zoom_y - octave_stem_ulength * grace_ratio) :
                                            (rest_get_floating_yposition(r_ob, start_ch_no_rest, NULL, NULL) + rest_get_top_extension_in_steps(r_ob, start_ch_no_rest->r_sym_duration) * r_ob->step_y * grace_ratio - staff_top)/r_ob->zoom_y) +
                            (start_ch_no_rest->beams_depth > 1) * CONST_SECOND_BEAM_UY_SHIFT * grace_ratio - (start_ch_no_rest->beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                            last_uy_pos = (end_ch_no_rest->firstnote ?
                                           MIN(num_staff_steps * CONST_STEP_UY - CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, (mc_to_yposition_in_scale(r_ob, end_ch_no_rest->lastnote->midicents, voice) - staff_top)/r_ob->zoom_y - octave_stem_ulength * grace_ratio) :
                                           (rest_get_floating_yposition(r_ob, end_ch_no_rest, NULL, NULL) + rest_get_top_extension_in_steps(r_ob, end_ch_no_rest->r_sym_duration) * r_ob->step_y * grace_ratio - staff_top)/r_ob->zoom_y) +
                            (end_ch_no_rest->beams_depth > 1) * CONST_SECOND_BEAM_UY_SHIFT * grace_ratio - (end_ch_no_rest->beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                        } else {
                            first_uy_pos = (start_ch_no_rest->firstnote ?
                                            MAX(CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, (mc_to_yposition_in_scale(r_ob, start_ch_no_rest->firstnote->midicents, voice) - staff_top)/r_ob->zoom_y + octave_stem_ulength * grace_ratio) :
                                            (rest_get_floating_yposition(r_ob, start_ch_no_rest, NULL, NULL) + rest_get_top_extension_in_steps(r_ob, start_ch_no_rest->r_sym_duration) * r_ob->step_y * grace_ratio - staff_top)/r_ob->zoom_y) -
                            (start_ch_no_rest->beams_depth > 1) * CONST_SECOND_BEAM_UY_SHIFT * grace_ratio + (start_ch_no_rest->beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                            last_uy_pos = (end_ch_no_rest->firstnote ? 
                                           MAX(CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, (mc_to_yposition_in_scale(r_ob, end_ch_no_rest->firstnote->midicents, voice) - staff_top)/r_ob->zoom_y + octave_stem_ulength * grace_ratio) :
                                           (rest_get_floating_yposition(r_ob, end_ch_no_rest, NULL, NULL) + rest_get_top_extension_in_steps(r_ob, end_ch_no_rest->r_sym_duration) * r_ob->step_y * grace_ratio - staff_top)/r_ob->zoom_y) -
                            (end_ch_no_rest->beams_depth > 1) * CONST_SECOND_BEAM_UY_SHIFT * grace_ratio + (end_ch_no_rest->beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                        }
                        
                        // small corrections
                        if (beaming_direction == 1 && start_ch->firstnote && end_ch->firstnote && start_ch_firstnote_mc == end_ch_lastnote_mc && last_uy_pos < first_uy_pos)
                            first_uy_pos = last_uy_pos;
                        if (beaming_direction == -1 && start_ch->firstnote && end_ch->firstnote && start_ch_lastnote_mc == end_ch_firstnote_mc && last_uy_pos > first_uy_pos)
                            first_uy_pos = last_uy_pos;
                        if (start_ch_no_rest->r_sym_duration.r_num < 0)
                            first_uy_pos = last_uy_pos;
                        if (end_ch_no_rest->r_sym_duration.r_num < 0)
                            last_uy_pos = first_uy_pos;
                        
                        // seeing if a chord in the middle is not working with the given uy_positions, in this case we put a moving hinge
                        original_first_uy_pos = first_uy_pos; 
                        original_last_uy_pos = last_uy_pos;                    
                        
                        correct_straight_line_positioning_for_middle_chords(r_ob, start_ch, end_ch, start_ch_no_rest->stem_offset_ux, end_ch_no_rest->stem_offset_ux, &first_uy_pos, &last_uy_pos, beaming_direction, true, true, false, 0, 0., true, is_level_inside_grace);
                        
                        // particular case connection
                        if (start_ch->firstnote && end_ch->firstnote) {
                            if (beaming_direction == 1 && last_uy_pos > first_uy_pos && 
                                end_ch->r_sym_duration.r_num > 0 && end_ch_lastnote_mc >= start_ch_lastnote_mc)
                                last_uy_pos = first_uy_pos;
                            else if (beaming_direction == 1 && last_uy_pos < first_uy_pos && 
                                     end_ch->r_sym_duration.r_num > 0 && end_ch_lastnote_mc <= start_ch_lastnote_mc)
                                first_uy_pos = last_uy_pos;
                            else if (beaming_direction == -1 && last_uy_pos > first_uy_pos && 
                                     end_ch->r_sym_duration.r_num > 0 && end_ch_firstnote_mc >= start_ch_firstnote_mc)
                                first_uy_pos = last_uy_pos;
                            else if (beaming_direction == -1 && last_uy_pos < first_uy_pos && 
                                     end_ch->r_sym_duration.r_num > 0 && end_ch_firstnote_mc <= start_ch_firstnote_mc)
                                last_uy_pos = first_uy_pos;
                        }
                        
                        slope = -(last_uy_pos - first_uy_pos)/(end_ch_no_rest->stem_offset_ux - start_ch_no_rest->stem_offset_ux);
                        
                        
                        // setting all heights
                        for (temp_ch = start_ch; temp_ch && (!temp_ch->prev || temp_ch->prev != end_ch); temp_ch = temp_ch->next) {
                            if (is_level_inside_grace != temp_ch->is_grace_chord)
                                continue;
                            
                            temp_ch->stemtip_stafftop_uy = rescale(temp_ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos);
                            temp_ch->direction = beaming_direction;
                            
                            if (beaming_direction == 1) {
                                temp_ch->topmost_stafftop_uy = temp_ch->stemtip_stafftop_uy;
                                temp_ch->topmost_stafftop_uy_noacc = temp_ch->stemtip_stafftop_uy; 
                            }
                            if (beaming_direction == -1) {
                                temp_ch->bottommost_stafftop_uy = temp_ch->stemtip_stafftop_uy;
                                temp_ch->bottommost_stafftop_uy_noacc = temp_ch->stemtip_stafftop_uy;
                            }
//                            temp_ch->beam_stafftop_uy = temp_ch->stemtip_stafftop_uy + MAX(0, temp_ch->beams_depth - 1) * CONST_BEAMINGS_UDISTANCE * (temp_ch->direction == 1 ? 1 : -1);
                        }
                        
                        // adding floating rests step values
                        if (r_ob->max_rest_floating_steps > 0) {
                            for (temp_ch = start_ch; temp_ch && (!temp_ch->prev || temp_ch->prev != end_ch); temp_ch = temp_ch->next) {
                                
                                if (is_level_inside_grace != temp_ch->is_grace_chord)
                                    continue;
                                
                                if (temp_ch->r_sym_duration.r_num < 0) {
                                    double beam_uy_pos, uy_pos, minimum_uy_pos;
                                    char num_beams = get_max_depth_for_level(temp_ch->rhythmic_tree_elem->l_parent);
                                    
                                    uy_pos = (rest_get_floating_yposition(r_ob, temp_ch, NULL, NULL) - staff_top)/r_ob->zoom_y;
                                    beam_uy_pos = first_uy_pos + (last_uy_pos - first_uy_pos) * (temp_ch->stem_offset_ux - first_ux_pos) / (end_ux_pos - first_ux_pos);
                                    
                                    if (beaming_direction == 1)
                                        minimum_uy_pos = uy_pos - rest_get_top_extension_in_steps(r_ob, temp_ch->figure) * CONST_STEP_UY - MAX(num_beams - 1, 0) * CONST_BEAMINGS_UDISTANCE - CONST_VERTICAL_USEPARATION_RESTS_FROM_BEAM;
                                    else
                                        minimum_uy_pos = uy_pos + rest_get_bottom_extension_in_steps(r_ob, temp_ch->figure) * CONST_STEP_UY + MAX(num_beams - 1, 0) * CONST_BEAMINGS_UDISTANCE + CONST_VERTICAL_USEPARATION_RESTS_FROM_BEAM;
                                    
                                    if (beaming_direction == 1) {
                                        if (minimum_uy_pos < beam_uy_pos) {
                                            temp_ch->float_steps += -MIN(r_ob->max_rest_floating_steps, ceil((beam_uy_pos - minimum_uy_pos) / CONST_STEP_UY));
                                            temp_ch->bottommost_stafftop_uy += temp_ch->float_steps * CONST_STEP_UY;
                                            temp_ch->bottommost_stafftop_uy_noacc = MAX(temp_ch->bottommost_stafftop_uy, temp_ch->bottommost_stafftop_uy_noacc);
                                        } else
                                            temp_ch->float_steps += 0;
                                    } else {
                                        if (minimum_uy_pos > beam_uy_pos) {
                                            temp_ch->float_steps += MIN(r_ob->max_rest_floating_steps, ceil((minimum_uy_pos - beam_uy_pos) / CONST_STEP_UY));
                                            temp_ch->topmost_stafftop_uy += temp_ch->float_steps * CONST_STEP_UY;
                                            temp_ch->topmost_stafftop_uy_noacc = MIN(temp_ch->topmost_stafftop_uy, temp_ch->topmost_stafftop_uy_noacc);
                                        } else
                                            temp_ch->float_steps += 0;
                                    }
                                    
                                }
                            }
                        }
                        
                        // Modify rest floating steps due to voice ensemble
                        if (voiceensemble_get_numparts(r_ob, voice) > 1) {
                            for (temp_ch = start_ch; temp_ch && (!temp_ch->prev || temp_ch->prev != end_ch); temp_ch = temp_ch->next) {
                            }
                        }
                        
                        // we assign the beaming slope to all inner lllls
                        set_beam_slope_for_level(box, slope);
                        
                        // we build the primary beam
                        long i;
                        for (i = 1; i <= prop->beam_number; i++){
                            t_beam *beam = build_beam(start_ch, end_ch);
                            double start_ok_uy = rescale(start_ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos);
                            double end_ok_uy = rescale(end_ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos);
                            double grace_ratio = is_level_inside_grace ? CONST_GRACE_CHORD_SIZE : 1.;
                            beam->depth = i;
                            beam->slope = prop->beam_slope;
                            beam->grace = is_level_inside_grace;
                            beam->beam_start_uy = start_ok_uy + (i - 1) * beaming_direction * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                            beam->beam_end_uy = end_ok_uy + (i - 1) * beaming_direction * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                            beam->has_beam_line = true;
                            beam->direction = beaming_direction;
                            append_beam(measure, beam);
                        }
                        
                        // we set all the inner beaming levels
                        
                        void *data[6];
                        data[0] = &first_ux_pos;
                        data[1] = &end_ux_pos;
                        data[2] = &first_uy_pos;
                        data[3] = &last_uy_pos;
                        data[4] = &beaming_direction;
                        data[5] = &is_level_inside_grace;
                        llll_funall(box, build_lower_beams_for_level_fn, data, 1, -1, FUNALL_SKIP_ATOMS);
                        
                        // We add the ticks
                        char last_used_tick_direction = 0;
                        for (temp_ch = start_ch; temp_ch && (!temp_ch->prev || temp_ch->prev != end_ch); temp_ch = temp_ch->next) {
                            
                            if (is_level_inside_grace != temp_ch->is_grace_chord)
                                continue;
                            
                            if (temp_ch->r_sym_duration.r_num > 0 && temp_ch->rhythmic_tree_elem->l_parent && temp_ch->rhythmic_tree_elem->l_parent->l_thing.w_obj) {
                                char ch_level_beams = get_highest_ancestor_beam_number(temp_ch->rhythmic_tree_elem, true); 
                                char ch_beams = temp_ch->beams_depth;
                                if (ch_level_beams < ch_beams){
                                    long i;
                                    for (i = ch_level_beams + 1; i <= ch_beams; i++){
                                        t_beam *beam = build_beam(temp_ch, temp_ch);
                                        t_llllelem *element_in_beam_llll = temp_ch->rhythmic_tree_elem;
                                        t_llll *beam_llll = get_first_ancestor_having_a_beam(r_ob, temp_ch->rhythmic_tree_elem);
                                        
                                        while (element_in_beam_llll && element_in_beam_llll->l_parent != beam_llll)
                                            element_in_beam_llll = element_in_beam_llll->l_parent->l_owner;
                                        
                                        beam->has_beam_line = true;
                                        beam->direction = beaming_direction;
                                        beam->depth = i;
                                        beam->is_tick = true;
                                        beam->slope = prop->beam_slope;
                                        beam->grace = is_level_inside_grace;
                                        
                                        t_llll *base = element_in_beam_llll->l_parent;
                                        t_llllelem *first_nongrace_elem = NULL, *last_nongrace_elem = NULL;
                                        
                                        while (base) {
                                            first_nongrace_elem = base->l_head;
                                            last_nongrace_elem = base->l_tail;
                                            
                                            while (first_nongrace_elem && hatom_gettype(&first_nongrace_elem->l_hatom) == H_LLLL && is_level_grace(hatom_getllll(&first_nongrace_elem->l_hatom)))
                                                first_nongrace_elem = first_nongrace_elem->l_next;
                                            
                                            while (last_nongrace_elem && hatom_gettype(&last_nongrace_elem->l_hatom) == H_LLLL && is_level_grace(hatom_getllll(&last_nongrace_elem->l_hatom)))
                                                last_nongrace_elem = last_nongrace_elem->l_prev;
                                            
                                            if (first_nongrace_elem != last_nongrace_elem)
                                                break;
                                            
                                            if (!base->l_owner || base == box)
                                                break;
                                            
                                            base = base->l_owner->l_parent;
                                        }
                                        
                                        if (temp_ch == start_ch || !element_in_beam_llll->l_prev || element_in_beam_llll == first_nongrace_elem)
                                            beam->tick_direction = 1;
                                        else if (temp_ch == end_ch || !element_in_beam_llll->l_next || element_in_beam_llll == last_nongrace_elem)
                                            beam->tick_direction = -1;
                                        else if (last_used_tick_direction)
                                            beam->tick_direction = last_used_tick_direction;
                                        else {
                                            t_llllelem *last_elem_in_a_row_having_ticks = element_in_beam_llll;
                                            t_llllelem *first_elem_in_a_row_having_ticks = element_in_beam_llll;
                                            
                                            while (last_elem_in_a_row_having_ticks && last_elem_in_a_row_having_ticks->l_next && 
                                                   (hatom_gettype(&last_elem_in_a_row_having_ticks->l_next->l_hatom) == H_OBJ ||
                                                    (hatom_gettype(&last_elem_in_a_row_having_ticks->l_next->l_hatom) == H_LLLL &&
                                                     hatom_getllll(&last_elem_in_a_row_having_ticks->l_next->l_hatom)->l_thing.w_obj && 
                                                     ((t_rhythm_level_properties *)hatom_getllll(&last_elem_in_a_row_having_ticks->l_next->l_hatom)->l_thing.w_obj)->beam_number <= ch_level_beams)))
                                                last_elem_in_a_row_having_ticks = last_elem_in_a_row_having_ticks->l_next;
                                            
                                            while (first_elem_in_a_row_having_ticks && first_elem_in_a_row_having_ticks->l_prev && 
                                                   (hatom_gettype(&first_elem_in_a_row_having_ticks->l_prev->l_hatom) == H_OBJ ||
                                                    (hatom_gettype(&first_elem_in_a_row_having_ticks->l_prev->l_hatom) == H_LLLL &&
                                                     hatom_getllll(&first_elem_in_a_row_having_ticks->l_prev->l_hatom)->l_thing.w_obj && 
                                                     ((t_rhythm_level_properties *)hatom_getllll(&first_elem_in_a_row_having_ticks->l_prev->l_hatom)->l_thing.w_obj)->beam_number <= ch_level_beams)))
                                                first_elem_in_a_row_having_ticks = first_elem_in_a_row_having_ticks->l_prev;
                                            
                                            if (!last_elem_in_a_row_having_ticks->l_next && element_in_beam_llll->l_prev)
                                                beam->tick_direction = -1;
                                            else 
                                                beam->tick_direction = 1;
                                        }
                                        last_used_tick_direction = beam->tick_direction;
                                        beam->beam_start_uy = beam->beam_end_uy = rescale(temp_ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos) + (i - 1) * beaming_direction * CONST_BEAMINGS_UDISTANCE * grace_ratio;
                                        append_beam(measure, beam);
                                    }
                                }
                            }
                        }
                        // stop iteration
                        return 1;
                    }
                }
            }
        }
    }
    return 0;
}


// NB. also resets 
void reset_floatsteps(t_notation_obj *r_ob, t_measure *measure){
    t_chord *chord;
    long val = 0;
    t_voice *voice = (t_voice *)measure->voiceparent;
    if (voiceensemble_get_numparts(r_ob, voice) > 1) {
        val = (voice->part_index % 2 == 0) ? CONST_FLOAT_STEP_PART_SHIFT : -CONST_FLOAT_STEP_PART_SHIFT;
    }

    for (chord = measure->firstchord; chord; chord = chord->next) {
//        chord->min_float_steps = LONG_MIN;
//        chord->max_float_steps = LONG_MAX;
//        if (!chord->firstnote && val == CONST_FLOAT_STEP_PART_SHIFT && chord->figure.r_den <= 2)
//            chord->float_steps = val - 2; // special case for 4/4 and 2/4 rests on upper parts, which would go ABOVE the staff otherwise
//        else
            chord->float_steps = val;
    }
}

void reset_stemtip_topmost_bottommost_stafftop_uy_positions(t_notation_obj *r_ob, t_measure *measure){
    t_chord *chord;
    double num_staff_steps = get_num_steps_in_staff(r_ob, (t_voice *) measure->voiceparent);

    for (chord = measure->firstchord; chord; chord = chord->next){
        if (chord->firstnote){
            double grace_ratio = chord->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1;
            if (chord->direction == -1) {
                chord->stemtip_stafftop_uy = MAX(CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, chord->bottommostnote_stafftop_uy + 7 * CONST_STEP_UY * grace_ratio);
                chord->topmost_stafftop_uy = chord->topmostnote_stafftop_uy - MAX(CONST_STEP_UY, note_get_accidental_top_uextension(r_ob, chord->lastnote));
                chord->topmost_stafftop_uy_noacc = chord->topmostnote_stafftop_uy - CONST_STEP_UY;
                chord->bottommost_stafftop_uy = chord->bottommost_stafftop_uy_noacc = chord->stemtip_stafftop_uy;
            } else if (chord->direction == 1) {
                chord->stemtip_stafftop_uy = MIN(num_staff_steps * CONST_STEP_UY - CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, chord->topmostnote_stafftop_uy - 7 * CONST_STEP_UY * grace_ratio);
                chord->topmost_stafftop_uy = chord->topmost_stafftop_uy_noacc = chord->stemtip_stafftop_uy;
                chord->bottommost_stafftop_uy = chord->bottommostnote_stafftop_uy + MAX(CONST_STEP_UY, note_get_accidental_top_uextension(r_ob, chord->firstnote));
                chord->bottommost_stafftop_uy_noacc = chord->bottommostnote_stafftop_uy + CONST_STEP_UY;
            }
        } else {
            double stafftop = get_staff_top_y(r_ob, (t_voice *)measure->voiceparent, false);
            double restpos = rest_get_nonfloating_yposition(r_ob, chord, NULL, NULL);
            chord->topmost_stafftop_uy = chord->topmost_stafftop_uy_noacc = (restpos - stafftop)/r_ob->zoom_y - rest_get_top_extension_in_steps(r_ob, chord->figure) * CONST_STEP_UY;
            chord->bottommost_stafftop_uy = chord->bottommost_stafftop_uy_noacc = (restpos - stafftop)/r_ob->zoom_y + rest_get_bottom_extension_in_steps(r_ob, chord->figure) * CONST_STEP_UY;
        }
    }
}

void build_measure_tuplet_beams_for_level(t_notation_obj *r_ob, t_llll *box, t_jfont *jf_tuplets_u){
    if (box && box->l_thing.w_obj){
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *) box->l_thing.w_obj;
        if (prop->is_tuplet){
            t_chord *start_ch = get_level_start_chord(box, true);
            t_chord *end_ch = get_level_end_chord(box, true);
            if (start_ch && end_ch){
                t_measure *measure = start_ch->parent;
                long tuplet_direction = prop->direction ? prop->direction : 1;
                if (!tuplet_direction)    // it should be set by now, but one never knows...
                    tuplet_direction = 1;
                
                if (r_ob->show_tuplets_preferences == k_TUPLET_DISPLAY_SHOW_FRACTION) {
                    t_chord *ch;
                    for (ch = start_ch; ch; ch = ch->next){
                        double uwidth, uheight;
                        t_beam *beam = build_beam(ch, ch);
                        beam->tuplet_text1[0] = beam->tuplet_text2[0] = 0; 
                        beam->is_tuplet = true;
                        beam->has_beam_line = false;
                        beam->tuplet_show_bracket = false;
                        snprintf_zero(beam->tuplet_text1, CONST_MAX_TUPLET_CHARS, "%ld/%ld", prop->tupletinfo.tuplet_local_ratio.r_num, prop->tupletinfo.tuplet_local_ratio.r_den);
                        jfont_text_measure(jf_tuplets_u, beam->tuplet_text1, &uwidth, &uheight);
                        beam->tuplet_text1_delta_ux = - uwidth/2.;
                        if (tuplet_direction == 1){
                            beam->tuplet_text1_uy = ch->topmost_stafftop_uy - uheight - CONST_TUPLET_USPACE_FROM_CHORDS;
                            ch->topmost_stafftop_uy -= uheight + CONST_TUPLET_USPACE_FROM_CHORDS;
                        } else {
                            beam->tuplet_text1_uy = ch->bottommost_stafftop_uy + CONST_TUPLET_USPACE_FROM_CHORDS;
                            ch->bottommost_stafftop_uy += uheight + CONST_TUPLET_USPACE_FROM_CHORDS;
                        }
                        beam->direction = tuplet_direction;
                        append_beam(measure, beam);
                        if (ch == end_ch)
                            break;
                    }
                } else {
                    t_beam *beam = build_beam(start_ch, end_ch);
                    double forced_slope = 0;
                    char force_slope = false;
                    long multiplier = 1;
                    
                    beam->tuplet_text1[0] = beam->tuplet_text2[0] = 0; 
                    if (r_ob->show_tuplets_preferences == k_TUPLET_DISPLAY_SHOW_AUTO) {
                        if (r_ob->notation_cursor.measure == measure)
                            beam->tuplet_number_display_type = k_TUPLET_DISPLAY_SHOW_SINGLE_NUMBER;
                        else if (!prop->tupletinfo.is_tuplet_completed) 
                            beam->tuplet_number_display_type = (start_ch == end_ch) ? k_TUPLET_DISPLAY_SHOW_FRACTION : k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES;
                        else if (perfect_log2(prop->tupletinfo.tuplet_local_ratio.r_num * prop->tupletinfo.tuplet_multiplier.r_num) < 0)
                            beam->tuplet_number_display_type = k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES;
                        else if (prop->tupletinfo.tuplet_local_ratio.r_num > prop->tupletinfo.tuplet_local_ratio.r_den)
                            beam->tuplet_number_display_type = k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES;
                        else if (prop->tupletinfo.tuplet_local_ratio.r_den >= 2 * prop->tupletinfo.tuplet_local_ratio.r_num)
                            beam->tuplet_number_display_type = k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES;
                        else
                            beam->tuplet_number_display_type = k_TUPLET_DISPLAY_SHOW_SINGLE_NUMBER;
                    } else
                        beam->tuplet_number_display_type = r_ob->show_tuplets_preferences;
                    
                    multiplier = ((long)ceil(rat2double(prop->tupletinfo.tuplet_multiplier))); // if multiplier is 1/something, it'd still be 1
                    
                    switch (beam->tuplet_number_display_type) {
                        case k_TUPLET_DISPLAY_SHOW_FRACTION:
                            snprintf_zero(beam->tuplet_text1, CONST_MAX_TUPLET_CHARS, "%ld/%ld", prop->tupletinfo.tuplet_local_ratio.r_num, prop->tupletinfo.tuplet_local_ratio.r_den);
                            break;
                        case k_TUPLET_DISPLAY_SHOW_SINGLE_NUMBER:
                            snprintf_zero(beam->tuplet_text1, CONST_MAX_TUPLET_CHARS, "%ld", prop->tupletinfo.tuplet_local_ratio.r_den * multiplier);
                            break;
                        case k_TUPLET_DISPLAY_SHOW_RATIO:
                            snprintf_zero(beam->tuplet_text1, CONST_MAX_TUPLET_CHARS, "%ld:%ld", prop->tupletinfo.tuplet_local_ratio.r_den * multiplier, prop->tupletinfo.tuplet_local_ratio.r_num * multiplier);
                            break;
                        case k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES:
                            snprintf_zero(beam->tuplet_text1, CONST_MAX_TUPLET_CHARS, "%ld", prop->tupletinfo.tuplet_local_ratio.r_den * multiplier);
                            snprintf_zero(beam->tuplet_text2, CONST_MAX_TUPLET_CHARS, ":%ld", prop->tupletinfo.tuplet_local_ratio.r_num * multiplier);
                            break;
                        default:
                            break;
                    }
                    
                    double end_ux_pos = end_ch->stem_offset_ux, first_ux_pos = start_ch->stem_offset_ux;
                    double last_uy_pos, first_uy_pos;

                    if (tuplet_direction == -1){
                        first_uy_pos = start_ch->bottommost_stafftop_uy_noacc + CONST_TUPLET_TICK_UHEIGHT + CONST_TUPLET_USPACE_FROM_CHORDS;
                        last_uy_pos = end_ch->bottommost_stafftop_uy + CONST_TUPLET_TICK_UHEIGHT + CONST_TUPLET_USPACE_FROM_CHORDS;
                    } else {
                        first_uy_pos = start_ch->topmost_stafftop_uy_noacc - CONST_TUPLET_TICK_UHEIGHT - CONST_TUPLET_USPACE_FROM_CHORDS;
                        last_uy_pos = end_ch->topmost_stafftop_uy - CONST_TUPLET_TICK_UHEIGHT - CONST_TUPLET_USPACE_FROM_CHORDS;
                    }
                    
                    beam->depth = 0;
                    beam->is_tuplet = true;
                    beam->direction = tuplet_direction;
                    beam->has_beam_line = 0;
                    beam->tuplet_show_bracket = (r_ob->show_tuplets_preferences != k_TUPLET_DISPLAY_NO_NUMBER && start_ch != end_ch && (!r_ob->only_use_shape_on_unbeamed_tuplets || !prop->tupletinfo.is_completely_on_solitary_beam_level));
                    
                    beam->dashed = !prop->tupletinfo.is_tuplet_completed;
                    if (prop->tupletinfo.tuplet_multiplier.r_num == 1 && prop->tupletinfo.tuplet_multiplier.r_den > 1)
                        beam->tuplet_graphical_unit = rat_long_div(prop->tupletinfo.tuplet_graphical_unit, prop->tupletinfo.tuplet_multiplier.r_den);
                    else
                        beam->tuplet_graphical_unit = prop->tupletinfo.tuplet_graphical_unit;
                    
                    if (tuplet_direction == -1 && start_ch->direction == 1)
                        first_ux_pos -= notehead_get_uwidth(r_ob, start_ch->r_sym_duration, NULL, false);
                    if (tuplet_direction == 1 && end_ch->direction == -1)
                        end_ux_pos += notehead_get_uwidth(r_ob, end_ch->r_sym_duration, NULL, false);
                    
                    // force slope? in case the bracket is over a portion of beaming
                    if (prop->tupletinfo.is_over_beam){
                        t_llll *rootbeamlevel = find_largest_beam_containing_level(box); // this is the root beam, if any
                        if (rootbeamlevel && rootbeamlevel->l_thing.w_obj) {
                            t_rhythm_level_properties *rootprop = (t_rhythm_level_properties *)rootbeamlevel->l_thing.w_obj;
                            if (rootprop->direction == tuplet_direction){
                                force_slope = true;
                                forced_slope = rootprop->beam_slope;
                            }
                        }
                    }
                    
                    correct_straight_line_positioning_for_middle_chords(r_ob, start_ch, end_ch, start_ch->stem_offset_ux, end_ch->stem_offset_ux, 
                                                                        &first_uy_pos, &last_uy_pos, tuplet_direction, false, false, force_slope, 
                                                                        forced_slope, MAX(CONST_STEP_UY * 1.2, CONST_TUPLET_USPACE_FROM_CHORDS), true, prop->is_grace);
                    
                    if (tuplet_direction == -1 && beam->tuplet_text2[0]){
                        first_uy_pos += 9;
                        last_uy_pos += 9;
                    }
                    
                    beam->slope = -(last_uy_pos - first_uy_pos)/(end_ux_pos - first_ux_pos);

                    beam->beam_start_uy = first_uy_pos;
                    beam->beam_end_uy = last_uy_pos;
                    
                    double uwidth, uheight;
                    jfont_text_measure(jf_tuplets_u, beam->tuplet_text1, &uwidth, &uheight);
                    beam->tuplet_text1_uy = (beam->beam_start_uy + beam->beam_end_uy)/2. - uheight/2.;
                    if (beam->tuplet_text2[0]) {
                        double uwidth2, uheight2, figure_uwidth;
                        jfont_text_measure(jf_tuplets_u, beam->tuplet_text2, &uwidth2, &uheight2);
                        figure_uwidth = chord_get_mainside_notehead_uwidth(r_ob, RAT_1OVER8, NULL) * CONST_FIGURE_IN_TUPLET_LEGEND_RATIO * 2 + 0.5; // estimated!
                        beam->tuplet_text1_delta_ux = - (uwidth + uwidth2 + figure_uwidth)/2.;
                    } else {
                        beam->tuplet_text1_delta_ux = - uwidth/2.;
                    }
                    if (tuplet_direction == -1 && start_ch->direction == 1)
                        beam->tuplet_text1_delta_ux -= notehead_get_uwidth(r_ob, start_ch->r_sym_duration, NULL, false)/2.;
                    if (tuplet_direction == 1 && end_ch->direction == -1)
                        beam->tuplet_text1_delta_ux += notehead_get_uwidth(r_ob, end_ch->r_sym_duration, NULL, false)/2.;
                    
                    append_beam(measure, beam);

                    // updating chord boundaries
                    t_chord *ch;
                    for (ch = start_ch; ch; ch = ch->next){
                        if (tuplet_direction == 1) {
                            double additional = (beam->tuplet_text2[0] ? 9 : 0);
                            ch->topmost_stafftop_uy = MIN(ch->topmost_stafftop_uy, rescale(ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos) - CONST_TUPLET_USPACE_FROM_FURTHER_STUFF - additional);
                            ch->topmost_stafftop_uy_noacc = MIN(ch->topmost_stafftop_uy_noacc, ch->topmost_stafftop_uy);
                        } else if (tuplet_direction == -1) {
                            ch->bottommost_stafftop_uy = MAX(ch->bottommost_stafftop_uy, rescale(ch->stem_offset_ux, first_ux_pos, end_ux_pos, first_uy_pos, last_uy_pos) + CONST_TUPLET_USPACE_FROM_FURTHER_STUFF);
                            ch->bottommost_stafftop_uy_noacc = MAX(ch->bottommost_stafftop_uy_noacc, ch->bottommost_stafftop_uy);
                        }
                        if (ch == end_ch)
                            break;
                    }
                    
                }
            }
        }
    }
}

void build_measure_tuplet_beams(t_notation_obj *r_ob, t_measure *measure){
    t_llll *tree = measure->rhythmic_tree;
    t_llll *scanned = llll_scan(tree, true);
    t_llllelem *scannedelem;
    llll_flatten(scanned, 1, 0);
    t_jfont *jf_tuplets_u = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, round(8.5)); 

    for (scannedelem = scanned->l_tail; scannedelem; scannedelem = scannedelem->l_prev){
        if (hatom_gettype(&scannedelem->l_hatom) == H_OBJ) {
            t_llllelem *elem = (t_llllelem *)hatom_getobj(&scannedelem->l_hatom);
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                #ifdef BACH_RHYTHMIC_TREE_DEBUG
                    char *buf = NULL;
                    llll_to_text_buf(hatom_getllll(&elem->l_hatom), &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, get_strings_for_rhythmic_tree_elements_verbosity1);
                    bach_freeptr(buf);
                #endif
                
                build_measure_tuplet_beams_for_level(r_ob, hatom_getllll(&elem->l_hatom), jf_tuplets_u);
            }
        }
    }
    // global tree
    build_measure_tuplet_beams_for_level(r_ob, tree, jf_tuplets_u);
    
    llll_free(scanned);
    jfont_destroy_debug(jf_tuplets_u);
}


void build_measure_beams(t_notation_obj *r_ob, t_measure *measure)
{
    // building ordinary beams
    void *data[2];
    char only_grace = false;
    data[0] = r_ob;
    data[1] = &only_grace;
    
    // building ordinary beams
    llll_funall(measure->rhythmic_tree, build_measure_beams_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);

    // building grace beams
    only_grace = true;
    llll_funall(measure->rhythmic_tree, build_measure_beams_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
}


void correct_floating_steps_for_voiceensembles(t_notation_obj *r_ob, t_measure *measure)
{
    t_chord *chord;
    t_voice *voice = (t_voice *)measure->voiceparent;
    t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
    t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
    t_voice *v;
    long measure_num = measure->measure_number;
    double measure_onset = notation_item_get_onset_ms(r_ob, (t_notation_item *)measure);
    
    if (first == last)
        return; // nothing to do! The voice is NOT in a voiceensemble!
    
    for (chord = measure->firstchord; chord; chord = chord->next) {
        
        if (chord->firstnote)
            continue;
        
        long rest_steps = 0;
        long top_ext = rest_get_top_extension_in_steps(r_ob, chord->r_sym_duration);
        long bottom_ext = rest_get_bottom_extension_in_steps(r_ob, chord->r_sym_duration);
        long pad = 2;
        double chord_ux_alignment = chord_get_alignment_ux(r_ob, chord);
        double principal_notehead_uwidth = get_principal_notehead_uwidth(r_ob, chord);
        const double ux_pad = 2;

        rest_get_floating_yposition(r_ob, chord, NULL, &rest_steps);

        // checking agains all other voiceensemble voices
        for (v = first; v && v->number < r_ob->num_voices; v = voice_get_next(r_ob, v)) {
            if (v == voice) {
                if (v == last)
                    break;
                else
                    continue;
            }
            
            if (v->part_index % 2 == voice->part_index % 2) { // same "side of the staff": not much to be done for this...
                if (v == last)
                    break;
                else
                    continue;
            }
            
            t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)v, measure_num);
            t_chord *c;
            if (!m || notation_item_get_onset_ms(r_ob, (t_notation_item *)m) != measure_onset)
                continue;
            
            for (c = m->firstchord; c; c = c->next) {
                if (!c->is_grace_chord && fabs(chord_get_alignment_ux(r_ob, c) - chord_ux_alignment) < principal_notehead_uwidth/2. + ux_pad) {
//                if (!c->is_grace_chord && rat_rat_cmp(c->r_sym_onset, chord->r_sym_onset) == 0) {
                    if (c->firstnote) {
                        if (voice->part_index % 2 == 0) {
                            long notehead_steps = midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(c->lastnote));
                            if (rest_steps - bottom_ext < notehead_steps + pad) {
                                chord->float_steps += (notehead_steps + bottom_ext + pad - rest_steps);
                                if (chord->float_steps % 2 && (rat_rat_cmp(chord->figure, RAT_1OVER2) == 0 || rat_long_cmp(chord->figure, 1) == 0))
                                    chord->float_steps += 1;
                                rest_get_floating_yposition(r_ob, chord, NULL, &rest_steps);
                            }
                        } else {
                            long notehead_steps = midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(c->lastnote));
                            if (rest_steps + top_ext > notehead_steps - pad) {
                                chord->float_steps -= (rest_steps + top_ext - notehead_steps + pad);
                                if (chord->float_steps % 2 && (rat_rat_cmp(chord->figure, RAT_1OVER2) == 0 || rat_long_cmp(chord->figure, 1) == 0))
                                    chord->float_steps -= 1;
                                rest_get_floating_yposition(r_ob, chord, NULL, &rest_steps);
                            }
                        }
                    }
                    break;
                }
            }
            
            if (v == last)
                break;
        }
    }
}

void build_beams_structures(t_notation_obj *r_ob, t_measure *measure) {    // STEP02 of the beaming process
    // In this second part of the function, we aim to calculate all the graphical values linked to the beams, which we need to build.
    
    // We check ties again (after having set the <measure_filling> field to each measure)
    check_measure_ties(r_ob, measure, r_ob->tie_assign_pitch, 2);

    // We reset the floatsteps
    reset_floatsteps(r_ob, measure);
    
    // We reset the <stemtip_stafftop_uy> for a default octave-length-stem, but also the <bottommost_stafftop_uy> and <topmost_stafftop_uy> fields of each chord
    reset_stemtip_topmost_bottommost_stafftop_uy_positions(r_ob, measure);

    // We clear the existing beams
    clear_measure_beams(r_ob, measure);
        
    // Correct floating steps of rests due to the presence of a conflicting notehead in another part
    correct_floating_steps_for_voiceensembles(r_ob, measure);
    
    // We build the proper #t_beam structures for beams
    build_measure_beams(r_ob, measure);

    // We build the proper #t_beam structures for tuplets
    build_measure_tuplet_beams(r_ob, measure);
    
    // We flatten ONLY the levels whose l_thing shows they are graphical only
    llll_funall(measure->rhythmic_tree, flatten_level_if_graphical_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    
    
    // We DON'Tfree the specific level information contained in the l_thing fields of each llll in the beaming tree. 
    // It's precious to inform us about levels, without needing to perform process_rhythmic_tree again
}


void calculate_chords_and_tempi_measure_onsets(t_notation_obj *r_ob, t_measure *measure){
    t_chord *curr_ch;
    t_tempo *curr_tempo;
    t_timepoint tp1, tp2;
    long conta = 0; 
    char verbose = false;

    curr_ch = measure->firstchord;
    tp1 = build_timepoint(measure->measure_number, long2rat(0));
    tp2 = build_timepoint(measure->measure_number, long2rat(0));
    if (verbose)
        post("**** Measure %ld", measure->measure_number + 1);
    while (curr_ch) {
        curr_ch->r_measure_onset_sec = get_rat_durations_sec_between_timepoints(r_ob, measure->voiceparent, tp1, tp2);
        if (verbose) {
            conta++;
            object_post((t_object *) r_ob, "Chord %ld. r_onset_sec: %ld/%ld = %f", conta, curr_ch->r_measure_onset_sec.r_num, curr_ch->r_measure_onset_sec.r_den, rat2double(curr_ch->r_measure_onset_sec));
        }
        if (!curr_ch->is_grace_chord)
            tp2.pt_in_measure = rat_rat_sum(tp2.pt_in_measure, rat_abs(curr_ch->r_sym_duration));
        curr_ch = curr_ch->next;
    }
    
    curr_tempo = measure->firsttempo;
    while (curr_tempo) {
        curr_tempo->r_measure_onset_sec = get_rat_durations_sec_between_timepoints(r_ob, measure->voiceparent, tp1, build_timepoint(curr_tempo->owner->measure_number, curr_tempo->changepoint));
        curr_tempo = curr_tempo->next;
    }
}




double chord_get_onset_ms(t_chord *chord){
    if (!chord->is_score_chord)
        return chord->onset;
    return 1000 * rat2double(chord->r_measure_onset_sec) + chord->parent->tuttipoint_onset_ms + (chord->parent->tuttipoint_reference ? chord->parent->tuttipoint_reference->onset_ms : 0);
}

double get_tempo_onset_ms(t_tempo *tempo){
    return 1000 * rat2double(tempo->r_measure_onset_sec) + tempo->owner->tuttipoint_onset_ms + tempo->owner->tuttipoint_reference->onset_ms;
}

t_note *chord_get_longest_note(t_notation_obj *r_ob, t_chord *chord)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_note *longest = NULL;
        for (t_note *nt = chord->firstnote; nt; nt = nt->next)
            if (!longest || nt->duration > longest->duration)
                longest = nt;
        return longest;
    } else
        return chord->firstnote;
}


double chord_get_alignment_x(t_notation_obj *r_ob, t_chord *chord)
{
    switch (r_ob->obj_type) {
        case k_NOTATION_OBJECT_SCORE:
            return unscaled_xposition_to_xposition(r_ob, chord_get_alignment_ux(r_ob, chord));
            break;
            
        case k_NOTATION_OBJECT_ROLL:
            return onset_to_xposition_roll(r_ob, chord->onset, NULL);
            break;
            
        default:
            return 0;
            break;
    }
}


double chord_get_alignment_ux(t_notation_obj *r_ob, t_chord *chord)
{
    switch (r_ob->obj_type) {
        case k_NOTATION_OBJECT_SCORE:
        {
            if (!chord->parent) {
                object_error((t_object *)r_ob, "There's a chord with no measure!");
                return 0;
            }
            if (!chord->parent->tuttipoint_reference) {
                object_error((t_object *)r_ob, "There's a measure with no tuttipoint reference!");
                return 0;
            }
            
            if (r_ob->spacing_type == k_SPACING_PROPORTIONAL)
                return chord->parent->tuttipoint_reference->offset_ux + chord->alignment_ux;
            else // shouldn't we use the line above also for non-proportional spacing? Why didn't we?
                return chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux -
                (chord->r_sym_duration.r_num >= 0 ? chord->direction * chord_get_mainside_notehead_uwidth(r_ob, chord->r_sym_duration, chord)/2. : 0);
        }
            break;
            
        case k_NOTATION_OBJECT_ROLL:
            return xposition_to_unscaled_xposition(r_ob, chord_get_alignment_x(r_ob, chord));
            break;
            
        default:
            return 0;
            break;
    }
}



double get_tail_alignment_x(t_notation_obj *r_ob, t_note *note)
{
    switch (r_ob->obj_type) {
        case k_NOTATION_OBJECT_SCORE:
            return unscaled_xposition_to_xposition(r_ob, get_tail_alignment_ux(r_ob, note));
            break;
            
        case k_NOTATION_OBJECT_ROLL:
        {
            t_chord *chord = note->parent;
            if (!chord) {
                object_error((t_object *)r_ob, "There's a note with no chord!");
                return 0;
            }
            
            return onset_to_xposition_roll(r_ob, chord->onset + chord_get_max_duration(r_ob, chord), NULL);
        }
            break;
            
        default:
            return 0;
            break;
    }
}


double get_tail_alignment_ux(t_notation_obj *r_ob, t_note *note)
{
    switch (r_ob->obj_type) {
        case k_NOTATION_OBJECT_SCORE:
        {
            t_chord *chord = note->parent;
            if (!chord) {
                object_error((t_object *)r_ob, "There's a note with no chord!");
                return 0;
            }

            if (!chord->parent) {
                object_error((t_object *)r_ob, "There's a chord with no measure!");
                return 0;
            }
            
            if (!chord->parent->tuttipoint_reference) {
                object_error((t_object *)r_ob, "There's a measure with no tuttipoint reference!");
                return 0;
            }
            
            return chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux + chord->duration_ux;
        }
            break;
            
        case k_NOTATION_OBJECT_ROLL:
            return xposition_to_unscaled_xposition(r_ob, get_tail_alignment_x(r_ob, note));
            break;
            
        default:
            return 0;
            break;
    }
}




t_rational ts_to_division(t_notation_obj *r_ob, t_timesignature *ts)
{
    t_rational div;
    t_llll *ll = ts_to_beaming_boxes(r_ob, ts, NULL, &div);
    llll_free(ll);
    return div;
}

t_rational ts_to_division_for_PWGL(t_notation_obj *r_ob, t_timesignature *ts)
{
    t_rational div;
    t_llll *ll = ts_to_beaming_boxes(r_ob, ts, &div, NULL);
    llll_free(ll);
    return div;
}

t_marker *nth_marker(t_notation_obj *r_ob, long n)
{
    t_marker *curr = r_ob->firstmarker;
    long i;
    long zero_based_index = n-1;
    
    if (zero_based_index < 0)
        return NULL;
    
    if (zero_based_index > r_ob->num_markers)
        return NULL;
    
    for (i=0; i<zero_based_index && curr; i++)
        curr = curr->next;
    return curr;
    // to be improved: if the marker# is > n/2, pass the list the other way round!
}

// computes the nth (1-based) chord of the whole nroll
t_chord* nth_chord_of_rollvoice(t_rollvoice *voice, long n)
{
    t_chord *curr = voice->firstchord; 
    long i; 
    long zero_based_index = n-1; 

    if (zero_based_index < 0) 
        return NULL;
    
    if (zero_based_index > voice->num_chords) 
        return NULL;
    
    for (i=0; i<zero_based_index && curr; i++)
        curr = curr->next;
    return curr;
    // to be improved: if the chord# is > n/2, pass the list the other way round!
}


void fill_marker_path_from_llllelem_range(t_notation_obj *r_ob, t_llllelem *first_llllelem, long *marker_num)
{
    // initializing stuff
    if (marker_num)
        *marker_num = 1;
    
    long tot_size = 0;
    t_llllelem *temp = first_llllelem;
    while (temp) {
        tot_size++;
        temp = temp->l_next;
    }
    
    if (tot_size >= 1 && is_hatom_number(&first_llllelem->l_hatom)) {
        *marker_num = hatom_getlong(&first_llllelem->l_hatom);
    }
}

void fill_measure_path_from_llllelem_range(t_notation_obj *r_ob, t_llllelem *first_llllelem, 
                                         long *voice_num, long *meas_num)
{
    // initializing stuff
    if (voice_num)
        *voice_num = 1;
    if (meas_num)
        *meas_num = 1;
    
    long tot_size = 0;
    t_llllelem *temp = first_llllelem;
    while (temp) {
        tot_size++;
        temp = temp->l_next;
    }
    
    if (tot_size == 1 && is_hatom_number(&first_llllelem->l_hatom)) {
        *meas_num = hatom_getlong(&first_llllelem->l_hatom);
    } else if (tot_size >= 2) { 
        if (is_hatom_number(&first_llllelem->l_hatom))
            *voice_num = hatom_getlong(&first_llllelem->l_hatom);
        if (is_hatom_number(&first_llllelem->l_next->l_hatom))
            *meas_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
    }
}


/// BEWARE: this function is 1-based!!!
void global_chord_number_to_measure_and_chord_index(t_notation_obj *r_ob, long voice_num, long global_chord_num,
                                                    long *local_chord_num, long *meas_num,
                                                    char tiemode_all, char skiprests, char restseqmode_all)
{
    t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voice_num - 1);
    if (voice) {
        if (global_chord_num == 0) {
            *meas_num = 0;
            *local_chord_num = 0;
        } else if (global_chord_num > 0) {
            if (tiemode_all || skiprests || restseqmode_all) {
                long count = 0;
                t_chord *chord = voice_get_first_chord(r_ob, (t_voice *)voice);
                for (; chord && count < global_chord_num; ) {
                    if (chord->firstnote) {
                        count++;
                        if (count >= global_chord_num)
                            break;
                        if (tiemode_all) {
                            while (chord && chord_is_all_tied_to(r_ob, chord, false, NULL))
                                chord = chord_get_next(chord);
                        }
                    } else {
                        if (!skiprests)
                            count++;
                        if (count >= global_chord_num)
                            break;
                        if (restseqmode_all) {
                            t_chord *temp;
                            while ((temp = chord_get_next(chord)) && !temp->firstnote)
                                chord = temp;
                        }
                    }
                    chord = chord_get_next(chord);
                }
                if (count == global_chord_num && chord) {
                    *meas_num = chord->parent->measure_number + 1;
                    *local_chord_num = chord_get_position(r_ob, chord);
                } else {
                    *meas_num = 0;
                    *local_chord_num = 0;
                }
            } else {
                for (t_measure *meas = voice->firstmeasure; meas; meas = meas->next) {
                    if (global_chord_num <= meas->num_chords) {
                        *local_chord_num = global_chord_num;
                        *meas_num = meas->measure_number + 1;
                        return;
                    } else {
                        global_chord_num -= meas->num_chords;
                    }
                }
                *local_chord_num = global_chord_num;
                *meas_num = voice->num_measures;
            }
        } else if (global_chord_num < 0) {
            if (tiemode_all || skiprests || restseqmode_all) {
                long count = 0;
                t_chord *chord = voice_get_last_chord(r_ob, (t_voice *)voice);
                global_chord_num = -global_chord_num;
                for (; chord && count < global_chord_num; ) {
                    if (chord->firstnote) {
                        if (tiemode_all) {
                            while (chord && chord_is_all_tied_from(chord, false))
                                chord = chord_get_prev(chord);
                        }
                        count++;
                    } else {
                        if (restseqmode_all) {
                            t_chord *temp;
                            while ((temp = chord_get_prev(chord)) && !temp->firstnote)
                                chord = temp;
                        }
                        if (!skiprests)
                            count++;
                    }
                    if (count >= global_chord_num)
                        break;
                    chord = chord_get_prev(chord);
                }
                if (count == global_chord_num && chord) {
                    *meas_num = chord->parent->measure_number + 1;
                    *local_chord_num = chord_get_position(r_ob, chord);
                } else {
                    *meas_num = 0;
                    *local_chord_num = 0;
                }
            } else {
                for (t_measure *meas = voice->lastmeasure; meas; meas = meas->prev) {
                    if (-global_chord_num <= meas->num_chords) {
                        *local_chord_num = global_chord_num;
                        *meas_num = meas->measure_number + 1;
                        return;
                    } else {
                        global_chord_num += meas->num_chords;
                    }
                }
                *local_chord_num = global_chord_num;
                *meas_num = voice->num_measures;
            }
        }
        return;
    }
}

// inputs are 1-based
void handle_params_for_chord_number_in_measure(t_notation_obj *r_ob, long voice_num, long meas_num, long *chord_num, char tiemode_all, char skiprests, char restseqmode_all)
{
    if ((!tiemode_all) && (!skiprests) && (!restseqmode_all))
        return;
    
    t_voice *voice = nth_voice(r_ob, voice_num-1);
    if (!voice)
        return;
    
    t_measure *meas = nth_measure_of_scorevoice((t_scorevoice *)voice, meas_num-1);
    if (!meas)
        return;
    
    long cn = *chord_num;
    if (cn == 0) {
        // nothing to do
    } else if (cn > 0) {
        long count = 0, chord_index = 0;
        t_chord *chord = meas->firstchord;
        for (; chord && count < cn; ) {
            chord_index++;
            if (chord->firstnote) {
                count++;
                if (count >= cn)
                    break;
                if (tiemode_all) {
                    while (chord && chord_is_all_tied_to(r_ob, chord, true, NULL))
                        chord = chord->next;
                }
            } else {
                if (!skiprests)
                    count++;
                if (count >= cn)
                    break;
                if (restseqmode_all) {
                    t_chord *temp;
                    while ((temp = chord->next) && !temp->firstnote)
                        chord = temp;
                }
            }
            chord = chord->next;
        }
        if (count == cn && chord) {
            *chord_num = chord_index;
        }
    } else {
        long count = 0, chord_index = meas->num_chords+1;
        t_chord *chord = meas->lastchord;
        cn = -cn;
        for (; chord && count < cn; ) {
            chord_index--;
            if (chord->firstnote) {
                if (tiemode_all) {
                    while (chord && chord_is_all_tied_from(chord, true))
                        chord = chord->prev;
                }
                count++;
            } else {
                if (restseqmode_all) {
                    t_chord *temp;
                    while ((temp = chord->prev) && !temp->firstnote)
                        chord = temp;
                }
                if (!skiprests)
                    count++;
            }
            if (count >= cn)
                break;
            chord = chord->prev;
        }
        if (count == cn && chord) {
            *chord_num = chord_index;
        }
        
    }
    
}

void fill_chord_path_from_llllelem_range(t_notation_obj *r_ob, t_llllelem *first_llllelem,
                                         long *voice_num, long *meas_num, long *chord_num,
                                         char tiemode_all, char skiprests, char restseqmode_all)
{
    // initializing stuff
    if (voice_num)
        *voice_num = 1;
    if (meas_num)
        *meas_num = 1;
    if (chord_num)
        *chord_num = 1;
    
    long tot_size = 0;
    t_llllelem *temp = first_llllelem;
    while (temp) {
        tot_size++;
        temp = temp->l_next;
    }
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if (tot_size == 1 && is_hatom_number(&first_llllelem->l_hatom)) {
            *chord_num = hatom_getlong(&first_llllelem->l_hatom);
        } else if (tot_size >= 2) { 
            if (is_hatom_number(&first_llllelem->l_hatom))
                *voice_num = hatom_getlong(&first_llllelem->l_hatom);
            if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                *chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
        }
        
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (tot_size == 1 && is_hatom_number(&first_llllelem->l_hatom)) {
//            *chord_num = hatom_getlong(&first_llllelem->l_hatom);
            long global_chord_num = hatom_getlong(&first_llllelem->l_hatom);
            global_chord_number_to_measure_and_chord_index(r_ob, *voice_num, global_chord_num, chord_num, meas_num,
                                                           tiemode_all, skiprests, restseqmode_all);

        } else if (tot_size >= 2) {
            if (tot_size >= 3) {
                if (is_hatom_number(&first_llllelem->l_hatom))
                    *voice_num = hatom_getlong(&first_llllelem->l_hatom);
                first_llllelem = first_llllelem->l_next;
            }

            if (hatom_gettype(&first_llllelem->l_hatom) == H_SYM && hatom_getsym(&first_llllelem->l_hatom) == _llllobj_sym_any) {
                // chord is numbered from the beginning
                long global_chord_num = 1;
                if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                    global_chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
                global_chord_number_to_measure_and_chord_index(r_ob, *voice_num, global_chord_num, chord_num, meas_num,
                                                               tiemode_all, skiprests, restseqmode_all);
            } else {
                if (is_hatom_number(&first_llllelem->l_hatom))
                    *meas_num = hatom_getlong(&first_llllelem->l_hatom);
                if (is_hatom_number(&first_llllelem->l_next->l_hatom)) {
                    *chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
                    handle_params_for_chord_number_in_measure(r_ob, *voice_num, *meas_num, chord_num, tiemode_all, skiprests, restseqmode_all);
                }
            }
        }
    }
}

void fill_note_path_from_llllelem_range(t_notation_obj *r_ob, t_llllelem *first_llllelem, 
                                        long *voice_num, long *meas_num, long *chord_num, long *note_num,
                                        char tiemode_all, char skiprests, char restseqmode_all)
{
    // initializing stuff
    if (voice_num)
        *voice_num = 1;
    if (meas_num)
        *meas_num = 1;
    if (chord_num)
        *chord_num = 1;
    if (note_num)
        *note_num = 1;
    
    long tot_size = 0;
    t_llllelem *temp = first_llllelem;
    while (temp) {
        tot_size++;
        temp = temp->l_next;
    }
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if (tot_size == 1 && is_hatom_number(&first_llllelem->l_hatom)) {
            *note_num = hatom_getlong(&first_llllelem->l_hatom);
        } else if (tot_size == 2) { 
            if (is_hatom_number(&first_llllelem->l_hatom))
                *chord_num = hatom_getlong(&first_llllelem->l_hatom);
            if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                *note_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
        } else if (tot_size >= 3) { 
            if (is_hatom_number(&first_llllelem->l_hatom))
                *voice_num = hatom_getlong(&first_llllelem->l_hatom);
            if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                *chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
            if (is_hatom_number(&first_llllelem->l_next->l_next->l_hatom))
                *note_num = hatom_getlong(&first_llllelem->l_next->l_next->l_hatom);
        }

    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (tot_size == 1 && is_hatom_number(&first_llllelem->l_hatom)) {
            *note_num = hatom_getlong(&first_llllelem->l_hatom);
        } else if (tot_size == 2) { 
            if (is_hatom_number(&first_llllelem->l_hatom))
                *chord_num = hatom_getlong(&first_llllelem->l_hatom);
            if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                *note_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
        } else if (tot_size >= 3) {
            if (tot_size >= 4) {
                if (is_hatom_number(&first_llllelem->l_hatom))
                    *voice_num = hatom_getlong(&first_llllelem->l_hatom);
                first_llllelem = first_llllelem->l_next;
            }
            
            if (hatom_gettype(&first_llllelem->l_hatom) == H_SYM && hatom_getsym(&first_llllelem->l_hatom) == _llllobj_sym_any) {
                // chord is numbered from the beginning
                long global_chord_num = 1;
                if (is_hatom_number(&first_llllelem->l_next->l_hatom))
                    global_chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
                if (is_hatom_number(&first_llllelem->l_next->l_next->l_hatom))
                    *note_num = hatom_getlong(&first_llllelem->l_next->l_next->l_hatom);
                global_chord_number_to_measure_and_chord_index(r_ob, *voice_num, global_chord_num, chord_num, meas_num, tiemode_all, skiprests, restseqmode_all);
            } else {
                if (is_hatom_number(&first_llllelem->l_hatom))
                    *meas_num = hatom_getlong(&first_llllelem->l_hatom);
                if (is_hatom_number(&first_llllelem->l_next->l_hatom)) {
                    *chord_num = hatom_getlong(&first_llllelem->l_next->l_hatom);
                    handle_params_for_chord_number_in_measure(r_ob, *voice_num, *meas_num, chord_num, tiemode_all, skiprests, restseqmode_all);
                }
                if (is_hatom_number(&first_llllelem->l_next->l_next->l_hatom))
                    *note_num = hatom_getlong(&first_llllelem->l_next->l_next->l_hatom);
            }
        }
    }
}


t_marker *get_marker_from_path(t_notation_obj *r_ob, long marker_num)
{
    if (marker_num < 0)
        marker_num = r_ob->num_markers + marker_num + 1;
    
    if (marker_num <= 0 || marker_num > r_ob->num_markers)
        return NULL;
    
    return nth_marker(r_ob, marker_num);
}

t_measure *measure_get_from_path(t_notation_obj *r_ob, long voice_num, long meas_num)
{
    if (voice_num < 0)
        voice_num = r_ob->num_voices + voice_num + 1;
    
    if (voice_num <= 0 || voice_num > r_ob->num_voices)
        return NULL;
    
    t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voice_num - 1);
        
    if (meas_num < 0)
        meas_num = voice->num_measures + meas_num + 1;
        
    return nth_measure_of_scorevoice(voice, meas_num - 1);
}

t_chord *chord_get_from_path(t_notation_obj *r_ob, long voice_num, long meas_num, long chord_num)
{
    if (voice_num < 0)
        voice_num = r_ob->num_voices + voice_num + 1;
    
    if (voice_num <= 0 || voice_num > r_ob->num_voices)
        return NULL;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_rollvoice *voice = (t_rollvoice *)nth_voice(r_ob, voice_num - 1);
        
        if (chord_num < 0)
            chord_num = voice->num_chords + chord_num + 1;

        if (chord_num > 0 && chord_num <= voice->num_chords)
            return nth_chord_of_rollvoice(voice, chord_num);
        
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voice_num - 1);
        
        if (meas_num < 0)
            meas_num = voice->num_measures + meas_num + 1;
        
        t_measure *meas = nth_measure_of_scorevoice(voice, meas_num - 1);
        if (meas) {
            if (chord_num < 0)
                chord_num = meas->num_chords + chord_num + 1;
            
            if (chord_num > 0 && chord_num <= meas->num_chords) 
                return nth_chord(meas, chord_num - 1);
        }
    }
    return NULL;
}


t_note *note_get_from_path(t_notation_obj *r_ob, long voice_num, long meas_num, long chord_num, long note_num)
{
    if (voice_num < 0)
        voice_num = r_ob->num_voices + voice_num + 1;

    if (voice_num <= 0 || voice_num > r_ob->num_voices)
        return NULL;

    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_rollvoice *voice = (t_rollvoice *)nth_voice(r_ob, voice_num - 1);

        if (chord_num < 0)
            chord_num = voice->num_chords + chord_num + 1;
        
        if (chord_num > 0 && chord_num <= voice->num_chords) {
            t_chord *temp = nth_chord_of_rollvoice(voice, chord_num);
            if (temp) {
                if (note_num < 0)
                    note_num = temp->num_notes + note_num + 1;
                return nth_note(temp, note_num - 1);
            }
        }
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, voice_num - 1);
        
        if (meas_num < 0)
            meas_num = voice->num_measures + meas_num + 1;
        
        t_measure *meas = nth_measure_of_scorevoice(voice, meas_num - 1);
        if (meas) {
            if (chord_num < 0)
                chord_num = meas->num_chords + chord_num + 1;
            
            if (chord_num > 0 && chord_num <= meas->num_chords) {
                t_chord *temp = nth_chord(meas, chord_num - 1);
                if (temp) {
                    if (note_num < 0)
                        note_num = temp->num_notes + note_num + 1;
                    return nth_note(temp, note_num - 1);
                }
            }
        }
    }
    return NULL;
}

t_marker *get_marker_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem)
{
    long marker_num = 1;
    fill_marker_path_from_llllelem_range(r_ob, start_llllelem, &marker_num);
    return get_marker_from_path(r_ob, marker_num);
}

t_chord *chord_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem, char tiemode_all, char skiprests, char restseqmode_all)
{
    long voice_num = 1, meas_num = 1, chord_num = 1;
    fill_chord_path_from_llllelem_range(r_ob, start_llllelem, &voice_num, &meas_num, &chord_num, tiemode_all, skiprests, restseqmode_all);
    return chord_get_from_path(r_ob, voice_num, meas_num, chord_num);
}

t_note *note_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem, char tiemode_all, char skiprests, char restseqmode_all)
{
    long voice_num = 1, meas_num = 1, chord_num = 1, note_num = 1;
    fill_note_path_from_llllelem_range(r_ob, start_llllelem, &voice_num, &meas_num, &chord_num, &note_num, tiemode_all, skiprests, restseqmode_all);
    return note_get_from_path(r_ob, voice_num, meas_num, chord_num, note_num);
}


t_measure *measure_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem){
    long voice_num = 1, meas_num = 1;
    fill_measure_path_from_llllelem_range(r_ob, start_llllelem, &voice_num, &meas_num);
    return measure_get_from_path(r_ob, voice_num, meas_num);
}

void add_all_chord_notes_to_preselection(t_notation_obj *r_ob, t_chord *chord){
    if (chord) {
        t_note *curr_nt;
        for (curr_nt = chord->firstnote; curr_nt; curr_nt = curr_nt->next) // cycle on the notes
            notation_item_add_to_preselection(r_ob, (t_notation_item *)curr_nt);
    }
}


void get_timesig_at_timepoint(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp, t_timesignature *timesig) {
    if (tp.voice_num  != voice->v_ob.number) {
        double ms = timepoint_to_ms(r_ob, tp, tp.voice_num);
        tp = ms_to_timepoint(r_ob, ms, voice->v_ob.number, k_MS_TO_TP_RETURN_INTERPOLATION);
    }
    
    tp.measure_num = CLAMP(tp.measure_num, 0, voice->num_measures-1);
    t_measure *meas = nth_measure_of_scorevoice(voice, tp.measure_num);
    *timesig = meas->timesignature;
}


void get_tempo_at_timepoint(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp, t_rational *figure_tempo_value, t_rational *tempo_figure, t_rational *tempo_value, char *interpolation){
    
    if (tp.voice_num  != voice->v_ob.number) {
        double ms = timepoint_to_ms(r_ob, tp, tp.voice_num);
        tp = ms_to_timepoint(r_ob, ms, voice->v_ob.number, k_MS_TO_TP_RETURN_INTERPOLATION);
    }
    
// calculates the tempo at a given timepoint. Fills the four last pointers given as argument
    t_measure *meas = nth_measure_of_scorevoice(voice, tp.measure_num);

    if (meas) {
        t_tempo *before = meas->lasttempo;
        t_measure *tmp;
        t_tempo *after;
        t_rational new_tempo_value;
        while (before && ((before->owner->measure_number == tp.measure_num) && (rat_rat_cmp(before->changepoint, tp.pt_in_measure) > 0)))
            before = tempo_get_prev(before);
        tmp = meas;
        tmp = tmp->prev;
        while (tmp && !before) {
            before = tmp->lasttempo;
            tmp = tmp->prev;
        }
        // now before has the previous tempo , or NULL if there isn't any previous tempo, with respect to the timepoint <tp>
        after = meas->firsttempo;
        while (after && ((after->owner->measure_number == tp.measure_num) && (rat_rat_cmp(after->changepoint, tp.pt_in_measure) < 0)))
            after = tempo_get_next(after);
        tmp = meas;
        tmp = tmp->next;
        while (tmp && !after) {
            after = tmp->firsttempo;
            tmp = tmp->next;
        }
        
        if (!before && !after) { // no tempo at all
            *tempo_figure = ts_to_division(r_ob, &meas->timesignature);
            *tempo_value = long2rat(60);
            *figure_tempo_value = long2rat(60);
            *interpolation = 0;
            return;
        } 
        
        if (!before) { 
            *tempo_figure = after->tempo_figure;
            *tempo_value = after->tempo_value;
            *figure_tempo_value = after->figure_tempo_value;
            *interpolation = 0;
            return;
        }
        
        if (!after) { 
            *tempo_figure = before->tempo_figure;
            *tempo_value = before->tempo_value;
            *figure_tempo_value = before->figure_tempo_value;
            *interpolation = 0;
            return;
        }
        
        
        // if we're here, it means that we have both <before> and <after>
        if (before->interpolation_type)
            new_tempo_value = rat_rat_sum(before->tempo_value, rat_rat_prod(get_sym_durations_between_timepoints(voice, build_timepoint(before->owner->measure_number, before->changepoint), tp), 
                                                                        rat_rat_div(rat_rat_diff(after->tempo_value, before->tempo_value),
                                                                                    get_sym_durations_between_timepoints(voice, build_timepoint(before->owner->measure_number, before->changepoint), build_timepoint(after->owner->measure_number, after->changepoint)))));
        else
            new_tempo_value = before->tempo_value;
            
        *tempo_value = new_tempo_value;
        *tempo_figure = before->tempo_figure;
        *figure_tempo_value = rat_rat_div(new_tempo_value, rat_long_prod(*tempo_figure, 4));
        *interpolation = before->interpolation_type;
    }
}


t_rational chord_get_overall_rat_onset_sec(t_chord *chord){
    return rat_rat_sum(rat_rat_sum(chord->r_measure_onset_sec, chord->parent->r_tuttipoint_onset_sec), chord->parent->tuttipoint_reference->r_onset_sec);
}

t_rational chord_get_overall_rat_onset_sec_plus_duration(t_chord *chord){
    t_chord *nextchord;
    if (!chord)
        return long2rat(0);
        
    nextchord = chord_get_next(chord);
    if (nextchord)
        return chord_get_overall_rat_onset_sec(nextchord);
    else if (chord->is_score_chord){
        t_scorevoice *voice = chord->parent->voiceparent;
        return rat_rat_sum(measure_get_overall_rat_onset_sec(voice->lastmeasure), voice->lastmeasure->r_total_duration_sec);
    } 
    
    return long2rat(0);
}

t_rational measure_get_overall_rat_onset_sec(t_measure *measure){
    return rat_rat_sum(measure->r_tuttipoint_onset_sec, measure->tuttipoint_reference->r_onset_sec);
}

double measure_get_overall_onset(t_measure *measure){
    return measure->tuttipoint_onset_ms + measure->tuttipoint_reference->onset_ms;
}

t_rational measure_get_overall_rat_onset_sec_plus_duration(t_measure *measure){
    return rat_rat_sum(rat_rat_sum(measure->r_tuttipoint_onset_sec, measure->tuttipoint_reference->r_onset_sec), measure->r_total_duration_sec);
}


void update_measure_chordnumbers(t_measure *measure) {
    long count = 0; t_chord *chord = measure->firstchord;
    while (chord) {
        count++;
        chord = chord->next;
    }
    measure->num_chords = count;
}


// if next_chord != NULL, the next_chord will be accounted in case the tie was WHITENULL (to define)
// leave NULL also r_ob if not needed
char chord_is_all_tied_to(t_notation_obj *r_ob, t_chord *chord, char within_measure, t_chord *next_chord) {
    t_note *note = chord->firstnote;
    t_note *tmp;

    if (!note) 
        return false;

    if (next_chord)
        for (tmp = next_chord->firstnote; tmp; tmp = tmp->next)
            tmp->r_it.flags = (e_bach_internal_notation_flags) (tmp->r_it.flags & ~k_FLAG_MODIFIED);
    
    while (note) {
        if (!note->tie_to)
            return false;
        if (note->tie_to == WHITENULL && next_chord){
            t_note *tmp;
            char found = false;
            for (tmp = next_chord->firstnote; tmp; tmp = tmp->next)
                if (!(tmp->r_it.flags & k_FLAG_MODIFIED) && note_get_screen_midicents(tmp) == note_get_screen_midicents(note)) {
                    found = true;
                    tmp->r_it.flags = (e_bach_internal_notation_flags) (tmp->r_it.flags | k_FLAG_MODIFIED);
                    if (r_ob && r_ob->tie_assign_pitch)
                        tmp->midicents = note->midicents;
                    break;
                }
            if (!found)
                return false;
        }
        note = note->next;
    }
    
    if (next_chord)
        for (tmp = next_chord->firstnote; tmp; tmp = tmp->next)
            tmp->r_it.flags = (e_bach_internal_notation_flags) (tmp->r_it.flags & ~k_FLAG_MODIFIED);
    
    if (within_measure == 1) {
        if (!chord->next || chord->next->r_sym_duration.r_num < 0 || chord->next->num_notes != chord->num_notes)
            return false;
    } else {
        t_chord *next_ch = chord_get_next(chord);
        if (!next_ch || next_ch->r_sym_duration.r_num < 0 || next_ch->num_notes != chord->num_notes)
            return false;
    }
    return true;
}

char chord_is_all_tied_from(t_chord *chord, char within_measure) {
    t_note *note = chord->firstnote;
    
    if (!note) 
        return false;
    
    while (note) {
        if (note->tie_from == NULL) {
            t_chord *prev = chord_get_prev(chord);
            if (prev) {
                t_note *tmp;
                char found = false;
                for (tmp = prev->firstnote; tmp; tmp = tmp->next) 
                    if (tmp->tie_to == WHITENULL && note_get_screen_midicents(tmp) == note_get_screen_midicents(note)) {
                        found = true;
                        break;
                    }
                if (!found)
                    return false;    
            } else
                return false;
        }
        note = note->next;
    }
    
    if (within_measure == 2) {
        if ((!chord->prev) || (chord->prev->r_sym_duration.r_num < 0) || (chord->prev->num_notes != chord->num_notes))
            return false;
    } else {
        t_chord *prev_ch = chord_get_prev(chord);
        if ((!prev_ch) || (prev_ch->r_sym_duration.r_num < 0) || (prev_ch->num_notes != chord->num_notes))
            return false;
    }
    return true;
}


char is_chord_followed_by_rest(t_notation_obj *r_ob, t_chord *chord, char within_measure) {
    if (!chord)
        return false;
    
    if (within_measure && !chord->next)
        return false;
    
    t_chord *nextch = chord_get_next(chord);
    if (nextch && nextch->r_sym_duration.r_num < 0)
        return true;
    return false;
}


char is_chord_preceded_by_rest(t_notation_obj *r_ob, t_chord *chord, char within_measure) {
    if (!chord)
        return false;

    if (within_measure && !chord->prev)
        return false;
    
    t_chord *prevch = chord_get_prev(chord);
    if (prevch && prevch->r_sym_duration.r_num < 0)
        return true;
    return false;
}

#ifdef BACH_SUPPORT_SLURS
void delete_slur(t_notation_obj *r_ob, t_slur *slur)
{
    long i;
    if (slur) {
        t_note *start = slur->start_note;
        t_note *end = slur->end_note;
        
        if (start) {
            i = 0;
            while (i < start->num_slurs_to)
                if (start->slur_to[i] == slur) {
                    long j;
                    for (j = i+1; j < start->num_slurs_to; j++)
                        start->slur_to[j-1] = start->slur_to[j];
                    start->num_slurs_to--;
                } else
                    i++;
        }
        
        if (end) {
            i = 0;
            while (i < end->num_slurs_from)
                if (end->slur_to[i] == slur) {
                    long j;
                    for (j = i+1; j < end->num_slurs_from; j++)
                        end->slur_from[j-1] = end->slur_from[j];
                    end->num_slurs_from--;
                } else
                    i++;
        }
        
        bach_freeptr(slur);
    }
}
#endif

// returns 1 if needs to check correct scheduling, 0 otherwise
char tempo_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_tempo *tempo)
{
    char need_check_scheduling = false;
    
    if (r_ob->m_inspector.active_bach_inspector_obj_type == k_TEMPO && (t_tempo *)r_ob->m_inspector.active_bach_inspector_item == tempo)
        close_bach_inspector(r_ob, &r_ob->m_inspector);

    if (notation_item_is_selected(r_ob, (t_notation_item *)tempo))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)tempo);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)tempo))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)tempo);

    if (r_ob->j_mousedown_ptr == tempo)
        set_mousedown(r_ob, NULL, k_NONE);
    
    if (r_ob->playing){
        if (r_ob->scheduled_item == (t_notation_item *)tempo) {
            r_ob->scheduled_item = NULL;
            need_check_scheduling = true;
        }
        
        if (tempo->owner && tempo->owner->voiceparent) {
            t_voice *voice = (t_voice *)tempo->owner->voiceparent;
            if (voice->number >= 0 && voice->number < CONST_MAX_VOICES && r_ob->tempo_play_cursor[voice->number] == tempo)
                r_ob->tempo_play_cursor[voice->number] = NULL;
        }
    }
    
    return need_check_scheduling;
}

t_llllelem *notation_item_to_undo_tick(t_notation_obj *r_ob, t_notation_item *item)
{
    t_llllelem *elem;
    for (elem = r_ob->undo_notation_items_under_tick->l_head; elem; elem = elem->l_next) {
        if ((t_notation_item *)hatom_getobj(&elem->l_hatom) == item)
            return elem;
    }
    return NULL;
}

char notation_item_is_under_undo_tick(t_notation_obj *r_ob, t_notation_item *item)
{
    t_llllelem *tick = notation_item_to_undo_tick(r_ob, item);
    if (tick)
        return true;
    return false;
}

void check_undo_notation_items_under_tick_dependencies(t_notation_obj *r_ob, t_notation_item *item)
{
    t_llllelem *elem = r_ob->undo_notation_items_under_tick->l_head;
    while (elem) {
        t_llllelem *next_elem = elem->l_next;
        t_notation_item *it = (t_notation_item *)hatom_getobj(&elem->l_hatom);
        if (it == item)
            llll_destroyelem(elem);
        elem = next_elem;    
    }
}

char measure_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_measure *meas)
{
    char need_check_scheduling = false;
    if ((r_ob->m_inspector.active_bach_inspector_obj_type == k_MEASURE && (t_measure *)r_ob->m_inspector.active_bach_inspector_item == meas) ||
        (r_ob->m_inspector.active_bach_inspector_obj_type == k_TEMPO && ((t_tempo *)r_ob->m_inspector.active_bach_inspector_item)->owner == meas) ||
        (r_ob->m_inspector.active_bach_inspector_obj_type == k_CHORD && ((t_chord *)r_ob->m_inspector.active_bach_inspector_item)->parent == meas) ||
        (r_ob->m_inspector.active_bach_inspector_obj_type == k_NOTE && ((t_note *)r_ob->m_inspector.active_bach_inspector_item)->parent->parent == meas))
        close_bach_inspector(r_ob, &r_ob->m_inspector);

    if (notation_item_is_selected(r_ob, (t_notation_item *)meas))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)meas);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)meas))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)meas);

    check_undo_notation_items_under_tick_dependencies(r_ob, (t_notation_item *)meas);

    if (r_ob->j_mousedown_ptr == meas)
        set_mousedown(r_ob, NULL, k_NONE);

    if (r_ob->j_last_mousedown_ptr == meas) {
        r_ob->j_last_mousedown_ptr = NULL;
        r_ob->j_last_mousedown_obj_type = k_NONE;
    }

    if (r_ob->playing){
        if (r_ob->scheduled_item == (t_notation_item *)meas) {
            r_ob->scheduled_item = NULL;
            need_check_scheduling = true;
        }
        
        if (meas->voiceparent) {
            t_voice *voice = (t_voice *)meas->voiceparent;
            if (voice->number >= 0 && voice->number < CONST_MAX_VOICES && r_ob->measure_play_cursor[voice->number] == meas)
                r_ob->measure_play_cursor[voice->number] = NULL;
        }
    }
    return need_check_scheduling;
}

void note_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_note *note, char also_remove_previous_ties)
{
    if (notation_item_is_selected(r_ob, (t_notation_item *)note))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)note);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)note))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)note);

    for (t_bpt *bpt = note->firstbreakpoint ? note->firstbreakpoint->next : NULL; bpt; bpt = bpt->next)
        breakpoint_check_dependencies_before_deleting_it(r_ob, bpt);
    
    if (r_ob->lambda_selected_item_ID == note->r_it.ID)
        r_ob->lambda_selected_item_ID = 0;
    
    if (r_ob->j_mousedown_ptr == note)
        set_mousedown(r_ob, NULL, k_NONE);

    if ((t_notation_item *)note == r_ob->active_slot_notationitem)
        r_ob->active_slot_notationitem = NULL;

    if (r_ob->j_last_mousedown_ptr == note) {
        r_ob->j_last_mousedown_ptr = NULL;
        r_ob->j_last_mousedown_obj_type = k_NONE;
    }

    
    if (r_ob->m_inspector.active_bach_inspector_obj_type == k_NOTE && (t_note *)r_ob->m_inspector.active_bach_inspector_item == note)
        close_bach_inspector(r_ob, &r_ob->m_inspector);


    check_undo_notation_items_under_tick_dependencies(r_ob, (t_notation_item *)note);

    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (note->tie_to) {
            if (note->tie_to != (t_note *) WHITENULL)
                note->tie_to->tie_from = NULL;
            else {
                t_chord *tch = note->parent ? chord_get_next(note->parent) : NULL;
                if (tch) {
                    for (t_note *tnt = tch->firstnote; tnt; tnt = tnt->next)
                        if (tnt->tie_from == note)
                            tnt->tie_from = NULL;
                }
            }
        }
        
        if (note->tie_from) {
            if (note->tie_from != (t_note *) WHITENULL)
                note->tie_from->tie_to = (!note->tie_from->tie_to || also_remove_previous_ties) ? NULL : (t_note *) WHITENULL;
            else {
                t_chord *tch = note->parent ? chord_get_prev(note->parent) : NULL;
                if (tch) {
                    for (t_note *tnt = tch->firstnote; tnt; tnt = tnt->next)
                        if (tnt->tie_to == note)
                            tnt->tie_to = (!tnt->tie_to || also_remove_previous_ties) ? NULL : (t_note *) WHITENULL;
                }
            }
        }

#ifdef BACH_SUPPORT_SLURS
        // deleting slurs, if any
        for (i = 0; i < note->num_slurs_to; i++)
            delete_slur(r_ob, note->slur_to[i]);
        for (i = 0; i < note->num_slurs_from; i++)
            delete_slur(r_ob, note->slur_from[i]);
#endif
    }
    

    if (note->played) {
        t_llllelem *playedelem = r_ob->notes_being_played->l_head, *nextplayedelem;
        while (playedelem) {
            nextplayedelem = playedelem->l_next;
            if ((t_note *)hatom_getobj(&playedelem->l_hatom) == note)
                llll_destroyelem(playedelem);
            playedelem = nextplayedelem;
        }
    }
    
    if (r_ob->active_slot_notationitem == (t_notation_item *)note) {
        close_slot_window(r_ob);
        r_ob->active_slot_notationitem = NULL;
    }

}


t_voice *chord_get_voice(t_notation_obj *r_ob, t_chord *ch){
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return (t_voice *)ch->voiceparent;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        return ch->parent ? (t_voice *)ch->parent->voiceparent : NULL;
    return NULL;
}


void dynamics_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_dynamics *dyn)
{
    if (notation_item_is_selected(r_ob, (t_notation_item *)dyn))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)dyn);
    
    if (notation_item_is_preselected(r_ob, (t_notation_item *)dyn))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)dyn);
    
    if (r_ob->j_mousedown_ptr == dyn)
        set_mousedown(r_ob, NULL, k_NONE);
    
    if (r_ob->j_last_mousedown_ptr == dyn) {
        r_ob->j_last_mousedown_ptr = NULL;
        r_ob->j_last_mousedown_obj_type = k_NONE;
    }
}


void breakpoint_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_bpt *bpt)
{
    if (notation_item_is_selected(r_ob, (t_notation_item *)bpt))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)bpt);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)bpt))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)bpt);

    if (r_ob->m_inspector.active_bach_inspector_obj_type == k_PITCH_BREAKPOINT && (t_bpt *)r_ob->m_inspector.active_bach_inspector_item == bpt)
        close_bach_inspector(r_ob, &r_ob->m_inspector);

    if (r_ob->j_mousedown_ptr == bpt)
        set_mousedown(r_ob, NULL, k_NONE);
    
    if (r_ob->j_last_mousedown_ptr == bpt) {
        r_ob->j_last_mousedown_ptr = NULL;
        r_ob->j_last_mousedown_obj_type = k_NONE;
    }

}


// returns 1 if needs to check correct scheduling, 0 otherwise
char chord_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_chord *chord, char also_remove_previous_ties, t_chord *update_chord_play_cursor_to_this_chord_if_needed){
    t_note *nt;
    char need_check_scheduling = false;
    
//    notation_obj_check_force(r_ob, false); // doesn't crash
    for (nt = chord->firstnote; nt; nt = nt->next)
        note_check_dependencies_before_deleting_it(r_ob, nt, also_remove_previous_ties);
    
//    notation_obj_check_force(r_ob, false); // crashes
    if (notation_item_is_selected(r_ob, (t_notation_item *)chord))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)chord);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)chord))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)chord);

    if (chord == r_ob->notation_cursor.chord) 
        r_ob->notation_cursor.chord = chord->next;
    
    if ((t_notation_item *)chord == r_ob->active_slot_notationitem)
        r_ob->active_slot_notationitem = NULL;
    
    if ((r_ob->m_inspector.active_bach_inspector_obj_type == k_CHORD && (t_chord *)r_ob->m_inspector.active_bach_inspector_item == chord) ||
        (r_ob->m_inspector.active_bach_inspector_obj_type == k_NOTE && ((t_note *)r_ob->m_inspector.active_bach_inspector_item)->parent == chord))
        close_bach_inspector(r_ob, &r_ob->m_inspector);
    
    if (chord->r_it.group)
        remove_element_from_group(r_ob, chord->r_it.group, (t_notation_item *)chord);
    
    if (r_ob->lambda_selected_item_ID == chord->r_it.ID) 
        r_ob->lambda_selected_item_ID = 0;

    if (r_ob->j_mousedown_ptr == chord)
        set_mousedown(r_ob, NULL, k_NONE);
    
    if (r_ob->j_last_mousedown_ptr == chord) {
        r_ob->j_last_mousedown_ptr = NULL;
        r_ob->j_last_mousedown_obj_type = k_NONE;
    }

    
    check_undo_notation_items_under_tick_dependencies(r_ob, (t_notation_item *)chord);

    if (r_ob->playing){
        if (r_ob->scheduled_item == (t_notation_item *)chord) {
            r_ob->scheduled_item = NULL;
            need_check_scheduling = true;
        }
        
        if ((chord->is_score_chord && chord->parent) || (!chord->is_score_chord && chord->voiceparent)) {
            t_voice *voice = chord_get_voice(r_ob, chord);
            if (voice && voice->number >= 0 && voice->number < CONST_MAX_VOICES && r_ob->chord_play_cursor[voice->number] == chord)
                r_ob->chord_play_cursor[voice->number] = update_chord_play_cursor_to_this_chord_if_needed;
        }
    }

    return need_check_scheduling;
}


// used by roll
// returns 1 if need to check correct scheduling, 0 otherwise
char chord_delete(t_notation_obj *r_ob, t_chord *chord, t_chord *update_chord_play_cursor_to_this_chord_if_needed, char also_recompute_total_length){
    t_rollvoice *parent = chord->voiceparent;
    char need_check_scheduling = false;
    char need_check_solos = is_solo_with_progeny(r_ob, (t_notation_item *)chord);

    if (chord_check_dependencies_before_deleting_it(r_ob, chord, false, update_chord_play_cursor_to_this_chord_if_needed))
        need_check_scheduling = true;
    
    if (chord){
        parent->num_chords--;
        if (chord->prev) {
            // not the first chord
            if (chord->next) {
                // not the last chord
                chord->prev->next = chord->next;
                chord->next->prev = chord->prev;
            } else {
                // last chord
                chord->prev->next = NULL;
                parent->lastchord = chord->prev;
            }
        } else {
            // first chord
            if (chord->next) {
                // some chords remain
                chord->next->prev = NULL;
                parent->firstchord = chord->next;
            } else {
                // there was just 1 chord
                parent->firstchord = NULL;
                parent->lastchord = NULL;
                parent->num_chords = 0;
            }
        }

//        shashtable_chuck_thing(r_ob->IDtable, chord->r_it.ID); // already done in free_chord
        free_chord(r_ob, chord);
    }
    
    
    if (also_recompute_total_length)
        recompute_total_length(r_ob);
    
    // checking solos?
    if (need_check_solos)
        update_solos(r_ob);
    
    return need_check_scheduling;
}

void update_solos(t_notation_obj *r_ob)
{
    r_ob->are_there_solos = are_there_solos(r_ob);
}

// used by score
void chord_delete_from_measure(t_notation_obj *r_ob, t_chord *chord_to_delete, char also_remove_previous_ties){
// deletes a chord from a measure
    if (chord_to_delete) {
        t_measure *measure = chord_to_delete->parent;
        t_rational abs_chord_to_delete_rat_duration = rat_abs(chord_to_delete->r_sym_duration);
        
        if (chord_check_dependencies_before_deleting_it(r_ob, chord_to_delete, also_remove_previous_ties, chord_get_prev(chord_to_delete)))
            check_correct_scheduling(r_ob, false);

        // delete rhythmic tree entries
        llll_destroyelem(chord_to_delete->rhythmic_tree_elem);

        if (chord_to_delete->prev) { // not at the beginning
            if (chord_to_delete->next) { // re-glue these!
                chord_to_delete->prev->next = chord_to_delete->next;
                chord_to_delete->next->prev = chord_to_delete->prev;
            } else { // delete last chord
                chord_to_delete->prev->next = NULL;
                measure->lastchord = chord_to_delete->prev;
            }
        } else { // delete the first chord
            if (chord_to_delete->next) {
                chord_to_delete->next->prev = NULL;
                measure->firstchord = chord_to_delete->next;
            } else {
                measure->firstchord = NULL;
                measure->lastchord = NULL;
            }
        }
        
//        shashtable_chuck_thing(r_ob->IDtable, chord_to_delete->r_it.ID);
        free_chord(r_ob, chord_to_delete);
        
        recompute_measure_r_onsets(r_ob, measure); //recalculating the r_sym_onset for each chord
        
        measure->num_chords--;
        measure->r_total_content_duration = rat_rat_diff(measure->r_total_content_duration, abs_chord_to_delete_rat_duration);
    }
}

t_llll *measure_get_rhythm_as_llll(t_notation_obj *r_ob, t_measure *measure) {
    t_chord *chord;
    t_llll *out;
    if (measure->firstchord && is_measure_single_whole_rest(r_ob, measure)) {
        t_llll *out = llll_get();
        llll_appendrat(out, rat_long_prod(measure_get_sym_duration(measure), -1), 0, WHITENULL_llll);
    }
        
    chord = measure->firstchord;
    out = llll_get();
    while (chord) {
        llll_appendrat(out, chord->r_sym_duration, 0, WHITENULL_llll);
        chord = chord->next;
    }
    return out;
}

t_llll *measure_get_chords_wrapped_as_llll(t_notation_obj *r_ob, t_measure *measure) {
    t_chord *chord = measure->firstchord;
    t_llll *out = llll_get();
    while (chord) {
        t_llll *toappend = llll_get();
        llll_appendobj(toappend, chord, 0, WHITENULL_llll);
        llll_appendllll(out, toappend, 0, WHITENULL_llll);
        chord = chord->next;
    }
    return out;
}

t_llll *measure_get_ties_as_llll(t_notation_obj *r_ob, t_measure *measure) {
    t_chord *chord = measure->firstchord;
    t_llll *out = llll_get();
    while (chord) {
        t_llll *in = llll_get();
        t_note *note = chord->firstnote;
        while (note) {
            llll_appendlong(in, (note->tie_to) ? 1 : 0, 0, WHITENULL_llll);
            note = note->next;
        }
        if (in->l_size == 0) // for a pause
            llll_appendlong(in, 0, 0, WHITENULL_llll);
        llll_appendllll(out, in, 0, WHITENULL_llll);
        chord = chord->next;
    }
    return out;
}


char ts_are_equal(t_timesignature *ts1, t_timesignature *ts2){
// are ts1 and ts2 equal? (1 if yes, 0 if no)
    if (ts1->denominator != ts2->denominator)
        return 0;
    else 
        if (ts1->numerator != ts2->numerator)
            return 0;
        else
            if (ts1->num_numerator_elements != ts2->num_numerator_elements)
                return 0;
            else {
                long n = ts1->num_numerator_elements;
                long i;
                for (i = 0; i < n; i++)
                    if (ts1->numerator_elements[i] != ts2->numerator_elements[i])
                        return 0;
                
                return 1;
            }
}

// 1 if the tempi are the the same tempo and in the same timepoint
char are_tempi_the_same_and_with_the_same_onset(t_tempo *tempo1, t_tempo *tempo2)
{
    
    if (!tempo1 || !tempo2 || !tempo1->owner || !tempo2->owner)
        return 0;
    
    if (get_tempo_onset_ms(tempo1) != get_tempo_onset_ms(tempo2))
        return 0;
    
    if (rat_rat_cmp(tempo1->tempo_figure, tempo2->tempo_figure) != 0)
        return 0;
    
    if (rat_rat_cmp(tempo1->figure_tempo_value, tempo2->figure_tempo_value) != 0)
        return 0;
    
    if (rat_rat_cmp(tempo1->tempo_value, tempo2->tempo_value) != 0)
        return 0;
    
    if (tempo1->interpolation_type != tempo2->interpolation_type)
        return 0;
    
    return 1;
}


// 1 if the tempi are the the same tempo and in the same timepoint
char are_tempi_the_same_and_in_the_same_tp(t_tempo *tempo1, t_tempo *tempo2)
{

    if (!tempo1 || !tempo2 || !tempo1->owner || !tempo2->owner)
        return 0;
    
    if (tempo1->owner->measure_number != tempo2->owner->measure_number)
        return 0;
    
    if (rat_rat_cmp(tempo1->changepoint, tempo2->changepoint) != 0)
        return 0;
    
    if (rat_rat_cmp(tempo1->tempo_figure, tempo2->tempo_figure) != 0)
        return 0;

    if (rat_rat_cmp(tempo1->figure_tempo_value, tempo2->figure_tempo_value) != 0)
        return 0;

    if (rat_rat_cmp(tempo1->tempo_value, tempo2->tempo_value) != 0)
        return 0;

    if (tempo1->interpolation_type != tempo2->interpolation_type)
        return 0;

    return 1;
}


double ts_get_uwidth(t_notation_obj *r_ob, t_timesignature *ts)
{
// returns the width of the ts printing, in standard size (e.g. Maestro 24)
    
    t_jfont *jf_ts;
    char num_txt[150]; 
    char den_txt[50]; 
    long len_utf_num, len_utf_den;
    char *num_utf, *den_utf;
    double num_width = 0.; double num_height = 0.;
    double den_width = 0.; double den_height = 0.;
    if (r_ob->show_time_signatures == 0)
        return 0.;
    jf_ts = jfont_create_debug(r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->notation_typo_preferences.base_pt_ts);
    num_utf = charset_unicodetoutf8_debug(ts->num_unicode, ts->len_num, &len_utf_num);
    den_utf = charset_unicodetoutf8_debug(ts->den_unicode, ts->len_den, &len_utf_den);
    strncpy(num_txt, num_utf, 150);
    strncpy(den_txt, den_utf, 49);
    bach_freeptr(num_utf);
    bach_freeptr(den_utf);
    
    jfont_text_measure(jf_ts, den_txt, &den_width, &den_height);
    jfont_text_measure(jf_ts, num_txt, &num_width, &num_height);
    
    jfont_destroy_debug(jf_ts);
    return MAX(den_width, num_width);
}

double ts_get_spacing_uwidth(t_notation_obj *r_ob, t_timesignature *ts)
{
    if (r_ob->show_time_signatures == 0 || r_ob->show_time_signatures == 2)
        return 0.;
    return ts_get_uwidth(r_ob, ts);
}

char split_rhythm_to_boxes_OLD(t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll *boxes, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, t_llll *garbage, char check_completeness, long max_num) {
    // splits a given rhythm with respect to a box pattern, possibly splitting also the infos information, which has to be a llll composed by lllls, one for each rhythm element,
    // associated 1-to-1 with a rhythm element, that may contain whatever you want (e.g. cents, velocity, ties...) 
    // Initializes and fills **new_rhythm, **new_infos, and **ties lllls.
    // e.g. if rhythm = (1/8 2/4 -1/16 1/16), infos = ((a) (b) (c) (d)) and boxes = (1/4 2/4) it returns 
    //         new_rhythm = ((1/8 1/8) (3/8 -1/16 1/16)), new_infos = (((a) (b)) ((b) (c) (d))) and ties = (0 1 0 0 0)
    // if check_completeness = 1, it fills all boxes with rests, if the content is not "enough" for the box dimension.
    // returns true if the boxes were completed; otherwise false
    // max_num is just the max number for the calculations. ignore it, leave 0.  
    
    // we initialize the general lllls
    char res = true; // completeness
    *new_rhythm = llll_get(); *new_infos = llll_get(); *new_ties = llll_get();
    if ((boxes->l_size > 0) && (rhythm->l_size > 0)) {
        int i;
        t_rational box_summed_elem_rat;
        t_llll **box_rhythm_llll, **box_infos_llll, **box_ties_llll;
        t_rational r_sym_onset = long2rat(0);  t_rational r_prev_onset = long2rat(0);
        t_llll* boxes_summed = llll_dx2x_of_plain_rat_llll(boxes, long2rat(0)); // computes the dx2x of boxes
        t_llllelem *rhythm_elem; 
        t_llllelem *infos_elem = (infos && (infos->l_size > 0)) ? infos->l_head : NULL; 
        t_llllelem *ties_elem = (ties && (ties->l_size > 0)) ? ties->l_head : NULL; 
        t_llllelem *boxes_summed_elem = boxes_summed->l_head->l_next; // we skip the first element, which is just 0
        // preparing single lllls for each box
        box_rhythm_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        box_infos_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        box_ties_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        for (i = 0; i < (long)boxes->l_size; i++) {
            box_rhythm_llll[i] = llll_get();
            box_infos_llll[i] = llll_get();
            box_ties_llll[i] = llll_get();
        }
        box_summed_elem_rat = hatom_getrational(&boxes_summed_elem->l_hatom);
        i = 0; //we start to "write" the first box
        for (rhythm_elem = rhythm->l_head; rhythm_elem && (i < (long)boxes->l_size); rhythm_elem = rhythm_elem->l_next) { // cycle on the rhythm
            char cmp;
            t_rational rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom);
            long rhythm_elem_sign =  (rhythm_elem_rat.r_num > 0) ? 1 : ((rhythm_elem_rat.r_num == 0) ? 0 : -1);
            r_prev_onset = r_sym_onset;
            r_sym_onset = rat_rat_sum(r_sym_onset, rat_abs(rhythm_elem_rat)); // new onset
            if (max_num > 0 && r_sym_onset.r_num > max_num) {
                r_sym_onset = approx_rat_with_rat(r_sym_onset, max_num, max_num);
            }
            // is it still in the same box?
            cmp = rat_rat_cmp(r_sym_onset, box_summed_elem_rat);
            if (cmp == -1) { // stays within the box
                // just append an element to the new_rhythm array
                llll_appendrat(box_rhythm_llll[i], rhythm_elem_rat, 0, WHITENULL_llll);
                if (infos_elem) llll_appendhatom_clone(box_infos_llll[i], &infos_elem->l_hatom, 0, WHITENULL_llll);
                else llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                if (ties_elem) llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                else llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
            } else if (cmp == 0) { // precisely at the end of the box
                // append an element to the new_rhythm array
                llll_appendrat(box_rhythm_llll[i], rhythm_elem_rat, 0, WHITENULL_llll);
                if (infos_elem) llll_appendhatom_clone(box_infos_llll[i], &infos_elem->l_hatom, 0, WHITENULL_llll);
                else llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                if (ties_elem) llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                else llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                i++; // go write the next box!
                boxes_summed_elem = boxes_summed_elem->l_next; // increase the box_summed_elem
                box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
            } else if (cmp == 1) { // goes over the next box
                // we complete the box. First we complete the fully filled boxes, if any
                t_rational box_summed_elem_rat_prev = r_prev_onset;
                while (rat_rat_cmp(r_sym_onset, box_summed_elem_rat) == 1) { // while it goes COMPLETELY over the box
                    llll_appendrat(box_rhythm_llll[i], rat_long_prod(rat_rat_diff(box_summed_elem_rat, box_summed_elem_rat_prev), rhythm_elem_sign), 0, WHITENULL_llll);
                    if (infos_elem) llll_appendhatom_clone(box_infos_llll[i], &infos_elem->l_hatom, 0, WHITENULL_llll);
                    else llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (rhythm_elem_sign && infos_elem && hatom_gettype(&infos_elem->l_hatom) == H_LLLL && hatom_getllll(&infos_elem->l_hatom)->l_tail && hatom_gettype(&hatom_getllll(&infos_elem->l_hatom)->l_tail->l_hatom) == H_LLLL)
                        llll_appendllll(box_ties_llll[i], llll_clone(hatom_getllll(&hatom_getllll(&infos_elem->l_hatom)->l_tail->l_hatom))); // appending IDs
                    else
                        llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len((rhythm_elem_sign == 1) ? 1 : 0, ties_elem), 0, WHITENULL_llll);
                    i++;
                    if (i >= (long)boxes->l_size) break;
                    box_summed_elem_rat_prev = box_summed_elem_rat;
                    boxes_summed_elem = boxes_summed_elem->l_next;
                    box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
                }
                // last box: what happens? 0 or -1?
                if (rat_rat_cmp(r_sym_onset, box_summed_elem_rat) == -1) { // stays within the box
                    llll_appendrat(box_rhythm_llll[i], rat_long_prod(rat_rat_diff(r_sym_onset, box_summed_elem_rat_prev), rhythm_elem_sign), 0, WHITENULL_llll);
                    if (infos_elem) llll_appendhatom_clone(box_infos_llll[i], &infos_elem->l_hatom, 0, WHITENULL_llll);
                    else llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (ties_elem) llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                    else llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                } else if (rat_rat_cmp(r_sym_onset, box_summed_elem_rat) == 0) { // precisely at the end of the box 
                    llll_appendrat(box_rhythm_llll[i], rat_long_prod(rat_rat_diff(r_sym_onset, box_summed_elem_rat_prev), rhythm_elem_sign), 0, WHITENULL_llll);
                    if (infos_elem) llll_appendhatom_clone(box_infos_llll[i], &infos_elem->l_hatom, 0, WHITENULL_llll);
                    else llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (ties_elem) llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                    else llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                    i++; // go write the next box!
                    boxes_summed_elem = boxes_summed_elem->l_next; // increase the box_summed_elem
                    box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
                }
            }
            if (infos_elem) infos_elem = infos_elem->l_next;
            if (ties_elem) ties_elem = ties_elem->l_next;
        }
        // checking completeness, if requested
        if (check_completeness) {
            int j;
            t_llllelem *elem;
            for (j = i, elem = llll_getindex(boxes, j + LLLL_IDX_BASE, I_NON_NEGATIVE); j < (long)boxes->l_size && elem; j++, elem = elem->l_next) {
                t_rational this_abs_sum = llll_sum_abs_of_rat_llll(box_rhythm_llll[j]);
                if (rat_rat_cmp(this_abs_sum, hatom_getrational(&elem->l_hatom)) < 0) {
                    llll_appendrat(box_rhythm_llll[j], rat_rat_diff(this_abs_sum, hatom_getrational(&elem->l_hatom)), 0, WHITENULL_llll);
                    llll_appendllll(box_infos_llll[j], llll_get(), 0, WHITENULL_llll);
                    llll_appendlong(box_ties_llll[j], 0, 0, WHITENULL_llll);
                    res = false;
                } 
            }
        }
        // we append all the box_lllls to the general lllls
        for (i = 0; i < (long)boxes->l_size; i++) {
            llll_appendllll(*new_rhythm, box_rhythm_llll[i], 0, WHITENULL_llll);
            llll_appendllll(*new_infos, box_infos_llll[i], 0, WHITENULL_llll);
            llll_appendllll(*new_ties, box_ties_llll[i], 0, WHITENULL_llll);
        }
        if (garbage) // garbage collection?
            llll_appendllll(garbage, boxes_summed, 0, WHITENULL_llll);
        else
            llll_free(boxes_summed);
        bach_freeptr(box_rhythm_llll);
        bach_freeptr(box_infos_llll);
        bach_freeptr(box_ties_llll);
    }
    
    return res;
}




char split_rhythm_to_boxes(t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll *boxes, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, char check_completeness, char mark_created_info_upon_split, char ties_have_ids)
{
// splits a given rhythm with respect to a box pattern, possibly splitting also the infos information, which has to be a llll composed by lllls, one for each rhythm element,
// associated 1-to-1 with a rhythm element, that may contain whatever you want (e.g. cents, velocity, ties...) 
// Initializes and fills **new_rhythm, **new_infos, and **ties lllls.
// e.g. if rhythm = (1/8 2/4 -1/16 1/16), infos = ((a) (b) (c) (d)) and boxes = (1/4 2/4) it returns 
//         new_rhythm = ((1/8 1/8) (3/8 -1/16 1/16)), new_infos = (((a) (b)) ((b) (c) (d))) and ties = (0 1 0 0 0)
// if check_completeness = 1, it fills all boxes with rests, if the content is not "enough" for the box dimension.
// returns true if the boxes were completed; otherwise false
// max_num is just the max number for the calculations. ignore it, leave 0.  

    // we initialize the general lllls
    char res = true; // completeness
    *new_rhythm = llll_get(); *new_infos = llll_get(); *new_ties = llll_get();
    if ((boxes->l_size > 0) && (rhythm->l_size > 0)) {
        int i;
        t_rational box_summed_elem_rat;
        t_llll **box_rhythm_llll, **box_infos_llll, **box_ties_llll;
        // we keep track of the onset, but we keep separately track of the integer part, in order to avoid having numbers higher than their denominators
        t_rational r_sym_onset = long2rat(0);  t_rational r_prev_onset = long2rat(0);
        long r_onset_integerpart = 0; long r_prev_onset_integerpart;
        
        t_llll* boxes_summed = llll_dx2x_of_plain_rat_llll(boxes, long2rat(0)); // computes the dx2x of boxes
        t_llllelem *rhythm_elem; 
        t_llllelem *infos_elem = (infos && (infos->l_size > 0)) ? infos->l_head : NULL; 
        t_llllelem *ties_elem = (ties && (ties->l_size > 0)) ? ties->l_head : NULL; 
        t_llllelem *boxes_summed_elem = boxes_summed->l_head->l_next; // we skip the first element, which is just 0
        // preparing single lllls for each box
        box_rhythm_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        box_infos_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        box_ties_llll = (t_llll **) bach_newptr(boxes->l_size * sizeof(t_llll *));
        for (i = 0; i < (long)boxes->l_size; i++) {
            box_rhythm_llll[i] = llll_get();
            box_infos_llll[i] = llll_get();
            box_ties_llll[i] = llll_get();
        }
        box_summed_elem_rat = hatom_getrational(&boxes_summed_elem->l_hatom);
        
        i = 0; //we start to "write" the first box
        for (rhythm_elem = rhythm->l_head; rhythm_elem && (i < (long)boxes->l_size); rhythm_elem = rhythm_elem->l_next) { // cycle on the rhythm
            if (hatom_gettype(&rhythm_elem->l_hatom) == H_LLLL) {
                long j = 0, num_rats = get_num_rationals_in_llll(hatom_getllll(&rhythm_elem->l_hatom));

                // just append an element to the new_rhythm array
                llll_appendhatom_clone(box_rhythm_llll[i], &rhythm_elem->l_hatom, 0, WHITENULL_llll);
                
                for (j = 0; j < num_rats; j++) {
                    if (infos_elem) 
                        llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                    else 
                        llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (ties_elem) 
                        llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                    else 
                        llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                    if (infos_elem) 
                        infos_elem = infos_elem->l_next;
                    if (ties_elem) 
                        ties_elem = ties_elem->l_next;
                }
            } else {
                char cmp;
                long box_summed_elem_rat_integerpart; 
                t_rational box_summed_elem_rat_remainder;
                t_rational rhythm_elem_rat = force_standard_rational(hatom_getrational(&rhythm_elem->l_hatom));
                long rhythm_elem_sign = (rhythm_elem_rat.r_num > 0) ? 1 : ((rhythm_elem_rat.r_num == 0) ? 0 : -1);
                
                r_prev_onset = r_sym_onset;
                r_prev_onset_integerpart = r_onset_integerpart;
                
                r_sym_onset = rat_rat_sum(r_sym_onset, rat_abs(rhythm_elem_rat)); // new onset
                if (r_sym_onset.r_num >= r_sym_onset.r_den){  // we take the integer part out
                    r_onset_integerpart += r_sym_onset.r_num / r_sym_onset.r_den; // integer division
                    r_sym_onset.r_num = r_sym_onset.r_num % r_sym_onset.r_den;
                }
                
                //            if (max_num > 0 && r_sym_onset.r_num > max_num)
                //                r_sym_onset = approx_rat_with_rat(r_sym_onset, max_num, max_num);
                
                // is it still in the same box?
                box_summed_elem_rat_integerpart = box_summed_elem_rat.r_num / box_summed_elem_rat.r_den;
                box_summed_elem_rat_remainder = genrat(box_summed_elem_rat.r_num % box_summed_elem_rat.r_den, box_summed_elem_rat.r_den);
                
                cmp = rat_rat_cmp_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_integerpart, box_summed_elem_rat_remainder);
                if (cmp == -1) { // stays within the box
                    // just append an element to the new_rhythm array
                    llll_appendrat(box_rhythm_llll[i], rhythm_elem_rat, 0, WHITENULL_llll);
                    if (infos_elem) 
                        llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                    else 
                        llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (ties_elem) 
                        llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                    else 
                        llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                } else if (cmp == 0) { // precisely at the end of the box
                    // append an element to the new_rhythm array
                    llll_appendrat(box_rhythm_llll[i], rhythm_elem_rat, 0, WHITENULL_llll);
                    if (infos_elem) 
                        llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                    else 
                        llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                    if (ties_elem) 
                        llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                    else 
                        llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                    i++; // go write the next box!
                    boxes_summed_elem = boxes_summed_elem->l_next; // increase the box_summed_elem
                    box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
                } else if (cmp == 1) { // goes over the next box
                    // we complete the box. First we complete the fully filled boxes, if any
                    t_rational box_summed_elem_rat_prev_remainder = r_prev_onset;
                    long box_summed_elem_rat_prev_integerpart = r_prev_onset_integerpart;
                    long count = 0;
                    
                    while (rat_rat_cmp_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_integerpart, box_summed_elem_rat_remainder) == 1) { 
                        // while it goes COMPLETELY over the box
                        t_rational dur_to_append = rat_long_prod(rat_rat_diff_integer_and_remainders(box_summed_elem_rat_integerpart, box_summed_elem_rat_remainder, box_summed_elem_rat_prev_integerpart, box_summed_elem_rat_prev_remainder), rhythm_elem_sign);
                        llll_appendrat(box_rhythm_llll[i], dur_to_append);
                        t_llllelem *new_infos_elem;
                        if (infos_elem) 
                            new_infos_elem = llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                        else 
                            new_infos_elem = llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                        if (ties_have_ids && rhythm_elem_sign && infos_elem && hatom_gettype(&infos_elem->l_hatom) == H_LLLL && hatom_getllll(&infos_elem->l_hatom)->l_tail && hatom_gettype(&hatom_getllll(&infos_elem->l_hatom)->l_tail->l_hatom) == H_LLLL)
                            llll_appendllll(box_ties_llll[i], llll_clone(hatom_getllll(&hatom_getllll(&infos_elem->l_hatom)->l_tail->l_hatom))); // appending IDs
                        else
                            llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len((rhythm_elem_sign == 1) ? 1 : 0, ties_elem), 0, WHITENULL_llll);
                        
                        if (mark_created_info_upon_split && count > 0)
                            new_infos_elem->l_thing.w_obj = WHITENULL_llll;
                        
                        count++;
                        i++;
                        if (i >= (long)boxes->l_size) break;
                        box_summed_elem_rat_prev_integerpart = box_summed_elem_rat_integerpart;
                        box_summed_elem_rat_prev_remainder = box_summed_elem_rat_remainder;
                        boxes_summed_elem = boxes_summed_elem->l_next;
                        box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
                        box_summed_elem_rat_integerpart = box_summed_elem_rat.r_num / box_summed_elem_rat.r_den;
                        box_summed_elem_rat_remainder = genrat(box_summed_elem_rat.r_num % box_summed_elem_rat.r_den, box_summed_elem_rat.r_den);
                    }
                    
                    // last box: what happens? 0 or -1?
                    if (rat_rat_cmp_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_integerpart, box_summed_elem_rat_remainder) == -1) { 
                        // stays within the box
                        llll_appendrat(box_rhythm_llll[i], 
                                       rat_long_prod(rat_rat_diff_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_prev_integerpart, box_summed_elem_rat_prev_remainder), rhythm_elem_sign), 0, WHITENULL_llll);
                        
                        t_llllelem *new_infos_elem;
                        if (infos_elem)
                            new_infos_elem = llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                        else 
                            new_infos_elem = llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                        if (mark_created_info_upon_split)
                            new_infos_elem->l_thing.w_obj = WHITENULL_llll;
                        
                        if (ties_elem)
                            llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                        else 
                            llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                        
                    } else if (rat_rat_cmp_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_integerpart, box_summed_elem_rat_remainder) == 0) { 
                        // precisely at the end of the box 
                        llll_appendrat(box_rhythm_llll[i], rat_long_prod(rat_rat_diff_integer_and_remainders(r_onset_integerpart, r_sym_onset, box_summed_elem_rat_prev_integerpart, box_summed_elem_rat_prev_remainder), rhythm_elem_sign), 0, WHITENULL_llll);

                        t_llllelem *new_infos_elem;
                        if (infos_elem)
                            new_infos_elem = llll_appendelem_clone_preserve_lthing(box_infos_llll[i], infos_elem, 0, WHITENULL_llll);
                        else 
                            new_infos_elem = llll_appendllll(box_infos_llll[i], llll_get(), 0, WHITENULL_llll);
                        if (mark_created_info_upon_split)
                            new_infos_elem->l_thing.w_obj = WHITENULL_llll;

                        if (ties_elem)
                            llll_appendhatom_clone(box_ties_llll[i], &ties_elem->l_hatom, 0, WHITENULL_llll); 
                        else 
                            llll_appendllll(box_ties_llll[i], repeat_long_for_llllelem_len(0, ties_elem), 0, WHITENULL_llll);
                        i++; // go write the next box!
                        boxes_summed_elem = boxes_summed_elem->l_next; // increase the box_summed_elem
                        box_summed_elem_rat = (boxes_summed_elem) ? hatom_getrational(&boxes_summed_elem->l_hatom) : long2rat(0);
                        box_summed_elem_rat_integerpart = box_summed_elem_rat.r_num / box_summed_elem_rat.r_den;
                        box_summed_elem_rat_remainder = genrat(box_summed_elem_rat.r_num % box_summed_elem_rat.r_den, box_summed_elem_rat.r_den);
                    }
                }
                if (infos_elem) 
                    infos_elem = infos_elem->l_next;
                if (ties_elem) 
                    ties_elem = ties_elem->l_next;
            }
        }
        // checking completeness, if requested
        if (check_completeness) {
            int j;
            t_llllelem *elem;
            for (j = i, elem = llll_getindex(boxes, j + LLLL_IDX_BASE, I_NON_NEGATIVE); j < (long)boxes->l_size && elem; j++, elem = elem->l_next) {
                t_rational this_abs_sum = llll_sum_abs_of_rat_llll(box_rhythm_llll[j]);
                if (rat_rat_cmp(this_abs_sum, hatom_getrational(&elem->l_hatom)) < 0) {
                    llll_appendrat(box_rhythm_llll[j], rat_rat_diff(this_abs_sum, hatom_getrational(&elem->l_hatom)), 0, WHITENULL_llll);
                    llll_appendllll(box_infos_llll[j], llll_get(), 0, WHITENULL_llll);
                    llll_appendlong(box_ties_llll[j], 0, 0, WHITENULL_llll);
                    res = false;
                } 
            }
        }
        // we append all the box_lllls to the general lllls
        for (i = 0; i < (long)boxes->l_size; i++) {
            llll_appendllll(*new_rhythm, box_rhythm_llll[i], 0, WHITENULL_llll);
            llll_appendllll(*new_infos, box_infos_llll[i], 0, WHITENULL_llll);
            llll_appendllll(*new_ties, box_ties_llll[i], 0, WHITENULL_llll);
        }

        llll_free(boxes_summed);

        bach_freeptr(box_rhythm_llll);
        bach_freeptr(box_infos_llll);
        bach_freeptr(box_ties_llll);
    }
    
    return res;
}

long get_tie_corresponding_to_mc(t_llll *ties, t_llll *mc, double this_mc, double tolerance, double use_lthing_marking) {
    t_llllelem *elem1, *elem2;
    long res = -1;
    if (!ties || !mc || ties->l_size == 0 || mc->l_size == 0) 
        return res;
    for (elem1 = ties->l_head, elem2 = mc->l_head; elem1 && elem2; elem1 = elem1->l_next, elem2 = elem2->l_next)
        if (fabs(hatom_getdouble(&elem2->l_hatom) - this_mc) < tolerance && (!use_lthing_marking || elem1->l_thing.w_obj == NULL)) {
            long this_tie_val = hatom_getlong(&elem1->l_hatom);
            if (use_lthing_marking)
                elem1->l_thing.w_obj = WHITENULL;
            if (res < 0 && this_tie_val == 0)
                return 0;
            else if (res < 0 && this_tie_val == 1)
                res = 1;
            else if (res == 1 && this_tie_val == 0)
                return 0;
        }
    return res;
}



e_header_elems header_objects_to_long(t_llll *inllll){
    t_llllelem *elem;
    e_header_elems res = k_HEADER_NONE;
    
    if (!inllll || inllll->l_size == 0) 
        return res;
    
    for (elem = inllll->l_head; elem; elem = elem->l_next) {
        if (hatom_gettype(&elem->l_hatom) == H_SYM) {
            t_symbol *this_sym = hatom_getsym(&elem->l_hatom);
            if (this_sym == _llllobj_sym_body)
                res = (e_header_elems) (res | k_HEADER_BODY);
            else if (this_sym == _llllobj_sym_clefs)
                res = (e_header_elems) (res | k_HEADER_CLEFS);
            else if (this_sym == _llllobj_sym_markers)
                res = (e_header_elems) (res | k_HEADER_MARKERS);
            else if (this_sym == _llllobj_sym_groups)
                res = (e_header_elems) (res | k_HEADER_GROUPS);
            else if (this_sym == _llllobj_sym_midichannels)
                res = (e_header_elems) (res | k_HEADER_MIDICHANNELS);
            else if (this_sym == _llllobj_sym_commands)
                res = (e_header_elems) (res | k_HEADER_COMMANDS);
            else if (this_sym == _llllobj_sym_keys)
                res = (e_header_elems) (res | k_HEADER_KEYS);
            else if (this_sym == _llllobj_sym_slotinfo)
                res = (e_header_elems) (res | k_HEADER_SLOTINFO);
            else if (this_sym == _llllobj_sym_voicenames)
                res = (e_header_elems) (res | k_HEADER_VOICENAMES);
            else if (this_sym == _llllobj_sym_voicespacing)
                res = (e_header_elems) (res | k_HEADER_VOICESPACING);
            else if (this_sym == _llllobj_sym_hidevoices)
                res = (e_header_elems) (res | k_HEADER_HIDEVOICES);
            else if (this_sym == _llllobj_sym_stafflines)
                res = (e_header_elems) (res | k_HEADER_STAFFLINES);
            else if (this_sym == _llllobj_sym_articulationinfo)
                res = (e_header_elems) (res | k_HEADER_ARTICULATIONINFO);
            else if (this_sym == _llllobj_sym_noteheadinfo)
                res = (e_header_elems) (res | k_HEADER_NOTEHEADINFO);
            else if (this_sym == _llllobj_sym_numparts)
                res = (e_header_elems) (res | k_HEADER_NUMPARTS);
            else if (this_sym == _llllobj_sym_loop)
                res = (e_header_elems) (res | k_HEADER_LOOP);
            else if (this_sym == _llllobj_sym_header)
                res = (e_header_elems) (res | (k_HEADER_ALL & (~(k_HEADER_BODY))));
        }
    }

    return res;
}


char is_at_least_a_note_tied_in_llllelem(t_llllelem *tie_elem){
// tells us if a tie-element correspond to a  chords where AT LEAST one note is tied (i.e. tie_elem = 1 or tie_elem = has at least one 1 in the list)
    long type;
    if (!tie_elem) return false;
    type = hatom_gettype(&tie_elem->l_hatom);
    if (type == H_LONG)
        if (hatom_getlong(&tie_elem->l_hatom) == 0) 
            return false;
        else
            return true;
    else if (type == H_LLLL) {
        t_llll *tie_llll = hatom_getllll(&tie_elem->l_hatom);
        if (tie_llll->l_size <= 0)
            return false;
        else {
            t_llllelem *elem;
            for (elem = tie_llll->l_head; elem; elem = elem->l_next)
                if ((hatom_gettype(&elem->l_hatom) == H_LONG) && (hatom_getlong(&elem->l_hatom) == 1))
                    return true;
        }
    }
    return false;
}
 
char is_all_llllelem_tied(t_llllelem *tie_elem, long num_next_chord_notes){
// tells us if a tie-element correspond to a all tied chords (i.e. tie_elem = 1 or tie_elem = (1 ... 1))
// one can optionally specify the number of notes of the next chord
    char all_tied = false;
    long type;
    if (!tie_elem) return false;
    type = hatom_gettype(&tie_elem->l_hatom);
    if (type == H_LONG)
        all_tied = (hatom_getlong(&tie_elem->l_hatom) == 0) ? false : true;
    else if (type == H_LLLL) {
        t_llll *tie_llll = hatom_getllll(&tie_elem->l_hatom);
        all_tied = true;
        if (tie_llll->l_size <= 0)
            all_tied = false;
        else {
            t_llllelem *elem;
            for (elem = tie_llll->l_head; elem; elem = elem->l_next)
                if ((hatom_gettype(&elem->l_hatom) == H_LONG) && (hatom_getlong(&elem->l_hatom) == 0)) {
                    all_tied = false;
                    break;
                }
        }
    }
    // we check if the next chord has a sufficient number of notes to accomplish the all-tie!
    if (all_tied) {
        if ((num_next_chord_notes <= 0) && (type == H_LLLL) && (num_next_chord_notes != -5) &&  // -5: special value, to forget this last check
            ((!tie_elem->l_next) || (hatom_gettype(&tie_elem->l_next->l_hatom) != H_LLLL) ||
                    (hatom_getllll(&tie_elem->l_next->l_hatom)->l_size != hatom_getllll(&tie_elem->l_hatom)->l_size)))
            all_tied = false;
        else if ((num_next_chord_notes > 0) && (type == H_LLLL) && ((long)(hatom_getllll(&tie_elem->l_hatom)->l_size) != num_next_chord_notes))
            all_tied = false;
    }
    return all_tied;
}


// auxiliary functions for merge_rests_and_alltied_chords_from_separate_parameters()
void mergeauxfn_copy(t_rational rhythm_elem_rat, t_llllelem *infos_elem, t_llllelem *ties_elem, t_llll *new_rhythm, t_llll *new_infos, t_llll *new_ties)
{
    llll_appendrat(new_rhythm, rhythm_elem_rat, 0, WHITENULL_llll);
    if (infos_elem) llll_appendelem_clone_preserve_lthing(new_infos, infos_elem, 0, WHITENULL_llll);
    if (ties_elem) llll_appendhatom_clone(new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
}

void mergeauxfn_rest_series_end(e_merge_when merge_when, t_rational *pivot_sum, t_llllelem *pivot_rhythm_elem, t_llllelem *pivot_info_elem, t_llllelem *pivot_ties_elem, t_llllelem *rhythm_elem, t_llllelem *infos_elem, t_llllelem *ties_elem, t_llll *new_rhythm, t_llll *new_infos, t_llll *new_ties, t_llll *discarded_info, t_llll *discarded_durations)
{
    char num_dots = 0;
    t_rational scr_dur;
    t_llllelem *tmp, *tmp_info, *tmp_ties;

    if (merge_when == k_MERGE_WHEN_ALWAYS || (merge_when == k_MERGE_WHEN_DRAWABLE && is_duration_drawable(NULL, *pivot_sum, &scr_dur, &num_dots))) {
        llll_appendrat(new_rhythm, *pivot_sum, 0, WHITENULL_llll);
        if (pivot_info_elem) llll_appendelem_clone_preserve_lthing(new_infos, pivot_info_elem, 0, WHITENULL_llll);
        llll_appendlong(new_ties, 0, 0, WHITENULL_llll);

        // append discarded info
        for (tmp = pivot_rhythm_elem ? pivot_rhythm_elem->l_next : NULL, tmp_info = pivot_info_elem ? pivot_info_elem->l_next : NULL, tmp_ties = pivot_ties_elem ? pivot_ties_elem->l_next : NULL; tmp; tmp = tmp->l_next, tmp_info = tmp_info ? tmp_info->l_next: NULL, tmp_ties = tmp_ties ? tmp_ties->l_next : NULL) {
            if (tmp == rhythm_elem)
                break;
            if (discarded_info && tmp_info) llll_appendelem_clone_preserve_lthing(discarded_info, tmp_info, 0, WHITENULL_llll);
            if (discarded_durations && tmp_info) llll_appendrat(discarded_durations, hatom_getrational(&tmp->l_hatom), 0, WHITENULL_llll);
        }
    } else {
        // copy all elements of the series!
        for (tmp = pivot_rhythm_elem, tmp_info = pivot_info_elem, tmp_ties = pivot_ties_elem; tmp; tmp = tmp->l_next, tmp_info = tmp_info ? tmp_info->l_next: NULL, tmp_ties = tmp_ties ? tmp_ties->l_next : NULL) {
            if (tmp == rhythm_elem)
                break;
            mergeauxfn_copy(hatom_getrational(&tmp->l_hatom), tmp_info, tmp_ties, new_rhythm, new_infos, new_ties);
        }
    }

    *pivot_sum = long2rat(0);
}

void mergeauxfn_alltied_series_end(e_merge_when merge_when, t_rational *pivot_sum, t_llllelem *pivot_rhythm_elem, t_llllelem *pivot_info_elem, t_llllelem *pivot_ties_elem, t_llllelem *rhythm_elem, t_llllelem *infos_elem, t_llllelem *ties_elem, t_llll *new_rhythm, t_llll *new_infos, t_llll *new_ties, t_llll *discarded_info, t_llll *discarded_durations)
{
    char num_dots = 0;
    t_rational scr_dur;
    t_llllelem *tmp, *tmp_info, *tmp_ties;
    
    if (merge_when == k_MERGE_WHEN_ALWAYS || (merge_when == k_MERGE_WHEN_DRAWABLE && is_duration_drawable(NULL, *pivot_sum, &scr_dur, &num_dots))) {
        llll_appendrat(new_rhythm, *pivot_sum, 0, WHITENULL_llll);
        if (pivot_info_elem) llll_appendelem_clone_preserve_lthing(new_infos, pivot_info_elem, 0, WHITENULL_llll);
        if (ties_elem) llll_appendhatom_clone(new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
//        if (pivot_ties_elem) llll_appendhatom_clone(new_ties, &pivot_ties_elem->l_hatom, 0, WHITENULL_llll);

        // append discarded info
        for (tmp = pivot_rhythm_elem ? pivot_rhythm_elem->l_next : NULL, tmp_info = pivot_info_elem ? pivot_info_elem->l_next : NULL, tmp_ties = pivot_ties_elem ? pivot_ties_elem->l_next : NULL; tmp; tmp = tmp->l_next, tmp_info = tmp_info ? tmp_info->l_next: NULL, tmp_ties = tmp_ties ? tmp_ties->l_next : NULL) {
            if (tmp == rhythm_elem)
                break;
            if (discarded_info && tmp_info) llll_appendelem_clone_preserve_lthing(discarded_info, tmp_info, 0, WHITENULL_llll);
            if (discarded_durations && tmp_info) llll_appendrat(discarded_durations, hatom_getrational(&tmp->l_hatom), 0, WHITENULL_llll);
        }
    } else {
        // copy all elements of the series!
        for (tmp = pivot_rhythm_elem, tmp_info = pivot_info_elem, tmp_ties = pivot_ties_elem; tmp; tmp = tmp->l_next, tmp_info = tmp_info ? tmp_info->l_next: NULL, tmp_ties = tmp_ties ? tmp_ties->l_next : NULL) {
            if (tmp == rhythm_elem)
                break;
            mergeauxfn_copy(hatom_getrational(&tmp->l_hatom), tmp_info, tmp_ties, new_rhythm, new_infos, new_ties);
        }
    }

    *pivot_sum = long2rat(0);
}




void merge_rests_and_alltied_chords_from_separate_parameters(t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, t_llll **discarded_info, t_llll **discarded_durations, e_merge_when merge_when)
{
// merge, when possible, the rests of a rhythm. e.g. (1/8 -1/8 -1/4 1/12) becomes (1/8 -3/8 1/12). It does the same with chords which are completely tied one to the other.
// You can associate to each element of the original list a llll within the infos llll.
// the elements corresponing to merged elements will be deleted in the new_infos list. 
// The function initializes and fills **new_rhythm, **new_infos.
// discarded_info contains the information which is discarded (since all-tied or something)

    *new_rhythm = llll_get(); 
    *new_infos = llll_get(); 
    *new_ties = llll_get(); 
    if (discarded_info)    
        *discarded_info = llll_get();
    if (discarded_durations)    
        *discarded_durations = llll_get();
    
    if (rhythm && rhythm->l_size > 0) {
        // we initialize the general lllls
        t_llllelem *rhythm_elem, *pivot_info_elem = NULL, *pivot_tie_elem = NULL, *pivot_rhythm_elem = NULL, *infos_elem, *ties_elem;
        t_rational pivot_sum = long2rat(0);
        infos_elem = (infos && infos->l_size > 0) ? infos->l_head : NULL; 
        ties_elem = (ties && ties->l_size > 0) ? ties->l_head : NULL; 
        for (rhythm_elem = rhythm->l_head; rhythm_elem; rhythm_elem = rhythm_elem->l_next) { // cycle on the rhythm
            t_rational rhythm_elem_rat;
            long rhythm_elem_sign;
            
            if (hatom_gettype(&rhythm_elem->l_hatom) == H_SYM)
                continue;
                
            else if (hatom_gettype(&rhythm_elem->l_hatom) == H_LLLL) {
                long j = 0, num_rats = get_num_rationals_in_llll(hatom_getllll(&rhythm_elem->l_hatom));

                if (pivot_sum.r_num > 0) {
                    mergeauxfn_alltied_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                } else if (pivot_sum.r_num < 0) {
                    mergeauxfn_rest_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                }

                
                llll_appendhatom_clone(*new_rhythm, &rhythm_elem->l_hatom, 0, WHITENULL_llll);
                if (infos_elem) 
                    llll_appendelem_clone_preserve_lthing(*new_infos, infos_elem, 0, WHITENULL_llll);
                if (ties_elem) 
                    llll_appendhatom_clone(*new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
                    
                for (j = 0; j < num_rats; j++) {
                    if (infos_elem)    infos_elem = infos_elem->l_next;
                    if (ties_elem) ties_elem = ties_elem->l_next;
                }
            } else {
                
                rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom);
                rhythm_elem_sign = (rhythm_elem_rat.r_num > 0) ? 1 : ((rhythm_elem_rat.r_num == 0) ? 0 : -1);
                
                if (merge_when == k_MERGE_WHEN_NEVER) { // never merge, just copy
                    mergeauxfn_copy(rhythm_elem_rat, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties);
                    
                } else {
                    if (rhythm_elem_sign < 0) { // It's a rest
                        // first, we see if a alltied-sequence has ended
                        if (pivot_sum.r_num > 0) {
                            mergeauxfn_alltied_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                        }
                        
                        if (pivot_sum.r_num == 0) { // first rest (of a series?)
                            pivot_rhythm_elem = rhythm_elem;
                            pivot_info_elem = infos_elem;
                            pivot_tie_elem = ties_elem;
                            pivot_sum = rhythm_elem_rat;
                        } else { //  not the first rest
                            pivot_sum = rat_rat_sum(pivot_sum, rhythm_elem_rat);
//                            if (discarded_info && infos_elem) llll_appendelem_clone_preserve_lthing(*discarded_info, infos_elem, 0, WHITENULL_llll);
//                            if (discarded_durations && infos_elem) llll_appendrat(*discarded_durations, rhythm_elem_rat, 0, WHITENULL_llll);
                        }
                        
                    } else if (is_all_llllelem_tied(ties_elem, -1) == 1) { // It's a chord completely tied to next
                        // first, we see if a rest-sequence has ended
                        if (pivot_sum.r_num < 0) {
                            mergeauxfn_rest_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                        }
                        
                        if (pivot_sum.r_num == 0){ // first alltiedchord (of a series?)
                            pivot_rhythm_elem = rhythm_elem;
                            pivot_info_elem = infos_elem;
                            pivot_tie_elem = ties_elem;
                            pivot_sum = rhythm_elem_rat;
                        } else { //  not the first alltiedchord
                            pivot_sum = rat_rat_sum(pivot_sum, rhythm_elem_rat);
//                            if (discarded_info && infos_elem) llll_appendelem_clone_preserve_lthing(*discarded_info, infos_elem, 0, WHITENULL_llll);
//                            if (discarded_durations && infos_elem) llll_appendrat(*discarded_durations, rhythm_elem_rat, 0, WHITENULL_llll);
                        }
                        
                    } else { // It's a chord NOT completely tied to the next
                        if (pivot_sum.r_num < 0) {
                            // end rest series
                            mergeauxfn_rest_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                            
                            // then copy
                            mergeauxfn_copy(rhythm_elem_rat, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties);
                       
                        } else if (pivot_sum.r_num > 0) { // an all tied sequence has ended, but with THIS chord!
                            pivot_sum = rat_rat_sum(pivot_sum, rhythm_elem_rat);
                            mergeauxfn_alltied_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem->l_next, infos_elem ? infos_elem->l_next : NULL, ties_elem /*? ties_elem->l_next : NULL*/, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
                        } else { // we just copy
                            mergeauxfn_copy(rhythm_elem_rat, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties);
                        }
                    }
                }
                if (infos_elem)    infos_elem = infos_elem->l_next;
                if (ties_elem) ties_elem = ties_elem->l_next;
            }
        }
        
        // finally, let's see if a rest-series or an all_tied_chords series has ended
        if (merge_when != k_MERGE_WHEN_NEVER) { // never merge, just copy
            if (pivot_sum.r_num < 0) {
                mergeauxfn_rest_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
            } else if (pivot_sum.r_num > 0) {
                mergeauxfn_alltied_series_end(merge_when, &pivot_sum, pivot_rhythm_elem, pivot_info_elem, pivot_tie_elem, rhythm_elem, infos_elem, ties_elem, *new_rhythm, *new_infos, *new_ties, discarded_info ? *discarded_info : NULL, discarded_durations ? *discarded_durations : NULL);
            }
        }
    }
}

// inplace-functions
void merge_rests_and_alltied_chords_from_separate_parameters_inplace(t_llll **rhythm, t_llll **infos, t_llll **ties, t_llll **discarded_info, t_llll **discarded_durations, e_merge_when merge_when)
{
    t_llll *rhythm_merged, *infos_merged, *ties_merged;
    merge_rests_and_alltied_chords_from_separate_parameters(*rhythm, *infos, *ties, &rhythm_merged, &infos_merged, &ties_merged, discarded_info, discarded_durations, merge_when);
    llll_free(*rhythm); 
    llll_free(*infos); 
    llll_free(*ties);
    *rhythm = rhythm_merged; 
    *infos = infos_merged; 
    *ties = ties_merged;  
}                                       


void check_tuplets(t_notation_obj *r_ob, t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, t_llll **tuplets, long tuplet_group_offset, long *max_tuplet_group, char admit_dotted_tuplets, char max_dots) {

    if (rhythm->l_size > 0) {
        // we initialize the general lllls
        t_llllelem *rhythm_elem, *infos_elem, *ties_elem;
        t_llllelem *start_tuplet_duration_elem = NULL; // pivot element for tuplets
        t_llllelem *start_tuplet_duration_info = NULL;
        t_llllelem *start_tuplet_duration_ties = NULL;
        t_rational start_tuplet_box_onset = long2rat(0);
        t_rational start_tuplet_duration = long2rat(0);
        char gotta_complete_a_tuplet = false; char restart = false;
        t_rational curr_tuplet_ratio = long2rat(1); t_rational box_onset = long2rat(0); t_rational curr_tuplet_sym_dur = long2rat(0);
        t_rational curr_tuplet_complete_sym_dur = long2rat(0); t_rational curr_tuplet_unit = long2rat(0); t_rational curr_tuplet_unit_figure = long2rat(0);
        t_rational box_duration;
        long curr_tuplet_multiplier = 1; long curr_completeness = true;
        long count_stay_inside = 0, count_rhythm_elem = 0;
        long tuplet_group, boxduration_log2, count = 0;
        char box_is_standard; // for our example: NO
        char debug[1000];
        
        char verbose = false; 
        
        t_rational rhythm_elem_rat;
        t_llllelem *new_rhythm_elem, *new_infos_elem, *new_ties_elem, *tuplets_elem;
        t_llllelem *start_rhythm_pivot_elem = NULL; t_llllelem *start_infos_pivot_elem = NULL; t_llllelem *start_ties_pivot_elem = NULL; t_llllelem *start_tuplets_pivot_elem = NULL;
        
        long curr_tuplet_group = 0; 
        infos_elem = (infos->l_size > 0) ? infos->l_head : NULL; 
        ties_elem = (ties->l_size > 0) ? ties->l_head : NULL; 
        
        // tuplets variables
        box_duration = llll_sum_abs_of_rat_llll(rhythm);

        tuplet_group = tuplet_group_offset;
        rhythm_elem = rhythm->l_head;

        *new_rhythm = llll_get(); *new_infos = llll_get(); *new_ties = llll_get(); *tuplets = llll_get();
        // standard/nonstandard box?
        boxduration_log2 = perfect_log2(box_duration.r_den); //e.g. 4/12: the perfect_log2 function returns -1
        box_is_standard = (boxduration_log2 >= 0) ? true : false; // for our example: NO
//        t_rational nonstandard_box_ratio = genrat(round(pow(2, floor(log2(box_duration.r_den)))), box_duration.r_den);

        if (verbose) {
            llll_to_char_array(rhythm, debug, 990);
            object_post((t_object *) r_ob, "****** TUPLET CHECK ******");
            object_post((t_object *) r_ob, "Box rhythm: %s", debug);
        }

        count_rhythm_elem = 0;
        while (rhythm_elem) { // cycle on the rhythm
            long rhythm_elem_sign;
            char stay_inside = true;    
            
//            count_rhythm_elem++;
//            if (count_rhythm_elem > 10000) // something's wrong... tuplet too hard...
//                break;

            if (restart) { 
                restart = false;
                rhythm_elem_rat = start_tuplet_duration;
            } else {
                rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom); // duration
            }
            rhythm_elem_sign = (rhythm_elem_rat.r_num > 0) ? 1 : ((rhythm_elem_rat.r_num == 0) ? 0 : -1);

            count_stay_inside = 0;
            while (stay_inside) {
                
//                count_stay_inside ++;
//                if (count_stay_inside > 10000) // something's wrong... tuplet too hard...
//                    break;
                    
                t_rational rhythm_elem_rat_abs = rat_abs(rhythm_elem_rat);
                char check_overflow = false;
                if (verbose)
                    object_post((t_object *) r_ob, "- Analyzing element: %ld/%ld", rhythm_elem_rat.r_num, rhythm_elem_rat.r_den);
                if (gotta_complete_a_tuplet) {
                    // there's a tuplet to complete
                    t_rational this_natural_unit = rhythm_elem_rat_abs;
                    // t_rational this_natural_unit_figure = genrat(rhythm_elem_rat_abs.r_num, round(pow(2, floor(log2(rhythm_elem_rat_abs.r_den)))));
                    t_rational unit_ratio = rat_rat_div(this_natural_unit, curr_tuplet_unit);
                    if (verbose)
                        object_post((t_object *) r_ob, "  There's a tuplet to complete. The unit ratio is %ld/%ld.", unit_ratio.r_num, unit_ratio.r_den);
                    if (unit_ratio.r_den == 1) { 
                        if (verbose)
                            object_post((t_object *) r_ob, "  The ratio is ok, we go on with ratio: %ld/%ld, tuplet_unit: %ld/%ld, tuplet_unit_figure: %ld/%ld.", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den);
                        count++;
                        // everything is pretty much ok. we might have 1/12 and now 1/6, still we can go on with the same tuplet type.
                    } else { // quite bad; we gotta change tuplet type, diminishing the unit
                        t_rational new_tuplet_complete_sym_dur;
                        long i;
                        t_rational new_unit = genrat(gcd(this_natural_unit.r_num, curr_tuplet_unit.r_num), lcm(this_natural_unit.r_den, curr_tuplet_unit.r_den));
                        t_rational new_unit_figure = genrat(new_unit.r_num, round(pow(2, floor(log2(new_unit.r_den)))));
                        // t_rational new_ratio = rat_rat_div(new_unit, new_unit_figure);
                        curr_tuplet_unit = new_unit;
                        curr_tuplet_unit_figure = new_unit_figure;
                        curr_tuplet_ratio = rat_rat_div(new_unit, new_unit_figure);
                        if (verbose)
                            object_post((t_object *) r_ob, "  Ratio NOT ok: we change the parameters. Now ratio: %ld/%ld, tuplet_unit: %ld/%ld, tuplet_unit_figure: %ld/%ld", curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den);
                        new_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                        if (rat_rat_cmp(curr_tuplet_sym_dur, new_tuplet_complete_sym_dur) >= 0) { // our cursur would alredy trespass new duration: we change the multiplier
                            curr_tuplet_multiplier = rat_rat_div(curr_tuplet_complete_sym_dur, new_tuplet_complete_sym_dur).r_num;
                            if (verbose)
                                object_post((t_object *) r_ob, "  Since the duration we had is >= than the new supposed duration (%ld/%ld >= %ld/%ld) we change the multiplier to: %ld", curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den, new_tuplet_complete_sym_dur.r_num, new_tuplet_complete_sym_dur.r_den, curr_tuplet_multiplier);
                        } else {
                            if (verbose)
                                object_post((t_object *) r_ob, "  Since the duration we had is < than the new supposed duration (%ld/%ld < %ld/%ld) we keep the multiplier: %ld", curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den, new_tuplet_complete_sym_dur.r_num, new_tuplet_complete_sym_dur.r_den, curr_tuplet_multiplier);
                        } 
                        curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                        if (verbose)
                            object_post((t_object *) r_ob, "  This gives a new complete_sym_dur: %ld/%ld", curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                        // ok, we start again with this new unit and ratio, and see what happens
                        restart = true;
                        rhythm_elem = start_tuplet_duration_elem;
                        infos_elem = start_tuplet_duration_info;
                        ties_elem = start_tuplet_duration_ties;
                        box_onset = start_tuplet_box_onset;
                        curr_tuplet_sym_dur = long2rat(0);
                        for (i = 0; i < count; i++) { 
                            llll_betail(*new_rhythm); 
                            llll_betail(*new_infos); 
                            llll_betail(*new_ties); 
                        }
                        break;
                    }
                    curr_tuplet_sym_dur = rat_rat_sum(curr_tuplet_sym_dur, rhythm_elem_rat_abs);
                    check_overflow = true;
                    
                } else {
                    
                    // no tuplet to complete
                    long thislog2 = perfect_log2(rhythm_elem_rat_abs.r_den); 
                    if (thislog2 >= 0) {
                        // no tuplet    
                        if (verbose)
                            object_post((t_object *) r_ob, "  There's no tuplet to complete, and the element is regular (not tupled). Just append and go on.");
                        start_tuplet_duration_elem = NULL;
                        start_tuplet_duration = long2rat(0);
                        start_tuplet_duration_info = NULL;
                        start_tuplet_duration_ties = NULL;
                        start_tuplet_box_onset = box_onset;
                        count = 0;
                    } else {
                        // start a new tuplet
                        tuplet_group++;
                        if (verbose)
                            object_post((t_object *) r_ob, "  There's no tuplet to complete, but the element is irregular (tupled). We start the tuplet group %ld.", tuplet_group);
                        count = 1; curr_tuplet_multiplier = 1;
                        start_tuplet_duration_elem = rhythm_elem; // pivot element
                        start_tuplet_duration = rhythm_elem_rat;
                        start_tuplet_duration_info = infos_elem;
                        start_tuplet_duration_ties = ties_elem;
                        start_tuplet_box_onset = box_onset;
                        curr_completeness = true;
                        curr_tuplet_unit = rhythm_elem_rat_abs;
//                        curr_tuplet_unit_figure = genrat(rhythm_elem_rat_abs.r_num, round(pow(2, floor(log2(rhythm_elem_rat_abs.r_den)))));
                        {
                            double thelog = log2(rhythm_elem_rat_abs.r_den);
                            double thefloor = floor(thelog);
                            double thepow = pow(2, thefloor);
                            double theround = round(thepow);
                            curr_tuplet_unit_figure = genrat(rhythm_elem_rat_abs.r_num, theround);
                        }
                        curr_tuplet_ratio = rat_rat_div(curr_tuplet_unit, curr_tuplet_unit_figure);
                        curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                        while (curr_completeness && (rat_rat_cmp(rat_rat_sum(curr_tuplet_complete_sym_dur, box_onset), box_duration) > 0)) {
                            char can_be_incompleted = false; t_rational how_many_units_in_the_remaining_box_duration;
                            if (!(box_is_standard)) { // first we handle the case of nonstandard timesignatures
                                // box is nonstandard
                                how_many_units_in_the_remaining_box_duration = rat_rat_div(rat_rat_diff(box_duration, box_onset), curr_tuplet_unit);
                                if (how_many_units_in_the_remaining_box_duration.r_den == 1) {
                                    can_be_incompleted = true;
                                } 
                            }
                            
                            if (can_be_incompleted) {
                                curr_completeness = false;
                                curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit, how_many_units_in_the_remaining_box_duration.r_num);
                            } else if (curr_tuplet_unit.r_num > 1) { // on the other hand, if the time signature is standard: if the curr_tuplet_complete_sym_dur 
                                                                     // is > then the box duration, we try to fit it in the box
                                long num = curr_tuplet_unit.r_num;
                                curr_tuplet_unit = rat_long_div(curr_tuplet_unit, num);
                                curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, num);
                                curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            } else if (rat_rat_cmp(rat_rat_sum(rat_long_div(curr_tuplet_complete_sym_dur, 3), box_onset), box_duration) == 0) {
                                curr_tuplet_unit = rat_long_div(curr_tuplet_unit, 3);
                                curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, 2);
                                curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            } else {
                                curr_tuplet_unit = rat_long_div(curr_tuplet_unit, 2);
                                curr_tuplet_unit_figure = rat_long_div(curr_tuplet_unit_figure, 2);
                                curr_tuplet_complete_sym_dur = rat_long_prod(curr_tuplet_unit_figure, (curr_tuplet_ratio.r_num * curr_tuplet_multiplier));
                            }
                        }
                        curr_tuplet_sym_dur = rhythm_elem_rat_abs;
                        if (verbose)
                            object_post((t_object *) r_ob, "  Group %ld has ratio: %ld/%ld, unit: %ld/%ld, unit_figure: %ld/%ld, complete_sym_dur: %ld/%ld.", tuplet_group, curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den, curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);
                        check_overflow = true;
                    }
                }
                
                llll_appendrat(*new_rhythm, rhythm_elem_rat, 0, WHITENULL_llll);
                if (infos_elem) llll_appendhatom_clone(*new_infos, &infos_elem->l_hatom, 0, WHITENULL_llll);
                if (ties_elem) llll_appendhatom_clone(*new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
                
                // tuplet overflowing?
                stay_inside = false;
                if (check_overflow) { 
                    t_rational diff = rat_rat_diff(curr_tuplet_complete_sym_dur, curr_tuplet_sym_dur); // how much is left to achieve the tuplet?
                    if (verbose)
                        object_post((t_object *) r_ob, "  To achieve the tuplet we need complete_sym_dur: %ld/%ld. With this element we have sym_dur: %ld/%ld", curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den, curr_tuplet_sym_dur.r_num, curr_tuplet_sym_dur.r_den);
                    if (diff.r_num > 0) { 
                        // tuplet is not ended yet, there's not much to do, just continue
                        if (verbose)
                            object_post((t_object *) r_ob, "    We still need %ld/%ld to complete the tuplet: we consider another element.", diff.r_num, diff.r_den);
                        gotta_complete_a_tuplet = true;
                        box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                    } else {
                        // tuplet is ended. we write the llll-things
                        char falsetuplet = ((count == 1) && (perfect_log2(curr_tuplet_complete_sym_dur.r_den) >= 0)) ? true : false;
                        t_llllelem *temp_elem;
                        for (temp_elem = start_tuplet_duration_elem; (temp_elem && (temp_elem->l_prev != rhythm_elem)); temp_elem = temp_elem->l_next) {
                            t_llll *element_tuplets = llll_get();
                            llll_appendrat(element_tuplets, (falsetuplet) ? long2rat(1) : curr_tuplet_ratio, 0, WHITENULL_llll); //ratio
                            llll_appendrat(element_tuplets, (falsetuplet) ? long2rat(0) : curr_tuplet_unit_figure, 0, WHITENULL_llll); //unit figure
                            llll_appendlong(element_tuplets, (falsetuplet) ? 0 : tuplet_group, 0, WHITENULL_llll); //group
                            llll_appendlong(element_tuplets, (falsetuplet) ? 1 : curr_tuplet_multiplier, 0, WHITENULL_llll); //multiplier
                            llll_appendrat(element_tuplets, (falsetuplet) ? long2rat(0) : curr_tuplet_unit, 0, WHITENULL_llll); //unit 
                            llll_appendlong(element_tuplets, (falsetuplet) ? 1 : curr_completeness, 0, WHITENULL_llll); //completeness
                            llll_appendllll(*tuplets, element_tuplets, 0, WHITENULL_llll);
                        }
                        if (verbose)
                            object_post((t_object *) r_ob, "    Tuplet group %ld has ended with ratio: %ld/%ld, unit: %ld/%ld, unit_figure: %ld/%ld, multiplier: %ld, complete_sym_dur: %ld/%ld.", tuplet_group, curr_tuplet_ratio.r_num, curr_tuplet_ratio.r_den, curr_tuplet_unit.r_num, curr_tuplet_unit.r_den, curr_tuplet_unit_figure.r_num, curr_tuplet_unit_figure.r_den, curr_tuplet_multiplier, curr_tuplet_complete_sym_dur.r_num, curr_tuplet_complete_sym_dur.r_den);

                        if (diff.r_num < 0) { // overflowing!
                            // gotta split the last chord...
                            t_rational old_element_dur = rat_long_prod(rat_rat_diff(rhythm_elem_rat_abs, rat_abs(diff)), rhythm_elem_sign);
                            t_rational new_element_dur = rat_long_prod(rat_abs(diff), rhythm_elem_sign);
                            stay_inside = true;
                            if (verbose)
                                object_post((t_object *) r_ob, "    Tuplet has overflown. We split %ld/%ld = %ld/%ld + %ld/%ld and we continue considering this last element.", rhythm_elem_rat.r_num, rhythm_elem_rat.r_den, old_element_dur.r_num, old_element_dur.r_den, new_element_dur.r_num, new_element_dur.r_den);

                            hatom_setrational(&(*new_rhythm)->l_tail->l_hatom, old_element_dur); // change the duration
                            llll_betail(*new_ties); llll_appendlong(*new_ties, 1, 0, WHITENULL_llll); // last ties has to be 1
                            rhythm_elem_rat = new_element_dur;
                            box_onset = rat_rat_diff(rat_rat_sum(box_onset, rhythm_elem_rat_abs), rat_abs(diff));
                        } else {
                            if (verbose)
                                object_post((t_object *) r_ob, "    Tuplet is exactly ended. We consider the next element (without needing to complete a tuplet).", diff.r_num, diff.r_den);

                            box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                        }
                        gotta_complete_a_tuplet = false;
                    }
                } else { // there was no tuplet
                    t_llll *element_tuplets = llll_get();
                    box_onset = rat_rat_sum(box_onset, rhythm_elem_rat_abs);
                    llll_appendrat(element_tuplets, long2rat(1), 0, WHITENULL_llll); //ratio
                    llll_appendrat(element_tuplets, long2rat(0), 0, WHITENULL_llll); //unitfigure
                    llll_appendlong(element_tuplets, 0, 0, WHITENULL_llll); //group
                    llll_appendlong(element_tuplets, 1, 0, WHITENULL_llll); //multiplier
                    llll_appendrat(element_tuplets, long2rat(0), 0, WHITENULL_llll); //unit
                    llll_appendlong(element_tuplets, 1, 0, WHITENULL_llll); //completed
                    llll_appendllll(*tuplets, element_tuplets, 0, WHITENULL_llll);
                }
            }
            
            if (restart) 
                continue;

            if (infos_elem) infos_elem = infos_elem->l_next;
            if (ties_elem) ties_elem = ties_elem->l_next;
            
            rhythm_elem = rhythm_elem->l_next;
        }
        
        if ((*tuplets)->l_size < (*new_rhythm)->l_size) { // there's a problem... this happens with very difficult divisions, but I don't know why!
            long i, howmany = (*new_rhythm)->l_size - (*tuplets)->l_size;
            if (verbose)
                object_post((t_object *) r_ob, "    ***** ERROR: tuplets length < rhythm length *****");

            // we roughly fix it
            for (i = 0; i < howmany; i++) {
                t_llll *element_tuplets = llll_get();
                llll_appendrat(element_tuplets, long2rat(1), 0, WHITENULL_llll); //ratio
                llll_appendrat(element_tuplets, long2rat(0), 0, WHITENULL_llll); //unitfigure
                llll_appendlong(element_tuplets, 0, 0, WHITENULL_llll); //group
                llll_appendlong(element_tuplets, 1, 0, WHITENULL_llll); //multiplier
                llll_appendrat(element_tuplets, long2rat(0), 0, WHITENULL_llll); //unit
                llll_appendlong(element_tuplets, 1, 0, WHITENULL_llll); //completed
                llll_appendllll(*tuplets, element_tuplets, 0, WHITENULL_llll);
            }
        }


//        // increasing units if possible (e.g. if a tuplet of 3/80 3/80 3/80 3/80 3/80 has unit 1/80, it can be raised to 3/80
//        for (new_rhythm_elem = (*new_rhythm)->l_head; new_rhythm_elem; new_rhythm_elem = new_rhythm_elem->l_next) {
//            TO DO
//        }

        // regrouping into larger multipliers; e.g. {1/24 1/24 1/24} {1/24 1/24 1/24} will be regrouped into a 6-plet {1/24 1/24 1/24 1/24 1/24 1/24}
        if (verbose)
            object_post((t_object *) r_ob, "    * Trying to regroup into larger multipliers...");

        new_rhythm_elem = (*new_rhythm)->l_head;
        new_infos_elem = (*new_infos)->l_head;
        new_ties_elem = (*new_ties)->l_head;
        tuplets_elem = (*tuplets)->l_head; 
        while (new_rhythm_elem && new_rhythm_elem->l_next && tuplets_elem &&tuplets_elem->l_next) {
            long next_tuplet_group, this_completed, next_completed;
            t_llll *this_tuplet_llll = hatom_getllll(&tuplets_elem->l_hatom);
            t_llll *next_tuplet_llll = hatom_getllll(&tuplets_elem->l_next->l_hatom);
            long this_tuplet_group = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_hatom);
            if (this_tuplet_group > curr_tuplet_group) { 
                curr_tuplet_group = this_tuplet_group; 
                start_rhythm_pivot_elem = new_rhythm_elem; 
                start_infos_pivot_elem = new_infos_elem; 
                start_ties_pivot_elem = new_infos_elem; 
                start_tuplets_pivot_elem = tuplets_elem; 
            }
            next_tuplet_group = hatom_getlong(&next_tuplet_llll->l_head->l_next->l_next->l_hatom);
            this_completed = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_next->l_hatom);
            next_completed = hatom_getlong(&next_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_next->l_hatom);
            if ((this_tuplet_group > 0) && (next_tuplet_group > 0) && (next_tuplet_group > this_tuplet_group) && (this_completed) && (next_completed)) {
                t_rational this_ratio = hatom_getrational(&this_tuplet_llll->l_head->l_hatom);
                t_rational next_ratio = hatom_getrational(&next_tuplet_llll->l_head->l_hatom);
                t_rational this_unit = hatom_getrational(&this_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_hatom);
                t_rational next_unit = hatom_getrational(&next_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_hatom);
                long this_multiplier = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_next->l_hatom);
                long next_multiplier = hatom_getlong(&next_tuplet_llll->l_head->l_next->l_next->l_next->l_hatom);
                if ((rat_rat_cmp(this_ratio, next_ratio) == 0) && (rat_rat_cmp(this_unit, next_unit) == 0)) {
                    // we group them!
                    t_llllelem *temp1 = start_rhythm_pivot_elem;
                    t_llllelem *temp2 = start_infos_pivot_elem;
                    t_llllelem *temp3 = start_tuplets_pivot_elem;
                    t_llllelem *temp4 = start_ties_pivot_elem;
                    while (temp1) {
                        t_llll *tuplets_llll = hatom_getllll(&temp3->l_hatom);
                        long group = hatom_getlong(&tuplets_llll->l_head->l_next->l_next->l_hatom);
                        if ((group == 0) || (group > next_tuplet_group)) break; // end of the cycle
                        hatom_setlong(&tuplets_llll->l_head->l_next->l_next->l_hatom, curr_tuplet_group); // group
                        hatom_setlong(&tuplets_llll->l_head->l_next->l_next->l_next->l_hatom, this_multiplier + next_multiplier); // multiplier
                        temp1 = temp1->l_next;
                        if (temp2) temp2 = temp2->l_next;
                        if (temp3) temp3 = temp3->l_next;
                        if (temp4) temp4 = temp4->l_next;
                    }
                }
            }
        

            // incrementing things
            if (new_infos_elem) new_infos_elem = new_infos_elem->l_next;
            if (new_ties_elem) new_ties_elem = new_ties_elem->l_next;
            if (tuplets_elem) tuplets_elem = tuplets_elem->l_next;

            new_rhythm_elem = new_rhythm_elem->l_next;
        }
        
        
        // eliminating dotted tuplets, if requested
/*        if (!(admit_dotted_tuplets)) {
            if (verbose) object_post((t_object *) r_ob, "    * Converting dotted tuplets (if any)...");
            new_rhythm_elem = (*new_rhythm)->l_head;
            new_infos_elem = (*new_infos)->l_head;
            new_ties_elem = (*new_ties)->l_head;
            tuplets_elem = (*tuplets)->l_head; 
            while (new_rhythm_elem && new_rhythm_elem->l_next  && tuplets_elem &&tuplets_elem->l_next) {
                t_llll *this_tuplet_llll = hatom_getllll(&tuplets_elem->l_hatom);
                long this_tuplet_group = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_hatom);
                if (this_tuplet_group > 0) {
                    t_rational this_unit_figure = hatom_getrational(&this_tuplet_llll->l_head->l_next->l_hatom);
                    if (this_unit_figure.r_num != 1) { // dotted tuplet
                        // we change it them!
                        t_rational this_ratio = hatom_getrational(&this_tuplet_llll->l_head->l_hatom);
                        t_rational new_unit_figure = genrat(1, round(pow(2, floor(log2(((double) this_unit_figure.r_den) / ((double)this_unit_figure.r_num))))));
                        t_rational old_new_unit_figure_ratio = rat_rat_div(this_unit_figure, new_unit_figure);
                        t_rational new_ratio = rat_rat_prod(this_ratio, old_new_unit_figure_ratio);
                        hatom_setrational(&this_tuplet_llll->l_head->l_hatom, new_ratio); // ratio
                        hatom_setrational(&this_tuplet_llll->l_head->l_next->l_hatom, new_unit_figure); // unit figure
                    }
                }
                
                // incrementing things
                if (new_infos_elem) new_infos_elem = new_infos_elem->l_next;
                if (new_ties_elem) new_ties_elem = new_ties_elem->l_next;
                if (tuplets_elem) tuplets_elem = tuplets_elem->l_next;
                
                new_rhythm_elem = new_rhythm_elem->l_next;
            }
        }*/


        // retranscribing until max_dots (using dots, if possible)
        if (verbose)
            object_post((t_object *) r_ob, "    * Retranscribing until max_dots (if possible)...");

        new_rhythm_elem = (*new_rhythm)->l_head;
        new_infos_elem = (*new_infos)->l_head;
        new_ties_elem = (*new_ties)->l_head;
        tuplets_elem = (*tuplets)->l_head; 
        while (new_rhythm_elem && new_rhythm_elem->l_next  && tuplets_elem &&tuplets_elem->l_next) {
            char destroyed = false;
            t_rational this_duration = hatom_getrational(&new_rhythm_elem->l_hatom);
            t_rational next_duration = hatom_getrational(&new_rhythm_elem->l_next->l_hatom);
            t_llll *this_tuplet_llll = hatom_getllll(&tuplets_elem->l_hatom);
            t_llll *next_tuplet_llll = hatom_getllll(&tuplets_elem->l_next->l_hatom);
            long this_tuplet_group, next_tuplet_group;
            long next_size = (new_ties_elem && new_ties_elem->l_next && (hatom_gettype(&new_ties_elem->l_next->l_hatom) == H_LLLL)) ?
                                hatom_getllll(&new_ties_elem->l_next->l_hatom)->l_size : -1;
            char tied = is_all_llllelem_tied(new_ties_elem, next_size);
            this_tuplet_group = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_hatom);
            next_tuplet_group = hatom_getlong(&next_tuplet_llll->l_head->l_next->l_next->l_hatom);
            if ((this_duration.r_num * next_duration.r_num > 0) && (tied) && (this_tuplet_group > 0) && (this_tuplet_group == next_tuplet_group)) { // same sign and same tuplet, and tied. can we make it dotted?
                t_rational ratio = hatom_getrational(&this_tuplet_llll->l_head->l_hatom);
                t_rational this_unit_figure = hatom_getrational(&this_tuplet_llll->l_head->l_next->l_hatom);
                t_rational this_unit = hatom_getrational(&this_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_hatom);
                t_rational next_unit_figure = hatom_getrational(&next_tuplet_llll->l_head->l_next->l_hatom);
                t_rational next_unit = hatom_getrational(&next_tuplet_llll->l_head->l_next->l_next->l_next->l_next->l_hatom);
                t_rational this_figure = rat_rat_prod(this_unit_figure, rat_rat_div(this_duration, this_unit));
                t_rational next_figure = rat_rat_prod(next_unit_figure, rat_rat_div(next_duration, next_unit));
                t_rational sum = rat_rat_sum(this_figure, next_figure);
                //long sign = (sum.r_num >= 0) ? 1 : -1;
                t_rational abssum = rat_abs(sum);
                t_rational screendur; char numdots;
                is_duration_drawable(r_ob, abssum, &screendur, &numdots);
                if ((numdots > -1) &&  // figure is drawable
                    (perfect_log2(rat_rat_prod(sum, ratio).r_den) < 0)) { // the gathered duration is NOT a perfet /4, /8... duration
                    // we can gather!
                    t_llllelem *tmp;
                    hatom_setrational(&new_rhythm_elem->l_hatom, rat_rat_sum(this_duration, next_duration)); // new duration
                    tmp = new_ties_elem->l_next;
                    llll_destroyelem(new_ties_elem);
                    new_ties_elem = tmp;
                    llll_destroyelem(new_rhythm_elem->l_next);
                    llll_destroyelem(new_infos_elem->l_next);
                    llll_destroyelem(tuplets_elem->l_next);
                    destroyed = true;
                }
            }
            
            if (!destroyed) {
                // incrementing things
                if (new_infos_elem) new_infos_elem = new_infos_elem->l_next;
                if (new_ties_elem) new_ties_elem = new_ties_elem->l_next;
                if (tuplets_elem) tuplets_elem = tuplets_elem->l_next;
                
                new_rhythm_elem = new_rhythm_elem->l_next;
            }
        }
        
        
        // re-merging REGULAR rests
        if (!admit_dotted_tuplets) {
            if (verbose)
                object_post((t_object *) r_ob, "    * Re-merging regular rests...");

            new_rhythm_elem = (*new_rhythm)->l_head;
            new_infos_elem = (*new_infos)->l_head;
            new_ties_elem = (*new_ties)->l_head;
            tuplets_elem = (*tuplets)->l_head; 
            while (new_rhythm_elem && new_rhythm_elem->l_next  && tuplets_elem &&tuplets_elem->l_next) {
                long this_tuplet_group, next_tuplet_group;
                t_rational this_duration, next_duration;
                t_llll *this_tuplet_llll, *next_tuplet_llll;
                this_tuplet_llll = hatom_getllll(&tuplets_elem->l_hatom);
                this_tuplet_group = hatom_getlong(&this_tuplet_llll->l_head->l_next->l_next->l_hatom);
                next_tuplet_llll = hatom_getllll(&tuplets_elem->l_next->l_hatom);
                next_tuplet_group = hatom_getlong(&next_tuplet_llll->l_head->l_next->l_next->l_hatom);
                this_duration = hatom_getrational(&new_rhythm_elem->l_hatom);
                next_duration = hatom_getrational(&new_rhythm_elem->l_next->l_hatom);
                if ((this_tuplet_group == 0) && (next_tuplet_group == 0) && (this_duration.r_num < 0) && (next_duration.r_num < 0) && 
                    (perfect_log2(this_duration.r_num) >= 0) && (perfect_log2(next_duration.r_num) >= 0)) {
                    
                    hatom_setrational(&new_rhythm_elem->l_hatom, rat_rat_sum(this_duration, next_duration));

                    llll_destroyelem(new_ties_elem->l_next);
                    llll_destroyelem(new_rhythm_elem->l_next);
                    llll_destroyelem(new_infos_elem->l_next);
                    llll_destroyelem(tuplets_elem->l_next);
                }
                
                // incrementing things
                if (new_infos_elem) new_infos_elem = new_infos_elem->l_next;
                if (new_ties_elem) new_ties_elem = new_ties_elem->l_next;
                if (tuplets_elem) tuplets_elem = tuplets_elem->l_next;
                
                new_rhythm_elem = new_rhythm_elem->l_next;
            }
        }
                
        *max_tuplet_group = (tuplet_group < *max_tuplet_group) ? *max_tuplet_group : tuplet_group + 1; // increasing safely max_tuplet_group 
    }
}

char are_there_measures_in_alignmentpoint(t_alignmentpoint *ap){
    long i;
    for (i=0; i < ap->num_aligned_obj; i++)
        if (ap->aligned_obj[i] && ap->aligned_obj[i]->type == k_MEASURE_END_BARLINE)
            return 1;
    
    return 0;
}

char are_there_only_measures_in_alignmentpoint(t_alignmentpoint *ap){
    long i;
    if (ap->num_aligned_obj <= 0) return 0;
    
    for (i=0; i<ap->num_aligned_obj; i++)
        if (ap->aligned_obj[i]->type != k_MEASURE_END_BARLINE)
            return 0;
    
    return 1;
}


double get_notehead_durationline_start_ux_shift(t_notation_obj *r_ob, t_note *note)
{
    double dl_ux_shift = 0.;
    
    get_notehead_specs_from_note(r_ob, note, NULL, NULL, NULL, NULL, NULL, NULL, &dl_ux_shift, false);
    
    if (r_ob->link_notehead_adjust_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_adjust_to_slot - 1].slot_type == k_SLOT_TYPE_FLOATLIST &&
        note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem) {
        // VIA SLOT ADJUST
        dl_ux_shift += *((double *)note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem->item);
    }
    return dl_ux_shift;
}

double get_notehead_ux_shift(t_notation_obj *r_ob, t_note *note)
{
    double ux_shift = 0., small_ux_shift = 0.;
    
    get_notehead_specs_from_note(r_ob, note, NULL, NULL, &ux_shift, NULL, &small_ux_shift, NULL, NULL, false);
    
    if (r_ob->link_notehead_adjust_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_adjust_to_slot - 1].slot_type == k_SLOT_TYPE_FLOATLIST && 
        note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem) {
        // VIA SLOT ADJUST
        ux_shift += *((double *)note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem->item);
        small_ux_shift += *((double *)note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem->item) * CONST_GRACE_CHORD_SIZE;
    }
    return note->parent && note->parent->is_score_chord && note->parent->is_grace_chord ? small_ux_shift : ux_shift;
}

double get_notehead_uy_shift(t_notation_obj *r_ob, t_note *note)
{
    double uy_shift = 0.;
    
    get_notehead_specs_from_note(r_ob, note, NULL, NULL, NULL, &uy_shift, NULL, NULL, NULL, false);

    if (r_ob->link_notehead_adjust_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_adjust_to_slot - 1].slot_type == k_SLOT_TYPE_FLOATLIST &&
        note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem && note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem->next) {
        uy_shift += *((double *)note->slot[r_ob->link_notehead_adjust_to_slot - 1].firstitem->next->item);
    }
    return uy_shift;
}

// get the maximum uwidth of the noteheads at the left of the chord
double chord_get_left_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord)
{
    t_note *note;
    double max_left_uwidth = 0;
        
    for (note = chord->firstnote; note; note = note->next) {
        if (note->notecenter_stem_delta_ux < 0) { // left
            max_left_uwidth = MAX(max_left_uwidth, note->notehead_uwidth);
        }
    }
    return max_left_uwidth;
}

// get the maximum uwidth of the noteheads at the right of the chord
double chord_get_right_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord){
    t_note *note;
    double max_right_uwidth = 0;
    
    for (note = chord->firstnote; note; note = note->next) {
        if (note->notecenter_stem_delta_ux > 0) { // right
            max_right_uwidth = MAX(max_right_uwidth, note->notehead_uwidth);
        }
    }
    return max_right_uwidth;
}

double chord_get_mainside_notehead_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration, t_chord *chord)
{
    if (!chord)
        return notehead_get_uwidth(r_ob, r_sym_duration, NULL, false);
    if (chord->direction == 1)
        return chord_get_left_notehead_uwidth(r_ob, chord);
    else
        return chord_get_right_notehead_uwidth(r_ob, chord);
}


t_note *get_principal_note(t_notation_obj *r_ob, t_chord *chord)
{
    t_note *temp, *res = NULL;
    double max_notecenter_stem_delta_ux = 32000; // foo but high
    for (temp = chord->firstnote; temp; temp = temp->next) {
        if (chord->direction == 1 && temp->notecenter_stem_delta_ux < 0 && fabs(temp->notecenter_stem_delta_ux) < max_notecenter_stem_delta_ux) {
            max_notecenter_stem_delta_ux = fabs(temp->notecenter_stem_delta_ux);
            res = temp;
        } else if (chord->direction == -1 && temp->notecenter_stem_delta_ux > 0 && temp->notecenter_stem_delta_ux < max_notecenter_stem_delta_ux) {
            max_notecenter_stem_delta_ux = temp->notecenter_stem_delta_ux;
            res = temp;
        }
    }
    return res;
}

double get_principal_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord)
{
    t_note *nt = get_principal_note(r_ob, chord);
    if (nt)
        return notehead_get_uwidth(r_ob, chord->r_sym_duration, nt, true);
    return rest_get_uwidth(r_ob, chord->r_sym_duration);
}

void get_notehead_specs(t_notation_obj *r_ob, long notehead_ID, t_rational rdur, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift)
{
    if (notehead_ID >= 0 && notehead_ID < r_ob->noteheads_typo_preferences.num_noteheads) {
        if (character) *character = notationobj_notehead_id2unicodechar(r_ob, notehead_ID, rdur);
        if (uwidth) *uwidth = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].uwidth;
        if (ux_shift) *ux_shift = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].ux_shift;
        if (uy_shift) *uy_shift = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].uy_shift;
        if (small_ux_shift) *small_ux_shift = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].small_ux_shift;
        if (small_uy_shift) *small_uy_shift = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].small_uy_shift;
        if (duration_line_start_ux_shift) *duration_line_start_ux_shift = r_ob->noteheads_typo_preferences.nhpref[notehead_ID].durationline_start_ux_shift;
    }
}

long get_notehead_specs_from_rdur(t_notation_obj *r_ob, t_rational rdur, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift)
{
    long id;
    if (rat_long_cmp(rdur, 2) >= 0) id = k_NOTEHEAD_DOUBLE_WHOLE_NOTE;
    else if (rat_long_cmp(rdur, 1) >= 0) id = k_NOTEHEAD_WHOLE_NOTE;
    else if (rat_rat_cmp(rdur, RAT_1OVER2) >= 0) id = k_NOTEHEAD_WHITE_NOTE;
    else id = k_NOTEHEAD_BLACK_NOTE;
    
    get_notehead_specs(r_ob, id, rdur, character, uwidth, ux_shift, uy_shift, small_ux_shift, small_uy_shift, duration_line_start_ux_shift);
    return id;
}


long get_notehead_specs_from_note(t_notation_obj *r_ob, t_note *note, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift, char avoid_returning_default)
{
    t_chord *ch = note->parent;
    
    if (note && r_ob->link_notehead_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_to_slot - 1].slot_type == k_SLOT_TYPE_NOTEHEAD && note->slot[r_ob->link_notehead_to_slot - 1].firstitem) {
        // NEW WAY OF DEFINING NOTEHEADS
        long id = notationobj_notehead_symbol2id(r_ob, ((t_symbol *)note->slot[r_ob->link_notehead_to_slot - 1].firstitem->item));
        get_notehead_specs(r_ob, id, note->parent->r_sym_duration, character, uwidth, ux_shift, uy_shift, small_ux_shift, small_uy_shift, duration_line_start_ux_shift);
        return id;
    }
    
    if (!ch)
        return get_notehead_specs_from_rdur(r_ob, RAT_1OVER4, character, uwidth, ux_shift, uy_shift, small_ux_shift, small_uy_shift, duration_line_start_ux_shift);
    
    // else:
    if (uwidth) *uwidth = notehead_get_uwidth(r_ob, ch->r_sym_duration, note, true); // this also accounts for the old way of defining custom noteheads
    
    long res = get_notehead_specs_from_rdur(r_ob, ch->is_score_chord ? ch->figure : ch->r_sym_duration, character, NULL, ux_shift, uy_shift, small_ux_shift, small_uy_shift, duration_line_start_ux_shift);

    return avoid_returning_default ? res : k_NOTEHEAD_DEFAULT;
}



// note is only needed if custom notehead is provided; otherwise r_sym_duration suffice
double notehead_get_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration, t_note *note, char account_for_grace_chords)
{
    double grace_ratio = account_for_grace_chords && note && note->parent && note->parent->is_score_chord && note->parent->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1.;
    
    if (note && r_ob->link_notehead_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_to_slot - 1].slot_type == k_SLOT_TYPE_INT && note->slot[r_ob->link_notehead_to_slot - 1].firstitem) {
        // OLD WAY OF DEFINING CUSTOM NOTEHEADS
        t_jfont *jf_custom;
        if (note && r_ob->link_notehead_font_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_font_to_slot - 1].slot_type == k_SLOT_TYPE_TEXT && 
            note->slot[r_ob->link_notehead_font_to_slot - 1].firstitem && note->slot[r_ob->link_notehead_font_to_slot - 1].length > 0)
            jf_custom = jfont_create_debug((char *)note->slot[r_ob->link_notehead_font_to_slot - 1].firstitem->item, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, 24);
        else 
            jf_custom = jfont_create_debug(r_ob->noteheads_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->notation_typo_preferences.base_pt);
        if (jf_custom) {
            char *noteheadchar_utf;
            double width, height;
            long outlen_notehead;
            unicodeChar val = *((long *) note->slot[r_ob->link_notehead_to_slot - 1].firstitem->item); 
            noteheadchar_utf = charset_unicodetoutf8_debug(&val, 1, &outlen_notehead);
            jfont_text_measure(jf_custom, noteheadchar_utf, &width, &height);
            bach_freeptr(noteheadchar_utf);
            jfont_destroy_debug(jf_custom);
            return width * grace_ratio;
        }
    } else if (note && r_ob->link_notehead_to_slot > 0 && r_ob->slotinfo[r_ob->link_notehead_to_slot - 1].slot_type == k_SLOT_TYPE_NOTEHEAD && note->slot[r_ob->link_notehead_to_slot - 1].firstitem) {
        // NEW WAY OF DEFINING NOTEHEADS
        long id = notationobj_notehead_symbol2id(r_ob, ((t_symbol *)note->slot[r_ob->link_notehead_to_slot - 1].firstitem->item));
        double width = 0;
        get_notehead_specs(r_ob, id, r_sym_duration, NULL, &width, NULL, NULL, NULL, NULL, NULL);
        return width * grace_ratio;
    }
    
    if (rat_rat_cmp(r_sym_duration, RAT_1OVER4) <= 0) 
        return r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_BLACK_NOTE].uwidth * grace_ratio;
    
    if (rat_rat_cmp(r_sym_duration, RAT_1OVER2) <= 0)
        return r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_WHITE_NOTE].uwidth * grace_ratio;
    
    if (rat_rat_cmp(r_sym_duration, genrat(1, 1)) <= 0)
        return r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_WHOLE_NOTE].uwidth * grace_ratio;
    
    return r_ob->noteheads_typo_preferences.nhpref[k_NOTEHEAD_DOUBLE_WHOLE_NOTE].uwidth * grace_ratio;
}

double rest_get_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration)
{
    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER128) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[8];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER64) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[7];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER32) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[6];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER16) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[5];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER8) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[4];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER4) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[3];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER2) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[2];
    
    if (rat_rat_cmp(rat_abs(r_sym_duration), genrat(1, 1)) <= 0) 
        return r_ob->notation_typo_preferences.rest_uwidths[1];
    
    return r_ob->notation_typo_preferences.rest_uwidths[0];
}

double rest_get_top_extension_in_steps(t_notation_obj *r_ob, t_rational r_sym_duration) { // these are in STEP_y!!! (e.g. 3.5 = 3.5 step_y steps)
    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER128) <= 0) 
        return 8.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER64) <= 0) 
        return 6.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER32) <= 0) 
        return 4.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER16) <= 0) 
        return 2.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER8) <= 0) 
        return 2.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER4) <= 0) 
        return 3.5;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER2) <= 0) 
        return 1.;
    
    if (rat_rat_cmp(rat_abs(r_sym_duration), genrat(1, 1)) <= 0) 
        return 2.;
    
    return 2.;
}

double rest_get_bottom_extension_in_steps(t_notation_obj *r_ob, t_rational r_sym_duration) { // these are in STEP_y!!!!
    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER128) <= 0) 
        return 4.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER64) <= 0) 
        return 4.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER32) <= 0) 
        return 4.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER16) <= 0) 
        return 4.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER8) <= 0) 
        return 2.;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER4) <= 0) 
        return 3.5;

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER2) <= 0) 
        return 0.;
    
    if (rat_rat_cmp(rat_abs(r_sym_duration), genrat(1, 1)) <= 0) 
        return 0.;
    
    return 2.;
}

unicodeChar rest_get_unicode_character(t_notation_obj *r_ob, t_rational r_sym_duration) {
    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER128) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[8];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER64) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[7];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER32) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[6];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER16) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[5];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER8) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[4];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER4) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[3];

    if (rat_rat_cmp(rat_abs(r_sym_duration), RAT_1OVER2) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[2];
    
    if (rat_rat_cmp(rat_abs(r_sym_duration), genrat(1, 1)) <= 0) 
        return r_ob->notation_typo_preferences.rests_unicode_characters[1];
    
    return r_ob->notation_typo_preferences.rests_unicode_characters[0];
}

char get_num_dots_with_tuplet_info(t_notation_obj *r_ob, t_rational duration, t_rational tuplet_group_unit, t_rational tuplet_group_figure){
    t_rational screen_duration;
    char num_dots;
    is_duration_drawable_with_tuplet_info(r_ob, duration, &screen_duration, &num_dots, tuplet_group_unit, tuplet_group_figure);
    return num_dots;
}

char get_num_dots(t_notation_obj *r_ob, t_rational duration){
    return get_num_dots_with_tuplet_info(r_ob, duration, long2rat(0), long2rat(0));
}


char is_duration_drawable_with_tuplet_info(t_notation_obj *r_ob, t_rational duration, t_rational *screen_duration, char *num_dots, t_rational tuplet_group_unit, t_rational tuplet_group_unit_figure) {
// tells us if a rational duration is drawable (e.g. 7/8 = 1/4 . .) or not (e.g. 5/8). if it is, it fills the screen duration and the num_dots. if not, num_dots = -1
    t_rational non_tuplet_dur;
    
    if (perfect_log2(duration.r_den) >= 0)
        non_tuplet_dur = rat_abs(duration);
    else {
        if (tuplet_group_unit.r_num == 0) { // "automatic"
            t_rational temp_group_unit = genrat(rat_abs(duration).r_num, round(pow(2, floor(log2(duration.r_den)))));
            non_tuplet_dur = rat_abs(temp_group_unit);
        } else // with specific infos about the tuplet
            non_tuplet_dur = rat_rat_prod(rat_rat_div(duration, tuplet_group_unit), tuplet_group_unit_figure);

    }

    if (non_tuplet_dur.r_den == 1)  {
        if (non_tuplet_dur.r_num == 1) {
            *num_dots = 0;
            screen_duration->r_num = 1;
            screen_duration->r_den = 1;
            return true;
        } else if (non_tuplet_dur.r_num == 2) {
            *num_dots = 0;
            screen_duration->r_num = 2;
            screen_duration->r_den = 1;
            return true;
        } else if (non_tuplet_dur.r_num == 3) {
            *num_dots = 1;
            screen_duration->r_num = 2;
            screen_duration->r_den = 1;
            return true;
        } else if (non_tuplet_dur.r_num > 1 && non_tuplet_dur.r_den == 1) {
            *num_dots = -1;
            return false;
        }
    } else
        *num_dots = perfect_log2(non_tuplet_dur.r_num + 1) - 1; // e.g. 15/16 -> log2(15+1) -1 = 4 - 1 = 3
    
    if (*num_dots == 0) {
        *screen_duration = non_tuplet_dur;
    } else if (*num_dots > 0) {
        screen_duration->r_num = (non_tuplet_dur.r_num + 1) / 2;
        screen_duration->r_den = non_tuplet_dur.r_den;
        rat_reduce(screen_duration);
    }
    return (*num_dots < 0 ? false : true);
}

char is_duration_drawable(t_notation_obj *r_ob, t_rational duration, t_rational *screen_duration, char *num_dots) {
    return is_duration_drawable_with_tuplet_info(r_ob, duration, screen_duration, num_dots, long2rat(0), long2rat(0));
}

unicodeChar get_notehead_unicode_character(t_notation_obj *r_ob, t_rational duration, double *uwidth) {
// fills also the width

    if (!r_ob) {
        if (uwidth) *uwidth = 7.9; // November for bach standard
        return 0;
    }
        
    unicodeChar character = 0;
    get_notehead_specs_from_rdur(r_ob, duration, &character, uwidth, NULL, NULL, NULL, NULL, NULL);
    return character;
}

// depth is the starting depth when this function is called (you might probably want to  always set it to 1 : it is used internally to avoid too long recursions)
t_llll *get_duration_drawable(t_rational duration, t_rational onset, t_rational box_length, long max_dots, long depth, char irregular) {
    t_llll *out = llll_get();
    long num_dots = perfect_log2(duration.r_num + 1) - 1;
    
    if (num_dots >= -1 && num_dots <= max_dots) {
        llll_appendrat(out, duration, 0, WHITENULL_llll);
        return out;
        
    } else if (irregular || (depth > CONST_MAX_DEPTH_DURATION_DRAWABLE) || (perfect_log2(onset.r_den) < 0)) { // onset is "tupletted" or depth is too much. we stop recursion, ignoring the onset!
        if (num_dots > 0) { // there are too many dots. still we can split, but easily.
            t_rational temp_rat = duration;
            long num = temp_rat.r_num; long den = temp_rat.r_den;                                    // e.g. for 31/32
            while ((num > 0) && (perfect_log2(temp_rat.r_num + 1) - 1 > max_dots)) {                // CYCLE 1                            // CYCLE 2 
                long new_num = (long)pow(2., max_dots + 1) - 1;                                        // 2^2-1 = 3: we take out 3/32        // 2^2-1 = 3: we take out 3/8
                llll_appendrat(out, genrat(new_num, den), 0, WHITENULL_llll);
                num -= new_num;                                                                        // there are 28/32 left                // there are 4/8 left
                temp_rat.r_num = num;
                rat_reduce(&temp_rat); num = temp_rat.r_num; den = temp_rat.r_den;                    // there are 7/8 left.                // there are 1/2 left
            }                                                                                        // log2(7+1)-1 = 2 > 1, we go on    // log2(1+1)-1 = 0, ok we exit
            if (temp_rat.r_num != 0)                                                                                                    // finally we have (1/2 3/8 3/32)
                llll_appendrat(out, temp_rat, 0, WHITENULL_llll);
            llll_rev(out, 1, 2);
            return out;                            
        } else { // no dots possible. we have to split (similarly). It's an awkward symbol (e.g. 5/8).
            // Consider as an example 25/32; max_dots = 1; 21 = 16 + 5 = 16 + 4 + 1
            t_llll *aux_llll = llll_get();
            long num = duration.r_num; 
            long den = duration.r_den;
            t_llllelem *elem;
            while (num > 0) {                                                                        // CYCLE 1                    // CYCLE 2                    // CYCLE 3
                long tosubtract = (long)round(pow(2,floor(log2(num))));                                // 2^floor(log2(25))=16        // 2^floor(log2(9))=8        // 2^floor(log2(1)) = 1
                if (tosubtract > 2 * den) // more than a double integer? make it a double integer
                    tosubtract = 2 * den;
                llll_appendrat(aux_llll, genrat(tosubtract, den), 0, WHITENULL_llll);            // we insert 16/32=1/2        // we insert 8/32 = 1/4        // we insert 1/32
                num -= tosubtract;                                                                    // there are 9/32 left        // there is 1/32 left        // there is nothing left.
            }                                                                                                                                                // finally we have (1/2 1/4 1/32) 
            // now we try to gather with dots
            llll_rev(aux_llll, 1, 2);    // here we have (1/32 1/4 1/2)
            elem = aux_llll->l_head;
            while (elem) {                                                                                                            // CYCLE 1            // CYCLE 2
                t_rational new_elem = hatom_getrational(&elem->l_hatom);                                                            // 1/32                // 1/4
                t_rational temp_elem = new_elem;
                long count = 0;
                if (rat_long_cmp(new_elem, 2) < 0) {
                    while (elem->l_next &&                                                                                            // true                // true                // false, we exit
                           count < max_dots &&                                                                                        // 0 < 1, ok        // 0 < 1, ok        // (1<1 ? false)
                           rat_rat_cmp(hatom_getrational(&elem->l_next->l_hatom), rat_long_prod(temp_elem, 2)) == 0) {                // 1/4 != 1/32 * 2    // 1/2 == 1/4 *2
                        temp_elem = hatom_getrational(&elem->l_next->l_hatom);                                                        // doesn't enter    // enters: 1/2
                        new_elem = rat_rat_sum(new_elem, temp_elem);                                                                                        // newelem = 3/4
                        count++;    
                        elem = elem->l_next;                                                                                                
                    }
                }
                llll_appendrat(out, new_elem, 0, WHITENULL_llll);                                                                    // append 1/32                            // append 3/4
                if (elem) 
                    elem = elem->l_next;
            }  
            llll_rev(out, 1, 2); // here we have (3/4 1/32)

            llll_free(aux_llll);

            return out;
        }
        
    } else { // we try to split correctly 
        
        // split duration in two or whatever
        t_rational l_box_length, r_box_length, l_sym_duration, r_sym_duration, l_sym_onset, r_sym_onset;
        long newdepth;
        if ((box_length.r_num == 1)  || (box_length.r_num % 2 == 0)) {
            if (rat_rat_cmp(onset, rat_long_div(box_length, 2)) >= 0) {
                l_sym_duration = long2rat(0); 
                r_sym_duration = duration;
                l_sym_onset = long2rat(0); 
                r_sym_onset = rat_rat_diff(onset, rat_long_div(box_length, 2));
            } else if (rat_rat_cmp(rat_rat_sum(onset, duration), rat_long_div(box_length, 2)) <= 0) {
                l_sym_duration = duration;
                r_sym_duration = long2rat(0);
                l_sym_onset = onset; 
                r_sym_onset = long2rat(0);
            } else {
                l_sym_duration = rat_rat_diff(rat_long_div(box_length, 2), onset);
                r_sym_duration = rat_rat_diff(rat_rat_sum(onset, duration), rat_long_div(box_length, 2));
                l_sym_onset = onset; 
                r_sym_onset = long2rat(0);
            }
            r_box_length = rat_long_div(box_length, 2);
            l_box_length = rat_long_div(box_length, 2);
        } else {
            if (rat_rat_cmp(onset, rat_long_div(box_length, box_length.r_num)) >= 0) {
                l_sym_duration = long2rat(0); 
                r_sym_duration = duration;
                l_sym_onset = long2rat(0); 
                r_sym_onset = rat_rat_diff(onset, rat_long_div(box_length, box_length.r_num));
            } else if (rat_rat_cmp(rat_rat_sum(onset, duration), rat_long_div(box_length, box_length.r_num)) <= 0) {
                l_sym_duration = duration;
                r_sym_duration = long2rat(0);
                l_sym_onset = onset; 
                r_sym_onset = long2rat(0);
            } else {
                l_sym_duration = rat_rat_diff(rat_long_div(box_length, box_length.r_num), onset);
                r_sym_duration = rat_rat_diff(rat_rat_sum(onset, duration), rat_long_div(box_length, box_length.r_num));
                l_sym_onset = onset; 
                r_sym_onset = long2rat(0);
            }
            l_box_length = rat_long_div(box_length, box_length.r_num);
            r_box_length = rat_rat_diff(box_length, l_box_length);
        }
        
        newdepth = depth + 1;
        llll_appendllll(out, get_duration_drawable(l_sym_duration, onset, l_box_length, max_dots, newdepth, false), 0, WHITENULL_llll); 
        llll_appendllll(out, get_duration_drawable(r_sym_duration, long2rat(0), r_box_length, max_dots, newdepth, false), 0, WHITENULL_llll); 
        return out;
    }
}


/*
t_llllelem *llll_easy_nth(t_llll *in_llll, long index) {
    t_llllelem *outelem;
    long i;

    if (!in_llll || !in_llll->l_head) return NULL;
    if (index < 0 || index >= in_llll->l_size) return NULL;
    
    if (index < in_llll->l_size / 2) {
        outelem = in_llll->l_head;
        for (i = 0; i < index; i++)
            if (outelem->l_next) 
                outelem = outelem->l_next;
            else
                return NULL;
    } else {
        outelem = in_llll->l_tail;
        for (i = in_llll->l_size - 1; i > index; i--)
            if (outelem->l_prev) 
                outelem = outelem->l_prev;
            else
                return NULL;
    }
    return outelem;
}*/

void llll_gather_if_drawable(t_llll *ll, char max_dots) {
    t_llllelem *elem = ll->l_tail;
    while (elem && (elem->l_prev)) {
        t_rational sum_with_prev = rat_rat_sum(hatom_getrational(&elem->l_hatom), hatom_getrational(&elem->l_prev->l_hatom));
        long num_dots = perfect_log2(sum_with_prev.r_num + 1) - 1;
        if ((num_dots >= 0) && (num_dots <= max_dots)) {
            hatom_setrational(&elem->l_hatom, sum_with_prev);
            llll_destroyelem(elem->l_prev);
        } else {
            elem = elem->l_prev;
        }
    }
}

void delete_chords_from_measure_from_discarded_info(t_notation_obj *r_ob, t_llll *discarded_info)
{
    t_llllelem *chord_elem;
    for (chord_elem = discarded_info->l_head; chord_elem; chord_elem = chord_elem->l_next){
        t_llll *ch_llll = (hatom_gettype(&chord_elem->l_hatom) == H_LLLL ? hatom_getllll(&chord_elem->l_hatom) : NULL);
        if (ch_llll && ch_llll->l_head && hatom_gettype(&ch_llll->l_head->l_hatom) == H_OBJ) {
            t_chord *chord = (t_chord *)hatom_getobj(&ch_llll->l_head->l_hatom);
            chord_delete_from_measure(r_ob, chord, false);
        }
    }
}


/// OLD, no longer used
void get_rhythm_drawable(t_notation_obj *r_ob, t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, 
                         t_llll **tuplets, long max_dots, long tuplet_group_offset, long *max_tuplet_group, char admit_dotted_tuplets, t_llll *garbage, t_llll *next_box_infos) 
{
// gets the rhythm written with correct musical symbols. e.g. (5/16 -7/8) becomes (1/4 1/16 -1/4 -1/8 -1/16) with ties (1 0 0 0 0), or also (1/4 1/16 -7/8) if max_dots is let >= 2 (7/8 = 1/4 dotted dotted) 
// You can associate to each element of the original list a llll within the infos llll.
// the elements corresponing to merged elements will be deleted in the new_infos list. 
// The function initializes and fills **new_rhythm, **new_infos, **ties. Returns also the max tuplet group number (given an offset in input)

    if (rhythm->l_size > 0) {
        t_llllelem *rhythm_elem, *infos_elem, *tuplets_elem, *ties_elem; 
        t_rational rhythm_elem_rat, cursor, box_length;
//        char debug1[1000], debug2[1000], debug3[1000], debug4[1000];
//        llll_to_char_array(rhythm, debug1, 1000);
//        llll_to_char_array(infos, debug2, 1000);
//        llll_to_char_array(ties, debug3, 1000);

        // first, we merge the rests AND all the tied chords
        t_llll *rhythm_rests_merged, *infos_rests_merged, *ties_rests_merged, *discarded_info, *discarded_durations;
        t_llll *rhythm_rests_merged_tuplets_checked; t_llll *infos_rests_merged_tuplets_checked; t_llll *ties_rests_merged_tuplets_checked; t_llll *tuplets_raw;
        if (r_ob->autoparse_rhythms) {
            merge_rests_and_alltied_chords_from_separate_parameters(rhythm, infos, ties, &rhythm_rests_merged, &infos_rests_merged, &ties_rests_merged, &discarded_info, &discarded_durations, k_MERGE_WHEN_DRAWABLE);
            
            if (discarded_info) {
                // cycle on the discarded info
                t_llllelem *disc_chord_elem;
                t_llllelem *disc_dur_elem;
                t_chord *next_box_first_chord = NULL;
                if (next_box_infos && hatom_gettype(&next_box_infos->l_head->l_hatom) == H_LLLL && next_box_infos->l_head->l_hatom.h_w.w_llll->l_head &&
                    hatom_gettype(&next_box_infos->l_head->l_hatom.h_w.w_llll->l_head->l_hatom) == H_OBJ)
                    next_box_first_chord = (t_chord *) hatom_getobj(&next_box_infos->l_head->l_hatom.h_w.w_llll->l_head->l_hatom);
                
                for (disc_chord_elem = discarded_info->l_head, disc_dur_elem = discarded_durations->l_head; disc_chord_elem && disc_dur_elem; 
                     disc_chord_elem = disc_chord_elem->l_next, disc_dur_elem = disc_dur_elem->l_next){
                    t_llll *ch_llll = (hatom_gettype(&disc_chord_elem->l_hatom) == H_LLLL ? hatom_getllll(&disc_chord_elem->l_hatom) : NULL);
                    if (ch_llll && ch_llll->l_head && hatom_gettype(&ch_llll->l_head->l_hatom) == H_OBJ) {
                        t_chord *chord = (t_chord *)hatom_getobj(&ch_llll->l_head->l_hatom);
                        if (chord && chord == next_box_first_chord)
                            chord->r_sym_duration = rat_rat_diff(chord->r_sym_duration, hatom_getrational(&disc_dur_elem->l_hatom)); 
                        else if (chord)
                            chord_delete_from_measure(r_ob, chord, false);
                    }
                }
                
                llll_free(discarded_info);
            }
            llll_free(discarded_durations);
        } else {
            rhythm_rests_merged = rhythm; 
            infos_rests_merged = infos; 
            ties_rests_merged = ties;
        }
//        llll_to_char_array(rhythm_rests_merged, debug1, 1000);
//        llll_to_char_array(infos_rests_merged, debug2, 1000);
//        llll_to_char_array(ties_rests_merged, debug3, 1000); 

        // then we check the tuplets
        check_tuplets(r_ob, rhythm_rests_merged, infos_rests_merged, ties_rests_merged, &rhythm_rests_merged_tuplets_checked, &infos_rests_merged_tuplets_checked, &ties_rests_merged_tuplets_checked, &tuplets_raw, tuplet_group_offset, max_tuplet_group, admit_dotted_tuplets, max_dots);
//        llll_to_char_array(rhythm_rests_merged_tuplets_checked, debug1, 1000);
//        llll_to_char_array(infos_rests_merged_tuplets_checked, debug2, 1000);
//        llll_to_char_array(ties_rests_merged_tuplets_checked, debug3, 1000);
//        llll_to_char_array(tuplets_raw, debug4, 1000);
        
        // freeing objects!
        if (r_ob->autoparse_rhythms) {
            if (garbage) { // garbage collection?
                llll_appendllll(garbage, rhythm_rests_merged, 0, WHITENULL_llll);
                llll_appendllll(garbage, infos_rests_merged, 0, WHITENULL_llll);
                llll_appendllll(garbage, ties_rests_merged, 0, WHITENULL_llll);
            } else {
                llll_free(rhythm_rests_merged);
                llll_free(infos_rests_merged);
                llll_free(ties_rests_merged);
            }
        } // else: we didn't create any new llll: we don't free them.
        
        // we initialize the general lllls
        *new_rhythm = llll_get(); *new_infos = llll_get(); *new_ties = llll_get(); *tuplets = llll_get();
        infos_elem = (infos->l_size > 0) ? infos_rests_merged_tuplets_checked->l_head : NULL; 
        tuplets_elem = (tuplets_raw->l_size > 0) ? tuplets_raw->l_head : NULL; 
        ties_elem = (ties->l_size > 0) ? ties_rests_merged_tuplets_checked->l_head : NULL; 
        
        cursor = long2rat(0); box_length = llll_sum_abs_of_rat_llll(rhythm);
        for (rhythm_elem = rhythm_rests_merged_tuplets_checked->l_head; rhythm_elem; rhythm_elem = rhythm_elem->l_next) { // cycle on the rhythm
            // is it in a tuplet? cause if so, we "unroll" its duration and use the "drawing" duration
            t_llll *this_tuplet = (tuplets_elem) ? hatom_getllll(&tuplets_elem->l_hatom) : NULL; t_rational ratio_multiplier; // N.B.: ratio_multiplier is *not* the tuplet ->tuplet_group_ratio_multiplier, but just a tool for multiplying 1/8 and having 1/12. It's the ratio.
            char tuplet = false;
            long rhythm_elem_sign;
            t_rational rhythm_elem_rat_abs;
            if (tuplets_elem && (hatom_getlong(&this_tuplet->l_head->l_next->l_next->l_hatom) > 0)) { //tuplet!
                t_rational tuplet_group_unit = hatom_getrational(&this_tuplet->l_head->l_next->l_next->l_next->l_next->l_hatom);
                t_rational tuplet_group_unit_figure = hatom_getrational(&this_tuplet->l_head->l_next->l_hatom);
                tuplet = true;
                rhythm_elem_rat = rat_rat_prod(rat_rat_div(hatom_getrational(&rhythm_elem->l_hatom), tuplet_group_unit), tuplet_group_unit_figure);
                ratio_multiplier = rat_rat_div(hatom_getrational(&rhythm_elem->l_hatom), rhythm_elem_rat);
            } else {
                rhythm_elem_rat = hatom_getrational(&rhythm_elem->l_hatom);
                ratio_multiplier = long2rat(1);
            }
            rhythm_elem_sign = (rhythm_elem_rat.r_num > 0) ? 1 : ((rhythm_elem_rat.r_num == 0) ? 0 : -1);
            rhythm_elem_rat_abs = rat_abs(rhythm_elem_rat);
            
            if ((rhythm_elem_rat_abs.r_num == 0) || (perfect_log2(rhythm_elem_rat_abs.r_num) >= 0)) { // numerator is 0,1,2,4,8...
                // nothing to do, just copy
                llll_appendrat(*new_rhythm, rat_rat_prod(rhythm_elem_rat, ratio_multiplier), 0, WHITENULL_llll);
                if (infos_elem) llll_appendhatom_clone(*new_infos, &infos_elem->l_hatom, 0, WHITENULL_llll);
                if (ties_elem) llll_appendhatom_clone(*new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
                if (tuplets_elem) llll_appendhatom_clone(*tuplets, &tuplets_elem->l_hatom, 0, WHITENULL_llll);
                cursor = rat_rat_sum(cursor, rat_rat_prod(rhythm_elem_rat_abs, ratio_multiplier));
            } else {
            
                t_llll *drawablellll = get_duration_drawable(rhythm_elem_rat_abs, cursor, box_length, max_dots, 1, tuplet);
                t_llllelem *elem;
//                char debug1[1000], debug2[1000];
//                llll_to_char_array(drawablellll, debug1, 990);
                llll_flatten(drawablellll, 0, 0);
//                while (drawablellll->l_depth > 1) llll_flat(drawablellll, 1, 1, 0);
//                llll_to_char_array(drawablellll, debug2, 990);
                
                // we filter the zeros (and the negatives, which - in turn - should never appear)
                llll_filter_zeros_and_negatives(drawablellll);
                
                // we try to gather things
                llll_gather_if_drawable(drawablellll, max_dots);

                // refilling elements
                for (elem = drawablellll->l_head; elem; elem = elem->l_next) {
                    t_rational aux_elem_rat = rat_long_prod(hatom_getrational(&elem->l_hatom), rhythm_elem_sign);
                    llll_appendrat(*new_rhythm, rat_rat_prod(aux_elem_rat, ratio_multiplier), 0, WHITENULL_llll);
                    if (infos_elem) llll_appendhatom_clone(*new_infos, &infos_elem->l_hatom, 0, WHITENULL_llll);
                    if (ties_elem) {
                        if (elem == drawablellll->l_tail) 
                            llll_appendhatom_clone(*new_ties, &ties_elem->l_hatom, 0, WHITENULL_llll);
                        else
                            llll_appendlong(*new_ties, 1, 0, WHITENULL_llll);
                    }
                    if (tuplets_elem) llll_appendhatom_clone(*tuplets, &tuplets_elem->l_hatom, 0, WHITENULL_llll);
                }
                // we get rid of the drawablellll
                if (garbage) { // garbage collection?
                    llll_appendllll(garbage, drawablellll, 0, WHITENULL_llll);
                } else {
                    llll_free(drawablellll);
                }
                
                cursor = rat_rat_sum(cursor, rat_rat_prod(rhythm_elem_rat_abs, ratio_multiplier));
                
            }
            
            if (infos_elem) infos_elem = infos_elem->l_next;
            if (ties_elem) ties_elem = ties_elem->l_next;
            if (tuplets_elem) tuplets_elem = tuplets_elem->l_next;
        }

        if (garbage) { // garbage collection?
            llll_appendllll(garbage, rhythm_rests_merged_tuplets_checked, 0, WHITENULL_llll);
            llll_appendllll(garbage, infos_rests_merged_tuplets_checked, 0, WHITENULL_llll);
            llll_appendllll(garbage, ties_rests_merged_tuplets_checked, 0, WHITENULL_llll);
            llll_appendllll(garbage, tuplets_raw, 0, WHITENULL_llll);
        } else {
            // freeing objects!
            llll_free(rhythm_rests_merged_tuplets_checked);
            llll_free(infos_rests_merged_tuplets_checked);
            llll_free(ties_rests_merged_tuplets_checked);
            llll_free(tuplets_raw);
        }
    } else {
        *new_rhythm = llll_get(); 
        *new_infos = llll_get(); 
        *new_ties = llll_get(); 
        *tuplets = llll_get();
    }
}


int get_middle_scaleposition(int clef) {
    switch (clef) { // if clef is a combination of clefs, the chord will cross the staves
        case k_CLEF_FFGG: return 0;
        case k_CLEF_FFG: return -8; 
        case k_CLEF_FGG: return 8; 
        case k_CLEF_FF: return -13; 
        case k_CLEF_FG: return 0; 
        case k_CLEF_GG: return 13; 
        case k_CLEF_PERCUSSION: case k_CLEF_NONE: case k_CLEF_WRONG: return 4 - k_CLEF_G; 
        default: return (4 - clef);  // single clef 
    }
}

double round_to_semiinteger(double stem_x) {
//    double y = round(stem_x - 0.1) + 0.5; // was: - 0.2 ) + 0.5
    double y = round(stem_x - 0.5) + 0.5; // was: - 0.2 ) + 0.5
    return y;
}

double get_lyrics_word_extension_y_pos(t_notation_obj *r_ob, double staff_bottom){
    return staff_bottom - (r_ob->lyrics_uy_pos - CONST_WORD_EXTENSIONS_UY_SHIFT) * r_ob->zoom_y;
}

void set_textfield_info_to_lyrics_slot(t_notation_obj *r_ob, char *text)
{
    t_llll *new_text_as_llll = llll_get();
    llll_appendsym(new_text_as_llll, text ? gensym(text) : gensym(""), 0, WHITENULL_llll);
    note_change_slot_item(r_ob, r_ob->is_editing_chord->firstnote, r_ob->link_lyrics_to_slot - 1, 1, new_text_as_llll);
    llll_free(new_text_as_llll);
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        r_ob->is_editing_chord->need_recompute_parameters = true;
    else
        recompute_all_for_measure(r_ob, r_ob->is_editing_chord->parent, false);
}

void set_textfield_info_to_dynamics_slot(t_notation_obj *r_ob, char *text)
{
    t_notation_item *nitem = notation_item_get_to_which_dynamics_should_be_assigned(r_ob, (t_notation_item *)r_ob->is_editing_chord);
    if (text && strlen(text) > 0) {
        t_llll *new_text_as_llll = llll_get();
        llll_appendsym(new_text_as_llll, text ? gensym(text) : gensym(""), 0, WHITENULL_llll);
        lock_general_mutex(r_ob);
        notation_item_change_slotitem(r_ob, nitem, r_ob->link_dynamics_to_slot - 1, 1, new_text_as_llll);
        llll_free(new_text_as_llll);
    } else {
        lock_general_mutex(r_ob);
        chord_delete_dynamics(r_ob, r_ob->is_editing_chord, true);
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        r_ob->is_editing_chord->need_recompute_parameters = true;
    else
        recompute_all_for_measure(r_ob, r_ob->is_editing_chord->parent, false);
    unlock_general_mutex(r_ob);
}



char delete_chord_lyrics(t_notation_obj *r_ob, t_chord *chord)
{
    t_note *note;
    
    if (notation_item_is_selected(r_ob, (t_notation_item *)chord->lyrics))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)chord->lyrics);

    for (note = chord->firstnote; note; note = note->next)
        note_clear_slot(r_ob, note, r_ob->link_lyrics_to_slot - 1);
    
    if (chord->lyrics) {
        chord->lyrics->lyrics_dashed_extension = chord->lyrics->lyrics_uheight = chord->lyrics->lyrics_uwidth = chord->lyrics->lyrics_ux_shift = 0;
    }
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        chord->need_recompute_parameters = true;
    else
        recompute_all_for_measure(r_ob, chord->parent, false);
    
    return (chord->lyrics && chord->lyrics->label ? 1 : 0);
}

// assigns the chord lyrics starting from the slot content
void assign_chord_lyrics(t_notation_obj *r_ob, t_chord *chord, t_jfont *jf_lyrics_nozoom)
{
    
    if (!chord->lyrics)
        return;    // should NEVER happen
        
    if (chord->lyrics->label) {
        bach_freeptr(chord->lyrics->label);
        chord->lyrics->label = NULL;
    }
    chord->lyrics->lyrics_dashed_extension = false;
    
    long slotnum = r_ob->link_lyrics_to_slot - 1;
    if (slotnum >= 0 && slotnum < CONST_MAX_SLOTS && r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_TEXT){
        t_note *nt;
        t_slot *slot = NULL;
        if (!chord->firstnote) {
            slot = notation_item_get_slot(r_ob, (t_notation_item *)chord, slotnum);
        } else {
            for (nt = chord->firstnote; nt; nt = nt->next) {
                if (nt->slot[slotnum].firstitem) {
                    slot = notation_item_get_slot(r_ob, (t_notation_item *)nt, slotnum);
                }
            }
        }
        
        if (slot && slot->firstitem) {
            char *text = (char *)slot->firstitem->item;
            char len = strlen(text);
            double width, height;
            char *text_ok = (char *)bach_newptr((len + 1) * sizeof(char));
            
            strncpy(text_ok, text, len + 1);
            
            // last char is a - ?
            if (len >= 1 && text_ok[len-1] == '-') {
                chord->lyrics->lyrics_dashed_extension = 1;
                text_ok[len-1] = 0;
            }
            
            chord->lyrics->label = text_ok;
            
            jfont_text_measure(jf_lyrics_nozoom, text_ok, &width, &height);
            
            chord->lyrics->lyrics_uwidth = width;
            chord->lyrics->lyrics_uheight = height;
            
            if (r_ob->lyrics_alignment == 2 || r_ob->lyrics_alignment == 0) // center or smart // TO DO: smart has to be perfected
                chord->lyrics->lyrics_ux_shift = - width/2.;
            else if (r_ob->lyrics_alignment == 3) // right
                chord->lyrics->lyrics_ux_shift = - width;
            else
                chord->lyrics->lyrics_ux_shift = 0;
        }
    }
}


char chord_delete_dynamics(t_notation_obj *r_ob, t_chord *chord, char add_undo_tick)
{
    t_note *note;
    char res = chord_has_dynamics(chord);
    long slot_num = r_ob->link_dynamics_to_slot - 1;
    t_dynamics *dyn = chord_get_dynamics(chord);
    char undo_tick_added = false;
    
    if (dyn && notation_item_is_selected(r_ob, (t_notation_item *)dyn))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)dyn);

    
    if (chord->firstnote) {
        for (note = chord->firstnote; note; note = note->next) {
            if (notation_item_get_slot_firstitem(r_ob, (t_notation_item *)note, slot_num)) {
                if (add_undo_tick && !undo_tick_added) {
                    undo_tick_added = true;
                    create_simple_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_UNDO_MODIFICATION_CHANGE);
                }
            }
            note_clear_slot(r_ob, note, slot_num);
        }
    } else {
        if (add_undo_tick)
            create_simple_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_UNDO_MODIFICATION_CHANGE);
        notation_item_clear_slot(r_ob, (t_notation_item *)chord, slot_num);
    }
    
    chord->dynamics_slot = NULL;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        chord->need_recompute_parameters = true;
    else
        recompute_all_for_measure(r_ob, chord->parent, false);
    
    return res;
}

// assigns the chord dynamics starting from the slot content
void chord_assign_dynamics(t_notation_obj *r_ob, t_chord *chord, t_jfont *jf_dynamics_nozoom, t_jfont *jf_dynamics_roman_nozoom)
{

    chord->dynamics_slot = NULL;
    
//    long slotnum = r_ob->link_dynamics_to_slot - 1;
//    if (slotnum >= 0 && slotnum < CONST_MAX_SLOTS && r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_DYNAMICS){

    for (long slotnum = 0; slotnum < CONST_MAX_SLOTS; slotnum ++) {
        if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_DYNAMICS) {
            t_notation_item *item = notation_item_get_bearing_dynamics(r_ob, (t_notation_item *)chord, slotnum);
            t_slotitem *firstitem = notation_item_get_slot_firstitem(r_ob, item, slotnum);
            if (firstitem && firstitem->item){
                t_dynamics *dyn = (t_dynamics *)firstitem->item;
                if (slotnum == r_ob->link_dynamics_to_slot - 1)
                    chord->dynamics_slot = notation_item_get_slot(r_ob, item, slotnum);
                
                if (jf_dynamics_nozoom && jf_dynamics_roman_nozoom) {
                    double w = 0, h = 0, firstw = 0, firsth = 0;
                    if (dyn->firstmark) {
                        if (dyn->firstmark->num_words > 0) {
                            dynamics_mark_measure(dyn->firstmark, jf_dynamics_nozoom, jf_dynamics_roman_nozoom, &w, &h);
                            if (dyn->firstmark->is_roman[0]) {
                                dyn->dynamics_left_uext = CONST_UX_NUDGE_LEFT_FOR_FIRST_ROMAN_WORD * r_ob->zoom_y;
                                dyn->dynamics_min_uwidth = w;
                                dyn->dynamics_right_uext = w - dyn->dynamics_left_uext;
                            } else {
                                jfont_text_measure(jf_dynamics_nozoom, dyn->firstmark->text_typographic[0]->s_name, &firstw, &firsth);
                                dyn->dynamics_left_uext = firstw/2.;
                                dyn->dynamics_min_uwidth = w;
                                dyn->dynamics_right_uext = firstw/2. + (w - firstw);
                            }
                        } else {
                            dyn->dynamics_left_uext = 0;
                            dyn->dynamics_min_uwidth = 0;
                            dyn->dynamics_right_uext = 0;
                        }
                        
                        for (t_dynamics_mark *dynsign = dyn->firstmark->next; dynsign; dynsign = dynsign->next) {
                            dynamics_mark_measure(dynsign, jf_dynamics_nozoom, jf_dynamics_roman_nozoom, &w, &h);
                            dyn->dynamics_min_uwidth += CONST_MIN_UWIDTH_BETWEEN_DYNAMICS + w;
                            if (!dynsign->next) {
                                if (dynsign->num_words > 0) {
                                    if (dynsign->is_roman[0]) {
                                        dyn->dynamics_right_uext = w - CONST_UX_NUDGE_LEFT_FOR_FIRST_ROMAN_WORD * r_ob->zoom_y;
                                    } else {
                                        jfont_text_measure(jf_dynamics_nozoom, dynsign->text_typographic[0]->s_name, &firstw, &firsth);
                                        dyn->dynamics_right_uext = w - firstw/2.;
                                    }
                                } else {
                                    dyn->dynamics_right_uext = 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



double velocity_to_notesize_factor(long velocity)
{
    return rescale_with_slope(velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY, 0.4, 1., 0);
}

// also calculate note size from velocity_handling, if needed
void calculate_note_sizes_from_slots(t_notation_obj *r_ob, t_note *note){
    if (r_ob->link_notesize_to_slot > 0){
        if (r_ob->slotinfo[r_ob->link_notesize_to_slot - 1].slot_type == k_SLOT_TYPE_INT && note->slot[r_ob->link_notesize_to_slot - 1].firstitem){
            note->notehead_resize = note->accidentals_resize = *((long *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->item)/100.;
        } else if (r_ob->slotinfo[r_ob->link_notesize_to_slot - 1].slot_type == k_SLOT_TYPE_FLOAT && note->slot[r_ob->link_notesize_to_slot - 1].firstitem){
            note->notehead_resize = note->accidentals_resize = *((double *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->item)/100.;
        } else if (r_ob->slotinfo[r_ob->link_notesize_to_slot - 1].slot_type == k_SLOT_TYPE_INTLIST && note->slot[r_ob->link_notesize_to_slot - 1].firstitem){
            note->notehead_resize = *((long *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->item)/100.;
            if (note->slot[r_ob->link_notesize_to_slot - 1].firstitem->next)
                note->accidentals_resize = *((long *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->next->item) / 100.;
            else
                note->accidentals_resize = 1.;
        } else if (r_ob->slotinfo[r_ob->link_notesize_to_slot - 1].slot_type == k_SLOT_TYPE_FLOATLIST && note->slot[r_ob->link_notesize_to_slot - 1].firstitem){
            note->notehead_resize = *((double *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->item)/100.;
            if (note->slot[r_ob->link_notesize_to_slot - 1].firstitem->next)
                note->accidentals_resize = *((double *)note->slot[r_ob->link_notesize_to_slot - 1].firstitem->next->item) / 100.;
            else
                note->accidentals_resize = 1.;
        } else {
            note->notehead_resize = note->accidentals_resize = 1.;
        }
    } else {
        note->notehead_resize = note->accidentals_resize = 1.;
    }
    
    if (r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE) {
        double factor = velocity_to_notesize_factor(note->velocity);
        note->accidentals_resize *= factor;
        note->notehead_resize *= factor;
    }
}

void calculate_chord_parameters(t_notation_obj *r_ob, t_chord *chord, int clef, char reset_graphical_position_values) {
// calculates all the parameters of a chord (such as notehead positions, accidental positions, width...) in order to simplify the drawing process 
// direction = 0: auto; 1: upwards, -1: downwards; 
// clef: a clef indicated by its MiddleC scaleposition with respect to the first staff line (e.g.: Gclef = -2, Fclef = 10, SopranoClef = 0, and so on)   
//         standard clef combinations are also possible (see the constants in the header)

    if (!(chord->is_score_chord && rat_long_cmp(chord->r_sym_duration, 0) == -1) && chord->num_notes > 0) { // it's NOT a rest!
        t_voice *voice = r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *) chord->voiceparent : (t_voice *) chord->parent->voiceparent;
        
        double staff_top_y = get_staff_top_y(r_ob, voice, false);
        double staff_bottom_y = get_staff_bottom_y(r_ob, voice, false);

        int scalepos_extension, middle_scaleposition;
        double *left_limit;    

        long *midicents;
        char *show_accidental;
        t_rational *accidental;
        long num_notes = chord->num_notes;
        // building arrays of midicents and accidentals:
        long i, j; 
        long proxy_count;
        char in_group;
        t_note *curr_nt;
        long *scaleposition, *proxygroup_start, *proxygroup_end, *noteheads_stempos;
        double *note_x, *note_x_real, this_stem_x;
        long this_direction; // real direction; will be filled up later
        long scalepositionsum = 0; 
        double left_uext = 0.; double right_uext = 0.; // left and right space (with respect to the chord stem) needed to paint the chord.
        long start_scalepos, rel_scalepos;
        long num_accidentals = 0;
        t_rational *accidental_copy;
        char *accidental_done;
        double *accidental_x_real;
        double *accidental_width;
        int *note_num_accidentals;
        unsigned short **accidental_text;
        long mem_i;
        long min_scaleposition, max_scaleposition;
        char is_ok = false, has_been_reordered = false;
        long *reordered;
        double *noteheads_uwidths;
        char *note_need_aux_stem;
        double *notehead_leftlim, *notehead_rightlim, *note_acc_resize, *note_head_resize, *notehead_ux_shift;
        
        if (num_notes <= 0) {
            object_error((t_object *) r_ob, "There's a chord with no notes!");
            return;
        }

        midicents = (long *) bach_newptr(num_notes * sizeof(long));
        show_accidental = (char *) bach_newptr(num_notes * sizeof(char));
        accidental = (t_rational *) bach_newptr(num_notes * sizeof(t_rational));
        reordered = (long *) bach_newptr(num_notes * sizeof(long));
        noteheads_uwidths = (double *) bach_newptr(num_notes * sizeof(double)); // uwidth of each notehead
        note_acc_resize = (double *) bach_newptr(num_notes * sizeof(double)); // resize factor for the accidental of each note
        note_head_resize = (double *) bach_newptr(num_notes * sizeof(double)); // resize factor for the notehead of each note
        notehead_ux_shift = (double *) bach_newptr(num_notes * sizeof(double)); // horizontal shift of the notehead note

        check_notes_order(chord);
        
        curr_nt = chord->firstnote; 
        i = 0;  
        
        while (curr_nt && i < num_notes) {
            // let's compute all the approximations, if needed
            if (!chord->is_score_chord) 
                note_compute_approximation(r_ob, curr_nt); // for score chords we already do that!!

            // deciding the notehead and accidentals size
            calculate_note_sizes_from_slots(r_ob, curr_nt);
            note_acc_resize[i] = curr_nt->accidentals_resize;
            note_head_resize[i] = curr_nt->notehead_resize;
            
            notehead_ux_shift[i] = get_notehead_ux_shift(r_ob, curr_nt);
            
            noteheads_uwidths[i] = curr_nt->notehead_resize * notehead_get_uwidth(r_ob, chord->is_score_chord ? chord->figure : RAT_1OVER4, curr_nt, false);
            curr_nt->notehead_uwidth = noteheads_uwidths[i];
            curr_nt->notehead_ID = get_notehead_specs_from_note(r_ob, curr_nt, NULL, NULL, NULL, NULL, NULL, NULL, NULL, false);
            
            midicents[i] = note_get_screen_midicents(curr_nt);
            accidental[i] = note_get_screen_accidental(curr_nt);
            reordered[i] = i; // default mapping
            
            // deciding whether to show the accidental
            if (chord->is_score_chord) // score
                show_accidental[i] = curr_nt->show_accidental;
            else { // roll (we calculate the show/hide here!)
                t_voice *voice = (t_voice *)chord->voiceparent;
                if (voice->key == 0)
                    show_accidental[i] = (note_get_screen_accidental(curr_nt).r_num == 0) ? false : true;
                else {
                    long ds = midicents2diatonicstep(note_get_screen_midicents(curr_nt));
                    if (ds >= 0 && rat_rat_cmp(voice->acc_pattern[ds], note_get_screen_accidental(curr_nt)) == 0)
                        show_accidental[i] = false;
                    else
                        show_accidental[i] = true;
                }

                switch (r_ob->show_accidentals_preferences) {
                    case k_SHOW_ACC_CLASSICAL:
                    case k_SHOW_ACC_ALLALTERED_NONATURALS:
                        curr_nt->show_accidental = show_accidental[i];
                        break;
                        
                    case k_SHOW_ACC_ALL:
                        curr_nt->show_accidental = true;
                        break;

                    case k_SHOW_ACC_NONE:
                        curr_nt->show_accidental = false;
                        break;

                    case k_SHOW_ACC_ALLALTERED:
                    {
                        if (show_accidental[i])
                            curr_nt->show_accidental = true;
                        else {
                            curr_nt->show_accidental = false;
                            
                            // we look for a previous chord having the same note but "accidentalized"
                            t_note *temp_nt;
                            t_chord *temp_ch;
                            for (temp_ch = chord->prev; temp_ch; temp_ch = temp_ch->prev) {
                                if (r_ob->accidentals_decay_threshold_ms > 0 && chord->onset - temp_ch->onset > r_ob->accidentals_decay_threshold_ms) {
                                    break;
                                }
                                char must_break = false;
                                for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next) {
                                    if (note_get_screen_midicents(temp_nt) == note_get_screen_midicents(curr_nt)) {
                                        if (note_get_screen_accidental(temp_nt).r_num != 0)
                                            curr_nt->show_accidental = true;
                                        must_break = true;
                                        break;
                                    }
                                }
                                if (must_break) break;
                            }
                        }
                    }
                        break;
                        
                    case k_SHOW_ACC_ALLALTERED_NOREPETITION:
                    {
                        if (show_accidental[i]) {
                            curr_nt->show_accidental = true;

                            // we look for a previous chord having the same note with the same "accidental"
                            t_note *temp_nt;
                            t_chord *temp_ch;
                            for (temp_ch = chord->prev; temp_ch; temp_ch = temp_ch->prev) {
                                if (r_ob->accidentals_decay_threshold_ms > 0 && chord->onset - temp_ch->onset > r_ob->accidentals_decay_threshold_ms) {
                                    break;
                                }
                                char must_break = false;
                                for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next) {
                                    if (note_get_screen_midicents(temp_nt) == note_get_screen_midicents(curr_nt)) {
                                        if (rat_rat_cmp(note_get_screen_accidental(temp_nt), note_get_screen_accidental(curr_nt)) == 0)
                                            curr_nt->show_accidental = false;
                                        must_break = true;
                                        break;
                                    }
                                }
                                if (must_break) break;
                            }
                        } else {
                            curr_nt->show_accidental = false;
                            
                            // we look for a previous chord having the same note but "accidentalized"
                            t_note *temp_nt;
                            t_chord *temp_ch;
                            for (temp_ch = chord->prev; temp_ch; temp_ch = temp_ch->prev) {
                                if (r_ob->accidentals_decay_threshold_ms > 0 && chord->onset - temp_ch->onset > r_ob->accidentals_decay_threshold_ms) {
                                    break;
                                }
                                char must_break = false;
                                for (temp_nt = temp_ch->firstnote; temp_nt; temp_nt = temp_nt->next) {
                                    if (note_get_screen_midicents(temp_nt) == note_get_screen_midicents(curr_nt)) {
                                        if (note_get_screen_accidental(temp_nt).r_num != 0)
                                            curr_nt->show_accidental = true;
                                        must_break = true;
                                        break;
                                    }
                                }
                                if (must_break) break;
                            }
                        }
                    }
                        break;

                    default:
                        break;
                }
                
                show_accidental[i] = curr_nt->show_accidental;
            }
            
            i++;
            curr_nt = curr_nt->next;
        }
        
        if (i != num_notes) 
            object_warn((t_object *)r_ob, "Warning: less or more notes than expected.");

        // re-ordering the arrays, in case the ordering by midicents does not correspond to the graphical order of notes 
        // (e.g. a chord with D# and Ebb)
        is_ok = false;
        while (!is_ok) {
            is_ok = true;
            for (i = 0; i < num_notes - 1; i++)
                if (midicents[i] > midicents[i+1]){ //midicents[0] midicents[1]
                    // wrong sequence!
                    long temp; 
                    t_rational temp2; 
                    char temp3;
                    double temp4;
                    
                    has_been_reordered = true;
                    
                    temp = midicents[i];
                    midicents[i] = midicents[i+1];
                    midicents[i+1] = temp;
                    
                    temp2 = accidental[i];
                    accidental[i] = accidental[i+1];
                    accidental[i+1] = temp2;

                    temp3 = show_accidental[i];
                    show_accidental[i] = show_accidental[i+1];
                    show_accidental[i+1] = temp3;

                    temp4 = noteheads_uwidths[i];
                    noteheads_uwidths[i] = noteheads_uwidths[i+1];
                    noteheads_uwidths[i+1] = temp4;
                    
                    temp4 = note_acc_resize[i];
                    note_acc_resize[i] = note_acc_resize[i+1];
                    note_acc_resize[i+1] = temp4;

                    temp4 = note_head_resize[i];
                    note_head_resize[i] = note_head_resize[i+1];
                    note_head_resize[i+1] = temp4;

                    temp4 = notehead_ux_shift[i];
                    notehead_ux_shift[i] = notehead_ux_shift[i+1];
                    notehead_ux_shift[i+1] = temp4;
                    
                    temp = reordered[i];
                    reordered[i] = reordered[i+1];
                    reordered[i+1] = temp;
                    
                    is_ok = false;
                    break;
                }
        }
        
        // used variables
        
        // Dummy position of the stem:
        // We used to use this first line below, but it makes no sense, since we only need a dummy position, relative to which all
        // other items will be computed. Only differences will be taken into account. Hence, we set this to 1000 (must be probably > 0?)
        // Not sure.
        //        this_stem_x = (CONST_ROLL_UX_LEFT_START + (onset - r_ob->screen_ms_start) * CONST_X_SCALING * r_ob->zoom_x) + r_ob->j_inset_x;
        this_stem_x = 1000;
        
        
        scaleposition = (long *) bach_newptr(num_notes * sizeof(long)); // scaleposition of each note (numbering referred to the display position: C3=0, D3=1 and so on)
        note_x = (double *) bach_newptr(num_notes * sizeof(double)); // *unscaled* x relative to the note (so there's a constant to handle the fact that we have to translate the note)
        note_x_real = (double *) bach_newptr(num_notes * sizeof(double)); // *unscaled* x of the displayed position of the (barycenter of the) notehead! (no constant, precise x value)
        proxygroup_start = (long *) bach_newptr(num_notes * sizeof(long));
        proxygroup_end = (long *) bach_newptr(num_notes * sizeof(long));
        noteheads_stempos = (long *) bach_newptr(num_notes * sizeof(long)); // position of each notehead with respect to the stem: 0 = stem default, +1 = shift right (if stem is down) or left (if stem is up); -1 shift oppositely... 
        note_need_aux_stem = (char *) bach_newptr(num_notes * sizeof(char)); // does each note need an aux stem?


        // finding scale-positions (= numbering referred to the display position, C3=0, D3=1, E3=2, F3=4 and so on)
        min_scaleposition = -32500; // just weird 
        max_scaleposition = -32500;
        for (scalepositionsum = 0, i = 0; i < num_notes; i++){
            scaleposition[i] = midicents_to_diatsteps_from_middleC(r_ob, midicents[i]);
            if (min_scaleposition == -32500 || scaleposition[i] < min_scaleposition)
                min_scaleposition = scaleposition[i];
            if (max_scaleposition == -32500 || scaleposition[i] > max_scaleposition)
                max_scaleposition = scaleposition[i];
            scalepositionsum += scaleposition[i];
        }

        scalepos_extension = max_scaleposition - min_scaleposition + 1; 
        if (scalepos_extension <= 0 || scalepos_extension > 200) 
            scalepos_extension = 1;
        left_limit = (double *) bach_newptr(scalepos_extension * 10 * sizeof(double)); // keep track (at the end) of the left start on each line/space, in order to put accidentals later on 
                                                                                         // 10 is the refinement value, very very useful: it's just like if we divided every position into 10 subpositions
                                                                                         // as 0. 0.1 0.2 ... 0.9 1. 1.1 ... 

        notehead_leftlim = (double *) bach_newptr(scalepos_extension * sizeof(double)); // keep track (at the end) of the left limit of noteheads for each step position
        notehead_rightlim = (double *) bach_newptr(scalepos_extension * sizeof(double)); // keep track (at the end) of the right limit of noteheads for each step position

        
        // finding automatic direction of the chord; depending on the barycenter of scaleposition
        middle_scaleposition = get_middle_scaleposition(clef); //this is m_y in the function documentation
        
        if (chord->is_score_chord) {
            if (chord->imposed_direction != 0)
                this_direction = chord->imposed_direction > 0 ? 1 : -1; // we keep the chosen direction
            else if (voiceensemble_get_numparts(r_ob, voice) > 1)
                this_direction = voice->part_index % 2 == 0 ? 1 : -1;
            else // automatic direction chosen
                this_direction = ((((double)scalepositionsum)/num_notes) >= middle_scaleposition ? -1 : 1);
        } else {
            if (chord->imposed_direction != 0) // automatic direction chosen
                this_direction = chord->imposed_direction > 0 ? 1 : -1; // we keep the chosen direction
            else if (voiceensemble_get_numparts(r_ob, voice) > 1)
                this_direction = voice->part_index % 2 == 0 ? 1 : -1;
            else
                this_direction = ((((double)scalepositionsum)/num_notes) >= middle_scaleposition ? -1 : 1);
        }
        
//        dev_post("chord direction: %d", this_direction);
        
        // finding proximity groups (= groups where notes are near, so they are to be put one left and one right with respect to the stem
        // this might obviously be worse, with unisons, etc. However, proximities groups are groups of notes which (among them) have always
        // "visual jumps" of less than the distance between two staff lines (e.g.: {C3 D3 D3 E3} but NOT {C3 E3}) 
        for (proxy_count = 0, in_group = false, i = 0; i < num_notes && proxy_count < num_notes; i++) {
            if (i < num_notes - 1 && scaleposition[i+1] <= scaleposition[i] + 1) { // proximity with the next note!
                if (in_group) { // we're already in a proxygroup: we just continue
                } else { // we're not in a proxygroup: a proxygroup starts!
                    proxygroup_start[proxy_count] = i;
                    in_group = true;
                }
            } else { // no proximity with the next note
                if (in_group) { // we were in a group. We stop the group
                    proxygroup_end[proxy_count] = i;
                    in_group = false;
                    proxy_count++;
                } else { // we weren't in any group. Nothing to do.
                    ;
                }
            }
        }

        // setting noteheads left and right lims
        for (i = 0; i < scalepos_extension; i++)
            notehead_rightlim[i] = notehead_leftlim[i] = this_stem_x;
        
        // reset all notes position to the default position
        for (i = 0; i < num_notes; i++) {
            noteheads_stempos[i] = 0;
            // setting note_ux values and updating noteheads left and right lims
            if (this_direction == 1) { // stem upwards
                note_x[i] = this_stem_x - noteheads_uwidths[i];
            } else if (this_direction == -1) { // stem downwards
                note_x[i] = this_stem_x;
            }
        }
            
    //    post("Found: %d proxy groups", proxy_count);
    //    for (i = 0; i < proxy_count; i++)
    //        post("   - Proxy %d: %d to %d", i, proxygroup_start[i], proxygroup_end[i]);

        // for every proximity group, choose the position of the noteheads
        for (i = 0; i < proxy_count && i < num_notes; i++) { //cycle on the proxygroups
            // number of notes in the proxy group
            int num_notes_no_unison;
            int proxy_num_notes = proxygroup_end[i] - proxygroup_start[i] + 1; 
            // defining how many notes there are (not counting unisons)
            long proxy_num_notes_to_use = (proxy_num_notes >= 0 ? proxy_num_notes : 1);
            int *notenum_no_unison = (int *) bach_newptr(proxy_num_notes_to_use * sizeof(int)); // number of note, not counting unison
            long count, jp;
            int prev_stempos, *minlimit, *maxlimit;
            char first_proxygroup_note;
            notenum_no_unison[0]=0;
    //        post("notenum_no_unison[0]: %d", notenum_no_unison[proxygroup_start[i]]);
            for (j = proxygroup_start[i] + 1; j <= proxygroup_end[i]; j++) { //cycle on the notes in the proxygroup
                jp = CLAMP(j - proxygroup_start[i], 1, proxy_num_notes_to_use - 1);
                if (scaleposition[j] == scaleposition[j-1]+1) // 1step proximity (tone/semitone)
                    notenum_no_unison[jp] = notenum_no_unison[jp-1] + 1;
                else // 0step proximity (unison)
                    notenum_no_unison[jp] = notenum_no_unison[jp-1];
    //            post("notenum_no_unison[%d]: %d", jp, notenum_no_unison[jp]);
            }
            num_notes_no_unison = notenum_no_unison[CLAMP(proxygroup_end[i] - proxygroup_start[i], 0, proxy_num_notes_to_use - 1)] + 1;
    //        post("num_notes_no_unison: %d");

            if (num_notes_no_unison <= 0) // just in case
                num_notes_no_unison = 1;
            
            // first, we set all the notes, and NOT the unisons
            // Plus: for each note_no_unison we keep track of the right and left limits (1 line/space below and 1 line/space above)
            minlimit = (int *) bach_newptr(num_notes_no_unison * sizeof(int));
            maxlimit = (int *) bach_newptr(num_notes_no_unison * sizeof(int));
            for (jp = 0; jp < num_notes_no_unison; jp++) {
                minlimit[jp]=0; 
                maxlimit[jp]=0;
            }
            prev_stempos = 0;
            first_proxygroup_note = true;
            for (j = proxygroup_start[i]; j <= proxygroup_end[i]; j++) { //cycle on the notes in the proxygroup
                long notenum_no_unison_jp;
                jp = j - proxygroup_start[i];
                notenum_no_unison_jp = CLAMP(notenum_no_unison[CLAMP(jp, 0, proxy_num_notes_to_use - 1)], 0, num_notes_no_unison - 1);
                if (first_proxygroup_note || (j > 0 && scaleposition[j] == scaleposition[j-1] + 1)) { // 1step proxymity (tone/semitone)
                    long rel_scaleposition = CLAMP(scaleposition[j] - min_scaleposition, 0, scalepos_extension - 1);

                    if (first_proxygroup_note) { // first_note in proxygroup
                        noteheads_stempos[j] = 0;
                        prev_stempos = 0;
                        first_proxygroup_note = false;
                    } else if (prev_stempos == 0) { // previous notehead at the default position (surely no unisons on the previous line/space)
                        noteheads_stempos[j] = -1;
                        prev_stempos = noteheads_stempos[j];
                        minlimit[notenum_no_unison_jp] = MIN(minlimit[notenum_no_unison_jp], noteheads_stempos[j]);
                        if (notenum_no_unison_jp - 1 >= 0)
                            minlimit[notenum_no_unison_jp - 1] = MIN(minlimit[notenum_no_unison_jp - 1], noteheads_stempos[j]);
                        if (notenum_no_unison_jp + 1 < num_notes_no_unison)
                            minlimit[notenum_no_unison_jp + 1] = MIN(minlimit[notenum_no_unison_jp +1], noteheads_stempos[j]);
                    } else if (prev_stempos > 0) { // previous notehead shifted in "stem direction" (surely some unisons!)
                        noteheads_stempos[j] = 0;
                        prev_stempos = 0;
                    } else { // previous notehead shifted in "counterstem direction" (unisons?)
                        noteheads_stempos[j] = 0;
                        prev_stempos = 0;
                    }

                    // setting note_ux values and updating noteheads left and right lims
                    if (this_direction == 1) { // stem upwards
                        note_x[j] = this_stem_x + (- noteheads_stempos[j] - 1) * noteheads_uwidths[j];
                        notehead_rightlim[rel_scaleposition] = MAX(notehead_rightlim[rel_scaleposition], noteheads_stempos[j] >= 0 ? this_stem_x : note_x[j] + noteheads_uwidths[j]);
                        notehead_leftlim[rel_scaleposition] = MIN(notehead_leftlim[rel_scaleposition], noteheads_stempos[j] >= 0 ? note_x[j] : this_stem_x);
                    } else if (this_direction == -1) { // stem downwards
                        note_x[j] = this_stem_x + noteheads_stempos[j] * noteheads_uwidths[j];
                        notehead_rightlim[rel_scaleposition] = MAX(notehead_rightlim[rel_scaleposition], noteheads_stempos[j] >= 0 ? note_x[j] + noteheads_uwidths[j] : this_stem_x);
                        notehead_leftlim[rel_scaleposition] = MIN(notehead_leftlim[rel_scaleposition], noteheads_stempos[j] >= 0 ? this_stem_x : note_x[j]);
                    }
                    if (rel_scaleposition - 1 >= 0) {
                        notehead_rightlim[rel_scaleposition - 1] = MAX(notehead_rightlim[rel_scaleposition - 1], notehead_rightlim[rel_scaleposition]);
                        notehead_leftlim[rel_scaleposition - 1] = MIN(notehead_leftlim[rel_scaleposition - 1], notehead_leftlim[rel_scaleposition]);
                    }
                    if (rel_scaleposition + 1 < scalepos_extension) {
                        notehead_rightlim[rel_scaleposition + 1] = MAX(notehead_rightlim[rel_scaleposition + 1], notehead_rightlim[rel_scaleposition]);
                        notehead_leftlim[rel_scaleposition + 1] = MIN(notehead_leftlim[rel_scaleposition + 1], notehead_leftlim[rel_scaleposition]);
                    }
                }
            }
            
            
            // then we set all the unisons
            for (count = 0, j = proxygroup_start[i] + 1; j <= proxygroup_end[i]; j++) { //cycle on the notes in the proxygroup
                if (scaleposition[j] == scaleposition[j-1]) { // 0step proxymity (unisons)
                    long rel_scaleposition = CLAMP(scaleposition[j] - min_scaleposition, 0, scalepos_extension - 1), notenum_no_unison_jp;
                    jp = j - proxygroup_start[i];
                    notenum_no_unison_jp = CLAMP(notenum_no_unison[CLAMP(jp, 0, proxy_num_notes_to_use - 1)], 0, num_notes_no_unison - 1);
                    if (minlimit[notenum_no_unison_jp] == 0) { // 
                        noteheads_stempos[j] = -1; // new pos
                        // updating min and max limits
                        minlimit[notenum_no_unison_jp] = MIN(minlimit[notenum_no_unison_jp], noteheads_stempos[j]);
                        if (notenum_no_unison_jp - 1 >= 0)
                            minlimit[notenum_no_unison_jp-1] = MIN(minlimit[notenum_no_unison_jp - 1], noteheads_stempos[j]);
                        if (notenum_no_unison_jp + 1 < num_notes_no_unison)
                            minlimit[notenum_no_unison_jp + 1] = MIN(minlimit[notenum_no_unison_jp + 1], noteheads_stempos[j]);
                    } else if (abs(minlimit[notenum_no_unison_jp]) > (maxlimit[notenum_no_unison_jp])) { // set note towards maxlimit
                        noteheads_stempos[j] = maxlimit[notenum_no_unison_jp] + 1; // new pos
                        // updating min and max limits
                        maxlimit[notenum_no_unison_jp] += 1;
                        if (notenum_no_unison_jp - 1>=0)
                            maxlimit[notenum_no_unison_jp - 1] = MAX(maxlimit[notenum_no_unison_jp - 1], maxlimit[notenum_no_unison_jp]);
                        if (notenum_no_unison_jp + 1<num_notes_no_unison)
                            maxlimit[notenum_no_unison_jp + 1] = MAX(maxlimit[notenum_no_unison_jp + 1], maxlimit[notenum_no_unison_jp]);
                    } else { // set note towards minlimit
                        noteheads_stempos[j] = minlimit[notenum_no_unison_jp] - 1; // new pos
                        // updating min and max limits
                        minlimit[notenum_no_unison_jp] -= 1;
                        if (notenum_no_unison_jp - 1>=0)
                            minlimit[notenum_no_unison_jp - 1] = MIN(minlimit[notenum_no_unison_jp - 1], minlimit[notenum_no_unison_jp]);
                        if (notenum_no_unison_jp + 1<num_notes_no_unison)
                            minlimit[notenum_no_unison_jp + 1] = MIN(minlimit[notenum_no_unison_jp + 1], minlimit[notenum_no_unison_jp]);
                    }
                    
                    // setting note_ux values and updating noteheads left and right lims
                    if (this_direction == 1) { // stem upwards
                        if (noteheads_stempos[j] >= 0) {
                            note_x[j] = notehead_leftlim[rel_scaleposition] - noteheads_uwidths[j];
                            notehead_leftlim[rel_scaleposition] -= noteheads_uwidths[j];
                        } else { 
                            note_x[j] = notehead_rightlim[rel_scaleposition];
                            notehead_rightlim[rel_scaleposition] += noteheads_uwidths[j];
                        }
                    } else if (this_direction == -1) { // stem downwards
                        if (noteheads_stempos[j] >= 0) {
                            note_x[j] = notehead_rightlim[rel_scaleposition];
                            notehead_rightlim[rel_scaleposition] += noteheads_uwidths[j];
                        } else { 
                            note_x[j] = notehead_leftlim[rel_scaleposition] - noteheads_uwidths[j];
                            notehead_leftlim[rel_scaleposition] -= noteheads_uwidths[j];
                        }
                    }
                    if (rel_scaleposition - 1 >= 0) {
                        notehead_rightlim[rel_scaleposition - 1] = MAX(notehead_rightlim[rel_scaleposition - 1], notehead_rightlim[rel_scaleposition]);
                        notehead_leftlim[rel_scaleposition - 1] = MIN(notehead_leftlim[rel_scaleposition - 1], notehead_leftlim[rel_scaleposition]);
                    }
                    if (rel_scaleposition + 1 < scalepos_extension) {
                        notehead_rightlim[rel_scaleposition + 1] = MAX(notehead_rightlim[rel_scaleposition + 1], notehead_rightlim[rel_scaleposition]);
                        notehead_leftlim[rel_scaleposition + 1] = MIN(notehead_leftlim[rel_scaleposition + 1], notehead_leftlim[rel_scaleposition]);
                    }
                }
            } 
            bach_freeptr(notenum_no_unison);
            bach_freeptr(minlimit);
            bach_freeptr(maxlimit);
        }

        // for every proxy group, see if we have to reverse the positions (e.g. Gclef: << G4 A4 >>, stem down: we want the G to be at left and the A at right!)
        for (i = 0; i < proxy_count; i++) {
            if (this_direction == -1 && noteheads_stempos[proxygroup_start[i]] >= 0 && noteheads_stempos[proxygroup_end[i]] < 0) { // wrong slope!
                for (j = proxygroup_start[i]; j <= proxygroup_end[i] && j < num_notes; j++) {
                    // stem is surely down: reverse positions!
                    if (noteheads_stempos[j] >= 0) {
                        note_x[j] = (2 * this_stem_x - note_x[j]) - noteheads_uwidths[j];
                    } else {
                        note_x[j] = (2 * this_stem_x - note_x[j]) - noteheads_uwidths[j];
                    }
                    noteheads_stempos[j] = - noteheads_stempos[j] - 1;
                }
            }
        }

    //    double left_width = 0.; double right_width = 0.;
        
        // compute notes REAL x position, and some utilities
        for (i = 0; i < num_notes; i++){
            note_need_aux_stem[i] = (noteheads_stempos[i] == 0 || noteheads_stempos[i] == -1 ? 0 : 1);
            note_x_real[i] = note_x[i] + (noteheads_uwidths[i] / 2.); // center of the note
            if (note_x_real[i] - this_stem_x > 0) { // note at right
                double delta = note_x[i] + noteheads_uwidths[i] - this_stem_x; 
                if (delta > right_uext)
                    right_uext = delta;
            } else { // note at left
                double delta = this_stem_x - note_x[i]; 
                if (delta > left_uext)
                    left_uext = delta;
            }
        }

    //    post("|------ note_x_real: %f, this_stem_x: %f", note_x_real[0], this_stem_x);

        
        // ***********************************    
        // FIND ACCIDENTALS POSITIONS
        // ***********************************    

        // first: calculate left limits in order to put the accidentals
        // left limits are obtained by each note position the left_limit array has a 10-step sampling
        start_scalepos = scaleposition[0];
        for (i = 0; i < scalepos_extension * 10; i++)
            left_limit[i] = this_stem_x + r_ob->accidentals_typo_preferences.ux_shift;
        
        for (i = 0; i < num_notes; i++){
            // each note affects the left limits
            long min_1, max_1; // minimum and maximum for inputting leftlimit values
            rel_scalepos = scaleposition[i] - start_scalepos;
            if (rel_scalepos == 0) { 
                // this is the first note: it'll affect only the following whole step
                min_1 = round(rel_scalepos * 10);
                max_1 = round((rel_scalepos + note_head_resize[i]) * 10);
            } else {
                min_1 = round((rel_scalepos - note_head_resize[i]) * 10);
                max_1 = round((rel_scalepos + note_head_resize[i]) * 10);
            }
            min_1 = CLAMP(min_1, 0, scalepos_extension * 10 - 1);
            max_1 = CLAMP(max_1, 0, scalepos_extension * 10 - 1);
            
            for (j = min_1; j < max_1; j++)
                left_limit[j] = MIN(left_limit[j], note_x_real[i] - (noteheads_uwidths[i] / 2.) - CONST_UX_ACC_SEPARATION_FROM_NOTE);
            
            if (note_need_aux_stem[i] && (r_ob->show_stems == k_SHOW_STEMS_MAIN_AND_AUXILIARY)) { // we take into account the auxiliary stems
                if (this_direction == 1) { // stem upwards
                    min_1 = rel_scalepos * 10; 
                    max_1 = scalepos_extension * 10;
                } else { // stem downwards
                    min_1 = 0; 
                    max_1 = rel_scalepos * 10;
                }
                for (j = min_1; j < max_1; j++)
                    left_limit[j] = MIN(left_limit[j], note_x_real[i] - CONST_UX_ACC_SEPARATION_FROM_NOTE);
            }
        }

        // find the number of accidentals
        for (i = 0; i < num_notes; i++)
            if (show_accidental[i])
                num_accidentals++;
        
        // copy the array of accidentals, so we can operate with it
        accidental_copy = (t_rational *) bach_newptr(num_notes * sizeof(t_rational));
        accidental_done = (char *) bach_newptr(num_notes * sizeof(char));
        accidental_x_real = (double *) bach_newptr(num_notes * sizeof(double));
        accidental_width = (double *) bach_newptr(num_notes * sizeof(double));
        note_num_accidentals = (int *) bach_newptr(num_notes * sizeof(int));
        accidental_text = (unsigned short **) bach_newptr(num_notes * sizeof(unsigned short *));
        for (mem_i = 0; mem_i < num_notes; mem_i++)
            accidental_text[mem_i] = (unsigned short *) bach_newptr(CONST_MAX_ACCIDENTALS * sizeof (unsigned short));

        for (i = 0; i < num_notes; i++) {
            note_num_accidentals[i] = 0;
            accidental_done[i] = 0;
        }
        for (i = 0; i < num_notes; i++) 
            accidental_copy[i] = accidental[i];

        // iterating on the accidentals to paint
        while (num_accidentals > 0) {
            t_rational this_acc;
            unsigned short acc_text[CONST_MAX_ACCIDENTALS]; 
            double acc_width = 0.;
            double delta;
            double new_left_limit;
            long k_start, k_end;

            // scroll the accidentals, from lower to upper, in order to find the one which would have the highest x_value (i.e. would be nearest to the stem)
            long best_i = -1; 
            double best_x_pos = -10000.; 
            for (j = 0; j < num_notes; j++) {
                
                // we map "strangely" the j to a i, in order to give priority to a "triangle-shaped" accidental chain. So first, we analize i=0, then i= num_notes, then i=1, then i= num_notes-1, and so on
                i = (j % 2 == 0 ? j/2 : (num_notes - (j-1)/2 - 1));

                if (show_accidental[i] && !accidental_done[i]) { // if we show the accidental 

                    long k_start = (scaleposition[i]-start_scalepos)*10 - floor(get_accidental_bottom_uextension(r_ob, accidental_copy[i]) * 10. * r_ob->zoom_y / r_ob->step_y);
                    long k_end = (scaleposition[i]-start_scalepos)*10 + ceil(get_accidental_top_uextension(r_ob, accidental_copy[i]) * 10. * r_ob->zoom_y / r_ob->step_y);
                    long min_in_kstart_kend = array_fmin(scalepos_extension*10, k_start - 2, k_end + 2, left_limit);  // 2 (= 2/10 of r_ob->step) is a good threshold for avoiding vertical contacts
                    // the min_in_kstart_kend now contains the minimum position where the accidentals might be painted
                    
                    if (best_x_pos == -10000 || (min_in_kstart_kend > best_x_pos)) {
                        best_i = i; // keep track of the best found index
                        best_x_pos = min_in_kstart_kend;
                    }
                }
            }

            if (best_i == -1) {
                object_warn((t_object *)r_ob, "Warning: error in chord drawing");
                break; // error: this should never happen (only if num_accidentals == 0, but then we would be outside this loop)
            }
            
            // find the best_i accidental string, and, at the same time, determine the width of the accidental
            this_acc = accidental_copy[best_i];
            for (j = 0; j < CONST_MAX_ACCIDENTALS; j++) 
                acc_text[j]=0;
            j = 0;
            if (this_acc.r_num ==0) {
                acc_text[j] = get_accidental_character(r_ob, this_acc);
                acc_width = get_accidental_uwidth(r_ob, this_acc, false) * note_acc_resize[best_i];
                j = 1;
            } else {
                while (j < CONST_MAX_ACCIDENTALS && this_acc.r_num != 0){
                    acc_text[j] = get_accidental_character(r_ob, this_acc);
                    acc_width += get_accidental_uwidth(r_ob, this_acc, false) * note_acc_resize[best_i];
                    j++;
                    if ((rat_long_cmp(this_acc,1) <= 0) && (rat_long_cmp(this_acc,-1) >= 0))
                        this_acc.r_num = 0;
                    else
                        this_acc = rat_long_sum(this_acc, ((this_acc.r_num * this_acc.r_den > 0) ? -1 : 1));
                } 
            }
            note_num_accidentals[best_i] = j;

            accidental_x_real[best_i] = best_x_pos;
            delta = this_stem_x - (accidental_x_real[best_i] - acc_width); 
            if (delta > left_uext)
                    left_uext = delta;

            for (j = 0; j < CONST_MAX_ACCIDENTALS; j++)
                accidental_text[best_i][j] = acc_text[j];

            accidental_width[best_i] = acc_width;
            
            // updating leftlimits
            new_left_limit = best_x_pos - acc_width - CONST_UX_ACC_SEPARATION_FROM_ACC;

            k_start = (scaleposition[best_i]-start_scalepos)*10 - floor(get_accidental_bottom_uextension(r_ob, accidental_copy[best_i]) * 10. * r_ob->zoom_y / r_ob->step_y);
            k_end = (scaleposition[best_i]-start_scalepos)*10 + ceil(get_accidental_top_uextension(r_ob, accidental_copy[best_i]) * 10. * r_ob->zoom_y / r_ob->step_y);

            for (j = CLAMP(k_start, 0, scalepos_extension * 10 - 1); j <= k_end && j <= scalepos_extension * 10 - 1; j++)
                left_limit[j] = new_left_limit;
                    
            // decrease the number of accidentals to put
            accidental_copy[best_i] = long2rat(0);
            accidental_done[best_i] = true;
            num_accidentals--;
        }

        
        // ***********************************    
        // FILL THE NOTES' MEMBERS
        // ***********************************    
        double ratio = chord->is_grace_chord ? CONST_GRACE_CHORD_SIZE : 1.;
        
        chord->direction = this_direction;
        chord->left_uextension = left_uext * ratio;
        chord->right_uextension = right_uext * ratio;
        chord->lyrics_portion_of_left_uextension = chord->lyrics_portion_of_right_uextension = 0;
        chord->dynamics_portion_of_left_uextension = 0; // chord->dynamics_portion_of_right_uextension = 0;
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)    // for [bach.score], this is handled by the beaming function
            chord->stemtip_stafftop_uy = 0;
        curr_nt = chord->firstnote; 
        i = 0;  

//        dev_post("Analizing chord: %p, num_notes: %ld, curr_nt: %p, next_nt: %p", chord, chord->num_notes, curr_nt, curr_nt ? curr_nt->next : NULL);

        while (curr_nt && i < num_notes) {
            long reordered_i = has_been_reordered ? longarray_findidx(num_notes, i, reordered) : i;
            double note_y;
            
            //        post("note_x_real: %f, this_stem_x: %f", note_x_real[0], this_stem_x);
            curr_nt->notecenter_stem_delta_ux = (note_x_real[reordered_i] - this_stem_x) * ratio;
            curr_nt->need_auxiliary_stem = note_need_aux_stem[reordered_i];
            for (j=0; j<CONST_MAX_ACCIDENTALS; j++)
                curr_nt->accidental_text[j] = accidental_text[reordered_i][j];
            curr_nt->accidental_text[j] = 0; // <accidental_text> is sized CONST_MAX_ACCIDENTALS+1
            curr_nt->num_accidentals = note_num_accidentals[reordered_i];
            curr_nt->accidental_stem_delta_ux = (curr_nt->num_accidentals > 0) ? (accidental_x_real[reordered_i] - this_stem_x) * ratio : this_stem_x;
//            curr_nt->accidental_uwidth = (curr_nt->num_accidentals > 0) ? accidental_width[reordered_i] * ratio : 0;
//            curr_nt->accidental_top_uextension = (curr_nt->num_accidentals > 0) ? get_accidental_top_uextension(r_ob, accidental[reordered_i]) * ratio : 0.;
//            curr_nt->accidental_bottom_uextension = (curr_nt->num_accidentals > 0) ? get_accidental_bottom_uextension(r_ob, accidental[reordered_i]) * ratio : 0.;
//            curr_nt->scaleposition = scaleposition[reordered_i];
            
            note_y = mc_to_yposition(r_ob, note_get_screen_midicents(curr_nt), voice);
            curr_nt->center_stafftop_uy = (note_y - staff_top_y)/r_ob->zoom_y;

            // ogni tanto è sputtanato voice->middleC_y
//            dev_post("voice: %p, v_ob_middleCy: %.2f, note_mc: %.2f, note_y: %.2f, staff_top_y: %.2f, zoom_y: %.2f, center_stafftop_uy: %.2f", 
//                     voice, (double)voice->middleC_y, (double)note_get_screen_midicents(curr_nt), (double)note_y, (double)staff_top_y, r_ob->zoom_y, curr_nt->center_stafftop_uy);

            if (!curr_nt->prev) {
                chord->bottommostnote_stafftop_uy = curr_nt->center_stafftop_uy;
                if (chord->direction == 1) {
                    chord->bottommost_stafftop_uy_noacc = chord->bottommostnote_stafftop_uy + CONST_STEP_UY * ratio;
                    chord->bottommost_stafftop_uy = chord->bottommostnote_stafftop_uy + MAX(CONST_STEP_UY * ratio, note_get_accidental_bottom_uextension(r_ob,curr_nt));
                } else {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                        chord->bottommost_stafftop_uy = chord->bottommost_stafftop_uy_noacc = MAX(0, chord->bottommostnote_stafftop_uy + 7 * CONST_STEP_UY * ratio);
                    else
                        chord->bottommost_stafftop_uy = chord->bottommost_stafftop_uy_noacc = chord->bottommostnote_stafftop_uy + 7 * CONST_STEP_UY * ratio;
                }
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && chord->direction == -1) 
                    chord->stemtip_stafftop_uy = chord->bottommostnote_stafftop_uy + 7 * CONST_STEP_UY * ratio;
            }
            if (!curr_nt->next) {
                chord->topmostnote_stafftop_uy = curr_nt->center_stafftop_uy;
                if (chord->direction == -1) {
                    chord->topmost_stafftop_uy_noacc = chord->topmostnote_stafftop_uy - CONST_STEP_UY * ratio;
                    chord->topmost_stafftop_uy = chord->topmostnote_stafftop_uy - MAX(CONST_STEP_UY * ratio, note_get_accidental_top_uextension(r_ob, curr_nt));
                } else {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                        chord->topmost_stafftop_uy = chord->topmost_stafftop_uy_noacc = MIN(staff_bottom_y - staff_top_y - CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION, chord->topmostnote_stafftop_uy - 7 * CONST_STEP_UY * ratio);
                    else
                        chord->topmost_stafftop_uy = chord->topmost_stafftop_uy_noacc = chord->topmostnote_stafftop_uy - 7 * CONST_STEP_UY * ratio;
                }
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && chord->direction == 1)
                    chord->stemtip_stafftop_uy = chord->topmostnote_stafftop_uy - 7 * CONST_STEP_UY * ratio;
            }
            
            i++;
            curr_nt = curr_nt->next;
        }
        
//        dev_post("chord->topmostnote_stafftop_uy: %.2f", chord->topmostnote_stafftop_uy);

        bach_freeptr(midicents);
        bach_freeptr(show_accidental);
        bach_freeptr(reordered);
        bach_freeptr(noteheads_uwidths);
        bach_freeptr(note_need_aux_stem);
        bach_freeptr(accidental);
        bach_freeptr(note_head_resize);
        bach_freeptr(note_acc_resize);
        bach_freeptr(notehead_ux_shift);
        bach_freeptr(scaleposition);
        bach_freeptr(note_x);
        bach_freeptr(note_x_real);
        bach_freeptr(proxygroup_start);
        bach_freeptr(proxygroup_end);
        bach_freeptr(noteheads_stempos);
        bach_freeptr(left_limit);
        bach_freeptr(notehead_rightlim);
        bach_freeptr(notehead_leftlim);
        bach_freeptr(accidental_copy);
        bach_freeptr(accidental_done);
        bach_freeptr(accidental_x_real);
        bach_freeptr(accidental_width);
        bach_freeptr(note_num_accidentals);
        for (mem_i = 0; mem_i < num_notes; mem_i++)
            bach_freeptr(accidental_text[mem_i]);
        bach_freeptr(accidental_text);
    }
    
    if (reset_graphical_position_values) {
        // recompute y positions
        chord->topmost_y = -1;
        chord->bottommost_y = -1;
        chord->beam_y = -1;
        chord->topmost_y_noacc = -1;
        chord->bottommost_y_noacc = -1;
        
        reset_articulation_position_for_chord(r_ob, chord);
    }
    
    if (chord->is_score_chord) {
        
        // determining notehead character
        long denlog2 = perfect_log2(chord->figure.r_den);
        if (chord->r_sym_duration.r_num > 0) { // NON-REST
        
            chord->notehead_unicode_character = get_notehead_unicode_character(r_ob, chord->figure, NULL);
            
/*            if ((chord->figure.r_num == 2) && (chord->figure.r_den == 1))
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.noteheads_unicode_characters[0];
            else if (denlog2 == 0)
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.noteheads_unicode_characters[1];
            else if (denlog2 == 1)
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.noteheads_unicode_characters[2];
            else
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.noteheads_unicode_characters[3]; */
            
            // changing the extensions w.r. to the flags
            if (chord->beams_depth == 0) { // no beaming
                if (denlog2 == 3) {
                    if (chord->right_uextension < r_ob->notation_typo_preferences.flag_uwidths[0])
                        chord->right_uextension = r_ob->notation_typo_preferences.flag_uwidths[0];
                } else if (denlog2 == 4) {
                    if (chord->right_uextension < r_ob->notation_typo_preferences.flag_uwidths[1])
                        chord->right_uextension = r_ob->notation_typo_preferences.flag_uwidths[1];
                } else if ((denlog2 > 4) || (denlog2 < 0)) { // we join the case (which should NEVER be the case...) of denlog2<0 i.e. wrong figure
                    if (chord->right_uextension < r_ob->notation_typo_preferences.flag_uwidths[2])
                        chord->right_uextension = r_ob->notation_typo_preferences.flag_uwidths[2];
                }
            }
            
            // changing the extensions w.r. to the lyrics
            if (r_ob->lyrics_affect_spacing && chord->lyrics && chord->lyrics->label){
                double this_left_uextension = -chord->lyrics->lyrics_ux_shift + (chord->direction == 1 ? 0.5 : -0.5) * chord_get_mainside_notehead_uwidth(r_ob, chord->r_sym_duration, chord);
                double this_right_uextension = chord->lyrics->lyrics_uwidth - this_left_uextension; 
                if (chord->left_uextension < this_left_uextension) {
                    chord->lyrics_portion_of_left_uextension = this_left_uextension - chord->left_uextension;
                    chord->left_uextension = this_left_uextension;
                }
                if (chord->right_uextension < this_right_uextension) {
                    chord->lyrics_portion_of_right_uextension = this_right_uextension - chord->right_uextension;
                    chord->right_uextension = this_right_uextension;
                }
            }
            
        } else { // REST
            
            // determining rest character
            if ((chord->figure.r_num == -2) && (chord->figure.r_den == 1)) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[0];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[0] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 0) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[1];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[1] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 1) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[2];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[2] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 2) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[3];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[3] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 3) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[4];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[4] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 4) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[5];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[5] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 5) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[6];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[6] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else if (denlog2 == 6) {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[7];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[7] / 2.;
                chord->right_uextension = chord->left_uextension;
            } else {
                chord->notehead_unicode_character = r_ob->notation_typo_preferences.rests_unicode_characters[8];
                chord->left_uextension = r_ob->notation_typo_preferences.rest_uwidths[8] / 2.;
                chord->right_uextension = chord->left_uextension;
            }
            
            chord->right_uextension += 0;
        }
        
        // changing the extensions w.r. to the dynamics
        if (r_ob->dynamics_affect_spacing && chord_has_dynamics(chord)){
            t_dynamics *dyn = chord_get_dynamics(chord);
            if (dyn) {
                double this_left_uextension = dynamics_get_left_extension_from_chord_stem(r_ob, dyn);
                double this_right_uextension = dyn->dynamics_min_uwidth - this_left_uextension;
                if (chord->left_uextension < this_left_uextension) {
                    chord->dynamics_portion_of_left_uextension = this_left_uextension - chord->left_uextension;
                    chord->left_uextension = this_left_uextension;
                }
                if (chord->right_uextension < this_right_uextension) {
                    chord->dynamics_portion_of_right_uextension = this_right_uextension - chord->right_uextension;
                    chord->right_uextension = this_right_uextension;
                }
            }
        }
        
    }
    
}

void compute_measure_chords_figure(t_notation_obj *r_ob, t_measure *measure){
    t_chord *chord;
    for (chord = measure->firstchord; chord; chord = chord->next)
        compute_chord_figure(r_ob, chord, true);
}

void compute_chord_figure(t_notation_obj *r_ob, t_chord *chord, char warn_when_weird)
{
    if (chord->parent && is_measure_single_whole_rest(r_ob, chord->parent)) {
        // chord is a single rest!
#ifdef CONFIGURATION_Development
        if (warn_when_weird && chord->r_sym_duration.r_num >= 0)
            object_warn((t_object *) r_ob, "Warning: chord in empty measure?");
#endif
        chord->num_dots = 0;
        chord->figure = long2rat(1);
        return;
    }
    
    // we calculate the graphical values of the chord
    // has dots? which graphical figure? (i.e. r_sym_duration?)
    t_rational tuplet_local_ratio = chord->overall_tuplet_ratio;
    char there_is_tuplet = (rat_long_cmp(tuplet_local_ratio, 1) != 0);
    long log_for_dots;
    chord->num_dots = 0;
    if (there_is_tuplet) // there's a tuplet
        chord->figure = rat_rat_div(rat_abs(chord->r_sym_duration), tuplet_local_ratio); 
    else
        chord->figure = rat_abs(chord->r_sym_duration);
    log_for_dots = perfect_log2(chord->figure.r_num + 1); // useful to know how many dots we have to put: 1/n = no dots, 3/n = 1 dot, 7/n = 2 dots... (2^k-1)/n = k-1 dots
    
    // analyzing numerators
    if (chord->figure.r_num == 1 || (chord->figure.r_num == 2 && chord->figure.r_den == 1)) { // easy case: 1/n or 2/1
        chord->num_dots = 0; // easy case, nothing to do
    } else if (log_for_dots > 0) { // dots
        long num_inferior_2_power;
        chord->num_dots = log_for_dots - 1;
        num_inferior_2_power = round(pow(2., chord->num_dots));
        chord->figure.r_num = num_inferior_2_power;
    } else { // very strange figure, though... e.g. 5/8 in the same figure?? hardly recommendable
        // it might happen on tuplets
#ifdef CONFIGURATION_Development
        if (warn_when_weird)
            object_warn((t_object *) r_ob, "Warning: awkward symbolic figure: %ld/%ld", chord->figure.r_num, chord->figure.r_den);
#endif
    }
    
    rat_reduce(&chord->figure);
}

long get_num_beams_from_figure(t_rational figure){
    t_rational eight = RAT_1OVER8;
    if (rat_rat_cmp(figure, eight) > 0)
        return 0;
    else {
        t_rational r_num_bits = rat_rat_div(eight, figure);
        return (r_num_bits.r_den == 1) ? (perfect_log2(r_num_bits.r_num) > 0 ? perfect_log2(r_num_bits.r_num) + 1 : floor(log2(r_num_bits.r_num) + 1)) : 
                    floor(log2(rat2double(r_num_bits)) + 1);
    }
}

long get_bits_from_figure(t_rational figure){
    long beambits = 0;
    long num_bits = get_num_beams_from_figure(figure);
//    t_rational r_num_bits = rat_rat_div(RAT_1OVER8, figure);
    // (r_num_bits.r_den == 1) ? ( (perfect_log2(r_num_bits.r_num) > 0) ? ( perfect_log2(r_num_bits.r_num) + 1) : floor(log2(r_num_bits.r_num) + 1)) : 
    //                                            floor(log2(rat2double(r_num_bits)) + 1);
    long j;    beambits = 0;
    for (j=1; j<num_bits+1; j++) {
        beambits |= (1 << j);
    }
    return beambits;
}

void snap_pitch_to_grid_for_note(t_notation_obj *r_ob, t_note *note) {
    //    note_set_auto_enharmonicity(note); // dg: 2019/01/26, why did I put this? this should not be here
    note->midicents = note->pitch_displayed.toMC();
}

double snap_to_microtonal_grid_do(double pitch, long tone_division){
    double temp = 200./tone_division; 
    double res = temp * round(pitch/temp);
    return res;
}

// it's basically what "bach.mcapprox" does: converts 5144 into 5100 for semitone grid, into 5150 for quartertone grid...
double snap_to_microtonal_grid(t_notation_obj *r_ob, double pitch){
    return snap_to_microtonal_grid_do(pitch, r_ob->tone_division);
}

void snap_pitch_to_grid_for_breakpoint(t_notation_obj *r_ob, t_bpt *bpt) {
    
    t_note *nt = bpt->owner;
    bpt->delta_mc = snap_to_microtonal_grid(r_ob, nt->midicents + bpt->delta_mc) - nt->midicents;
}

// screen_midicents and accidentals have to be sized AT LEAST CONST_MAX_ENHARMONICITY_OPTIONS to be safe!!
// fills the current_enharmonic_list_screenmc and current_enharmonic_list_screenacc fields of the notationobj structure, and fills the last pointer
// which tells us which form the note currently has
void note_get_enharmonic_possibilities(t_notation_obj *r_ob, t_note *note, long *curr_idx){
    
    // get automatic 
    long screen_midicents_default; 
    t_rational screen_accidental_default;
    long step_between_screen_midicents_and_next_natural_note, step_between_screen_midicents_and_previous_natural_note;
    t_voice *voice = note->parent->is_score_chord ? (t_voice *)note->parent->parent->voiceparent : (t_voice *)note->parent->voiceparent;
    
    mc_to_screen_approximations(r_ob, note->midicents, &screen_midicents_default, &screen_accidental_default, voice->acc_pattern, voice->full_repr);
    *curr_idx = -1;
    
    // current possibility
    r_ob->current_enharmonic_list_screenmc[0] = screen_midicents_default;
    r_ob->current_enharmonic_list_screenacc[0] = screen_accidental_default;
    if (note_get_screen_midicents(note) == screen_midicents_default && rat_rat_cmp(note_get_screen_accidental(note), screen_accidental_default) == 0)
        *curr_idx = 0;
    
    // above
    step_between_screen_midicents_and_next_natural_note = is_natural_note(screen_midicents_default + 100) ? 100 : 200;
    r_ob->current_enharmonic_list_screenmc[1] = screen_midicents_default + step_between_screen_midicents_and_next_natural_note;
    r_ob->current_enharmonic_list_screenacc[1] = rat_rat_diff(screen_accidental_default, genrat(step_between_screen_midicents_and_next_natural_note, 200));
    if (note_get_screen_midicents(note) == r_ob->current_enharmonic_list_screenmc[1] && rat_rat_cmp(note_get_screen_accidental(note), r_ob->current_enharmonic_list_screenacc[1]) == 0)
        *curr_idx = 1;

    // below
    step_between_screen_midicents_and_previous_natural_note = is_natural_note(screen_midicents_default - 100) ? -100 : -200;
    r_ob->current_enharmonic_list_screenmc[2] = screen_midicents_default + step_between_screen_midicents_and_previous_natural_note;
    r_ob->current_enharmonic_list_screenacc[2] = rat_rat_sum(genrat(-step_between_screen_midicents_and_previous_natural_note, 200), screen_accidental_default);
    if (note_get_screen_midicents(note) == r_ob->current_enharmonic_list_screenmc[2] && rat_rat_cmp(note_get_screen_accidental(note), r_ob->current_enharmonic_list_screenacc[2]) == 0)
        *curr_idx = 2;
}


t_pitch note_get_pitch(t_notation_obj *r_ob, t_note *note)
{
    if (note->pitch_original.isNaP())
        return note->pitch_displayed;
    else
        return note->pitch_original;
}

void note_get_poc(t_notation_obj *r_ob, t_note *note, t_hatom *h)
{
    if (note_is_enharmonicity_userdefined(note))
        hatom_setpitch(h, note_get_pitch(r_ob, note));
    else
        hatom_setdouble(h, note->midicents);
}

void note_set_velocity(t_notation_obj *r_ob, t_note *note, long velocity)
{
    note->velocity = velocity;
    if (note->firstbreakpoint)
        note->firstbreakpoint->velocity = velocity;
}

void note_set_pitch(t_notation_obj *r_ob, t_note *note, t_pitch pitch)
{
    note->pitch_original = pitch;
    note->midicents = pitch.toMC();
    
    note->parent->need_recompute_parameters = true;
    if (note->parent->is_score_chord) { // only for score!
        note->parent->parent->need_check_ties = true;
        validate_accidentals_for_measure(r_ob, note->parent->parent);
        note->parent->parent->tuttipoint_reference->need_recompute_spacing = k_SPACING_RECALCULATE;
        set_need_perform_analysis_and_change_flag(r_ob);
    }
    note_compute_approximation(r_ob, note);
}

// DEPRECATED, OLD!!
void note_set_pitch_from_notename(t_notation_obj *r_ob, t_note *note, t_symbol *note_name, char dont_change_cents_for_enharmonic_changes)
{
    long screen_mc = 6000, old_screen_mc = note_get_screen_midicents(note);
    t_rational screen_acc = long2rat(0), old_screen_acc = note->pitch_original.alter();
    notename2midicents(r_ob->middleC_octave, &r_ob->last_used_octave, note_name->s_name, &screen_mc, &screen_acc);
    note_set_user_enharmonicity_from_screen_representation(note, screen_mc, screen_acc);

    if (rat_rat_cmp(rat_long_sum(rat_long_prod(old_screen_acc, 200), old_screen_mc), rat_long_sum(rat_long_prod(screen_acc, 200), screen_mc)) != 0)
        note->midicents = screen_mc + rat2double(rat_long_prod(screen_acc, 200));
    
    note->parent->need_recompute_parameters = true;
    if (note->parent->is_score_chord) { // only for score!
        note->parent->parent->need_check_ties = true;
        validate_accidentals_for_measure(r_ob, note->parent->parent);
        note->parent->parent->tuttipoint_reference->need_recompute_spacing = k_SPACING_RECALCULATE;
        set_need_perform_analysis_and_change_flag(r_ob);
    }
    note_compute_approximation(r_ob, note);
}

void enharmonically_retranscribe_note(t_notation_obj *r_ob, t_note *note, char auto_mode, long new_screen_midicents, t_rational new_screen_accidental) {
    long screen_mc = note_get_screen_midicents(note);
    t_rational screen_acc = note_get_screen_accidental(note);
    if (auto_mode) {
        if (screen_acc.r_num >= 0) {
            long step_between_natural_notes = is_natural_note(screen_mc + 100) ? 100 : 200;
            screen_mc = screen_mc + step_between_natural_notes;
            screen_acc = rat_rat_diff(screen_acc, genrat(step_between_natural_notes, 200));
        } else {
            long step_between_natural_notes = is_natural_note(screen_mc - 100) ? -100 : -200;
            screen_mc = screen_mc + step_between_natural_notes;
            screen_acc = rat_rat_sum(genrat(-step_between_natural_notes, 200), screen_acc);
        }
    } else {
        screen_mc = new_screen_midicents;
        screen_acc = new_screen_accidental;
    }
    note_set_user_enharmonicity_from_screen_representation(note, screen_mc, screen_acc);

    
    note->parent->need_recompute_parameters = true;
    note_compute_approximation(r_ob, note);
    if (note->parent->is_score_chord) { // only for score!
        note->parent->parent->need_check_ties = true;
        validate_accidentals_for_measure(r_ob, note->parent->parent);
        recompute_all_measure_chord_parameters(r_ob, note->parent->parent);
        note->parent->parent->tuttipoint_reference->need_recompute_spacing = k_SPACING_RECALCULATE;
        set_need_perform_analysis_and_change_flag(r_ob);
    }
}


void free_notationitem_slots(t_notation_obj *r_ob, t_notation_item *nitem)
{
    //freeing slots
    long i;
    for (i = 0; i < CONST_MAX_SLOTS; i++){
        t_slotitem *temp4, *temp3 = notation_item_get_slot_firstitem(r_ob, nitem, i);
        while (temp3) {
            temp4 = temp3;
            temp3 = temp3->next;
            if (temp4->item) {
                if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_NOTEHEAD) {
                    // nothing to do!!!
                } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_DYNAMICS) {
                    dynamics_check_dependencies_before_deleting_it(r_ob, (t_dynamics *)temp4->item);
                    free_dynamics(r_ob, (t_dynamics *) temp4->item);
                } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_LLLL || r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_INTMATRIX ||
                           r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_TOGGLEMATRIX || r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_FLOATMATRIX)
                    llll_free((t_llll *) temp4->item);
                else
                    bach_freeptr(temp4->item);
            }
            bach_freeptr(temp4);
        }
    }
}


void free_note(t_notation_obj *r_ob, t_note *note)
{
#ifdef BACH_NOTES_HAVE_ID
    if (note->r_it.ID) // chuck note ID from table
        shashtable_chuck_thing(r_ob->IDtable, note->r_it.ID);
#endif 
    
    notation_item_free((t_notation_item *)note);

    // free the memory of the note pointers
    t_bpt *temp2, *temp = note->firstbreakpoint;
    while (temp) { // freeing breakpoints
        temp2 = temp;
        temp = temp->next;
        bach_freeptr(temp2);
    }

    bach_freeptr(note->durationline);

    if (note->articulation)
        bach_freeptr(note->articulation);

    note->r_it.ID = BACH_MAGIC_BAD; // to know we freed...

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_item_check(r_ob, (t_notation_item *)note);
#endif
    
    free_notationitem_slots(r_ob, (t_notation_item *)note);
    
    bach_freeptr(note);
    note = NULL;
}

void free_voice(t_notation_obj *r_ob, t_voice *voice) {
    notation_item_free((t_notation_item *)voice);
    bach_freeptr(voice);
    voice = NULL;
}

void free_lyrics(t_notation_obj *r_ob, t_lyrics *ly)
{
    if (ly->label)
        bach_freeptr(ly->label);
    bach_freeptr(ly);
}

void free_dynamics(t_notation_obj *r_ob, t_dynamics *dy)
{
    dynamics_free_marks(dy);
    bach_freeptr(dy);
}

void free_chord(t_notation_obj *r_ob, t_chord *chord)
{
// free the memory related to the chord *chord
    t_note *temp1, *temp2;

    // chuck chord ID from table
    if (chord->r_it.ID)
        shashtable_chuck_thing(r_ob->IDtable, chord->r_it.ID);
    
    free_lyrics(r_ob, chord->lyrics);
    notation_item_free((t_notation_item *)chord);
    
    temp1 = chord->firstnote; 
    
    while (temp1) {
        temp2 = temp1->next;
        free_note(r_ob, temp1);
        temp1 = temp2;
    }

#ifdef BACH_CHORDS_HAVE_SLOTS
    free_notationitem_slots(r_ob, (t_notation_item *)chord);
#endif
    
    if (chord->articulation)
        bach_freeptr(chord->articulation);

    chord->r_it.ID = BACH_MAGIC_BAD; // to have a clue that we freed...
    bach_freeptr(chord);
    chord = NULL;
}

long llll_free_all_l_things_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && hatom_getllll(a)->l_thing.w_obj)
        bach_freeptr(hatom_getllll(a)->l_thing.w_obj);
    return 0;
}


void llll_free_all_l_things(t_llll *llll){
    llll_funall(llll, llll_free_all_l_things_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
}



long remove_leaf_reference_from_chord(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_OBJ){
        t_chord *ch = (t_chord *) hatom_getobj(a);
        ch->rhythmic_tree_elem = NULL;
    }
    return 0;
}

void free_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure){
    measure->lock_rhythmic_tree = false; // we unlock the beaming tree, in any case
    if (!measure->rhythmic_tree)
        return;
    llll_funall(measure->rhythmic_tree, remove_leaf_reference_from_chord, NULL, 1, -1, 0);
    llll_free_freethings(measure->rhythmic_tree, LLLL_FREETHING_MEM);
}


// free the memory related to the measure *measure
void free_measure_ext(t_notation_obj *r_ob, t_measure *measure, char dont_free_chords, char dont_free_rhythmic_tree) {
    t_chord *temp1 = measure->firstchord; t_chord *temp2;
    t_tempo *temp3, *temp4;
    t_beam *temp5, *temp6;
    
    if (measure->r_it.ID) // chuck measure from table
        shashtable_chuck_thing(r_ob->IDtable, measure->r_it.ID);
    
    measure->measure_number = BACH_MAGIC_BAD; // to know we freed...
    
    if (measure->end_barline)
        bach_freeptr(measure->end_barline);
    
    if (measure->info_for_pwgl)
        llll_free(measure->info_for_pwgl);
    
    if (measure->boxes)
        llll_free(measure->boxes);
    
    if (!dont_free_rhythmic_tree)
        if (measure->rhythmic_tree)
            free_rhythmic_tree(r_ob, measure);
    
    notation_item_free((t_notation_item *)measure);
    
    if (!dont_free_chords) {
        while (temp1) {
            temp2 = temp1->next;
            free_chord(r_ob, temp1);
            temp1 = temp2;
        }
    }
    
    temp3 = measure->firsttempo;
    while (temp3) {
        temp4 = temp3->next;
        free_tempo(r_ob, temp3);
        temp3 = temp4;
    }
    
    temp5 = measure->firstbeam;
    while (temp5) {
        temp6 = temp5->next;
        free_beam(r_ob, temp5);
        temp5 = temp6;
    }
    
    bach_freeptr(measure);
    measure = NULL;
}


// free the memory related to the measure *measure
void free_measure(t_notation_obj *r_ob, t_measure *measure) {
    free_measure_ext(r_ob, measure, false, false);
}

void free_beam(t_notation_obj *r_ob, t_beam *beam) {
    // free the memory related to the beam *beam
    beam->has_beam_line = -66; // to have a clue that we freed...
    
    bach_freeptr(beam); 
    beam = NULL;
}

void free_tempo(t_notation_obj *r_ob, t_tempo *tempo) {
// free the memory related to the tempo *tempo
    tempo->need_recalculate_onset = -66; // to have a clue that we freed...
    
    notation_item_free((t_notation_item *)tempo);
    bach_freeptr(tempo); 
    tempo = NULL;
}

void free_group(t_notation_obj *r_ob, t_group *group) {
// free the memory related to the group *group
    group->num_elements = BACH_MAGIC_BAD; // to know we freed...
    
    bach_freeptr(group); 
    group = NULL;
}

void free_marker(t_notation_obj *r_ob, t_marker *marker) {
// free the memory related to the tempo *tempo
    if (marker->content)
        llll_free(marker->content);
    marker->name_uwidth = BACH_MAGIC_BAD; // to know we freed...
    
#ifdef BACH_MARKERS_HAVE_SLOTS
    free_notationitem_slots(r_ob, (t_notation_item *)marker);
#endif

    notation_item_free((t_notation_item *)marker);
    bach_freeptr(marker); 
    marker = NULL;
}

void free_tuttipoint(t_notation_obj *r_ob, t_tuttipoint *tuttipoint) {
// free the memory related to the tuttipoint *tuttipoint
    tuttipoint->ID = BACH_MAGIC_BAD; // to know we freed...

    bach_freeptr(tuttipoint);
    tuttipoint = NULL;
}

/*
void add_tempi(t_notation_obj *r_ob, t_scorevoice *voice, long measure_num, t_llll *tempi_as_llll) {
    // tempi_as_llll may be in one the form
    // (tempo)
    // ((tempofigure tempo) (tempofigure tempo...))
    // ((tempofigure tempo point_in_measure) (tempofigure tempo point_in_measure...))
    // ((tempofigure tempo point_in_measure interpolation_type) (tempofigure tempo point_in_measure interpolation_type...))

    if (tempi_as_llll && (tempi_as_llll->l_size > 0)) {
        if (tempi_as_llll->l_depth == 2) { // just (tempo)
            if (hatom_gettype(&tempi_as_llll->l_head->l_hatom) == H_LLLL) {
                t_llll *firstelem = hatom_getllll(&tempi_as_llll->l_head->l_hatom);
                t_rational tempo_value = (hatom_gettype(&firstelem->l_head->l_hatom) == H_RAT) ? 
                                        hatom_getrational(&firstelem->l_head->l_hatom) :
                                        approx_double_with_rat_fixed_den(hatom_getdouble(&firstelem->l_head->l_hatom), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
                t_tempo *tempo;
                t_measure *meas;
                tempo = build_tempo(long2rat(0), tempo_value, RAT_1OVER4, 0);
                meas = nth_measure_of_scorevoice(voice, measure_num);
                if (meas)
                    insert_tempo(r_ob, meas, tempo);
            }
        } else if (tempi_as_llll->l_depth == 3) { 
            t_llllelem *elem;
            for (elem = tempi_as_llll->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_tempo *tempo;
                    t_measure *meas;
                    t_llll *thisllll = hatom_getllll(&elem->l_hatom);
                    t_rational tempo_value = long2rat(60); t_rational tempo_figure = RAT_1OVER4; t_rational pt_in_measure = long2rat(0); 
                    long interpolation_type = 0;
                    if (thisllll->l_size == 1) {
                        tempo_value = (hatom_gettype(&thisllll->l_head->l_hatom) == H_RAT) ? 
                                                hatom_getrational(&thisllll->l_head->l_hatom) :
                                                approx_double_with_rat_fixed_den(hatom_getdouble(&thisllll->l_head->l_hatom), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
                    } else if (thisllll->l_size == 2) {
                        tempo_figure = hatom_getrational(&thisllll->l_head->l_hatom);
                        tempo_value = (hatom_gettype(&thisllll->l_head->l_next->l_hatom) == H_RAT) ? 
                                                hatom_getrational(&thisllll->l_head->l_next->l_hatom) :
                                                approx_double_with_rat_fixed_den(hatom_getdouble(&thisllll->l_head->l_next->l_hatom), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
                    } else if (thisllll->l_size == 3) {
                        tempo_figure = hatom_getrational(&thisllll->l_head->l_hatom);
                        tempo_value = (hatom_gettype(&thisllll->l_head->l_next->l_hatom) == H_RAT) ? 
                                                hatom_getrational(&thisllll->l_head->l_next->l_hatom) :
                                                approx_double_with_rat_fixed_den(hatom_getdouble(&thisllll->l_head->l_next->l_hatom), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
                        pt_in_measure = hatom_getrational(&thisllll->l_head->l_next->l_next->l_hatom);
                    } else if (thisllll->l_size == 4) {                    
                        tempo_figure = hatom_getrational(&thisllll->l_head->l_hatom);
                        tempo_value = (hatom_gettype(&thisllll->l_head->l_next->l_hatom) == H_RAT) ? 
                                                hatom_getrational(&thisllll->l_head->l_next->l_hatom) :
                                                approx_double_with_rat_fixed_den(hatom_getdouble(&thisllll->l_head->l_next->l_hatom), CONST_RAT_APPROX_TEMPI_DEN, 0, NULL);
                        pt_in_measure = hatom_getrational(&thisllll->l_head->l_next->l_next->l_hatom);
                        interpolation_type = hatom_getlong(&thisllll->l_head->l_next->l_next->l_next->l_hatom);
                    }
                    tempo = build_tempo(pt_in_measure, tempo_value, tempo_figure, interpolation_type);
                    meas = nth_measure_of_scorevoice(voice, measure_num);
                    if (meas)
                        insert_tempo(r_ob, meas, tempo);
                }
            }
        }
    }
}
*/


// for bach.roll only
double get_stem_x_from_alignment_point_x(t_notation_obj *r_ob, t_chord *chord, double chord_alignment_x)
{
    double stem_x = 0;

    if (r_ob->align_chords_with_what == k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_CENTER || r_ob->align_chords_with_what == k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_END) {
        t_note *nt = NULL;
        double note_width = get_principal_notehead_uwidth(r_ob, chord) * r_ob->zoom_y;
        
        if (!r_ob->forceround_stems_to_semiinteger && (nt = get_principal_note(r_ob, chord))) {
            if (r_ob->align_chords_with_what == k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_CENTER)
                stem_x = chord_alignment_x + chord->direction * note_width / 2.;
            else
                stem_x = (chord->direction == 1 ? chord_alignment_x : chord_alignment_x - note_width);
//            double orig_stem_x = stem_x;
            double grace_ratio = (chord->is_score_chord && chord->is_grace_chord) ? CONST_GRACE_CHORD_SIZE : 1.;
            double x_shift = (get_notehead_ux_shift(r_ob, nt) + nt->notecenter_stem_delta_ux) * r_ob->zoom_y * grace_ratio;
            x_shift -= ((nt->notehead_uwidth / 2.) * r_ob->zoom_y);
            double textbox_x = stem_x + x_shift;
            double textbox_x_rounded = round(textbox_x);
            double diff = textbox_x_rounded - textbox_x;
            stem_x += diff;

//            dev_post("alignment: %.2f, note_halfwidth: %.2f, stem_x: %.2f, textbox_x: %.2f, textbox_x_rounded: %.2f, diff: %.2f, stem_x_snapped: %.2f", chord_alignment_x, note_width/2., orig_stem_x, textbox_x, textbox_x_rounded, diff, stem_x);
        } else {
            double note_width_rounded = round(note_width);
            if (!nt)
                stem_x = chord_alignment_x;
            else
                stem_x = chord_alignment_x + chord->direction * note_width_rounded / 2.;
            
//            double orig_stem_x = stem_x;

            if (r_ob->show_stems > 0)
                stem_x = round_to_semiinteger(stem_x); // if stems are visible, they are rounded to the semiinteger

//            dev_post("alignment: %.2f, note_halfwidth: %.2f, note_halfwidth_rounded: %.2f, stem_x: %.2f, stem_x_rounded: %.2f", chord_alignment_x, note_width/2., note_width_rounded/2., orig_stem_x, stem_x);
        }
        
    } else {
        stem_x = chord_alignment_x;
        
        if (r_ob->show_stems > 0)
            stem_x = round_to_semiinteger(stem_x); // if stems are visible, they are rounded to the semiinteger
    }
    
    return stem_x;
}


// returns 1 if the point (point_x, point_y) is within the shape of the given note.
int is_in_note_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y){
    long system_num = 0;
    double note_x, note_y, dist;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        note_x = unscaled_xposition_to_xposition(r_ob, note->parent->parent->tuttipoint_reference->offset_ux + note->parent->stem_offset_ux) + note->notecenter_stem_delta_ux * r_ob->zoom_y;
        note_y = mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(note), (t_voice *)note->parent->parent->voiceparent);
    } else {
        system_num = -1;  // for auto calculation
        note_x = note->notecenter_stem_delta_ux * r_ob->zoom_y + get_stem_x_from_alignment_point_x(r_ob, note->parent, onset_to_xposition_roll(r_ob,note->parent->onset, &system_num));
        note_y = r_ob->system_jump * system_num + mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(note), (t_voice *)note->parent->voiceparent);
    }
    
    dist = ((point_x-note_x)*(point_x-note_x) + (point_y-note_y)*(point_y-note_y));
    //    if (dist < (CONST_NOTE_CLICK_URADIUS * r_ob->zoom_y)*(CONST_NOTE_CLICK_URADIUS * r_ob->zoom_y))
    if (dist < ((note->notehead_uwidth/2. + CONST_NOTE_CLICK_URADIUS_PAD) * r_ob->zoom_y)*((note->notehead_uwidth/2. + CONST_NOTE_CLICK_URADIUS_PAD) * r_ob->zoom_y))
        return 1;
    else
        return 0;
}


int is_in_rest_shape(t_notation_obj *r_ob, t_chord *restchord, long point_x, long point_y)
{
    // returns 1 if the point (point_x, point_y) is within the shape of the note NN.
    double pause_x = unscaled_xposition_to_xposition(r_ob, restchord->parent->tuttipoint_reference->offset_ux + restchord->stem_offset_ux);
    double width = rest_get_uwidth(r_ob, restchord->figure);
    double note_y = rest_get_nonfloating_yposition(r_ob, restchord, NULL, NULL) - restchord->float_steps * r_ob->step_y;
    if ((fabs(point_x-pause_x) < width * r_ob->zoom_y) && (fabs(point_y-note_y) < 4 * r_ob->step_y))
        return 1;
    else
        return 0;
}

int is_in_tail_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y){
    // returns 1 if the point (point_x, point_y) is within the shape of the tail of the duration-line of the note NN.
    long system_num = 0;

    double tail_x = -100000;
    t_chord *chord = note->parent;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        system_num = -1;  // for auto calculation
        tail_x = onset_to_xposition_roll(r_ob, chord->onset + note->duration, &system_num);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        tail_x = unscaled_xposition_to_xposition(r_ob, chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux + chord->duration_ux);
    
    double tail_correction, tail_y;
    if (r_ob->allow_glissandi) {
        tail_correction = 0.;
        tail_y = r_ob->system_jump * system_num + mc_to_yposition(r_ob, note->midicents + note->lastbreakpoint->delta_mc + tail_correction,  chord_get_voice(r_ob, chord));
    } else {
        tail_correction = round(note->lastbreakpoint->delta_mc);
        tail_y = r_ob->system_jump * system_num + mc_to_yposition(r_ob, note_get_screen_midicents(note) + tail_correction, chord_get_voice(r_ob, chord));
    }
    //    double note_y = mc_to_yposition_in_scale((t_notation_obj *) x, note_get_screen_midicents(note));
    if ((fabs(point_x - tail_x) < ((r_ob->durations_line_width * (CONST_NOTETAIL_UWIDTH - 0.1) * r_ob->zoom_y) / 2.)) && (fabs(tail_y - point_y) < (r_ob->breakpoints_size * 0.666 + 1) * r_ob->zoom_y))
        return 1;
    else
        return 0;
}

int is_in_articulation_shape(t_notation_obj *r_ob, t_articulation *art, long point_x, long point_y)
{
    if (fabs(point_x - art->middle_x_pos) <= art->width / 2. + CONST_ARTICULATION_SELECTION_HORIZONTAL_UTOLERANCE * r_ob->zoom_y &&
        fabs(point_y - art->middle_y_pos) <= art->height / 2. + CONST_ARTICULATION_SELECTION_VERTICAL_UTOLERANCE * r_ob->zoom_y)
        return 1;
    else
        return 0;
}


void breakpoint_get_pt(t_notation_obj *r_ob, t_bpt *bpt, double *bpt_x_pix, double *bpt_y_pix, double *start_pos_x, double *end_pos_x)
{
    double start_pos = 0, end_pos = 0;
    long system_num = 0;
    double bpt_x = 0, bpt_y = 0;
    t_note *note = bpt->owner;
    t_chord *chord = note->parent;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if (start_pos_x)
            start_pos = *start_pos_x;
        else
            start_pos = onset_to_xposition_roll(r_ob, chord->onset, NULL);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (start_pos_x)
            start_pos = *start_pos_x;
        else
            start_pos = chord_get_alignment_x(r_ob, chord);
        if (end_pos_x)
            end_pos = *end_pos_x;
        else {
            t_note *last_tied;
            if (r_ob->dl_spans_ties && (last_tied = note_get_last_in_tieseq(bpt->owner)))
                end_pos = unscaled_xposition_to_xposition(r_ob, last_tied->parent->parent->tuttipoint_reference->offset_ux + last_tied->parent->stem_offset_ux + last_tied->parent->duration_ux);
            else
                end_pos = unscaled_xposition_to_xposition(r_ob, chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux + chord->duration_ux);
        }
    }

    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        system_num = -1;
        bpt_x = onset_to_xposition_roll(r_ob, chord->onset + bpt->rel_x_pos * note->duration, &system_num);
    } else
        bpt_x = start_pos + (end_pos - start_pos) * bpt->rel_x_pos;
    
    if (r_ob->breakpoints_have_noteheads)
        bpt_y = r_ob->system_jump * system_num + mc_to_yposition_in_scale(r_ob, note->midicents + round(bpt->delta_mc), chord_get_voice(r_ob, chord));
    else
        bpt_y = r_ob->system_jump * system_num + mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(note) + round(bpt->delta_mc), chord_get_voice(r_ob, chord));
    
    *bpt_x_pix = bpt_x;
    *bpt_y_pix = bpt_y;
}

int is_in_durationline_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y)
{
    
    // returns 1 if the point (point_x, point_y) is within the shape of the the duration-line of the note *note.
    // it is complicated from the fact that we have a bezier curve to analize
    t_chord *chord = note->parent;
    long system_num = 0;
    double start_pos = -100000, end_pos = -100000;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        system_num = -1; // for auto calculation
        start_pos = onset_to_xposition_roll(r_ob,chord->onset, &system_num);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_note *last_tied;
        start_pos = unscaled_xposition_to_xposition(r_ob, chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux);
        if (r_ob->dl_spans_ties && (last_tied = note_get_last_in_tieseq(note)))
            end_pos = unscaled_xposition_to_xposition(r_ob, last_tied->parent->parent->tuttipoint_reference->offset_ux + last_tied->parent->stem_offset_ux + last_tied->parent->duration_ux);
        else
            end_pos = unscaled_xposition_to_xposition(r_ob, chord->parent->tuttipoint_reference->offset_ux + chord->stem_offset_ux + chord->duration_ux);
    }
    
    //    double end_pos = onset_to_xposition_roll((t_notation_obj *) x,chord->onset+note->duration, &system_num); // same system, can't handle the different systems now...
    
    t_bpt *temp = note->firstbreakpoint->next;
    double prev_bpt_x = start_pos;
    double prev_bpt_y = r_ob->system_jump * system_num + mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(note), chord_get_voice(r_ob, chord));
    double line_tol = ((r_ob->durations_line_width * r_ob->zoom_y) / 2.);
    while (temp) {
        double bpt_x, bpt_y;
        breakpoint_get_pt(r_ob, temp, &bpt_x, &bpt_y, &start_pos, &end_pos);
        if (is_pt_in_curve_shape(point_x, point_y, prev_bpt_x, prev_bpt_y, bpt_x, bpt_y, temp->slope, line_tol * CONST_CLICK_BEZIER_TOLLERATION_FACTOR))
            return 1;
        
        prev_bpt_x = bpt_x; prev_bpt_y = bpt_y;
        temp = temp->next;
    }
    return 0;
}



int is_in_breakpoint_shape(t_notation_obj *r_ob, t_bpt *breakpoint, long point_x, long point_y)
{
    double bpt_x, bpt_y;
    breakpoint_get_pt(r_ob, breakpoint, &bpt_x, &bpt_y, NULL, NULL);

    if ((fabs(point_x - bpt_x) <= r_ob->breakpoints_size * 0.6 * r_ob->zoom_y) && (fabs(point_y - bpt_y) <= r_ob->breakpoints_size * r_ob->zoom_y))
        return 1;
    else
        return 0;

    return 0;
}


// returns 1 if the point (point_x, point_y) is on the marker
int is_in_marker_shape(t_notation_obj *r_ob, t_marker *marker, long point_x, long point_y)
{
    double marker_x = -10000;

    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (marker->attach_to == k_MARKER_ATTACH_TO_MEASURE && r_ob->timepoint_to_unscaled_xposition) {
            t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, marker);
            marker_x = unscaled_xposition_to_xposition(r_ob, (r_ob->timepoint_to_unscaled_xposition)(r_ob, tp, false, CONST_MARKERS_ON_FIRST_MEASURE_CHORDS));
        } else
            marker_x = ms_to_xposition(r_ob, marker->position_ms, 1);
    } else {
        marker_x = onset_to_xposition_roll(r_ob, marker->position_ms, NULL);
    }
    
    if (fabs(point_x - marker_x) < 2 + 2 * r_ob->zoom_y && point_y < r_ob->height - (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y)
        return 1;
    return 0;
}



double notationobj_get_marker_voffset(t_notation_obj *r_ob, t_marker *mk)
{
    double ypos = 0;
    if (r_ob->ruler % 2) {
        if (r_ob->show_ruler_labels)
            ypos = 9 * r_ob->zoom_y;
        else
            ypos = 6 * r_ob->zoom_y;
    } else
        ypos = 3 * r_ob->zoom_y;
    
    if (r_ob->smart_markername_placement)
        ypos += r_ob->markers_font_size * r_ob->zoom_y * mk->name_line;
    
    return ypos;
}


// returns 1 if the point (point_x, point_y) is on the markername
int is_in_markername_shape(t_notation_obj *r_ob, t_marker *marker, long point_x, long point_y)
{
    double marker_x;
    double marker_namewidth, marker_name_y_start, marker_nameheight;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (marker->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
            t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, marker);
            marker_x = unscaled_xposition_to_xposition(r_ob, (r_ob->timepoint_to_unscaled_xposition)(r_ob, tp, false, CONST_MARKERS_ON_FIRST_MEASURE_CHORDS));
        } else
            marker_x = ms_to_xposition(r_ob, marker->position_ms, 1);

/*        if (marker->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
            //        t_timepoint tp = measure_attached_marker_to_timepoint((t_notation_obj *)x, marker);
            marker_x = unscaled_xposition_to_xposition(r_ob, ms_to_unscaled_xposition(r_ob, marker->position_ms, 1));
        } else
            marker_x = ms_to_xposition(r_ob, marker->position_ms, 1); */
        
        marker_namewidth = marker->name_uwidth * r_ob->zoom_y;
        marker_name_y_start = r_ob->j_inset_y + 10 * r_ob->zoom_y + notationobj_get_marker_voffset(r_ob, marker);
        marker_nameheight = r_ob->markers_font_size * r_ob->zoom_y;
    } else {
        marker_x = onset_to_xposition_roll(r_ob, marker->position_ms, NULL);
        marker_namewidth = marker->name_uwidth * r_ob->zoom_y;
        marker_name_y_start = r_ob->j_inset_y + 10 * r_ob->zoom_y + notationobj_get_marker_voffset(r_ob, marker);
        marker_nameheight = r_ob->markers_font_size * r_ob->zoom_y;
    }
    
    if (marker->name_painted_direction > 0) {
        if (point_x > marker_x && point_x < marker_x + marker_namewidth + 2 * r_ob->zoom_y &&
            point_y > marker_name_y_start && point_y < marker_name_y_start + marker_nameheight)
                return 1;
    } else {
        if (point_x > marker_x - marker_namewidth - 2 * r_ob->zoom_y && point_x < marker_x &&
            point_y > marker_name_y_start && point_y < marker_name_y_start + marker_nameheight)
            return 1;
    }
    
    return 0;
}


// returns 1 if the point (point_x, point_y) is within the scrollbar handle
// returns -1 if the point is on the scrollbar row, but NOT on the scrollbar handle and BEFORE the scrollbar
// returns -2 if the point is on the scrollbar row, but NOT on the scrollbar handle and AFTER the scrollbar
int is_in_scrollbar_shape(t_notation_obj *r_ob, long point_x, long point_y){
    if (r_ob->height - point_y < (CONST_XSCROLLBAR_UHEIGHT + 2) * r_ob->zoom_y + fabs(CONST_XSCROLLBAR_Y_SHIFT)) {
        if (point_x >= r_ob->hscrollbar_x && point_x <= r_ob->hscrollbar_x + r_ob->hscrollbar_width)
            return 1;
        else if (point_x < r_ob->hscrollbar_x)
            return -1;
        else
            return -2;
    } else
        return 0;
}

// returns 1 if the point (point_x, point_y) is within the vscrollbar handle
// returns -1 if the point is on the vscrollbar col, but NOT on the vscrollbar handle and OVER the scrollbar
// returns -2 if the point is on the vscrollbar col, but NOT on the vscrollbar handle and UNDER the scrollbar
int is_in_vscrollbar_shape(t_notation_obj *r_ob, long point_x, long point_y){
    if (r_ob->width - point_x < (CONST_YSCROLLBAR_UWIDTH + 2) * r_ob->zoom_y + fabs(CONST_YSCROLLBAR_X_SHIFT)) {
        if (point_y >= r_ob->vscrollbar_y && point_y <= r_ob->vscrollbar_y + r_ob->vscrollbar_height)
            return 1;
        else if (point_y < r_ob->vscrollbar_y)
            return -1;
        else
            return -2;
    } else
        return 0;
}


// returns 1 if the point (point_x, point_y) is on the chord lyrics
char is_in_chord_lyrics_shape(t_notation_obj *r_ob, t_chord *chord, long point_x, long point_y)
{
    if (chord && chord->lyrics && chord->lyrics->label) {
        double left_x = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? onset_to_xposition_roll(r_ob, chord->onset, NULL) : unscaled_xposition_to_xposition(r_ob, chord_get_alignment_ux(r_ob, chord)))
                         + chord->lyrics->lyrics_ux_shift * r_ob->zoom_y;
        double width = chord->lyrics->lyrics_uwidth * r_ob->zoom_y;
        double bottom_staff_y = get_staff_bottom_y(r_ob, (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *) chord->voiceparent : (t_voice *) chord->parent->voiceparent), false);
        double top_y = bottom_staff_y - r_ob->lyrics_uy_pos * r_ob->zoom_y;
        
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
            left_x += (chord->direction == 1 ? -0.5 : 0.5) * get_principal_notehead_uwidth(r_ob, chord) * r_ob->zoom_y;
        
        if (point_x > left_x && point_x < left_x + width && 
            point_y > top_y && point_y < top_y + chord->lyrics->lyrics_uheight * r_ob->zoom_y)
            return 1;
    }
    
    return 0;
}

char is_in_dynamics_shape(t_notation_obj *r_ob, t_dynamics *dyn, long point_x, long point_y)
{
    t_rect enclosure;
    dynamics_get_rect(r_ob, dyn, &enclosure);
    return is_pt_in_rectangle(build_pt(point_x, point_y), enclosure);
}

long clef_symbol_to_clef_number(t_notation_obj *r_ob, t_symbol *clef){
    if (clef == _llllobj_sym_FFGG)
        return k_CLEF_FFGG;
    else if (clef == _llllobj_sym_FGG)
        return k_CLEF_FGG; 
    else if (clef == _llllobj_sym_FFG)
        return k_CLEF_FFG; 
    else if (clef == _llllobj_sym_FG)
        return k_CLEF_FG; 
    else if (clef == _llllobj_sym_FF)
        return k_CLEF_FF;
    else if (clef == _llllobj_sym_GG)
        return k_CLEF_GG;
    else if (clef == _llllobj_sym_F || clef == _llllobj_sym_Bass)
        return k_CLEF_F;
    else if (clef == _llllobj_sym_G)
        return k_CLEF_G;
    else if (clef == _llllobj_sym_G8 || clef == _llllobj_sym_G8va)
        return k_CLEF_G8va;
    else if (clef == _llllobj_sym_G8vb)
        return k_CLEF_G8vb;
    else if (clef == _llllobj_sym_G15 || clef == _llllobj_sym_G15ma)
        return k_CLEF_G15ma;
    else if (clef == _llllobj_sym_G15mb)
        return k_CLEF_G15mb;
    else if (clef == _llllobj_sym_F8va)
        return k_CLEF_F8va;
    else if (clef == _llllobj_sym_F8 || clef == _llllobj_sym_F8vb)
        return k_CLEF_F8vb;
    else if (clef == _llllobj_sym_F15ma)
        return k_CLEF_F15ma;
    else if (clef == _llllobj_sym_F15 || clef == _llllobj_sym_F15mb)
        return k_CLEF_F15mb;
    else if (clef == _llllobj_sym_Soprano)
        return k_CLEF_SOPRANO;
    else if (clef == _llllobj_sym_Mezzo)
        return k_CLEF_MEZZO;
    else if (clef == _llllobj_sym_Alto)
        return k_CLEF_ALTO;
    else if (clef == _llllobj_sym_Tenor)
        return k_CLEF_TENOR;
    else if (clef == _llllobj_sym_Barytone)
        return k_CLEF_BARYTONE;
    else if (clef == _llllobj_sym_Percussion)
        return k_CLEF_PERCUSSION;
    else if (clef == _llllobj_sym_none)
        return k_CLEF_NONE;
    else
        return k_CLEF_NONE;
}

t_symbol* clef_number_to_clef_symbol(t_notation_obj *r_ob, long clef){
    switch (clef) {
        case k_CLEF_FFGG: return _llllobj_sym_FFGG;
        case k_CLEF_FFG: return _llllobj_sym_FFG;
        case k_CLEF_FGG: return _llllobj_sym_FGG;
        case k_CLEF_FF: return _llllobj_sym_FF;
        case k_CLEF_FG: return _llllobj_sym_FG;
        case k_CLEF_GG: return _llllobj_sym_GG;
        case k_CLEF_F: return _llllobj_sym_F;
        case k_CLEF_G: return _llllobj_sym_G;
        case k_CLEF_G8va: return _llllobj_sym_G8va;
        case k_CLEF_G8vb: return _llllobj_sym_G8vb;
        case k_CLEF_G15ma: return _llllobj_sym_G15ma;
        case k_CLEF_G15mb: return _llllobj_sym_G15mb;
        case k_CLEF_F8va: return _llllobj_sym_F8va;
        case k_CLEF_F8vb: return _llllobj_sym_F8vb;
        case k_CLEF_F15ma: return _llllobj_sym_F15ma;
        case k_CLEF_F15mb: return _llllobj_sym_F15mb;
        case k_CLEF_SOPRANO: return _llllobj_sym_Soprano;
        case k_CLEF_MEZZO: return _llllobj_sym_Mezzo;
        case k_CLEF_ALTO: return _llllobj_sym_Alto;
        case k_CLEF_TENOR: return _llllobj_sym_Tenor;
        case k_CLEF_BARYTONE: return _llllobj_sym_Barytone;
        case k_CLEF_PERCUSSION: return _llllobj_sym_Percussion;
        case k_CLEF_NONE: return _llllobj_sym_none;
        case k_CLEF_AUTO: return _llllobj_sym_Auto;
        default: return _llllobj_sym_none;
    }
}



// returns 1 if the point (point_x, point_y) is on the clef of the voice *voice
char is_in_voicename_shape(t_notation_obj *r_ob, long point_x, long point_y, t_voice *voice){
    long topy = get_staff_top_y(r_ob, voice, true);
    long bottomy = get_staff_bottom_y(r_ob, voice, true);
    if ((point_x < 1 + r_ob->notation_typo_preferences.clef_ux_shift + r_ob->voice_names_uwidth * r_ob->zoom_y + r_ob->j_inset_x) && 
        (point_x > 0) && // was: (point_x > r_ob->j_inset_x) &&
        (point_y >= topy && point_y <= bottomy))
        return 1;
    else
        return 0;
}

// returns 1 if the point (point_x, point_y) is on the clef of the voice *voice
char is_in_clef_shape(t_notation_obj *r_ob, long point_x, long point_y, t_voice *voice){
    long topy = get_staff_top_y(r_ob, voice, true);
    long bottomy = get_staff_bottom_y(r_ob, voice, true);
    long end_x_to_repaint_no_inset = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) ?
        onset_to_xposition_roll(r_ob, r_ob->screen_ms_start - CONST_X_LEFT_START_DELETE_MS / r_ob->zoom_x, NULL) :
    unscaled_xposition_to_xposition(r_ob, r_ob->screen_ux_start - (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? CONST_X_LEFT_START_DELETE_UX_SCORE : CONST_X_LEFT_START_DELETE_UX_ROLL));
    if ((point_x > 1 + r_ob->notation_typo_preferences.clef_ux_shift + r_ob->voice_names_uwidth * r_ob->zoom_y + r_ob->j_inset_x) && 
        (point_x < end_x_to_repaint_no_inset) &&
        (point_y >= topy && point_y <= bottomy))
        return 1;
    else
        return 0;
}


// breakpoints

t_bpt* add_breakpoint(t_notation_obj *r_ob, t_note *note, double rel_x_pos, double delta_mc, double slope, char auto_mc_pos, long velocity, char auto_velocity){
// add the breakpoint determined by (rel_x_pos, delta_mc) to the note *note.
// if auto_mc_pos == 0, it uses the delta_mc. if auto_mc_pos == 1, it positions automatically on the existing lines and detect slope automatically
    if (note && rel_x_pos > 0. && rel_x_pos < 1) {
        t_bpt *temp;
        t_bpt *new_bpt = build_breakpoint(rel_x_pos, delta_mc, -1, slope, note); // we handle velocity later

        // find the correct placement in the linkedlist
        temp = note->firstbreakpoint;
        while (temp->next) {
            if (temp->next->rel_x_pos > rel_x_pos) { // here! between temp and temp->next!
                if (fabs(temp->next->rel_x_pos - rel_x_pos) < CONST_EPSILON4) {
                    // do we want to erase the bpt lying over this newly added breakpoint?
                    // TO BE DECIDED
                }
                if (auto_mc_pos) {
                    if (fabs(temp->next->slope) < CONST_EPSILON5) {
                        new_bpt->delta_mc = temp->delta_mc + (rel_x_pos - temp->rel_x_pos) * (temp->next->delta_mc - temp->delta_mc) / (temp->next->rel_x_pos - temp->rel_x_pos); 
                        new_bpt->slope = 0.;
                    } else {
                        double new_velocity = 0;
                        new_bpt->delta_mc = get_breakpoints_interpolated_mc(r_ob, note, rel_x_pos, &new_velocity) - note->midicents;
                        new_bpt->velocity = round(new_velocity);
                        temp->next->slope *= 0.5;
                        new_bpt->slope = temp->next->slope;
                    }
                }
                new_bpt->prev = temp;
                new_bpt->next = temp->next;
                temp->next->prev = new_bpt;
                temp->next = new_bpt;
                note->num_breakpoints++;
                break;
            }
            temp = temp->next;
        }
        
        if (auto_velocity) {
            if (!new_bpt->prev || !new_bpt->next)
                new_bpt->velocity = note->velocity;
            else if (new_bpt->next->rel_x_pos == new_bpt->prev->rel_x_pos)
                new_bpt->velocity = new_bpt->prev->velocity;
            else
                new_bpt->velocity = new_bpt->prev->velocity + ((new_bpt->rel_x_pos - new_bpt->prev->rel_x_pos)/(new_bpt->next->rel_x_pos - new_bpt->prev->rel_x_pos)) * (new_bpt->next->velocity - new_bpt->prev->velocity);
        } else
            new_bpt->velocity = velocity; 
        return new_bpt;
    } else if (note && rel_x_pos == 1 && !auto_mc_pos) { // last bpt
        note->lastbreakpoint->delta_mc = delta_mc;
        note->lastbreakpoint->slope = slope;
    }
    return NULL;
}

char delete_breakpoint(t_notation_obj *r_ob, t_bpt *breakpoint){
// delete the breakpoint *breakpoint from the note *note
    
    breakpoint_check_dependencies_before_deleting_it(r_ob, breakpoint);
//    if (breakpoint && breakpoint->owner && breakpoint->rel_x_pos > 0. && breakpoint->rel_x_pos < 1.) {
    if (breakpoint && breakpoint->owner && breakpoint->prev && breakpoint->next) {
        t_bpt *temp = breakpoint;
        breakpoint->owner->num_breakpoints--;
        breakpoint->prev->next = breakpoint->next;
        breakpoint->next->prev = breakpoint->prev;
        bach_freeptr(temp);
        return 1;
//    } else if (breakpoint && breakpoint->owner && breakpoint->rel_x_pos == 1) {
    } else if (breakpoint && breakpoint->owner && breakpoint->prev) {
        breakpoint->delta_mc = 0.;
        breakpoint->slope = 0.;
        return 1;
    }
    return 0;
}

char move_breakpoint(t_notation_obj *r_ob, t_bpt *breakpoint, double delta_rel_x_pos, double delta_mc_pos){
// delete the breakpoint *breakpoint from the note *note
    if (breakpoint && breakpoint->owner && breakpoint->rel_x_pos > 0. && breakpoint->rel_x_pos < 1.) {
        if ((breakpoint->rel_x_pos + delta_rel_x_pos > breakpoint->prev->rel_x_pos) && (breakpoint->rel_x_pos + delta_rel_x_pos < breakpoint->next->rel_x_pos)) { // if the bpt stays between the previous one and the next one
            breakpoint->rel_x_pos += delta_rel_x_pos;
            breakpoint->delta_mc += delta_mc_pos;
        }
        return 1;
    } else if (breakpoint && breakpoint->owner && !breakpoint->next) { // tail
        breakpoint->delta_mc += delta_mc_pos;
    } else if (breakpoint && breakpoint->owner &&  breakpoint->rel_x_pos == 1. && breakpoint == breakpoint->owner->lastbreakpoint)  { // moving the note tail
        breakpoint->delta_mc += delta_mc_pos; // only y movements allowed for the note tail!! Indeed, it is *by definition* always with rel_x_pos = 1.
        return 1;
    }
    return 0;
}


// selection
void test_selection(t_notation_obj *r_ob)
{
#ifdef CONFIGURATION_Development
    // clear all the "selection"-linkedlist
    for (t_notation_item *temp = r_ob->firstselecteditem; temp; temp = temp->next_selected) {
        for (t_notation_item *temp2 = temp->next_selected; temp2; temp2 = temp2->next_selected) {
            if (temp == temp2) {
                char foo;
                foo = 7; // error
            }
        }
    }
#endif
}


// selection
void clear_selection(t_notation_obj *r_ob)
{
// clear all the "selection"-linkedlist
    t_notation_item *temp = r_ob->firstselecteditem;
    while (temp){
        t_notation_item *next = temp->next_selected;
        temp->prev_selected = temp->next_selected = NULL;
        temp->selected = false;
        temp = next;
    }
    r_ob->selection_type = k_NONE;
    r_ob->firstselecteditem = NULL;
    r_ob->lastselecteditem = NULL;
    r_ob->num_selecteditems = 0;
}

void clear_preselection(t_notation_obj *r_ob)
{
    t_notation_item *temp = r_ob->firstpreselecteditem;
    while (temp){
        t_notation_item *next = temp->next_preselected;
        temp->prev_preselected = temp->next_preselected = NULL;
        temp->preselected = false;
        temp = next;
    }
    r_ob->firstpreselecteditem = NULL;
    r_ob->lastpreselecteditem = NULL;
}

void clear_voice_selection(t_notation_obj *r_ob, long voice_num){
    // clear all the "selection"-linkedlist
    t_notation_item *temp2, *temp = r_ob->firstselecteditem;
    while (temp){
        char to_delete = false;
        temp2 = temp->next_selected;
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            if (temp->type == k_CHORD && ((t_chord *)temp)->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_NOTE && ((t_note *)temp)->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_DURATION_TAIL && ((t_note *)temp)->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_PITCH_BREAKPOINT && ((t_bpt *)temp)->owner->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
            if (temp->type == k_CHORD && ((t_chord *)temp)->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_NOTE && ((t_note *)temp)->parent->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_DURATION_TAIL && ((t_note *)temp)->parent->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_PITCH_BREAKPOINT && ((t_bpt *)temp)->owner->parent->parent->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
            else if (temp->type == k_MEASURE && ((t_measure *)temp)->voiceparent->v_ob.number == voice_num) 
                to_delete  = true;
        }
        if (to_delete)
            notation_item_delete_from_selection(r_ob, temp);
        temp = temp2;
    }
    r_ob->selection_type = get_selected_items_common_type(r_ob);
}

long get_selected_items_common_type(t_notation_obj *r_ob){
    // let's check if the selected items are all of the same kind, or not!
    if (r_ob->firstselecteditem){
        t_notation_item *temp = r_ob->firstselecteditem; 
        long this_type = r_ob->firstselecteditem ? r_ob->firstselecteditem->type : k_NONE;
        while (temp){
            if (temp->type != this_type){
                if (((temp->type == k_PITCH_BREAKPOINT) && (this_type == k_DURATION_TAIL)) ||
                    ((temp->type == k_DURATION_TAIL) && (this_type == k_PITCH_BREAKPOINT)) || 
                    ((temp->type == k_PITCH_BREAKPOINT) && (this_type == k_PITCH_BREAKPOINT_OR_DURATION_TAIL)) ||
                    ((temp->type == k_DURATION_TAIL) && (this_type == k_PITCH_BREAKPOINT_OR_DURATION_TAIL))) {
                    this_type = k_PITCH_BREAKPOINT_OR_DURATION_TAIL;
                } else {
                    this_type = k_MIXED;
                    break;
                }
            }
            temp = temp->next_selected;
        }
        return this_type;
    }
    return 0;
}


char item_type_has_names(e_element_types item_type)
{
    switch (item_type) {
        case k_CHORD:
        case k_NOTE:
        case k_MEASURE:
        case k_VOICE:
        case k_TEMPO:
        case k_MARKER:
            return true;
            break;
        default:
            return false;
            break;
    }
}

t_notation_item *notation_item_retrieve_from_ID(t_notation_obj *r_ob, long ID)
{
    return (t_notation_item *) shashtable_retrieve(r_ob->IDtable, ID);
}

t_notation_item *notation_item_get_first_selected_account_for_lambda(t_notation_obj *r_ob, char lambda)
{
    return lambda ? notation_item_retrieve_from_ID(r_ob, r_ob->lambda_selected_item_ID) : r_ob->firstselecteditem;
}

void notation_item_init(t_notation_item *it, e_element_types item_type)
{ 
    it->ID = 0;
    it->names = item_type_has_names(item_type) ? llll_get() : NULL;
    it->label_families = item_type_has_names(item_type) ? llll_get() : NULL;
    it->group = NULL;
    it->next_selected = it->prev_selected = it->next_preselected = it->prev_preselected = NULL;
    it->next_group_item = it->prev_group_item = NULL;
    it->selected = it->preselected = false;
    it->type = item_type;
    it->flags = (e_bach_internal_notation_flags) 0;
}

void notation_item_clone(t_notation_obj *r_ob, t_notation_item *new_it, t_notation_item *old_it)
{
    notation_item_init(new_it, old_it->type);
    
    // cloning groups
    if (old_it->group)
        append_element_in_group(r_ob, old_it->group, new_it);

    // cloning names
    llll_free(new_it->names); 
    new_it->names = llll_clone(old_it->names);
    t_llllelem *elem; 
    for (elem = old_it->label_families->l_head; elem; elem = elem->l_next) {
        t_llll *ll = hatom_getllll(&elem->l_hatom);
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
        t_llllelem *app = llll_appendobj(fam->items, new_it, 0, WHITENULL_llll);
        llll_appendllll(new_it->label_families, obj_couple_to_llll(fam, app), 0, WHITENULL_llll);
        fam->need_update_contour = true;
    }
    
//    verbose_post_label_families(r_ob);
}

/*
t_notationel build_notationel(void *item_pointer, char item_type){ 
    t_notationel el;
    el.item = item_pointer;
    el.type = item_type;
    el.prev = el.next = NULL;
    return el;
}

t_notationel* build_notationel_mem(void *item_pointer, char item_type){ 
// constructor for the _selecteditem structure. Leave parent and grandparent null, there aren't any 
    t_notationel *thnotation_item_is_selected = (t_notationel *)bach_newptr(sizeof(t_notationel));
    thnotation_item_is_selected->item = item_pointer;
    thnotation_item_is_selected->type = item_type;
    thnotation_item_is_selected->next = NULL;
    thnotation_item_is_selected->prev = NULL;
    return thnotation_item_is_selected;
}*/

t_notation_item* notation_item_add_to_preselection(t_notation_obj *r_ob, t_notation_item *item){
// add an item to the "preselection"-linkedlist
    if (item && !item->preselected) {
        if (r_ob->firstpreselecteditem) { // put the item at the end of the list
            item->next_preselected = NULL;
            item->prev_preselected = r_ob->lastpreselecteditem;
            r_ob->lastpreselecteditem->next_preselected = item;
            r_ob->lastpreselecteditem = item;
        } else { // there were no selected items
            r_ob->firstpreselecteditem = item;
            r_ob->lastpreselecteditem = r_ob->firstpreselecteditem;
            r_ob->firstpreselecteditem->prev_preselected = NULL; 
            r_ob->firstpreselecteditem->next_preselected = NULL; 
        }
        
        item->preselected = true;
    }
    
    return item;
}

void notation_item_delete_from_preselection(t_notation_obj *r_ob, t_notation_item *item){
// delete an item from the "selection"-linkedlist
    if (item) {

        // removing the element
        if (item->prev_preselected) {
            item->prev_preselected->next_preselected = item->next_preselected;
        } else { // item is the first item in the list 
            r_ob->firstpreselecteditem = item->next_preselected;
        }
        
        if (item->next_preselected) {
            item->next_preselected->prev_preselected = item->prev_preselected;
        } else { // item is the last item in the list 
            r_ob->lastpreselecteditem = item->prev_preselected;
        }
        item->prev_preselected = item->next_preselected = NULL;
        
        item->preselected = false;
    }
}

t_notation_item* notation_item_add_to_selection(t_notation_obj *r_ob, t_notation_item *item){
// add an item to the "selection"-linkedlist
    if (item && !item->selected) {
    
        // adding the element to the selection linked list
        r_ob->num_selecteditems++; // increase the # of sel items
        if (r_ob->firstselecteditem) { // put the item at the end of the list
            item->next_selected = NULL;
            item->prev_selected = r_ob->lastselecteditem;
            r_ob->lastselecteditem->next_selected = item;
            r_ob->lastselecteditem = item;
        } else { // no selected items
            r_ob->firstselecteditem = item;
            r_ob->lastselecteditem = r_ob->firstselecteditem;
            r_ob->firstselecteditem->prev_selected = NULL; 
            r_ob->firstselecteditem->next_selected = NULL; 
        }
        
        item->selected = true; 
    } 
    
    return item;
}

long notation_item_is_preselected(t_notation_obj *r_ob, t_notation_item *item)
{
    return item->preselected;
}

long notation_item_is_selected(t_notation_obj *r_ob, t_notation_item *item)
{
    return item->selected;
}


long are_all_selecteditems_tied_to_chord(t_notation_obj *r_ob, t_chord *ch)
{
    t_chord *first = chord_get_first_in_tieseq(ch);
    t_chord *last = chord_get_last_in_tieseq(ch);
    if (first && last && first != last && r_ob->firstselecteditem != r_ob->lastselecteditem) {
        for (t_notation_item *it = r_ob->firstselecteditem; it; it = it->next_selected) {
            char found = 0;
            for (t_chord *temp = first; temp; temp = chord_get_next(temp)) {
                if ((t_notation_item *)temp == it) { // found!
                    found = 1;
                    break;
                }
                if (temp == last)
                    break;
            }
            if (!found)
                return 0;
        }
        return 1;
    }
    return 0;
}


long are_all_selecteditems_tied_to_note(t_notation_obj *r_ob, t_note *nt)
{
    t_note *first = note_get_first_in_tieseq(nt);
    t_note *last = note_get_last_in_tieseq(nt);
    if (first && last && first != last && r_ob->firstselecteditem != r_ob->lastselecteditem) {
        for (t_notation_item *it = r_ob->firstselecteditem; it; it = it->next_selected) {
            char found = 0;
            for (t_note *temp = first; temp && temp != WHITENULL; temp = temp->tie_to) {
                if (it->type == k_NOTE) {
                    if ((t_notation_item *)temp == it) { // found!
                        found = 1;
                        break;
                    }
                } else if (it->type == k_CHORD && ((t_chord *)it)->num_notes == 1) {
                    if (temp == ((t_chord *)it)->firstnote) { // found!
                        found = 1;
                        break;
                    }
                }
                if (temp == last)
                    break;
            }
            if (!found)
                return 0;
        }
        return 1;
    }
    return 0;
}



e_selection_modes symbol_to_mode(t_notation_obj *r_ob, t_symbol *s)
{
    if (s == _llllobj_sym_sel)
        return k_SELECTION_MODE_FORCE_SELECT;
    
    if (s == _llllobj_sym_unsel)
        return k_SELECTION_MODE_FORCE_UNSELECT;

    if (s == _llllobj_sym_subsel)
        return k_SELECTION_MODE_INTERSECT_WITH_SELECTION;

    return k_SELECTION_MODE_INVOLUTIVE;
}

// mode is one of the e_selection_modes
void move_preselecteditems_to_selection(t_notation_obj *r_ob, e_selection_modes mode, char use_groups, char add_all_tied_notes)
{
// merge the "preselection" linkedlist with the "selection"-linkedlist
    
    t_notation_item *this_notation_item_preselected2 = r_ob->firstpreselecteditem;
    while (this_notation_item_preselected2) {
        // let's see if the object is already selected
        char el_is_selected = notation_item_is_selected(r_ob, this_notation_item_preselected2);
        long type = this_notation_item_preselected2->type;
        
        if (mode == k_SELECTION_MODE_INTERSECT_WITH_SELECTION && (el_is_selected || (type == k_NOTE && notation_item_is_selected(r_ob, (t_notation_item *)((t_note *)this_notation_item_preselected2)->parent)))) {
            
            if (el_is_selected) {
                // mark selected element as the one to be kept!
                this_notation_item_preselected2->flags |= k_FLAG_TO_BE_KEPT;
            } else {
                // explode selected chord into series of selected notes.
                this_notation_item_preselected2->flags |= k_FLAG_TO_BE_KEPT;
                ((t_note *)this_notation_item_preselected2)->parent->r_it.flags |= k_FLAG_TO_BE_MODIFIED;
            }
            
            
        } else if (el_is_selected && mode != k_SELECTION_MODE_FORCE_SELECT) {
                // item was selected: will be deselected!
                notation_item_delete_from_selection(r_ob, this_notation_item_preselected2);
        } else if (!el_is_selected) { // ELEMENT WAS NOT SELECTED
            
            if (mode == k_SELECTION_MODE_INTERSECT_WITH_SELECTION) {
                // nothing to do: we only intersect with selection!
            } else if (this_notation_item_preselected2->type == k_NOTE && notation_item_is_selected(r_ob, (t_notation_item *)((t_note *)this_notation_item_preselected2)->parent)) {
                if (mode != k_SELECTION_MODE_FORCE_SELECT) {
                    t_chord *ch = ((t_note *)this_notation_item_preselected2)->parent;
                    t_note *nt;
                    notation_item_delete_from_selection(r_ob, (t_notation_item *)((t_note *)this_notation_item_preselected2)->parent);
                    for (nt = ch->firstnote; nt; nt = nt->next)
                        if (nt != (t_note *)this_notation_item_preselected2)
                            notation_item_add_to_selection(r_ob, (t_notation_item *)nt);
                }
            } else if (this_notation_item_preselected2->type == k_PITCH_BREAKPOINT && notation_item_is_globally_selected(r_ob, (t_notation_item *)((t_bpt *)this_notation_item_preselected2)->owner)) {
                // nothing to do: note is already selected
            } else if (this_notation_item_preselected2->type == k_DURATION_TAIL && notation_item_is_globally_selected(r_ob, this_notation_item_preselected2)) {
                // nothing to do: note is already selected
            } else if (mode != k_SELECTION_MODE_FORCE_UNSELECT){
                // item was NOT selected: we add it at the end of the list
                notation_item_add_to_selection(r_ob, this_notation_item_preselected2);
                // check if breakpoints or tail were selected
                if (this_notation_item_preselected2->type == k_NOTE) {
                    t_bpt *bpt;
                    for (bpt = ((t_note *)this_notation_item_preselected2)->firstbreakpoint; bpt; bpt = bpt->next){
                        if (notation_item_is_selected(r_ob, (t_notation_item *)bpt))
                            notation_item_delete_from_selection(r_ob, (t_notation_item *)bpt);
                    }
                }
                
                if (this_notation_item_preselected2->type == k_NOTE) {
                    // check if all notes of a chord are selected
                    long count_notes_in_region = 0;
                    t_note *nt = ((t_note *)this_notation_item_preselected2);
                    t_chord *ch = ((t_note *)this_notation_item_preselected2)->parent;
                    t_note *curr_nt;
                    for (curr_nt = ch->firstnote; curr_nt; curr_nt = curr_nt->next ) // cycle on the notes: we count how many notes are inside the selection
                        if (notation_item_is_selected(r_ob, (t_notation_item *)curr_nt)) // note already selected
                            count_notes_in_region++;
                    
                    
                    if (count_notes_in_region == ch->num_notes) { // whole chord has been selected!
                        for (curr_nt = ch->firstnote; curr_nt; curr_nt = curr_nt->next ) // cycle on the notes: we count how many notes are inside the selection
                            notation_item_delete_from_selection(r_ob, (t_notation_item *)curr_nt);
                        notation_item_add_to_selection(r_ob, (t_notation_item *)ch);
                    } else {
                        
                        // check if any of the note breakpoints are selected, in which case, we deselect them since the whole note was selected
                        if (nt->num_breakpoints > 2) {
                            t_bpt *bpt;
                            for (bpt = ((t_note *)this_notation_item_preselected2)->firstbreakpoint; bpt; bpt = bpt->next)
                                if (notation_item_is_selected(r_ob, (t_notation_item *)bpt))
                                    notation_item_delete_from_selection(r_ob, (t_notation_item *)bpt);
                        }
                    }
                }
            }
        }
        this_notation_item_preselected2 = this_notation_item_preselected2->next_preselected;
    }

    // if mode is intersection, delete remaining selected items
    if (mode == k_SELECTION_MODE_INTERSECT_WITH_SELECTION) {
        t_notation_item *temp = r_ob->firstselecteditem;
        t_llll *toadd = llll_get();
        while (temp) {
            t_notation_item *nexttemp = temp->next_selected;
            if (temp->flags & k_FLAG_TO_BE_KEPT) {
                temp->flags &= ~k_FLAG_TO_BE_KEPT;
            } else if (temp->type == k_CHORD && temp->flags & k_FLAG_TO_BE_MODIFIED) {
                t_note *nt;
                t_chord *ch = (t_chord *)temp;
                char all_notes_to_be_kept = true;
                for (nt = ch->firstnote; nt; nt = nt->next) {
                    if (!(nt->r_it.flags & k_FLAG_TO_BE_KEPT)) {
                        all_notes_to_be_kept = false;
                        break;
                    }
                }
                if (!all_notes_to_be_kept) {
                    notation_item_delete_from_selection(r_ob, temp);
                    for (nt = ch->firstnote; nt; nt = nt->next)
                        if (nt->r_it.flags & k_FLAG_TO_BE_KEPT)
                            llll_appendobj(toadd, nt);
                }
                
                for (nt = ch->firstnote; nt; nt = nt->next)
                    nt->r_it.flags &= ~k_FLAG_TO_BE_KEPT;
                temp->flags &= ~k_FLAG_TO_BE_MODIFIED;
            } else {
                notation_item_delete_from_selection(r_ob, temp);
            }
            temp = nexttemp;
        }
        for (t_llllelem *el = toadd->l_head; el; el = el->l_next)
            notation_item_add_to_selection(r_ob, (t_notation_item *)hatom_getobj(&el->l_hatom));
        llll_free(toadd);
    }

    // group checking
    if (use_groups) { // r_ob->firstselecteditem
        this_notation_item_preselected2 = r_ob->firstpreselecteditem;
        while (this_notation_item_preselected2) {
            t_chord *groupch = NULL;
            if (this_notation_item_preselected2->type == k_NOTE)
                groupch = ((t_note *)this_notation_item_preselected2)->parent;
            else if (this_notation_item_preselected2->type == k_CHORD)
                groupch = (t_chord *)this_notation_item_preselected2;
            if (groupch && groupch->r_it.group){
                char is_selected = false;
                if (this_notation_item_preselected2->type == k_NOTE)
                    is_selected = notation_item_is_selected(r_ob, this_notation_item_preselected2) || notation_item_is_selected(r_ob, (t_notation_item *)((t_note *)this_notation_item_preselected2)->parent);
                else if (this_notation_item_preselected2->type == k_CHORD)
                    is_selected = notation_item_is_selected(r_ob, (t_notation_item *)groupch);
                
                t_notation_item *el;
                for (el = groupch->r_it.group->firstelem; el; el = el->next_group_item){
                    if (el->type == k_CHORD){
                        if (is_selected) {
                            if (!notation_item_is_selected(r_ob, el)) {
                                t_note *nt;
                                for (nt = ((t_chord *)el)->firstnote; nt; nt = nt->next)
                                    if (notation_item_is_selected(r_ob, (t_notation_item *)nt))
                                        notation_item_delete_from_selection(r_ob, (t_notation_item *)nt);
                                notation_item_add_to_selection(r_ob, el);
                            }
                        } else {
                            if (notation_item_is_selected(r_ob, el)) {
                                notation_item_delete_from_selection(r_ob, el);
                            } else {
                                t_note *nt;
                                for (nt = ((t_chord *)el)->firstnote; nt; nt = nt->next)
                                    if (notation_item_is_selected(r_ob, (t_notation_item *)nt))
                                        notation_item_delete_from_selection(r_ob, (t_notation_item *)nt);
                            }
                        }
                    }
                }
            }
            this_notation_item_preselected2 = this_notation_item_preselected2->next_preselected;
        }
        
    }
    
    // add all tied notes of selected notes
    if (add_all_tied_notes) {
        t_llll *chords_to_be_checked = llll_get();
        
        this_notation_item_preselected2 = r_ob->firstpreselecteditem;
        while (this_notation_item_preselected2) {
            if (this_notation_item_preselected2->type == k_NOTE) {
                t_note *this_note = ((t_note *)this_notation_item_preselected2);
                t_note *first_tied = note_get_first_in_tieseq(this_note);
                t_note *last_tied = note_get_last_in_tieseq(this_note);
                if (this_note && first_tied && last_tied) {
                    t_note *temp_note;
                    for (temp_note = first_tied; temp_note && temp_note != WHITENULL; temp_note = temp_note->tie_to) {
                        if (temp_note == this_note) continue;
                        
                        char is_selected = notation_item_is_selected(r_ob, (t_notation_item *)temp_note) || notation_item_is_selected(r_ob, (t_notation_item *)temp_note->parent);
                        if (!is_selected) {
                            llll_appendobj(chords_to_be_checked, temp_note->parent);
                            notation_item_add_to_selection(r_ob, (t_notation_item *)temp_note);
                        }
                        
                        if (temp_note == last_tied) break;
                    }
                }
            } else if (this_notation_item_preselected2->type == k_CHORD) {
                t_note *this_note;
                for (this_note = ((t_chord *)this_notation_item_preselected2)->firstnote; this_note; this_note = this_note->next) {
                    t_note *first_tied = note_get_first_in_tieseq(this_note);
                    t_note *last_tied = note_get_last_in_tieseq(this_note);
                    if (this_note && first_tied && last_tied) {
                        t_note *temp_note;
                        for (temp_note = first_tied; temp_note && temp_note != WHITENULL; temp_note = temp_note->tie_to) {
                            if (temp_note == this_note) continue;
                            
                            char is_selected = notation_item_is_selected(r_ob, (t_notation_item *)temp_note) || notation_item_is_selected(r_ob, (t_notation_item *)temp_note->parent);
                            if (!is_selected) {
                                llll_appendobj(chords_to_be_checked, temp_note->parent);
                                notation_item_add_to_selection(r_ob, (t_notation_item *)temp_note);
                            }
                            
                            if (temp_note == last_tied) break;
                        }
                    }
                }
            }
            this_notation_item_preselected2 = this_notation_item_preselected2->next_preselected;
        }
        
        
        // checking if now we have unselected chords with all their notes selected
        t_llllelem *elem;
        for (elem = chords_to_be_checked->l_head; elem; elem = elem->l_next) {
            t_chord *chord = (t_chord *)hatom_getobj(&elem->l_hatom);
            if (notation_item_is_selected(r_ob, (t_notation_item *)chord)) {
                // possibly removing its notes
            } else if (chord->firstnote && are_all_notes_in_chord_selected(r_ob, chord)) {
                t_note *note;
                for (note = chord->firstnote; note; note = note->next)
                    notation_item_delete_from_selection(r_ob, (t_notation_item *)note);
                notation_item_add_to_selection(r_ob, (t_notation_item *)chord);
            }
        }
        
        llll_free(chords_to_be_checked);
    }
    
    // check selection type (only notes? only chords? mixed...)
    r_ob->selection_type = get_selected_items_common_type(r_ob);

    // clear the preselection linkedlist
    clear_preselection(r_ob);
}


t_note *note_get_first_selected(t_notation_obj *r_ob)
{
    t_notation_item *selit = r_ob->firstselecteditem;
    for (selit = r_ob->firstselecteditem; selit; selit = selit->next_selected) {
        if (selit->type == k_NOTE)
            return (t_note *)selit;
    }
    return NULL;
}


t_chord *chord_get_first_selected(t_notation_obj *r_ob)
{
    t_notation_item *selit = r_ob->firstselecteditem;
    for (selit = r_ob->firstselecteditem; selit; selit = selit->next_selected) {
        if (selit->type == k_CHORD)
            return (t_chord *)selit;
    }
    return NULL;
}

t_dynamics *dynamics_get_first_selected(t_notation_obj *r_ob)
{
    t_notation_item *selit = r_ob->firstselecteditem;
    for (selit = r_ob->firstselecteditem; selit; selit = selit->next_selected) {
        if (selit->type == k_DYNAMICS)
            return (t_dynamics *)selit;
    }
    return NULL;
}


t_lyrics *lyrics_get_first_selected(t_notation_obj *r_ob)
{
    t_notation_item *selit = r_ob->firstselecteditem;
    for (selit = r_ob->firstselecteditem; selit; selit = selit->next_selected) {
        if (selit->type == k_LYRICS)
            return (t_lyrics *)selit;
    }
    return NULL;
}



long notationitem_onset_leq(void *data, t_llllelem *a, t_llllelem *b)
{
    t_notation_obj *r_ob = (t_notation_obj *)data;
    t_notation_item *a_it = (t_notation_item *)hatom_getobj(&a->l_hatom);
    t_notation_item *b_it = (t_notation_item *)hatom_getobj(&b->l_hatom);
    
    if (a_it && b_it) {
        double a_onset = notation_item_get_onset_ms(r_ob, a_it);
        double b_onset = notation_item_get_onset_ms(r_ob, b_it);
        if (a_onset < b_onset)
            return 1;
        else if (a_onset > b_onset)
            return 0;
        else { // markers before anything
            if (a_it->type != k_MARKER && b_it->type == k_MARKER)
                return 0;
            else
                return 1;
        }
    }
    
    return 1;
}

long notationitem_onset_geq(void *data, t_llllelem *a, t_llllelem *b)
{
    t_notation_obj *r_ob = (t_notation_obj *)data;
    t_notation_item *a_it = (t_notation_item *)hatom_getobj(&a->l_hatom);
    t_notation_item *b_it = (t_notation_item *)hatom_getobj(&b->l_hatom);
    
    if (a_it && b_it)
    {
        double a_onset = notation_item_get_onset_ms(r_ob, a_it);
        double b_onset = notation_item_get_onset_ms(r_ob, b_it);
        if (a_onset < b_onset)
            return 0;
        else if (a_onset > b_onset)
            return 1;
        else { // markers before anything
            if (a_it->type == k_MARKER && b_it->type != k_MARKER)
                return 0;
            else
                return 1;
        }
    }
    
    return 1;
}


void sort_selection(t_notation_obj *r_ob, char inverse_order)
{
    lock_general_mutex(r_ob);

    // sorting selection as llll
    t_llll *ll = llll_get();
    for (t_notation_item *it = r_ob->firstselecteditem; it; it = it->next_selected)
        llll_appendobj(ll, it);
    llll_inplacesort(ll, inverse_order ? (sort_fn)notationitem_onset_geq : (sort_fn)notationitem_onset_leq, r_ob);
    
    // clearing all selection
    t_notation_item *temp = r_ob->firstselecteditem;
    while (temp){
        t_notation_item *next = temp->next_selected;
        temp->prev_selected = temp->next_selected = NULL;
        temp->selected = false;
        temp = next;
    }
    r_ob->firstselecteditem = NULL;
    r_ob->lastselecteditem = NULL;
    r_ob->num_selecteditems = 0;
    
    // re-setting all selected items, one by one
    for (t_llllelem *el = ll->l_head; el; el = el->l_next) {
        notation_item_add_to_selection(r_ob, (t_notation_item *)hatom_getobj(&el->l_hatom));
    }
    
    llll_free(ll);

    unlock_general_mutex(r_ob);
}





char note_delete_breakpoints(t_notation_obj *r_ob, t_note *note){ 
//delete the breakpoints of a given note
    char changed = 0;
    t_bpt *bpt = note->firstbreakpoint;
    while (bpt) { // cycle on the selected items
        delete_breakpoint(r_ob, bpt);
        changed = 1;
        bpt = bpt->next;
    }
    if (note->firstbreakpoint)
        note->firstbreakpoint->velocity = note->lastbreakpoint->velocity = note->velocity;
    return changed;
}

char delete_breakpoints_in_selection(t_notation_obj *r_ob)
{
//delete breakpoints the selected region
    char changed = 0;
    t_notation_item *curr_it;
    lock_general_mutex(r_ob);    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        t_notation_item *next = curr_it->next_selected;
        if (curr_it->type == k_PITCH_BREAKPOINT) { // it is a note
            if (((t_bpt *)curr_it)->next) {    // not the note tail
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)((t_bpt *) curr_it)->owner->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                delete_breakpoint(r_ob, (t_bpt *) curr_it);
                changed = 1;
            }
        }
        curr_it = next;
    }
    clear_selection(r_ob);
    unlock_general_mutex(r_ob);    
    return changed;
}

char delete_all_breakpoints(t_notation_obj *r_ob, long voice_number)
{
    (r_ob->whole_obj_undo_tick_function)(r_ob);
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    lock_general_mutex(r_ob);
    if (voice_number >= 0) {
        voice = nth_voice(r_ob, voice_number);
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            for (note = chord->firstnote; note; note = note->next) {
                note_delete_breakpoints(r_ob, note);
            }
    } else {
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
            for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
                for (note = chord->firstnote; note; note = note->next) {
                    note_delete_breakpoints(r_ob, note);
                }
    }
    unlock_general_mutex(r_ob);
    return 1;
}

void delete_all_articulations_from_notation_item(t_notation_obj *r_ob, t_notation_item *owner)
{
    if (owner->type == k_CHORD) {
        t_chord *ch = (t_chord *) owner;
        ch->num_articulations = 0;
        bach_freeptr(ch->articulation);
        ch->articulation = NULL;
    } else if (owner->type == k_NOTE) {
        t_note *nt = (t_note *) owner;
        nt->num_articulations = 0;
        bach_freeptr(nt->articulation);
        nt->articulation = NULL;
        if (r_ob->link_articulations_to_slot > 0 && r_ob->link_articulations_to_slot <= CONST_MAX_SLOTS) {
            note_clear_slot(r_ob, nt, r_ob->link_articulations_to_slot - 1);
        }
    }
}

void delete_articulation_from_notation_item(t_notation_obj *r_ob, t_notation_item *owner, long articulation_number)
{
    void *articulation_owner = owner;
    long owner_type = owner->type; 
    long num_owner_articulations = 0; 
    long i;
    t_chord *ch = (owner_type == k_CHORD) ? ((t_chord *) articulation_owner) : ((t_note *) articulation_owner)->parent;

    if (owner_type == k_CHORD) 
        num_owner_articulations = ((t_chord *) articulation_owner)->num_articulations;
    else if (owner_type == k_NOTE)
        num_owner_articulations = ((t_note *) articulation_owner)->num_articulations;
        
    if (num_owner_articulations == 1) {
        delete_all_articulations_from_notation_item(r_ob, owner);

    } else {
        if (articulation_number >= 0 && num_owner_articulations > 0 && articulation_number < num_owner_articulations) {
            t_articulation **array = (owner_type == k_CHORD ? &((t_chord *) articulation_owner)->articulation : &((t_note *) articulation_owner)->articulation);
            if (articulation_number < num_owner_articulations - 1)
                bach_copyptr(*array + articulation_number + 1, *array + articulation_number, (num_owner_articulations - articulation_number - 1) * sizeof(t_articulation));
            
            for (i = 0; i < num_owner_articulations - 1; i++)
                (*array)[i].number = i;
            
            if (owner_type == k_CHORD)
                ((t_chord *) articulation_owner)->num_articulations = num_owner_articulations - 1;
            else if (owner_type == k_NOTE)
                ((t_note *) articulation_owner)->num_articulations =  num_owner_articulations - 1;
            
            *array = (t_articulation *)bach_resizeptr(*array, (num_owner_articulations - 1) * sizeof(t_articulation));
        }
        ch->bottommost_y_noacc = ch->topmost_y_noacc = -1;
        reset_articulation_position_for_chord(r_ob, ch);
    }
}


char delete_articulations_in_selection(t_notation_obj *r_ob)
{
    char changed = 0;
    t_notation_item *curr_it;
    lock_general_mutex(r_ob);    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items

        if (!notation_item_is_globally_locked(r_ob, curr_it)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            
            if (curr_it->type == k_NOTE) { // it is a note
                delete_all_articulations_from_notation_item(r_ob, curr_it);
                changed = 1;
                curr_it = curr_it->next_selected;
            } else if (curr_it->type == k_CHORD) {
                t_chord *ch = ((t_chord *)curr_it);
                t_note *nt;
                delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)ch);
                changed = 1;
                for (nt = ch->firstnote; nt; nt = nt->next)
                    delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)nt);
                curr_it = curr_it->next_selected;
            } else if (curr_it->type == k_MEASURE) {
                t_measure *meas = ((t_measure *)curr_it);
                t_chord *ch; t_note *nt;
                changed = 1;
                for (ch = meas->firstchord; ch; ch = ch->next) {
                    delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)ch);
                    for (nt = ch->firstnote; nt; nt = nt->next)
                        delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)nt);
                }
                curr_it = curr_it->next_selected;
                
            } else if (curr_it->type == k_ARTICULATION) {
                t_notation_item *temp = curr_it->next_selected;
                t_articulation *art = ((t_articulation *)curr_it);
                t_notation_item *owner = art->owner;
                t_chord *ch = (owner->type == k_NOTE) ? ((t_note *) owner)->parent : ((t_chord *) owner);
                notation_item_delete_from_selection(r_ob, curr_it);
                
                // OLD WAY
                delete_articulation_from_notation_item(r_ob, owner, art->number);
                if (owner->type == k_NOTE) {
                    ((t_note *)owner)->parent->bottommost_y_noacc = ((t_note *)owner)->parent->topmost_y_noacc = -1;
                } else if (owner->type == k_CHORD) {
                    ((t_chord *)owner)->bottommost_y_noacc = ((t_chord *)owner)->topmost_y_noacc = -1;
                }
                
                // NEW WAY
                if (r_ob->link_articulations_to_slot > 0 && r_ob->link_articulations_to_slot <= CONST_MAX_SLOTS) {
                    long s = r_ob->link_articulations_to_slot - 1;
                    if (r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS && art->parent)
                        slotitem_delete(r_ob, s, art->parent);
                }
                
                changed = 1;
                ch->topmost_y_noacc = ch->bottommost_y_noacc = -1;
                curr_it = temp;
            } else
                curr_it = curr_it->next_selected;
        } else
            curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}

t_articulation *build_articulation(t_notation_obj *r_ob, long articulation_ID, t_notation_item *owner, t_slotitem *parent, t_symbol *original_name)
{
    t_articulation *art = (t_articulation *)bach_newptrclear(sizeof(t_articulation)); // all positions are set to 0 here, via the clear part
    art->articulation_ID = articulation_ID;
    art->need_recompute_position = true;
    art->number = 0;
    art->owner = owner;
    art->parent = parent;
    art->original_name = original_name;
        
    notation_item_init(&art->r_it, k_ARTICULATION);
    return art;
}

void destroy_articulation(t_articulation *art)
{
    bach_freeptr(art);
}


void add_articulation_to_notation_item(t_notation_obj *r_ob, t_notation_item *item, long articulation_ID)
{
    // OLD WAY!!!
/*    if (item->type == k_CHORD) {
        t_chord *ch = (t_chord *)item;
        if (ch->num_articulations == 0)
            ch->articulation = (t_articulation *)bach_newptr(sizeof(t_articulation));
        else
            ch->articulation = (t_articulation *)bach_resizeptr(ch->articulation, (ch->num_articulations + 1) * sizeof(t_articulation));
        ch->articulation[ch->num_articulations].articulation_ID = articulation_ID;
        ch->articulation[ch->num_articulations].need_recompute_position = true;
        ch->articulation[ch->num_articulations].number = ch->num_articulations;
        ch->articulation[ch->num_articulations].owner = (t_notation_item *)ch;
        ch->articulation[ch->num_articulations].parent = NULL;
        notation_item_init(&ch->articulation[ch->num_articulations].r_it, k_ARTICULATION);
        ch->num_articulations++;
    } else if (item->type == k_NOTE) {
        t_note *nt = (t_note *)item;
        if (nt->num_articulations == 0)
            nt->articulation = (t_articulation *)bach_newptr(sizeof(t_articulation));
        else
            nt->articulation = (t_articulation *)bach_resizeptr(nt->articulation, (nt->num_articulations + 1) * sizeof(t_articulation));
        nt->articulation[nt->num_articulations].articulation_ID = articulation_ID;
        nt->articulation[nt->num_articulations].need_recompute_position = true;
        nt->articulation[nt->num_articulations].number = nt->num_articulations;
        nt->articulation[nt->num_articulations].owner = (t_notation_item *)nt;
        nt->articulation[nt->num_articulations].parent = NULL;
        notation_item_init(&nt->articulation[nt->num_articulations].r_it, k_ARTICULATION);
        nt->num_articulations++;
    }
 */
    
    // NEW WAY: via Slot-linkage ;-)

    if (item->type == k_CHORD && ((t_chord *)item)->lastnote)
        item = (t_notation_item *)((t_chord *)item)->lastnote;
    else if (item->type != k_CHORD && item->type != k_NOTE)
        item = NULL;

    if (item) {
        long s = r_ob->link_articulations_to_slot - 1;
        t_slot *slot = notation_item_get_slot(r_ob, item, s);
        if (slot && s >= 0 && s < CONST_MAX_SLOTS && r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS) {
            t_slotitem *thisitem = build_slotitem(r_ob, slot);
            t_articulation *art = build_articulation(r_ob, articulation_ID, item, thisitem, notationobj_articulation_id2symbol(r_ob, articulation_ID));
            thisitem->item = art;
            slotitem_append(thisitem);
            reset_articulation_position_for_chord(r_ob, notation_item_get_parent_chord(r_ob, item));
        }
    }
}

char add_articulation_to_selected_elements(t_notation_obj *r_ob, long articulation_ID)
{
    char changed = 0;
    t_notation_item *curr_it;
    lock_general_mutex(r_ob);    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        
        if (!notation_item_is_globally_locked(r_ob, curr_it)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            
            if (curr_it->type == k_CHORD) {
                add_articulation_to_notation_item(r_ob, curr_it, articulation_ID);
                changed = 1;
            } else if (curr_it->type == k_NOTE) {
                add_articulation_to_notation_item(r_ob, curr_it, articulation_ID);
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}

char reset_selection_breakpoint_slope(t_notation_obj *r_ob){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_PITCH_BREAKPOINT) { // it is a breakpoint
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)((t_bpt *)curr_it)->owner->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            ((t_bpt *)curr_it)->slope = 0.;
            changed = 1;
        }
        curr_it = curr_it->next_selected;
    }
    return changed;
}

void llll_append_notationitem_flag_raw(t_notation_obj *r_ob, t_llll *ll, t_notation_item *item)
{
#ifdef BACH_OUTPUT_SYMBOLIC_FLAGS
    llll_appendsym(ll, get_element_flag_as_symbol(r_ob, item));
#else
    llll_appendlong(ll, get_element_flag(r_ob, item));
#endif
}

t_llll *get_multiple_flags_for_undo(t_notation_obj *r_ob, t_notation_item *father_item)
{
    t_llll *out = llll_get();
    llll_append_notationitem_flag_raw(r_ob, out, father_item);
    if (father_item->type == k_CHORD) {
        t_note *nt;
        t_llll *subllll = llll_get();
        for (nt = ((t_chord *)father_item)->firstnote; nt; nt = nt->next)
            llll_append_notationitem_flag_raw(r_ob, subllll, (t_notation_item *)nt);
        llll_appendllll(out, subllll, 0, WHITENULL_llll);
    }
    return out;
}

void set_multiple_flags_from_llll_for_undo(t_notation_obj *r_ob, t_llll *ll, t_notation_item *father_item)
{
    t_llllelem *elem;
    
    if (!ll || !ll->l_head)
        return;
    
    if (father_item->type == k_CHORD) {
        t_note *nt;
        elem = ll->l_head;
        
        notation_item_set_flags_from_llllelem(r_ob, elem, father_item, false);
        if (elem->l_next && hatom_gettype(&elem->l_next->l_hatom) == H_LLLL) {
            t_llllelem *subelem;
            for (nt = ((t_chord *)father_item)->firstnote, subelem = hatom_getllll(&elem->l_next->l_hatom)->l_head; nt && subelem; nt = nt->next, subelem = subelem->l_next)
                notation_item_set_flags_from_llllelem(r_ob, subelem, (t_notation_item *)nt, false);
        }
    } else 
        notation_item_set_flags_from_llllelem(r_ob, ll->l_head, father_item, false);
}


// beware!! DESTRUCTIVE: destroys *elem ONLY if it is really a mutelock flag 
char notation_item_set_flags_from_llllelem(t_notation_obj *r_ob, t_llllelem *elem, t_notation_item *item, char destroy_flag_llllelem){
    if (elem && (hatom_gettype(&elem->l_hatom) == H_LONG || hatom_gettype(&elem->l_hatom) == H_SYM)) {
        long flags = hatom_gettype(&elem->l_hatom) == H_LONG ? hatom_getlong(&elem->l_hatom) : symbol2notationitemflag(hatom_getsym(&elem->l_hatom));
        char locked = (flags & k_FLAG_ELEMENT_LOCKED) ? 1 : 0;
        char muted = (flags & k_FLAG_ELEMENT_MUTED) ? 1 : 0;
        char solo = (flags & k_FLAG_ELEMENT_SOLO) ? 1 : 0;
        char tree_locked = (flags & k_FLAG_ELEMENT_BEAMING_TREE_LOCKED) ? 1 : 0;
        if (item->type == k_MEASURE) {
            ((t_measure *) item)->locked = locked;
            ((t_measure *) item)->muted = muted;
            ((t_measure *) item)->solo = solo;
            ((t_measure *) item)->lock_rhythmic_tree = tree_locked;
        } else if (item->type == k_CHORD) {
            ((t_chord *) item)->locked = locked;
            ((t_chord *) item)->muted = muted;
            ((t_chord *) item)->solo = solo;
        } else if (item->type == k_NOTE) {
            ((t_note *) item)->locked = locked;
            ((t_note *) item)->muted = muted;
            ((t_note *) item)->solo = solo;
        } else if (item->type == k_VOICE) {
            ((t_voice *) item)->locked = locked;
            ((t_voice *) item)->muted = muted;
            ((t_voice *) item)->solo = solo;
        }
        if (destroy_flag_llllelem)
            llll_destroyelem(elem);
        return 1;
    } else {
        if (item->type == k_MEASURE){
            ((t_measure *) item)->locked = false;
            ((t_measure *) item)->muted = false;
            ((t_measure *) item)->solo = false;
            ((t_measure *) item)->lock_rhythmic_tree = false;
        } else if (item->type == k_CHORD){
            ((t_chord *) item)->locked = false;
            ((t_chord *) item)->muted = false;
            ((t_chord *) item)->solo = false;
        } else if (item->type == k_NOTE){
            ((t_note *) item)->locked = false;
            ((t_note *) item)->muted = false;
            ((t_note *) item)->solo = false;
        } else if (item->type == k_VOICE){
            ((t_voice *) item)->locked = false;
            ((t_voice *) item)->muted = false;
            ((t_voice *) item)->solo = false;
        }
        return 0;
    }
}

char reset_selection_tail_gliss(t_notation_obj *r_ob){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_PITCH_BREAKPOINT && !((t_bpt *)curr_it)->next) { // it is a duration tail
            t_note *note = ((t_bpt *)curr_it)->owner;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            note->lastbreakpoint->slope = 0.;
            note->lastbreakpoint->delta_mc = 0.;
            changed = 1;
        }
        curr_it = curr_it->next_selected;
    }
    return changed;
}

// type > 0: delete only those elements, type < 0: keep only those elements
void delete_item_type_from_selection(t_notation_obj *r_ob, long type) {
    t_notation_item *item = r_ob->firstselecteditem;
    while (item) {
        t_notation_item *next = item->next_selected;
        if ((type > 0 && item->type == type) || (type < 0 && item->type != -type)) 
            notation_item_delete_from_selection(r_ob, item);
        item = next;
    }
}

void notation_item_delete_from_selection(t_notation_obj *r_ob, t_notation_item *item){
    // delete an item from the "selection"-linkedlist
    if (item && item->selected) {
        if (r_ob->selectioncursor == item)
            r_ob->selectioncursor = item->next_selected;
        
        if (item->prev_selected) {
            item->prev_selected->next_selected = item->next_selected;
        } else { // item is the first item in the list 
            r_ob->firstselecteditem = item->next_selected;
        }
        if (item->next_selected) {
            item->next_selected->prev_selected = item->prev_selected;
        } else { // item is the last item in the list 
            r_ob->lastselecteditem = item->prev_selected;
        }
        
        // decrease the number of selected items
        r_ob->num_selecteditems--;
        
        item->selected = false;
        
        // let's check if the selected items are all of the same kind
        r_ob->selection_type = get_selected_items_common_type(r_ob);
    }
}

// llll communication

t_llll* get_commands_values_as_llll(t_notation_obj *r_ob, char bw_compatible)
{
    int j;
    t_llll* out_llll = llll_get();

    llll_appendsym(out_llll, _llllobj_sym_commands, 0, WHITENULL_llll);
    
    for (j=0; j < (bw_compatible ? 5 : CONST_MAX_COMMANDS); j++) {
        t_llll* inner_llll = llll_get(); 
        t_llll *note = llll_get(), *chord = llll_get(), *rest = llll_get(), *key = llll_get();
        
        llll_appendlong(inner_llll, j + 1, 0, WHITENULL_llll); // command number, 1-based
        
        llll_appendsym(note, _llllobj_sym_note, 0, WHITENULL_llll); // command for note
        llll_appendsym(note, r_ob->command_note[j] ? r_ob->command_note[j] : _llllobj_sym_note, 0, WHITENULL_llll);
        llll_appendllll(inner_llll, note, 0, WHITENULL_llll);

        llll_appendsym(chord, _llllobj_sym_chord, 0, WHITENULL_llll); // command for chord
        llll_appendsym(chord, r_ob->command_chord[j] ? r_ob->command_chord[j] : _llllobj_sym_chord, 0, WHITENULL_llll); // command for chord
        llll_appendllll(inner_llll, chord, 0, WHITENULL_llll);

        llll_appendsym(rest, _llllobj_sym_rest, 0, WHITENULL_llll); // command for rest
        llll_appendsym(rest, r_ob->command_rest[j] ? r_ob->command_rest[j] : _llllobj_sym_rest, 0, WHITENULL_llll); // command for chord
        llll_appendllll(inner_llll, rest, 0, WHITENULL_llll);

        char key_char[2];
        key_char[0] = r_ob->command_key[j];
        key_char[1] = 0;
        llll_appendsym(key, _llllobj_sym_key, 0, WHITENULL_llll); // hot key
        if (r_ob->command_key[j] > 0)
            llll_appendsym(key, gensym(key_char), 0, WHITENULL_llll);
        else 
            llll_appendlong(key, 0, 0, WHITENULL_llll);
        llll_appendllll(inner_llll, key, 0, WHITENULL_llll);
        
        llll_appendllll(out_llll, inner_llll, 0, WHITENULL_llll);
    }
    
    return out_llll;
}


t_llll* note_get_graphic_values_as_llll(t_notation_obj *r_ob, t_note *note){
    // breakpoints
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_graphic, 0, WHITENULL_llll);
    
    // OLD FORMAT
//    llll_appendlong(out_llll, note_get_screen_midicents(note), 0, WHITENULL_llll); // display midicents (of the natural diatonic note)
//    llll_appendrat(out_llll, note_get_screen_accidental(note), 0, WHITENULL_llll); // display accidental (as a ratio: 1/4 = +1/4 tone...)
    
    // NEW FORMAT
    llll_appendpitch(out_llll, note->pitch_displayed);
    
    return out_llll;
}


// returns 1 if deleted
char ease_breakpoint(t_notation_obj *r_ob, t_bpt *bpt, double smooth_rel_x, char direction)
{
    if (smooth_rel_x == 0.)
        return 0;
    
    if (bpt && bpt->next && bpt->prev) {
        if (direction > 0) {
            if (bpt->rel_x_pos + smooth_rel_x > bpt->next->rel_x_pos) {
                delete_breakpoint(r_ob, bpt);
                return 1;
            } else 
                bpt->rel_x_pos += smooth_rel_x;
        } else if (direction < 0){
            if (bpt->rel_x_pos - smooth_rel_x< bpt->prev->rel_x_pos) {
                delete_breakpoint(r_ob, bpt);
                return 1;
            } else 
                bpt->rel_x_pos -= smooth_rel_x;
        }
    }
    return 0;
}


void get_domains_or_minmax_for_absolutetemporal_slots(t_notation_obj *r_ob, t_slot *slot, long slotnum, double *min, double *max)
{
    if (slot_is_temporal_absolute(r_ob, slotnum)) {
        *min = 0;
        *max = slot_get_max_x(r_ob, slot, slotnum);
    } else {
        *min = r_ob->slotinfo[slotnum].slot_domain[0];
        *max = r_ob->slotinfo[slotnum].slot_domain[1];
    }
}

void ease_slotitem(t_notation_obj *r_ob, t_slotitem *item, double smooth_rel_x, char direction, long slotnum)
{
    if (smooth_rel_x == 0.)
        return;
    
    if (item) {
        double domain_min, domain_max, domain_width;
        get_domains_or_minmax_for_absolutetemporal_slots(r_ob, item->parent, slotnum, &domain_min, &domain_max);
        
        domain_width = domain_max - domain_min;
        switch (r_ob->slotinfo[slotnum].slot_type) {
            case k_SLOT_TYPE_FUNCTION:
                if (direction > 0) {
                    ((t_pts *)item->item)->x += smooth_rel_x * domain_width;
                    if ((!item->next && ((t_pts *)item->item)->x > domain_max) ||
                        (item->next && ((t_pts *)item->item)->x > ((t_pts *)item->next->item)->x))
                        slotitem_delete(r_ob, slotnum, item);
                } else if (direction < 0) {
                    ((t_pts *)item->item)->x -= smooth_rel_x * domain_width;
                    if ((!item->prev && ((t_pts *)item->item)->x < domain_min) ||
                        (item->prev && ((t_pts *)item->item)->x < ((t_pts *)item->prev->item)->x))
                        slotitem_delete(r_ob, slotnum, item);
                }
                break;
            case k_SLOT_TYPE_3DFUNCTION:
                if (direction > 0) {
                    ((t_pts3d *)item->item)->x += smooth_rel_x * domain_width;
                    if ((!item->next && ((t_pts3d *)item->item)->x > domain_max) ||
                        (item->next && ((t_pts3d *)item->item)->x > ((t_pts *)item->next->item)->x))
                        slotitem_delete(r_ob, slotnum, item);
                } else if (direction < 0) {
                    ((t_pts3d *)item->item)->x -= smooth_rel_x * domain_width;
                    if ((!item->prev && ((t_pts3d *)item->item)->x < domain_min) ||
                        (item->prev && ((t_pts3d *)item->item)->x < ((t_pts *)item->prev->item)->x))
                        slotitem_delete(r_ob, slotnum, item);
                }
                break;
            case k_SLOT_TYPE_SPAT:
                if (direction > 0) {
                    ((t_spatpt *)item->item)->t += smooth_rel_x * domain_width;
                    if ((!item->next && ((t_spatpt *)item->item)->t > domain_max) ||
                        (item->next && ((t_spatpt *)item->item)->t > ((t_spatpt *)item->next->item)->t))
                        slotitem_delete(r_ob, slotnum, item);
                } else if (direction < 0) {
                    ((t_spatpt *)item->item)->t -= smooth_rel_x * domain_width;
                    if ((!item->prev && ((t_spatpt *)item->item)->t < domain_min) ||
                        (item->prev && ((t_spatpt *)item->item)->t < ((t_spatpt *)item->prev->item)->t))
                        slotitem_delete(r_ob, slotnum, item);
                }
                break;
            case k_SLOT_TYPE_DYNFILTER:
                if (direction > 0) {
                    ((t_biquad *)item->item)->t += smooth_rel_x * domain_width;
                    if ((!item->next && ((t_biquad *)item->item)->t > domain_max) ||
                        (item->next && ((t_biquad *)item->item)->t > ((t_biquad *)item->next->item)->t))
                        slotitem_delete(r_ob, slotnum, item);
                } else if (direction < 0) {
                    ((t_biquad *)item->item)->t -= smooth_rel_x * domain_width;
                    if ((!item->prev && ((t_biquad *)item->item)->t < domain_min) ||
                        (item->prev && ((t_biquad *)item->item)->t < ((t_biquad *)item->prev->item)->t))
                        slotitem_delete(r_ob, slotnum, item);
                }
                break;
        }
    }
}

void glue_portion_of_single_temporal_slot(t_notation_obj *r_ob, t_note *receiver, t_llll *slot_llll, long slotnum,
                                          double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                          double portion_duration_ratio_to_receiver, char direction, double smooth_ms,
                                          double giver_duration, double total_new_duration)
{
    t_llll *receiver_slot = note_get_single_slot_values_as_llll(r_ob, receiver, k_CONSIDER_FOR_SAVING, slotnum, false);
    t_llll *final_slot = llll_get();
    t_llllelem *elem;
    t_llll *ll;
    char slot_is_temporalabsolute = slot_is_temporal_absolute(r_ob, slotnum);
    
    double domain_min = slot_get_domain_min(r_ob, slotnum);
    double domain_max = slot_get_domain_max(r_ob, slotnum, (t_notation_item *)receiver);
//    get_domains_or_minmax_for_absolutetemporal_slots(r_ob, &receiver->slot[slotnum], slotnum, &domain_min, &domain_max);

    double x_shift = (domain_max - domain_min) * portion_duration_ratio_to_receiver;
    double working_min = domain_min, working_max = domain_max;
    long idx_of_slotitem_to_be_smoothed = -1;
    
    // extract portion of slot_llll
    t_note *dummy = build_default_note(r_ob); // dummy!!!
    dummy->duration = giver_duration;
    t_llll *temp = llll_get();
    llll_appendllll_clone(temp, slot_llll, 0, WHITENULL_llll, NULL);
    set_slots_values_to_note_from_llll(r_ob, dummy, temp);
    t_llll *extracted_portion = notation_item_get_partial_single_slot_values_as_llll(r_ob, (t_notation_item *)dummy, k_CONSIDER_FOR_SAVING, slotnum, start_glued_note_portion_rel_x, end_glued_note_portion_rel_x);
    free_note(r_ob, dummy);
    llll_free(temp);

    if (direction > 0) {
        // shifting all extracted portion x's
        for (elem = extracted_portion->l_head; elem; elem = elem->l_next) 
            if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) { 
                double new_x;
                if (slot_is_temporalabsolute) {
                    new_x = domain_max + hatom_getdouble(&ll->l_head->l_hatom);
                } else
                    new_x = domain_max + rescale(hatom_getdouble(&ll->l_head->l_hatom), domain_min, domain_max, 0, portion_duration_ratio_to_receiver * (domain_max - domain_min));
                hatom_setdouble(&ll->l_head->l_hatom, new_x);
            }
        
        idx_of_slotitem_to_be_smoothed = receiver_slot->l_size - 1;

        // chaining
        llll_behead(extracted_portion); // it's the slot number
        llll_chain(final_slot, receiver_slot);
        llll_chain(final_slot, extracted_portion);
        working_max = domain_max + x_shift;
    } else if (direction < 0) {
        // shifting all extracted portion x's
        for (elem = extracted_portion->l_head; elem; elem = elem->l_next) 
            if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) {
                double new_x = domain_min - rescale(domain_max - hatom_getdouble(&ll->l_head->l_hatom), domain_min, domain_max, 0, portion_duration_ratio_to_receiver * (domain_max - domain_min));
                hatom_setdouble(&ll->l_head->l_hatom, new_x);
            }

        idx_of_slotitem_to_be_smoothed = extracted_portion->l_size - 2;

        llll_behead(receiver_slot); // it's the slot number
        llll_chain(final_slot, extracted_portion);
        llll_chain(final_slot, receiver_slot);
        working_min = domain_min - x_shift;
    }
        
    // rescaling all time instants
    for (elem = final_slot->l_head; elem; elem = elem->l_next) {
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) {
            double old_x = hatom_getdouble(&ll->l_head->l_hatom);
            double new_x;
            if (slot_is_temporalabsolute) {
                new_x = rescale(old_x, working_min, working_max, 0, total_new_duration);
                hatom_setdouble(&ll->l_head->l_hatom, CLAMP(new_x, 0, total_new_duration));
            } else {
                new_x = rescale(old_x, working_min, working_max, domain_min, domain_max);
                hatom_setdouble(&ll->l_head->l_hatom, CLAMP(new_x, domain_min, domain_max));
            }
        }
    }

    t_llll *final_slot_wrapped_ll = llll_get();
    llll_appendllll(final_slot_wrapped_ll, final_slot, 0, WHITENULL_llll);
    
    // In order to glue absolute-valued slots, and to avoid cropping them, the note must have its final duration already (which might not be the case)
    // So we set it and then we undo it, just to avoid cropping
    double old_receiver_duration = receiver->duration;
    receiver->duration = total_new_duration;
    set_slots_values_to_note_from_llll(r_ob, receiver, final_slot_wrapped_ll);
    receiver->duration = old_receiver_duration;
    
    // easing transition slotitem
    if (idx_of_slotitem_to_be_smoothed >= 0) {
        t_slotitem *slotitem_to_be_smoothed = nth_slotitem(r_ob, (t_notation_item *)receiver, slotnum, idx_of_slotitem_to_be_smoothed);
        if (slotitem_to_be_smoothed) {
            if (smooth_ms < 0)
                slotitem_delete(r_ob, slotnum, slotitem_to_be_smoothed);
            else
                ease_slotitem(r_ob, slotitem_to_be_smoothed, smooth_ms/(receiver->duration * (1 + portion_duration_ratio_to_receiver)), direction, slotnum);
        }
    }
    
    llll_free(final_slot_wrapped_ll);
}



t_llll *find_sublist_with_router(t_notation_obj *r_ob, t_llll *note_llll, t_symbol *sym)
{
    if (note_llll) {
        t_llllelem *elem;
        for (elem = note_llll->l_head; elem; elem = elem->l_next) {
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *ll = hatom_getllll(&elem->l_hatom);
                if (ll && ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_SYM && hatom_getsym(&ll->l_head->l_hatom) == sym) {
                    return ll;
                }
            }
        }
    }
    return NULL;
}

// glues a portion of temporal slot to a given note
void glue_portion_of_temporal_slots(t_notation_obj *r_ob, t_note *receiver, t_llll *note_llll, 
                                    double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                    double portion_duration_ratio_to_receiver, char direction, double smooth_ms, double giver_duration, double new_duration)
{
    t_llll *ll = find_sublist_with_router(r_ob, note_llll, _llllobj_sym_slots);
    long i;
    char done[CONST_MAX_SLOTS];
    for (i = 0; i < CONST_MAX_SLOTS; i++)
        done[i] = false;
    
    if (ll && ll->l_head) {
        t_llllelem *slot_elem;
        for (slot_elem = ll->l_head->l_next; slot_elem; slot_elem = slot_elem->l_next) {
            if (hatom_gettype(&slot_elem->l_hatom) == H_LLLL) {
                t_llll *this_slot_ll = hatom_getllll(&slot_elem->l_hatom);
                if (this_slot_ll && this_slot_ll->l_head) {
                    long slotnum = llllelem_to_slotnum(r_ob, this_slot_ll->l_head, true);
                    if (slotnum >= 0 && slotnum < CONST_MAX_SLOTS && slot_is_temporal(r_ob, slotnum)) { // temporal
                        done[slotnum] = true;
                        glue_portion_of_single_temporal_slot(r_ob, receiver, this_slot_ll, slotnum,
                                                             start_glued_note_portion_rel_x, end_glued_note_portion_rel_x, 
                                                             portion_duration_ratio_to_receiver, direction, smooth_ms, giver_duration, new_duration);
                    }
                }
            }
        }
    }
    
    // checking remaining slots
    double rel_x = 1./(1. + portion_duration_ratio_to_receiver);
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        if (slot_is_temporal(r_ob, i) && !done[i] && receiver->slot[i].firstitem)
            rescale_domain_of_single_temporal_slot(r_ob, receiver, i, direction > 0 ? 0. : 1 - rel_x, direction > 0 ? rel_x : 1.);
    }
}

// glues a portion of temporal slot to a given note
void rescale_domain_of_single_temporal_slot(t_notation_obj *r_ob, t_note *receiver, long slotnum, 
                                            double relative_start_x, double relative_end_x)
{
    t_slotitem *item;

    double domain_min = r_ob->slotinfo[slotnum].slot_domain[0], domain_max = r_ob->slotinfo[slotnum].slot_domain[1];
    get_domains_or_minmax_for_absolutetemporal_slots(r_ob, &receiver->slot[slotnum], slotnum, &domain_min, &domain_max);
    
    double domain_width = domain_max - domain_min;
    switch (r_ob->slotinfo[slotnum].slot_type) {
        case k_SLOT_TYPE_FUNCTION:
            for (item = receiver->slot[slotnum].firstitem; item; item = item->next) 
                ((t_pts *)item->item)->x = rescale(((t_pts *)item->item)->x, domain_min, domain_max, domain_min + relative_start_x * domain_width, domain_min + relative_end_x * domain_width);
            break;
        case k_SLOT_TYPE_3DFUNCTION:
            for (item = receiver->slot[slotnum].firstitem; item; item = item->next) 
                ((t_pts3d *)item->item)->x = rescale(((t_pts3d *)item->item)->x, domain_min, domain_max, domain_min + relative_start_x * domain_width, domain_min + relative_end_x * domain_width);
            break;
        case k_SLOT_TYPE_SPAT:
            for (item = receiver->slot[slotnum].firstitem; item; item = item->next) 
                ((t_spatpt *)item->item)->t = rescale(((t_spatpt *)item->item)->t, domain_min, domain_max, domain_min + relative_start_x * domain_width, domain_min + relative_end_x * domain_width);
            break;
        case k_SLOT_TYPE_DYNFILTER:
            for (item = receiver->slot[slotnum].firstitem; item; item = item->next) 
                ((t_biquad *)item->item)->t = rescale(((t_biquad *)item->item)->t, domain_min, domain_max, domain_min + relative_start_x * domain_width, domain_min + relative_end_x * domain_width);
            break;
    }
}    

void rescale_breakpoints(t_notation_obj *r_ob, t_note *receiver, double relative_start_x, double relative_end_x)
{
    t_bpt *bpt;
    
    if (receiver->firstbreakpoint) {
        for (bpt = receiver->firstbreakpoint->next; bpt; bpt = bpt->next) {
            if (bpt == receiver->lastbreakpoint)
                break;
            bpt->rel_x_pos = rescale(bpt->rel_x_pos, 0, 1, relative_start_x, relative_end_x);
        }

        if (relative_start_x > 0.)
            add_breakpoint(r_ob, receiver, relative_start_x, 0, 0, false, receiver->velocity, false);
        if (relative_end_x < 1.)
            add_breakpoint(r_ob, receiver, relative_end_x, receiver->lastbreakpoint->prev ? receiver->lastbreakpoint->prev->delta_mc : 0, 0, 
                           false, receiver->lastbreakpoint->prev ? receiver->lastbreakpoint->prev->velocity : receiver->velocity, false);
    }
}


char is_breakpoint_useless(t_notation_obj *r_ob, t_bpt *bpt)
{
    if (bpt->prev && bpt->next && bpt->prev->delta_mc == bpt->delta_mc && bpt->delta_mc == bpt->next->delta_mc &&
        (!r_ob->breakpoints_have_velocity || (bpt->prev->velocity == bpt->velocity && bpt->velocity == bpt->next->velocity)))
        return true;
    return false;
}


// glues a portion of temporal slot to a given note
// a negative smooth means: get rid of the discontinuity point
void glue_portion_of_breakpoints(t_notation_obj *r_ob, t_note *receiver, t_llll *note_llll, t_note *dummy_giver,
                                       double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                       double portion_duration_ratio_to_receiver, char direction, double smooth_ms)
{
    t_llll *ll = find_sublist_with_router(r_ob, note_llll, _llllobj_sym_breakpoints);
    long idx_of_bpt_to_be_smoothed = -1;
    
    if (ll && ll->l_head && dummy_giver) {
        t_llll *receiver_breakpoints = note_get_breakpoint_values_as_llll(r_ob, receiver, k_CONSIDER_FOR_SAVING, NULL, NULL);
        t_llll *final_breakpoints = llll_get();
        t_llllelem *elem;
        t_llll *ll;
        double x_shift = portion_duration_ratio_to_receiver;
        double working_min = 0, working_max = 1;
        double new_extracted_portion_start_mc;
        
        // extract portion of slot_llll
        t_llll *extracted_portion = note_get_partial_breakpoint_values_as_llll(r_ob, dummy_giver, start_glued_note_portion_rel_x, end_glued_note_portion_rel_x, &new_extracted_portion_start_mc);
        
        if (direction > 0) {
            // shifting all extracted portion x's
            for (elem = extracted_portion->l_head; elem; elem = elem->l_next) 
                if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) { 
                    double new_x = 1 + rescale(hatom_getdouble(&ll->l_head->l_hatom), 0, 1, 0, portion_duration_ratio_to_receiver);
                    hatom_setdouble(&ll->l_head->l_hatom, new_x);
                }

            // shifting all y's depending on mc_diff between the left and right note
            for (elem = extracted_portion->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && ll->l_head->l_next && is_hatom_number(&ll->l_head->l_next->l_hatom)) {
                    double old_y = hatom_getdouble(&ll->l_head->l_next->l_hatom);
                    double new_y = old_y + (new_extracted_portion_start_mc - receiver->midicents);
                    hatom_setdouble(&ll->l_head->l_next->l_hatom, new_y);
                }
            }
            
            idx_of_bpt_to_be_smoothed = receiver_breakpoints->l_size - 1;
            
            // chaining
            llll_behead(extracted_portion); // it's the "breakpoints" symbol
            llll_chain(final_breakpoints, receiver_breakpoints);
            llll_chain(final_breakpoints, extracted_portion);
            working_max = 1 + x_shift;
            
        } else if (direction < 0) {
            // shifting all extracted portion x's
            for (elem = extracted_portion->l_head; elem; elem = elem->l_next) 
                if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) {
                    double new_x = -rescale(1 - hatom_getdouble(&ll->l_head->l_hatom), 0, 1, 0, portion_duration_ratio_to_receiver);
                    hatom_setdouble(&ll->l_head->l_hatom, new_x);
                }

            // shifting all y's depending on mc_diff between the left and right note
            for (elem = receiver_breakpoints->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && ll->l_head->l_next && is_hatom_number(&ll->l_head->l_next->l_hatom)) {
                    double old_y = hatom_getdouble(&ll->l_head->l_next->l_hatom);
                    double new_y = old_y + (new_extracted_portion_start_mc - receiver->midicents);
                    hatom_setdouble(&ll->l_head->l_next->l_hatom, new_y);
                }
            }
            
            idx_of_bpt_to_be_smoothed = extracted_portion->l_size - 2;
            receiver->midicents = new_extracted_portion_start_mc;
            
            llll_behead(receiver_breakpoints); // it's the "breakpoints" symbol
            llll_chain(final_breakpoints, extracted_portion);
            llll_chain(final_breakpoints, receiver_breakpoints);
            working_min = -x_shift;
        }
        
        // rescaling all time instants
        for (elem = final_breakpoints->l_head; elem; elem = elem->l_next) {
            if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom)) && ll->l_head && is_hatom_number(&ll->l_head->l_hatom)) {
                double old_x = hatom_getdouble(&ll->l_head->l_hatom);
                double new_x = rescale(old_x, working_min, working_max, 0, 1);
                hatom_setdouble(&ll->l_head->l_hatom, CLAMP(new_x, 0, 1));
                    
            }
        }
        
        set_breakpoints_values_to_note_from_llll(r_ob, receiver, final_breakpoints);
        
        // easing transition breakpoint
        if (idx_of_bpt_to_be_smoothed >= 0) {
            t_bpt *bpt_to_be_smoothed = nth_breakpoint(receiver, idx_of_bpt_to_be_smoothed);
            if (bpt_to_be_smoothed) {
                if (smooth_ms < 0 || is_breakpoint_useless(r_ob, bpt_to_be_smoothed))
                    delete_breakpoint(r_ob, bpt_to_be_smoothed);
                else
                    ease_breakpoint(r_ob, bpt_to_be_smoothed, smooth_ms/(receiver->duration * (1 + portion_duration_ratio_to_receiver)), direction);
            }
            
            if (direction > 0) {
                if (bpt_to_be_smoothed && bpt_to_be_smoothed->prev && is_breakpoint_useless(r_ob, bpt_to_be_smoothed->prev))
                    delete_breakpoint(r_ob, bpt_to_be_smoothed->prev);
            } else if (direction < 0) {
                if (bpt_to_be_smoothed && bpt_to_be_smoothed->next && is_breakpoint_useless(r_ob, bpt_to_be_smoothed->next))
                    delete_breakpoint(r_ob, bpt_to_be_smoothed->next);
            }
        }
        
        llll_free(final_breakpoints);
 
    } else {
        double rel_x = 1./(1. + portion_duration_ratio_to_receiver);
        rescale_breakpoints(r_ob, receiver, direction > 0 ? 0. : 1 - rel_x, direction > 0 ? rel_x : 1.);
        
        // handling pitch differences
        if (note_llll->l_size >= 1) {
            double giver_midicents = hatom_getdouble(&note_llll->l_head->l_hatom);
            double giver_velocity = note_llll->l_size >= 3 ? hatom_getdouble(&note_llll->l_head->l_next->l_next->l_hatom) : receiver->lastbreakpoint->velocity;
            if (direction > 0 && receiver->lastbreakpoint) { // && receiver->lastbreakpoint->delta_mc != giver_midicents - receiver->midicents) {
                t_bpt *added = NULL;
                t_bpt *added_prev = NULL; 
                if (smooth_ms >= 0.) {
                    added = add_breakpoint(r_ob, receiver, rel_x + 0.000001, giver_midicents - receiver->midicents, 0, false, giver_velocity, false);
                    if (added)
                        added_prev = added->prev;
                    if (ease_breakpoint(r_ob, added, smooth_ms/(receiver->duration * (1 + portion_duration_ratio_to_receiver)), 1))
                        added = NULL;
                }
                receiver->lastbreakpoint->delta_mc = giver_midicents - receiver->midicents;
                receiver->lastbreakpoint->slope = 0;
                receiver->lastbreakpoint->velocity = giver_velocity;
                if (added && is_breakpoint_useless(r_ob, added))
                    delete_breakpoint(r_ob, added);
                if (added_prev && is_breakpoint_useless(r_ob, added_prev))
                    delete_breakpoint(r_ob, added_prev);
            } else if (direction < 0 && receiver->firstbreakpoint) { // && receiver->midicents != giver_midicents) {
                t_bpt *added = NULL;
                t_bpt *added_next = NULL; 
                if (smooth_ms >= 0.) {
                    added = add_breakpoint(r_ob, receiver, 1 - rel_x - 0.000001, 0, 0, false, giver_velocity, false);
                    if (added)
                        added_next = added->next;
                    if (ease_breakpoint(r_ob, added, smooth_ms/(receiver->duration * (1 + portion_duration_ratio_to_receiver)), -1))
                        added = NULL;
                }
                if (receiver->firstbreakpoint->next)
                    receiver->firstbreakpoint->next->slope = 0;
                receiver->firstbreakpoint->velocity = giver_velocity;
                // shifting all following breakpoints
                t_bpt *temp;
                for (temp = added ? added->next : receiver->firstbreakpoint->next; temp; temp = temp->next)
                    temp->delta_mc += (receiver->midicents - giver_midicents);
                if (added && is_breakpoint_useless(r_ob, added))
                    delete_breakpoint(r_ob, added);
                if (added_next && is_breakpoint_useless(r_ob, added_next))
                    delete_breakpoint(r_ob, added_next);
            }
        }
    }
}



// obtains only a portion of the temporal envelopes (the portion between start_rel_x_pos and end_rel_x_pos)
// mode is one of the e_data_considering_types
t_llll* notation_item_get_partial_single_slot_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, long slotnum, double start_rel_x_pos, double end_rel_x_pos)
{
    double can_extend = (end_rel_x_pos < 0 && r_ob->slotinfo[slotnum].extend_beyond_tails);
    
    if (end_rel_x_pos < 0)
        end_rel_x_pos = 1;
    
    if (!slot_is_temporal(r_ob, slotnum))
        return notation_item_get_single_slot_values_as_llll(r_ob, nitem, mode, slotnum, false);
    
    double domain_min = slot_get_domain_min(r_ob, slotnum);
    double domain_max = slot_get_domain_max(r_ob, slotnum, nitem);
    double new_domain_max = domain_max;
    if (r_ob->slotinfo[slotnum].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS)
        new_domain_max = domain_max * (end_rel_x_pos - start_rel_x_pos);

    t_llll* out_llll = llll_get();
    
    if (mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE && mode != k_CONSIDER_FOR_EXPORT_PWGL) {
        if (r_ob->output_slot_names && (mode == k_CONSIDER_FOR_EVALUATION || mode == k_CONSIDER_FOR_PLAYING || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_PLAYING_ONLY_IF_SELECTED))
            llll_appendsym(out_llll, r_ob->slotinfo[slotnum].slot_name, 0, WHITENULL_llll); // slot name
        else
            llll_appendlong(out_llll, slotnum + 1, 0, WHITENULL_llll); // slot number, 1-based
    }    
    
    double start_x_pos, end_x_pos;
    if (slot_is_temporal_absolute(r_ob, slotnum)) {
        start_x_pos = start_rel_x_pos * notation_item_get_duration_ms(r_ob, nitem);
        end_x_pos = end_rel_x_pos * notation_item_get_duration_ms(r_ob, nitem);
    } else {
        start_x_pos = rescale(start_rel_x_pos, 0, 1, domain_min, domain_max);
        end_x_pos = rescale(end_rel_x_pos, 0, 1, domain_min, domain_max);
    }

    switch (r_ob->slotinfo[slotnum].slot_type) { // slot type
        case k_SLOT_TYPE_FUNCTION: {
            
            t_slotitem *temp = notation_item_get_slot_firstitem(r_ob, nitem, slotnum);
            
            while (temp && ((t_pts *)temp->item)->x < start_x_pos)
                temp = temp->next;
            
            // first point
            if (temp && temp->prev && ((t_pts *)temp->item)->x > start_x_pos) {
                t_pts *pts_prev = (t_pts *)temp->prev->item;
                t_pts *pts = (t_pts *)temp->item;
                double start_y_pos = rescale_with_slope(start_x_pos, pts_prev->x, pts->x, pts_prev->y, pts->y, pts->slope);
                llll_appendllll(out_llll, double_triplet_to_llll(domain_min, start_y_pos, 0.), 0, WHITENULL_llll);
            }
            
            // middle points
            while (temp && (can_extend || ((t_pts *)temp->item)->x <= end_x_pos)) {
                t_pts *pts = (t_pts *)temp->item;
                llll_appendllll(out_llll, double_triplet_to_llll(rescale(pts->x, start_x_pos, end_x_pos, domain_min, new_domain_max), pts->y, pts->slope), 0, WHITENULL_llll);
                temp = temp->next;
            }
            
            // last point
            if (temp && temp->prev && !can_extend && ((t_pts *)temp->item)->x > end_x_pos) {
                t_pts *pts_prev = (t_pts *)temp->prev->item;
                t_pts *pts = (t_pts *)temp->item;
                double end_y_pos = rescale_with_slope(end_x_pos, pts_prev->x, pts->x, pts_prev->y, pts->y, pts->slope);
                llll_appendllll(out_llll, double_triplet_to_llll(new_domain_max, end_y_pos, 0.), 0, WHITENULL_llll);
            }
            break;
        }
            
        case k_SLOT_TYPE_3DFUNCTION: { 
            
            t_slotitem *temp = notation_item_get_slot_firstitem(r_ob, nitem, slotnum);
            
            while (temp && ((t_pts3d *)temp->item)->x < start_x_pos)
                temp = temp->next;
            
            // first point
            if (temp && temp->prev && ((t_pts3d *)temp->item)->x > start_x_pos) {
                t_pts3d *pts_prev = (t_pts3d *)temp->prev->item;
                t_pts3d *pts = (t_pts3d *)temp->item;
                double start_y_pos = rescale_with_slope(start_x_pos, pts_prev->x, pts->x, pts_prev->y, pts->y, pts->slope);
                double start_z_pos = rescale_with_slope(start_x_pos, pts_prev->x, pts->x, pts_prev->z, pts->z, pts->slope);
                llll_appendllll(out_llll, double_quadruplet_to_llll(domain_min, start_y_pos, start_z_pos, 0.), 0, WHITENULL_llll);
            }
            
            // middle points
            while (temp && (can_extend || ((t_pts3d *)temp->item)->x <= end_x_pos)) {
                t_pts3d *pts = (t_pts3d *)temp->item;
                llll_appendllll(out_llll, double_quadruplet_to_llll(rescale(pts->x, start_x_pos, end_x_pos, domain_min, new_domain_max), pts->y, pts->z, pts->slope), 0, WHITENULL_llll);
                temp = temp->next;
            }
            
            // last point
            if (temp && temp->prev && !can_extend && ((t_pts3d *)temp->item)->x > end_x_pos) {
                t_pts3d *pts_prev = (t_pts3d *)temp->prev->item;
                t_pts3d *pts = (t_pts3d *)temp->item;
                double end_y_pos = rescale_with_slope(end_x_pos, pts_prev->x, pts->x, pts_prev->y, pts->y, pts->slope);
                double end_z_pos = rescale_with_slope(end_x_pos, pts_prev->x, pts->x, pts_prev->z, pts->z, pts->slope);
                llll_appendllll(out_llll, double_quadruplet_to_llll(new_domain_max, end_y_pos, end_z_pos, 0.), 0, WHITENULL_llll);
            }
            break;
        }

        case k_SLOT_TYPE_SPAT: { 
            
            t_slotitem *temp = notation_item_get_slot_firstitem(r_ob, nitem, slotnum);

            while (temp && ((t_spatpt *)temp->item)->t < start_x_pos)
                temp = temp->next;
            
            // first point
            if (temp && temp->prev && ((t_spatpt *)temp->item)->t > start_x_pos) {
                t_spatpt *pts_prev = (t_spatpt *)temp->prev->item;
                t_spatpt *pts = (t_spatpt *)temp->item;
                double start_radius_pos = rescale(start_x_pos, pts_prev->t, pts->t, pts_prev->radius, pts->radius);
                double start_angle_pos = rescale(start_x_pos, pts_prev->t, pts->t, pts_prev->angle, pts->angle);
                llll_appendllll(out_llll, double_triplet_and_long_to_llll(domain_min, start_radius_pos, start_angle_pos, 0), 0, WHITENULL_llll);
            }
            
            // middle points
            while (temp && (can_extend || ((t_spatpt *)temp->item)->t <= end_x_pos)) {
                t_spatpt *pts = (t_spatpt *)temp->item;
                llll_appendllll(out_llll, double_triplet_and_long_to_llll(rescale(pts->t, start_x_pos, end_x_pos, domain_min, new_domain_max), pts->radius, pts->angle, pts->interp), 0, WHITENULL_llll);
                temp = temp->next;
            }
            
            // last point
            if (temp && temp->prev && !can_extend && ((t_spatpt *)temp->item)->t > end_x_pos) {
                t_spatpt *pts_prev = (t_spatpt *)temp->prev->item;
                t_spatpt *pts = (t_spatpt *)temp->item;
                double end_radius_pos = rescale(end_x_pos, pts_prev->t, pts->t, pts_prev->radius, pts->radius);
                double end_angle_pos = rescale(end_x_pos, pts_prev->t, pts->t, pts_prev->angle, pts->angle);
                llll_appendllll(out_llll, double_triplet_and_long_to_llll(new_domain_max, end_radius_pos, end_angle_pos, pts->interp), 0, WHITENULL_llll);
            }
            break;
        }
            
        case k_SLOT_TYPE_DYNFILTER: { 
            
            t_slotitem *temp = notation_item_get_slot_firstitem(r_ob, nitem, slotnum);
            
            while (temp && ((t_biquad *)temp->item)->t < start_x_pos)
                temp = temp->next;
            
            // first point
            if (temp && temp->prev && ((t_biquad *)temp->item)->t > start_x_pos) {
                t_biquad pts_prev = *((t_biquad *)temp->prev->item);
                t_biquad pts = *((t_biquad *)temp->item);
                t_biquad interp = interpolate_biquad(r_ob, pts_prev, pts, rescale(start_x_pos, pts_prev.t, pts.t, 0, 1), 1);
                t_llll *ll = llll_get();
                llll_appenddouble(ll, 0, 0, WHITENULL_llll);
                llll_chain(ll, get_biquad_as_full_llll(r_ob, &interp));
                llll_appendllll(out_llll, ll, 0, WHITENULL_llll);
            }
            
            // middle points
            while (temp && (can_extend || ((t_biquad *)temp->item)->t <= end_x_pos)) {
                t_biquad *pts = (t_biquad *)temp->item;
                t_llll *ll = llll_get();
                llll_appenddouble(ll, rescale(pts->t, start_x_pos, end_x_pos, domain_min, domain_max), 0, WHITENULL_llll);
                llll_chain(ll, get_biquad_as_full_llll(r_ob, pts));
                llll_appendllll(out_llll, ll, 0, WHITENULL_llll);
                temp = temp->next;
            }
            
            // last point
            if (temp && temp->prev && !can_extend && ((t_biquad *)temp->item)->t > end_x_pos) {
                t_biquad pts_prev = *((t_biquad *)temp->prev->item);
                t_biquad pts = *((t_biquad *)temp->item);
                t_biquad interp = interpolate_biquad(r_ob, pts_prev, pts, rescale(end_x_pos, pts_prev.t, pts.t, 0, 1), 1);
                t_llll *ll = llll_get();
                llll_appenddouble(ll, 0, 0, WHITENULL_llll);
                llll_chain(ll, get_biquad_as_full_llll(r_ob, &interp));
                llll_appendllll(out_llll, ll, 0, WHITENULL_llll);
            }
            break;
        }
        
        default:
            llll_free(out_llll);
            out_llll = notation_item_get_single_slot_values_as_llll(r_ob, nitem, mode, slotnum, false);
            break;

    }
    
    return out_llll;
}


// obtains only a portion of the breakpoints bpc (the portion between start_rel_x_pos and end_rel_x_pos
// mode is one of the e_data_considering_types
t_llll* note_get_partial_breakpoint_values_as_llll(t_notation_obj *r_ob, t_note *note, double start_rel_x_pos, double end_rel_x_pos, double *new_start_midicents){
    // if mode == 2 it is a partialnote, and new_start_midicents is filled
    t_bpt *temp;
    double start_y_pos = 0., start_vel;
    double duration_ratio;
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_breakpoints, 0, WHITENULL_llll);
    
    if (new_start_midicents) 
        *new_start_midicents = note->midicents;
    
    duration_ratio = (MIN(end_rel_x_pos, 1.) - MAX(start_rel_x_pos, 0.));
    
    temp = note->firstbreakpoint;
    while (temp && temp->rel_x_pos < start_rel_x_pos)
        temp = temp->next;

    if (temp && temp->prev && (temp->rel_x_pos > start_rel_x_pos)) {
        double rel_x_pos_ratio;
        t_llll *inner2_llll;
        rel_x_pos_ratio = (start_rel_x_pos - temp->prev->rel_x_pos) /(temp->rel_x_pos - temp->prev->rel_x_pos);
        start_y_pos = temp->prev->delta_mc + rel_x_pos_ratio * (temp->delta_mc - temp->prev->delta_mc);
        if (temp->delta_mc >= temp->prev->delta_mc)
            start_y_pos = rescale_with_slope(start_y_pos, temp->prev->delta_mc, temp->delta_mc, temp->prev->delta_mc, temp->delta_mc, temp->slope);
        else
            start_y_pos = temp->delta_mc + temp->prev->delta_mc - rescale_with_slope(temp->prev->delta_mc - start_y_pos, 0, temp->prev->delta_mc - temp->delta_mc, temp->delta_mc, temp->prev->delta_mc, temp->slope);
        
        inner2_llll = llll_get();
        if (new_start_midicents) *new_start_midicents = note->midicents + start_y_pos; // resetting start midicents
        llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // new relative x position: 0.
        llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // y position: 0.
        llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // first point: slope = 0.
        if (r_ob->breakpoints_have_velocity) {
            start_vel = temp->prev->velocity + rel_x_pos_ratio * (temp->velocity - temp->prev->velocity);
            llll_appendlong(inner2_llll, temp->velocity, 0, WHITENULL_llll); // velocity
        }
        llll_appendllll(out_llll, inner2_llll, 0, WHITENULL_llll);
    }
    
    while (temp && temp->rel_x_pos <= end_rel_x_pos) {
        t_llll* inner2_llll = llll_get();
        
        llll_appenddouble(inner2_llll, (temp->rel_x_pos - start_rel_x_pos)/(end_rel_x_pos-start_rel_x_pos), 0, WHITENULL_llll); // relative x position
        llll_appenddouble(inner2_llll, temp->delta_mc - start_y_pos, 0, WHITENULL_llll); // y position
        llll_appenddouble(inner2_llll, temp->slope, 0, WHITENULL_llll); // slope
        if (r_ob->breakpoints_have_velocity)
            llll_appendlong(inner2_llll, temp->velocity, 0, WHITENULL_llll); // velocity
        
        llll_appendllll(out_llll, inner2_llll, 0, WHITENULL_llll);
        
        temp = temp->next;
    }
    
    if (temp && temp->rel_x_pos > end_rel_x_pos) {
        double endvelocity;
        double end_y_pos = get_breakpoints_interpolated_mc(r_ob, note, end_rel_x_pos, &endvelocity);
        t_llll *inner2_llll = llll_get();
        llll_appenddouble(inner2_llll, 1., 0, WHITENULL_llll); // new relative x position: 0.
        llll_appenddouble(inner2_llll, end_y_pos - note->midicents, 0, WHITENULL_llll); // y position: 0.
        llll_appenddouble(inner2_llll, temp->slope, 0, WHITENULL_llll); // first point: slope = 0.
        if (r_ob->breakpoints_have_velocity) 
            llll_appendlong(inner2_llll, endvelocity, 0, WHITENULL_llll); // velocity
        llll_appendllll(out_llll, inner2_llll, 0, WHITENULL_llll);
    }
    
    return out_llll;
}


t_llll* note_get_breakpoint_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode, 
                                           double *new_start_midicents, double *new_start_velocity)
{
// if mode == 2 it is a partialnote, and new_start_midicents is filled
    t_bpt *temp;
    double start_x_pos = 0., start_y_pos = 0., start_vel;
    // breakpoints
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_breakpoints, 0, WHITENULL_llll);
    
    if (new_start_velocity)
        *new_start_velocity = note->velocity;
    
    if (new_start_midicents) 
        *new_start_midicents = note->midicents;
    
    temp = note->firstbreakpoint;
    if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) { // partial notes!
        double hot_point = (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) ? r_ob->play_head_start_ms : r_ob->curr_sampling_ms;
        double duration = note->duration;
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && mode == k_CONSIDER_FOR_SAMPLING && r_ob->dl_spans_ties)
            duration = get_all_tied_note_sequence_duration_ms(note);
        while (temp && note->parent->onset + temp->rel_x_pos * duration < hot_point)
            temp = temp->next;
        if (temp && temp->prev && (note->parent->onset + temp->rel_x_pos * duration != hot_point)) {
            double rel_x_pos_ratio;
            t_llll *inner2_llll;
            start_x_pos = (hot_point - note->parent->onset) / duration;
            rel_x_pos_ratio = (start_x_pos - temp->prev->rel_x_pos) /(temp->rel_x_pos - temp->prev->rel_x_pos);
            start_y_pos = temp->prev->delta_mc + rel_x_pos_ratio * (temp->delta_mc - temp->prev->delta_mc);
            if (temp->delta_mc >= temp->prev->delta_mc)
                start_y_pos = rescale_with_slope(start_y_pos, temp->prev->delta_mc, temp->delta_mc, temp->prev->delta_mc, temp->delta_mc, temp->slope);
            else
                start_y_pos = temp->delta_mc + temp->prev->delta_mc - rescale_with_slope(temp->prev->delta_mc - start_y_pos, 0, temp->prev->delta_mc - temp->delta_mc, temp->delta_mc, temp->prev->delta_mc, temp->slope);
            
            inner2_llll = llll_get();
            if (new_start_midicents) 
                *new_start_midicents = note->midicents + start_y_pos; // resetting start midicents
            llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // new relative x position: 0.
            llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // y position: 0.
            llll_appenddouble(inner2_llll, 0., 0, WHITENULL_llll); // first point: slope = 0.
            if (r_ob->breakpoints_have_velocity) {
                start_vel = temp->prev->velocity + rel_x_pos_ratio * (temp->velocity - temp->prev->velocity);
                if (new_start_velocity) 
                    *new_start_velocity = start_vel; // resetting start velocity
                llll_appendlong(inner2_llll, round(start_vel), 0, WHITENULL_llll); // velocity
            }
            llll_appendllll(out_llll, inner2_llll, 0, WHITENULL_llll);
        }
    }
    while (temp) {
        t_llll* inner2_llll = llll_get();
        
        llll_appenddouble(inner2_llll, (temp->rel_x_pos - start_x_pos)/(1-start_x_pos), 0, WHITENULL_llll); // relative x position
        llll_appenddouble(inner2_llll, temp->delta_mc - start_y_pos, 0, WHITENULL_llll); // y position
        llll_appenddouble(inner2_llll, temp->slope, 0, WHITENULL_llll); // slope
        if (r_ob->breakpoints_have_velocity)
            llll_appendlong(inner2_llll, temp->velocity, 0, WHITENULL_llll); // velocity
        
        llll_appendllll(out_llll, inner2_llll, 0, WHITENULL_llll);
        
        temp = temp->next;
    }
    
    return out_llll;
}

t_llll* note_get_articulation_values_as_llll(t_notation_obj *r_ob, t_note *note){
    long i;
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_articulations, 0, WHITENULL_llll);
    for (i = 0; i < note->num_articulations; i++) {
        long id = note->articulation[i].articulation_ID;
        if (id > 0)
            llll_appendsym(out_llll, articulation_id2symbol(&r_ob->articulations_typo_preferences, id), 0, WHITENULL_llll);
    }
    return out_llll;
}



t_llll* chord_get_articulation_values_as_llll(t_notation_obj *r_ob, t_chord *chord){
    long i;
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_articulations, 0, WHITENULL_llll);
    for (i = 0; i < chord->num_articulations; i++) {
        long id = chord->articulation[i].articulation_ID;
        if (id > 0)
            llll_appendsym(out_llll, articulation_id2symbol(&r_ob->articulations_typo_preferences, id), 0, WHITENULL_llll);
    }
    return out_llll;
}


t_llll *get_biquad_as_full_llll(t_notation_obj *r_ob, t_biquad *bqd)
{
    t_llll *out = llll_get();
    t_llll *params = llll_get();
    
    llll_appenddouble(out, bqd->b0, 0, WHITENULL_llll);
    llll_appenddouble(out, bqd->b1, 0, WHITENULL_llll);
    llll_appenddouble(out, bqd->b2, 0, WHITENULL_llll);
    llll_appenddouble(out, bqd->a1, 0, WHITENULL_llll);
    llll_appenddouble(out, bqd->a2, 0, WHITENULL_llll);
    
    llll_appendsym(params, filtertype_to_filtersym(bqd->filter_type), 0, WHITENULL_llll);
    llll_appenddouble(params, bqd->cutoff_freq, 0, WHITENULL_llll);
    llll_appenddouble(params, bqd->gain_dB, 0, WHITENULL_llll);
    llll_appenddouble(params, bqd->Q, 0, WHITENULL_llll);
    
    llll_appendllll(out, params, 0, WHITENULL_llll);
    return out;
}


// mode is one of the e_data_considering_types
t_llll* notation_item_get_single_slot_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, long slotnum, char only_get_selected_items)
{
    long j = slotnum;
    t_llll* inner4_llll = llll_get();
    char mode_is_playback_or_sortof = (mode == k_CONSIDER_FOR_EVALUATION || mode == k_CONSIDER_FOR_PLAYING || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE  || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_PLAYING_ONLY_IF_SELECTED);

    if (mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE && mode != k_CONSIDER_FOR_EXPORT_PWGL && mode != k_CONSIDER_FOR_SLOT_VALUES_ONLY) {
        if (r_ob->output_slot_names && mode_is_playback_or_sortof)
            llll_appendsym(inner4_llll, r_ob->slotinfo[j].slot_name, 0, WHITENULL_llll); // slot name
        else
            llll_appendlong(inner4_llll, j + 1, 0, WHITENULL_llll); // slot number, 1-based
    }
    
    t_slot *slot = notation_item_get_slot(r_ob, nitem, slotnum);
    double rangeslope = r_ob->slotinfo[slotnum].slot_range_par;
    char is_relative = (r_ob->slotinfo[j].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE);

    if (!slot)
        return inner4_llll;
    
    switch (r_ob->slotinfo[j].slot_type) { // slot type
        case k_SLOT_TYPE_FUNCTION: { 
            t_slotitem *temp_item = slot->firstitem;
            double new_x_pos = 0.;
            if ((mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) && !only_get_selected_items && slot_is_temporal(r_ob, j)) {
                // adding partial tempitems if function is temporal!
                
                double hot_point = (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) ? r_ob->play_head_start_ms : r_ob->curr_sampling_ms;
                
                double dur = notation_item_get_duration_ms(r_ob, nitem);
                if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && nitem->type == k_NOTE && mode == k_CONSIDER_FOR_SAMPLING && r_ob->slotinfo[j].slot_singleslotfortiednotes)
                    dur = get_all_tied_note_sequence_duration_ms((t_note *)nitem);

                while (temp_item && (notation_item_get_onset_ms(r_ob, nitem) + ((t_pts *)temp_item->item)->x * (is_relative ? dur : 1) < hot_point))
                    temp_item = temp_item->next;
                if (temp_item && temp_item->prev && (notation_item_get_onset_ms(r_ob, nitem) + ((t_pts *)temp_item->item)->x * dur != hot_point)) {
                    double this_x = ((t_pts *)temp_item->item)->x; double prev_x = ((t_pts *)temp_item->prev->item)->x;
                    double this_y = ((t_pts *)temp_item->item)->y; double prev_y = ((t_pts *)temp_item->prev->item)->y;
                    double this_slope = ((t_pts *)temp_item->item)->slope;
                    double x_ratio, new_y_pos;
                    t_llll *inner5_llll;
                    if (r_ob->slotinfo[j].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                        new_x_pos = (hot_point - notation_item_get_onset_ms(r_ob, nitem)) / dur;
                    } else if (r_ob->slotinfo[j].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                        new_x_pos = (hot_point - notation_item_get_onset_ms(r_ob, nitem));
                    }
                    x_ratio = (new_x_pos - prev_x) /(this_x - prev_x);
                    new_y_pos = prev_y + x_ratio * (this_y - prev_y);
                    if (this_y >= prev_y)
                        new_y_pos = rescale_with_slope(new_y_pos, prev_y, this_y, prev_y, this_y, this_slope);
                    else
                        new_y_pos = this_y + prev_y - rescale_with_slope(prev_y - new_y_pos, 0, prev_y - this_y, this_y, prev_y, this_slope);
                    
                    if (mode == k_CONSIDER_FOR_SAMPLING) {
                        llll_appenddouble(inner4_llll, new_y_pos, 0, WHITENULL_llll); // y position only
                    } else {
                        inner5_llll = llll_get();
                        llll_appenddouble(inner5_llll, 0., 0, WHITENULL_llll); // relative x position
                        llll_appenddouble(inner5_llll, new_y_pos, 0, WHITENULL_llll); // y position
                        llll_appenddouble(inner5_llll, 0., 0, WHITENULL_llll); //
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                } else if (mode == k_CONSIDER_FOR_SAMPLING && ((t_pts *)temp_item->item)->x == hot_point) {
                    llll_appenddouble(inner4_llll, ((t_pts *)temp_item->item)->y, 0, WHITENULL_llll); // y position only
                }
            }
            if (mode != k_CONSIDER_FOR_SAMPLING || !slot_is_temporal(r_ob, j)) {
                while (temp_item && temp_item->item) {
                    if (!only_get_selected_items || temp_item->selected) {
                        t_llll* inner5_llll = llll_get();
                        
                        double slope = ((t_pts *)temp_item->item)->slope;
                        if (temp_item->prev && mode_is_playback_or_sortof && rangeslope != 0 && r_ob->combine_range_slope_during_playback)
                            slope = combine_slopes(rangeslope, slope);
                        
                        llll_appenddouble(inner5_llll, (((t_pts *)temp_item->item)->x - new_x_pos)/(1-new_x_pos), 0, WHITENULL_llll); // x
                        llll_appenddouble(inner5_llll, ((t_pts *)temp_item->item)->y, 0, WHITENULL_llll); // y
                        llll_appenddouble(inner5_llll, slope, 0, WHITENULL_llll); // slope
                        
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                    temp_item = temp_item->next;
                }
            }
            break; 
        }
        case k_SLOT_TYPE_3DFUNCTION: { 
            t_slotitem *temp_item = slot->firstitem;
            double new_x_pos = 0.;
            if ((mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING)
                && !only_get_selected_items && slot_is_temporal(r_ob, j)) { // adding partial tempitems if function is temporal!
                double hot_point = (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) ? r_ob->play_head_start_ms : r_ob->curr_sampling_ms;
                while (temp_item && (notation_item_get_onset_ms(r_ob, nitem) + ((t_pts3d *)temp_item->item)->x * (is_relative ? notation_item_get_duration_ms(r_ob, nitem) : 1) < hot_point))
                    temp_item = temp_item->next;
                if (temp_item && temp_item->prev && (notation_item_get_onset_ms(r_ob, nitem) + ((t_pts3d *)temp_item->item)->x * notation_item_get_duration_ms(r_ob, nitem) != hot_point)) {
                    double this_x = ((t_pts3d *)temp_item->item)->x; 
                    double prev_x = ((t_pts3d *)temp_item->prev->item)->x;
                    double this_y = ((t_pts3d *)temp_item->item)->y; 
                    double prev_y = ((t_pts3d *)temp_item->prev->item)->y;
                    double this_z = ((t_pts3d *)temp_item->item)->z; 
                    double prev_z = ((t_pts3d *)temp_item->prev->item)->z;
                    double this_slope = ((t_pts3d *)temp_item->item)->slope;
                    double x_ratio, new_y_pos, new_z_pos;
                    t_llll *inner5_llll;
                    if (r_ob->slotinfo[j].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE)
                        new_x_pos = (hot_point - notation_item_get_onset_ms(r_ob, nitem)) / notation_item_get_duration_ms(r_ob, nitem);
                    else if (r_ob->slotinfo[j].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS)
                        new_x_pos = (hot_point - notation_item_get_onset_ms(r_ob, nitem));
                    x_ratio = (new_x_pos - prev_x) /(this_x - prev_x);

                    new_y_pos = prev_y + x_ratio * (this_y - prev_y);
                    new_z_pos = prev_z + x_ratio * (this_z - prev_z);
                    
                    if (this_y >= prev_y)
                        new_y_pos = rescale_with_slope(new_y_pos, prev_y, this_y, prev_y, this_y, this_slope);
                    else
                        new_y_pos = this_y + prev_y - rescale_with_slope(prev_y - new_y_pos, 0, prev_y - this_y, this_y, prev_y, this_slope);

                    if (this_z >= prev_z)
                        new_z_pos = rescale_with_slope(new_z_pos, prev_z, this_z, prev_z, this_z, this_slope);
                    else
                        new_z_pos = this_z + prev_z - rescale_with_slope(prev_z - new_z_pos, 0, prev_z - this_z, this_z, prev_z, this_slope);
                    
                    if (mode == k_CONSIDER_FOR_SAMPLING) {
                        llll_appenddouble(inner4_llll, new_y_pos, 0, WHITENULL_llll); // y position
                        llll_appenddouble(inner4_llll, new_z_pos, 0, WHITENULL_llll); // z position
                    } else {
                        inner5_llll = llll_get();
                        llll_appenddouble(inner5_llll, 0., 0, WHITENULL_llll); // relative x position
                        llll_appenddouble(inner5_llll, new_y_pos, 0, WHITENULL_llll); // y position
                        llll_appenddouble(inner5_llll, new_z_pos, 0, WHITENULL_llll); // z position
                        llll_appenddouble(inner5_llll, 0., 0, WHITENULL_llll); // first
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                }
            }
            if (mode != k_CONSIDER_FOR_SAMPLING || !slot_is_temporal(r_ob, j)) {
                while (temp_item && temp_item->item) {
                    if (!only_get_selected_items || temp_item->selected) {
                        t_llll* inner5_llll = llll_get();
                        
                        double slope = ((t_pts3d *)temp_item->item)->slope;
                        if (temp_item->prev && mode_is_playback_or_sortof && rangeslope != 0 && r_ob->combine_range_slope_during_playback)
                            slope = combine_slopes(rangeslope, slope);

                        
                        llll_appenddouble(inner5_llll, (((t_pts3d *)temp_item->item)->x - new_x_pos)/(1-new_x_pos), 0, WHITENULL_llll); // x
                        llll_appenddouble(inner5_llll, ((t_pts3d *)temp_item->item)->y, 0, WHITENULL_llll); // y
                        llll_appenddouble(inner5_llll, ((t_pts3d *)temp_item->item)->z, 0, WHITENULL_llll); // z
                        llll_appenddouble(inner5_llll, slope, 0, WHITENULL_llll); // slope
                        
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                    temp_item = temp_item->next;
                }
            }
            break; 
        }
        case k_SLOT_TYPE_SPAT: { 
            t_slotitem *temp_item = slot->firstitem;
            double new_t_pos = 0.;
            if ((mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) && !only_get_selected_items) { // adding partial tempitems
                double hot_point = (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) ? r_ob->play_head_start_ms : r_ob->curr_sampling_ms;
                while (temp_item && (notation_item_get_onset_ms(r_ob, nitem) + ((t_spatpt *)temp_item->item)->t * (is_relative ? notation_item_get_duration_ms(r_ob, nitem) : 1) < hot_point))
                    temp_item = temp_item->next;
                if (temp_item && temp_item->prev && (notation_item_get_onset_ms(r_ob, nitem) + ((t_spatpt *)temp_item->item)->t * notation_item_get_duration_ms(r_ob, nitem) != hot_point)) {
                    double this_t = ((t_spatpt *)temp_item->item)->t; double prev_t = ((t_spatpt *)temp_item->prev->item)->t;
                    double this_r = ((t_spatpt *)temp_item->item)->radius; double prev_r = ((t_spatpt *)temp_item->prev->item)->radius;
                    double this_a = ((t_spatpt *)temp_item->item)->angle; double prev_a = ((t_spatpt *)temp_item->prev->item)->angle;
                    double t_ratio, new_r, new_a;
                    t_llll *inner5_llll;
                    new_t_pos = (hot_point - notation_item_get_onset_ms(r_ob, nitem)) / notation_item_get_duration_ms(r_ob, nitem);
                    t_ratio = (new_t_pos - prev_t) / (this_t - prev_t);
                    new_r = prev_r + t_ratio * (this_r - prev_a);
                    new_a = prev_a + t_ratio * (this_a - prev_r);
                    
                    if (mode == k_CONSIDER_FOR_SAMPLING) {
                        llll_appenddouble(inner4_llll, new_r, 0, WHITENULL_llll); //radius
                        llll_appenddouble(inner4_llll, new_a, 0, WHITENULL_llll); // angle
                    } else {
                        inner5_llll = llll_get();
                        llll_appenddouble(inner5_llll, 0., 0, WHITENULL_llll); // t
                        llll_appenddouble(inner5_llll, new_r, 0, WHITENULL_llll); //radius
                        llll_appenddouble(inner5_llll, new_a, 0, WHITENULL_llll); // angle
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                }
            }
            if (mode != k_CONSIDER_FOR_SAMPLING || !slot_is_temporal(r_ob, j)) {
                while (temp_item && temp_item->item) {
                    if (!only_get_selected_items || temp_item->selected) {
                        t_llll* inner5_llll = llll_get();
                        
                        llll_appenddouble(inner5_llll, (((t_spatpt *)temp_item->item)->t - new_t_pos) / (1-new_t_pos), 0, WHITENULL_llll); // t
                        llll_appenddouble(inner5_llll, ((t_spatpt *)temp_item->item)->radius, 0, WHITENULL_llll); // radius
                        llll_appenddouble(inner5_llll, rad2deg(((t_spatpt *)temp_item->item)->angle), 0, WHITENULL_llll); // angle
                        llll_appendlong(inner5_llll, ((t_spatpt *)temp_item->item)->interp, 0, WHITENULL_llll); // interpolation type
                        
                        llll_appendllll(inner4_llll, inner5_llll, 0, WHITENULL_llll);
                    }
                    
                    temp_item = temp_item->next;
                }
            }
            break; 
        }
        case k_SLOT_TYPE_INT: { 
            t_slotitem *temp_item = slot->firstitem;
            long val = *((long *)temp_item->item);
            
            if (temp_item)
                llll_appendlong(inner4_llll, val);
            break; 
        }
        case k_SLOT_TYPE_FLOAT: { 
            t_slotitem *temp_item = slot->firstitem;
            double val = *((double *)temp_item->item);
            
            if ((mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) && !only_get_selected_items) { // adding partial tempitems
                double hot_point = (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) ? r_ob->play_head_start_ms : r_ob->curr_sampling_ms;
                val += hot_point - notation_item_get_onset_ms(r_ob, nitem);
            }

            if (temp_item)
                llll_appenddouble(inner4_llll, val);
            break; 
        }
        case k_SLOT_TYPE_INTLIST: { 
            t_slotitem *temp_item = slot->firstitem;
            while (temp_item) {
                llll_appendlong(inner4_llll, *((long *)temp_item->item), 0, WHITENULL_llll); // value
                temp_item = temp_item->next;
            }
            break; 
        }                
        case k_SLOT_TYPE_FLOATLIST: { 
            t_slotitem *temp_item = slot->firstitem;
            while (temp_item) {
                llll_appenddouble(inner4_llll, *((double *)temp_item->item), 0, WHITENULL_llll); // value
                temp_item = temp_item->next;
            }
            break; 
        }
            
        case k_SLOT_TYPE_ARTICULATIONS: {
            t_slotitem *temp_item = slot->firstitem;
            while (temp_item) {
                llll_appendsym(inner4_llll, ((t_articulation *)temp_item->item)->original_name ? ((t_articulation *)temp_item->item)->original_name : notationobj_articulation_id2symbol(r_ob, ((t_articulation *)temp_item->item)->articulation_ID), 0, WHITENULL_llll); // value
                temp_item = temp_item->next;
            }
            break; 
        }

        case k_SLOT_TYPE_NOTEHEAD:
        {
            t_slotitem *temp_item = slot->firstitem;
            if (temp_item)
                llll_appendsym(inner4_llll, (t_symbol *)temp_item->item, 0, WHITENULL_llll);
            break;
        }

        case k_SLOT_TYPE_DYNAMICS:
        {
            t_slotitem *temp_item = slot->firstitem;
            if (temp_item)
                llll_chain(inner4_llll, dynamics_to_llll(r_ob, (t_dynamics *)temp_item->item, (e_data_considering_types)mode));
            break;
        }

        case k_SLOT_TYPE_TEXT: {
            if (slot->firstitem) {
                long num_letters = slot->length;
                char *text = (char *) bach_newptr(MAX(num_letters + 1, 1)*sizeof(char));
                if (slot->firstitem->item) {
                    char *first_letter = ((char *)slot->firstitem->item);
                    if (!first_letter) {
                        dev_post("Slot error.");
                        text[0] = 0;
                    } else {
                        strncpy(text, first_letter, num_letters);
                        text[num_letters]='\0'; // we manually add the ending character (which is NOT automatically added by strncpy)
                    }
                } else {
                    text[0] = 0;
                }
                
                llll_appendsym(inner4_llll, gensym(text), 0, WHITENULL_llll); // text as a symbol
                bach_freeptr(text);
            }
            break;
        }
            
        case k_SLOT_TYPE_LLLL:
        case k_SLOT_TYPE_INTMATRIX:
        case k_SLOT_TYPE_FLOATMATRIX:
        case k_SLOT_TYPE_TOGGLEMATRIX:
        {
            t_llll *this_llll = NULL;
            if (slot->firstitem && slot->firstitem->item) {
                t_llll *cloned;
                this_llll = (t_llll *) slot->firstitem->item;
                cloned = llll_clone(this_llll);
                if (r_ob->slotinfo[j].slot_type != k_SLOT_TYPE_LLLL) {
                    // we wellshape the matrix!
                    llll_force_matrix_size(cloned, r_ob->slotinfo[j].slot_num_rows, r_ob->slotinfo[j].slot_num_cols, NULL);
                }
#ifdef BACH_NEW_LLLLSLOT_SYNTAX
                llll_chain(inner4_llll, cloned);
#else
                llll_appendllll(inner4_llll, cloned);
#endif
            } else {
#ifdef BACH_NEW_LLLLSLOT_SYNTAX
                // nothing to do!
#else
                llll_appendllll(inner4_llll, llll_get(), 0, WHITENULL_llll);
#endif
            }
            break; 
        }
            
#ifdef BACH_MAX
        case k_SLOT_TYPE_FILELIST: { 
            long active_number = -1; long count = 0;
            t_slotitem *active = slot_get_active_slotitem(slot);
            t_slotitem *temp_item = slot->firstitem;
            t_file *file; 
            t_fourcc type = 0;
            while (temp_item){
                char completepath[MAX_PATH_CHARS];
                file = ((t_file *)temp_item->item);
                if (file->exists) {
                    if (path_topathname(file->pathID, file->filename, completepath)) {
                        if (locatefile_extended(file->filename, &file->pathID, &type, &type,-1)) {
                            file->exists = false;
                            file->pathID = 0;
                            object_warn((t_object *) r_ob, "Warning: file %s has been moved and cannot be found", file->filename);
                            strncpy_zero(completepath, file->filename, MAX_PATH_CHARS); // if unsuccesful, we just copy the path name
                                                                                        // this is the case, for instance, if a user has 
                                                                                        // moved the file (so it does not exist any more) 
                            notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
                        } else {
                            path_topathname(file->pathID, file->filename, completepath);
                            object_warn((t_object *) r_ob, "Warning: file %s has been moved and has been relocated", file->filename);
                        }
                    }
                } else {
                    // we still try to locate it!
                    if (locatefile_extended(file->filename, &file->pathID, &type, &type,-1)) {
                        strncpy_zero(completepath, file->filename, MAX_PATH_CHARS);
                    } else {
                        path_topathname(file->pathID, file->filename, completepath);
                        file->exists = true;
                        object_warn((t_object *) r_ob, "Warning: file %s has been relocated", file->filename);
                        notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
                    }
                }
                llll_appendsym(inner4_llll, gensym(completepath), 0, WHITENULL_llll); // filepath as a symbol
                if (temp_item == active) 
                    active_number = count;
                count++;
                temp_item = temp_item->next;
            }
            
            llll_appendlong(inner4_llll, active_number+1, 0, WHITENULL_llll); // active file#
            break; 
        }    
            
        case k_SLOT_TYPE_FILTER: { 
            t_slotitem *temp_item = slot->firstitem;
            if (temp_item)
                llll_chain(inner4_llll, get_biquad_as_full_llll(r_ob, (t_biquad *)temp_item->item));
            break; 
        }    
            
        case k_SLOT_TYPE_DYNFILTER: { 
            t_slotitem *temp_item = slot->firstitem;
            while (temp_item){
                t_llll *singleel = llll_get();
                llll_appenddouble(singleel, ((t_biquad *)temp_item->item)->t, 0, WHITENULL_llll);
                llll_appendllll(singleel, get_biquad_as_full_llll(r_ob, (t_biquad *)temp_item->item), 0, WHITENULL_llll);
                llll_appendllll(inner4_llll, singleel, 0, WHITENULL_llll);
                temp_item = temp_item->next;
              }
            break; 
        }
        case k_SLOT_TYPE_COLOR: { 
            t_slotitem *temp_item = slot->firstitem;
            if (temp_item) {
                t_jrgba *color = (t_jrgba *)temp_item->item;
                llll_appenddouble(inner4_llll, color->red, 0, WHITENULL_llll);
                llll_appenddouble(inner4_llll, color->green, 0, WHITENULL_llll);
                llll_appenddouble(inner4_llll, color->blue, 0, WHITENULL_llll);
                llll_appenddouble(inner4_llll, color->alpha, 0, WHITENULL_llll);
            }
            break; 
        }    
            
#endif
        default: break; // we'll just have an empty list
    }    
    return inner4_llll;
}


t_llll* note_get_single_slot_values_as_llll(t_notation_obj *r_ob, t_note *note, char mode, long slotnum, char only_get_selected_items)
{
    return notation_item_get_single_slot_values_as_llll(r_ob, (t_notation_item *)note, mode, slotnum, only_get_selected_items);
}



t_llll* notation_item_get_partial_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char force_all_slots, double start_rel_x_pos, double end_rel_x_pos){
    // if mode == 2 it's a partialnote
    
    // slots
    t_llll* out_llll = llll_get();
    int j;
    llll_appendsym(out_llll, _llllobj_sym_slots, 0, WHITENULL_llll); 
    
    for (j = 0; j < CONST_MAX_SLOTS; j++) {
        if (notation_item_get_slot_firstitem(r_ob, nitem, j) || force_all_slots) { // do we need this slot?
            t_llll *thisslot_llll = notation_item_get_partial_single_slot_values_as_llll(r_ob, nitem, mode, j, start_rel_x_pos, end_rel_x_pos);
            llll_appendllll(out_llll, thisslot_llll, 0, WHITENULL_llll);
        }
    }
    
    return out_llll;
}


t_llll* note_get_slots_values_as_llll(t_notation_obj *r_ob, t_note *note, char mode, char force_all_slots){
// if mode == 2 it's a partialnote

    // slots
    t_llll* out_llll = llll_get();
    int j;
    llll_appendsym(out_llll, _llllobj_sym_slots);

    for (j = 0; j < CONST_MAX_SLOTS; j++) {
        t_note *note_for_slot = note;
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && mode == k_CONSIDER_FOR_SAMPLING && r_ob->slotinfo[j].slot_singleslotfortiednotes)
            note_for_slot = note_get_first_in_tieseq(note);
        if (note_for_slot->slot[j].firstitem || force_all_slots) { // do we need this slot?
            if (mode != k_CONSIDER_FOR_DUMPING_ONLY_TIE_SPANNING || r_ob->slotinfo[j].slot_singleslotfortiednotes) {
                t_llll *thisslot_llll = note_get_single_slot_values_as_llll(r_ob, note_for_slot, mode, j, false);
                llll_appendllll(out_llll, thisslot_llll);
            }
        }
    }
    
    return out_llll;
}


t_llll* notation_item_get_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char get_even_if_empty)
{
    // if mode == 2 it's a partialnote
    
    // slots
    t_llll* out_llll = llll_get();
    int j;
    llll_appendsym(out_llll, _llllobj_sym_slots, 0, WHITENULL_llll);
    
    for (j = 0; j < CONST_MAX_SLOTS; j++) {
        if (notation_item_get_slot_firstitem(r_ob, nitem, j) || get_even_if_empty) { // do we need this slot?
            if (mode != k_CONSIDER_FOR_DUMPING_ONLY_TIE_SPANNING || r_ob->slotinfo[j].slot_singleslotfortiednotes) {
                t_llll *thisslot_llll = notation_item_get_single_slot_values_as_llll(r_ob, nitem, mode, j, false);
                llll_appendllll(out_llll, thisslot_llll, 0, WHITENULL_llll);
            }
        }
    }
    
    return out_llll;
}


t_llll* notation_item_get_multiple_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char get_even_if_empty, t_llll *which_slots_1based)
{
    // if mode == 2 it's a partialnote
    
    // slots
    t_llll* out_llll = llll_get();
    llll_appendsym(out_llll, _llllobj_sym_slots, 0, WHITENULL_llll);
    
    for (t_llllelem *elem = which_slots_1based->l_head; elem; elem = elem->l_next){
        long j = -1;
        if (hatom_gettype(&elem->l_hatom) == H_SYM) {
            t_symbol *s = hatom_getsym(&elem->l_hatom);
            if (s == _llllobj_sym_dynamic || s == _llllobj_sym_dynamics)
                j = r_ob->link_dynamics_to_slot - 1;
            else if (s == _llllobj_sym_articulation || s == _llllobj_sym_articulations)
                j = r_ob->link_articulations_to_slot - 1;
            else if (s == _llllobj_sym_lyrics)
                j = r_ob->link_lyrics_to_slot - 1;
            else if (s == _llllobj_sym_notehead || s == _llllobj_sym_noteheads)
                j = r_ob->link_notehead_to_slot - 1;
            else if (s == _llllobj_sym_annotation)
                j = r_ob->link_annotation_to_slot - 1;
        } else {
            j = hatom_getlong(&elem->l_hatom) - 1;
        }
        if (j >= 0 && j < CONST_MAX_SLOTS) {
            if (notation_item_get_slot_firstitem(r_ob, nitem, j) || get_even_if_empty) { // do we need this slot?
                if (mode != k_CONSIDER_FOR_DUMPING_ONLY_TIE_SPANNING || r_ob->slotinfo[j].slot_singleslotfortiednotes) {
                    t_llll *thisslot_llll = notation_item_get_single_slot_values_as_llll(r_ob, nitem, mode, j, false);
                    llll_appendllll(out_llll, thisslot_llll, 0, WHITENULL_llll);
                }
            }
        }
    }
    
    return out_llll;
}




t_llll* note_get_graphic_values_no_router_as_llll(t_notation_obj *r_ob, t_note *note){
    // see if we need graphic extra
    t_llll *outllll;
    if (note_is_enharmonicity_userdefined(note)) {
        outllll = note_get_graphic_values_as_llll(r_ob, note);
        llll_behead(outllll);
    } else {
        outllll = llll_get();
    }
    return outllll;
}


t_llll* note_get_breakpoints_values_no_router_as_llll(t_notation_obj *r_ob, t_note *note){
    // see if we need breakpoint extras
    t_llll *outllll;
    if ((note->num_breakpoints > 2) || ((note->num_breakpoints == 2) && ((note->lastbreakpoint->slope != 0.) || (note->lastbreakpoint->delta_mc != 0.)))){
        outllll = note_get_breakpoint_values_as_llll(r_ob, note, k_CONSIDER_FOR_DUMPING, NULL, NULL);
        llll_behead(outllll);
    } else {
        outllll = llll_get();
    }
    return outllll;
}

t_llll* notation_item_get_slots_values_no_header_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char force_all_slots)
{
    t_llll *outllll;
    char needslots = 0; long i;
    for (i=0; i<CONST_MAX_SLOTS; i++) {
        if (notation_item_get_slot_firstitem(r_ob, nitem, i)) {
            needslots = 1;
            break;
        }
    }
    if (needslots) {
        outllll = notation_item_get_slots_values_as_llll(r_ob, nitem, k_CONSIDER_FOR_DUMPING, force_all_slots);
        llll_behead(outllll);
    } else {
        outllll = llll_get();
    }
    return outllll;
}



t_llll* note_get_slots_values_no_header_as_llll(t_notation_obj *r_ob, t_note *note, char force_all_slots)
{
    return notation_item_get_slots_values_no_header_as_llll(r_ob, (t_notation_item *)note, force_all_slots);
}





char should_output_note_graphics(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode)
{
    if (note_is_enharmonicity_userdefined(note) && mode != k_CONSIDER_FOR_SAMPLING &&
        !note->pitch_displayed.isNaP() && note->pitch_displayed.toMC() != note->midicents)
        return 1;
    
    return 0;
}





t_llll* note_get_extras_values_as_llll(t_notation_obj *r_ob, t_note *note)
{
    t_llll* out_llll = llll_get();
    char needslots = 0; long i;

    // OBSOLETE: No longer need the graphics extra
    if (should_output_note_graphics(r_ob, note, k_CONSIDER_FOR_SAVING))
        llll_appendllll(out_llll, note_get_graphic_values_as_llll(r_ob, note), 0, WHITENULL_llll);

    // see if we need breakpoint extras
    if (note_breakpoints_are_nontrivial(r_ob, note))
        llll_appendllll(out_llll, note_get_breakpoint_values_as_llll(r_ob, note, k_CONSIDER_FOR_DUMPING, NULL, NULL), 0, WHITENULL_llll);

    // see if we need slots extras (if there's AT LEAST 1 slot, we put them all, so it's practical: slot n is at place n in the list
    for (i=0; i<CONST_MAX_SLOTS; i++) {
        if (note->slot[i].firstitem) {
            needslots = 1;
            break;
        }
    }

    // see if we need articulations
    if (note->num_articulations > 0)
        llll_appendllll(out_llll, note_get_articulation_values_as_llll(r_ob, note), 0, WHITENULL_llll);

    if (needslots)
        llll_appendllll(out_llll, note_get_slots_values_as_llll(r_ob, note, k_CONSIDER_FOR_DUMPING, false), 0, WHITENULL_llll);    
    return out_llll;
}


t_llll* get_uislotnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode){
    t_llll* out_llll = llll_get();
    llll_appendllll(out_llll, note_get_slots_values_as_llll(r_ob, note, mode, false), 0, WHITENULL_llll);    
    return out_llll;
}



t_llll* get_rollnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode){
    double new_mc = 0., new_vel = 0;
    t_llll* out_llll = llll_get();

    
    // pitch or midicents
    note_appendpitch_to_llll_for_gathered_syntax_or_playout(r_ob, out_llll, note, mode);
    
    if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE)
        llll_appenddouble(out_llll, (note->parent->onset + note->duration) - r_ob->play_head_start_ms, 0, WHITENULL_llll); // duration
    else if (mode == k_CONSIDER_FOR_SAMPLING) 
        llll_appenddouble(out_llll, (note->parent->onset + note->duration) - r_ob->curr_sampling_ms, 0, WHITENULL_llll); // duration
    else 
        llll_appenddouble(out_llll, note->duration, 0, WHITENULL_llll); // duration
    
    llll_appendlong(out_llll, note->velocity, 0, WHITENULL_llll); // velocity

    if (should_output_note_graphics(r_ob, note, mode))
        llll_appendllll(out_llll, note_get_graphic_values_as_llll(r_ob, note), 0, WHITENULL_llll);
    
    // see if we need breakpoint extras
    if (note_breakpoints_are_nontrivial(r_ob, note)) {
        llll_appendllll(out_llll, note_get_breakpoint_values_as_llll(r_ob, note, mode, &new_mc, &new_vel), 0, WHITENULL_llll);
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) {
            hatom_setdouble(&out_llll->l_head->l_hatom, new_mc);
            hatom_setlong(&out_llll->l_head->l_next->l_next->l_hatom, round(new_vel));
            if (mode == k_CONSIDER_FOR_SAMPLING)
                llll_betail(out_llll); // don't need breakpoints
        }
    }
        
    // see if we need slots extras (if there's AT LEAST 1 slot, we put them all, so it's practical: slot n is at place n in the list
    if (notation_item_has_slot_content(r_ob, (t_notation_item *)note))
        llll_appendllll(out_llll, note_get_slots_values_as_llll(r_ob, note, mode, false), 0, WHITENULL_llll);    

    // see if we need articulations
    if (note->num_articulations > 0 && mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)
        llll_appendllll(out_llll, note_get_articulation_values_as_llll(r_ob, note), 0, WHITENULL_llll);    

    if (mode == k_CONSIDER_FOR_UNDO || (note->r_it.names->l_size > 0 && mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)) 
        llll_appendllll(out_llll, get_names_as_llll((t_notation_item *)note, true), 0, WHITENULL_llll);

    if (mode == k_CONSIDER_FOR_SAMPLING)
        llll_append_notationitem_global_flag(r_ob, out_llll, (t_notation_item *)note);
    else
        llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)note);

#ifdef BACH_NOTES_HAVE_ID
    if (mode == k_CONSIDER_FOR_UNDO) 
        llll_appendllll(out_llll, get_ID_as_llll((t_notation_item *)note), 0, WHITENULL_llll);
#endif
    
    if (mode == k_CONSIDER_FOR_SAMPLING) 
        llll_destroyelem(out_llll->l_head->l_next); // no duration needed


    return out_llll;
}

// returns the interpolated midicents of a note (returns the velocity as well if the pointer is defined
// point is 0 to 1
double get_breakpoints_interpolated_mc(t_notation_obj *r_ob, t_note *note, double point, double *velocity){
    t_bpt *bpt1 = note->firstbreakpoint;

    if (!bpt1) {
        if (velocity) *velocity = note->velocity;
        return note->midicents;
    }
    
    if (point <= bpt1->rel_x_pos) {
        if (velocity) *velocity = note->velocity;
        return note->midicents;
    }

    if (note->lastbreakpoint && point >= note->lastbreakpoint->rel_x_pos){
        if (velocity) {
            if (r_ob->breakpoints_have_velocity)
                *velocity = note->lastbreakpoint->velocity;
            else
                 *velocity = note->velocity;
        }
        return note->midicents + note->lastbreakpoint->delta_mc;
    }

    while (bpt1 && bpt1->next){
        if (bpt1->rel_x_pos <= point && bpt1->next->rel_x_pos >= point) {
            if (velocity) {
                if (r_ob->breakpoints_have_velocity)
                    *velocity = rescale_with_slope(point, bpt1->rel_x_pos, bpt1->next->rel_x_pos, bpt1->velocity, bpt1->next->velocity, 0.);
                else
                    *velocity = note->velocity;
            }
            return note->midicents + rescale_with_slope(point, bpt1->rel_x_pos, bpt1->next->rel_x_pos, bpt1->delta_mc, bpt1->next->delta_mc, bpt1->next->slope);
        }
        bpt1 = bpt1->next;
    }
    
    if (note->lastbreakpoint) {
        if (velocity) {
            if (r_ob->breakpoints_have_velocity)
                *velocity = note->lastbreakpoint->velocity;
            else
                *velocity = note->velocity;
        }
        return note->midicents + note->lastbreakpoint->delta_mc;
    }
    
    if (velocity) *velocity = note->velocity;
    return note->midicents;
}

t_llll* get_rollpartialnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode, double ms_start, double ms_end){
    double original_onset = note->parent->onset;
    double new_onset;
    double new_duration = 0;
    double velocity = note->velocity;
    double midicents;
    t_llll* out_llll = llll_get();
    
    if (original_onset >= ms_end)
        new_duration = 0;
    else if (original_onset >= ms_start && original_onset + note->duration <= ms_end) 
        new_duration = note->duration;
    else if (original_onset >= ms_start)
        new_duration = ms_end - original_onset;
    else if (original_onset < ms_start && original_onset + note->duration <= ms_end)
        new_duration = original_onset + note->duration - ms_start;
    else if (original_onset < ms_start)
        new_duration = ms_end - ms_start;
    
    if (original_onset >= ms_end)
        new_onset = ms_end;
    else if (original_onset >= ms_start)
        new_onset = original_onset;
    else
        new_onset = ms_start;

    double start_x_rel = (new_onset - original_onset)/note->duration;
    double end_x_rel = (new_onset + new_duration - original_onset)/note->duration;
    
    // PITCH
    if (new_onset <= original_onset) {
        note_appendpitch_to_llll_for_gathered_syntax_or_playout(r_ob, out_llll, note, mode);
    } else {
        midicents = get_breakpoints_interpolated_mc(r_ob, note, (new_onset - original_onset)/note->duration, &velocity);
        llll_appenddouble(out_llll, midicents, 0, WHITENULL_llll); // midicents
    }
    
    llll_appenddouble(out_llll, new_duration, 0, WHITENULL_llll); // duration
    llll_appendlong(out_llll, velocity, 0, WHITENULL_llll); // velocity
    
    if (should_output_note_graphics(r_ob, note, mode) && midicents == note->midicents)
        llll_appendllll(out_llll, note_get_graphic_values_as_llll(r_ob, note), 0, WHITENULL_llll);
    
    // see if we need breakpoint extras
    if (note_breakpoints_are_nontrivial(r_ob, note)) {
        double new_mc = 0.;
        llll_appendllll(out_llll, note_get_partial_breakpoint_values_as_llll(r_ob, note, start_x_rel, end_x_rel, &new_mc), 0, WHITENULL_llll);
    }
    
    // see if we need slots extras (if there's AT LEAST 1 slot, we put them all, so it's practical: slot n is at place n in the list
    // TO DO: slots have to be correctly trimmed
    if (notation_item_has_slot_content(r_ob, (t_notation_item *)note))
        llll_appendllll(out_llll, notation_item_get_partial_slots_values_as_llll(r_ob, (t_notation_item *)note, mode, false, start_x_rel, end_x_rel), 0, WHITENULL_llll);
    
    // see if we need articulation extras 
    if (note->num_articulations > 0)
        llll_appendllll(out_llll, note_get_articulation_values_as_llll(r_ob, note), 0, WHITENULL_llll);    
    
    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)note);
    
    return out_llll;
}

char note_breakpoints_are_nontrivial(t_notation_obj *r_ob, t_note *note) {
    if ((note->num_breakpoints > 2) || 
        ((note->num_breakpoints == 2) && 
            ((note->lastbreakpoint->slope != 0.) || (note->lastbreakpoint->delta_mc != 0.) || (r_ob->breakpoints_have_velocity && note->lastbreakpoint->velocity != note->velocity))))
        return true;
    return false;
}



// if mode >= 0 notes are returned only if not muted, if mode < 0 notes are always returned!
t_llll* get_rollpartialchord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, double start_ms, double end_ms){ // retrieve the chord values as an unmeasured chord, i.e. for [roll]
    t_note *temp_note;
    t_llll* out_llll = llll_get(); 
    
    double new_onset;
    
    if (chord->onset >= end_ms)
        new_onset = end_ms;
    else if (chord->onset >= start_ms)
        new_onset = chord->onset;
    else
        new_onset = start_ms;
    
    llll_appenddouble(out_llll, new_onset, 0, WHITENULL_llll); // onset
    
    temp_note = chord->firstnote;
    while (temp_note) { // append notes lllls
        if (mode == k_CONSIDER_ALL_NOTES || !notation_item_is_globally_muted(r_ob, (t_notation_item *)temp_note)) { // we take into account the fact that if mode == k_CONSIDER_ALL_NOTES (all gathered syntax) we want to have ALL the notes
            if (new_onset < end_ms && (chord->onset + temp_note->duration >= start_ms))
                llll_appendllll(out_llll, get_rollpartialnote_values_as_llll(r_ob, temp_note, mode, start_ms, end_ms), 0, WHITENULL_llll);
        }
        temp_note = temp_note->next;
    }
    
    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)chord);
    
    return out_llll;
}


t_llll* chord_get_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode){ 
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return get_rollchord_values_as_llll(r_ob, chord, mode);
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) 
        return get_scorechord_values_as_llll(r_ob, chord, mode, false);
    return NULL;
}


void set_chord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll *chordvalues, char always_from_scratch, char also_recompute_total_length, char check_notes_order)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        set_rollchord_values_from_llll(r_ob, chord, chordvalues, 0., always_from_scratch, also_recompute_total_length, check_notes_order);
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) 
        set_scorechord_values_from_llll(r_ob, chord, chordvalues, always_from_scratch, check_notes_order);
}


char name_is_none(t_llll *names)
{
    if (names->l_size == 1 && hatom_gettype(&names->l_head->l_hatom) == H_SYM && (hatom_getsym(&names->l_head->l_hatom) == _llllobj_sym_none))
        return 1;
    return 0;
}

char name_is_abr_none_abr(t_llll *names)
{
    if (names->l_size == 1 && hatom_gettype(&names->l_head->l_hatom) == H_SYM && (hatom_getsym(&names->l_head->l_hatom) == _llllobj_sym_abr_none_abr))
        return 1;
    return 0;
}

// mode is one of the e_data_considering_types
t_llll* get_rollchord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode){ // retrieve the chord values as an unmeasured chord, i.e. for [roll]
    t_note *temp_note;
    t_llll* out_llll = llll_get(); 
    double playhead_pos_ms = r_ob->play_head_start_ms;
    
    if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) {
        t_llll *ll = llll_get();
        llll_appendsym(ll, gensym("partial"));
        llll_appenddouble(ll, chord->onset);
        llll_appenddouble(ll, r_ob->play_head_start_ms);
        llll_appenddouble(ll, r_ob->play_head_start_ms - chord->onset);
        llll_appendllll(out_llll, ll);
    } else
        llll_appenddouble(out_llll, chord->onset); // onset
    
    temp_note = chord->firstnote;
    while (temp_note) { // append notes lllls
        if (mode == k_CONSIDER_ALL_NOTES || mode == k_CONSIDER_FOR_SAVING || mode == k_CONSIDER_FOR_EXPORT_OM || mode == k_CONSIDER_FOR_EXPORT_PWGL || mode == k_CONSIDER_FOR_UNDO 
            || ((mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) && should_element_be_played(r_ob, (t_notation_item *)temp_note) && chord->onset + temp_note->duration >= playhead_pos_ms)
            || (mode == k_CONSIDER_FOR_PLAYING_ONLY_IF_SELECTED && notation_item_is_globally_selected(r_ob, (t_notation_item *)temp_note)) 
            || should_element_be_played(r_ob, (t_notation_item *)temp_note))
                llll_appendllll(out_llll, get_rollnote_values_as_llll(r_ob, temp_note, mode), 0, WHITENULL_llll);    
        temp_note = temp_note->next;
    }

    if (mode == k_CONSIDER_FOR_UNDO || (chord->r_it.names->l_size > 0 && mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)) 
        llll_appendllll(out_llll, get_names_as_llll((t_notation_item *)chord, true), 0, WHITENULL_llll);

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)chord);

    if (mode == k_CONSIDER_FOR_UNDO) 
        llll_appendllll(out_llll, get_ID_as_llll((t_notation_item *)chord), 0, WHITENULL_llll);

    return out_llll;
}


// mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_BEGINNING : note has been split through collapsing, and this is the beginning (uncompleted)
// mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE : note has been split through collapsing, and this is the middle (uncompleted)
// mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END : note has been split through collapsing, and this is the end
t_llll* get_scorenote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode)
{
    t_llll* out_llll = llll_get();
    double new_mc = 0., new_vel = 0.;

    // pitch or midicents
    note_appendpitch_to_llll_for_gathered_syntax_or_playout(r_ob, out_llll, note, mode);
    
    llll_appendlong(out_llll, note->velocity, 0, WHITENULL_llll); // velocity
    
    if (mode == k_CONSIDER_FOR_UNDO) {
        // special case. We append an llll and not a single number
        // this llll contains the ID of the note ending the tie, and the ID of the note from which the tie comes (if any: otherwise, 0)
        llll_appendllll(out_llll, long_couple_to_llll(note->tie_to ? (note->tie_to == (t_note *)WHITENULL ? 1 : note->tie_to->r_it.ID) : 0, note->tie_from && note->tie_from != (t_note *)WHITENULL ? note->tie_from->r_it.ID : 0), 0, WHITENULL_llll);
    } else if (mode != k_CONSIDER_FOR_SAMPLING) {
        t_note *pivot = note;
        if ((mode == k_CONSIDER_FOR_PLAYING || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) && (!r_ob->play_tied_elements_separately)) {
            if (r_ob->play_mode == k_PLAYMODE_NOTEWISE)
                pivot = note_get_last_in_tieseq(note);
            else {
                t_chord *last_tied_chord = chord_get_last_in_tieseq(note->parent);
                while (pivot && pivot->tie_to && pivot->tie_to != WHITENULL) {
                    if (pivot->parent == last_tied_chord)
                        break;
                    pivot = pivot->tie_to;
                }
            }
        }
        
        llll_appendlong(out_llll, (mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_BEGINNING || mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE || (pivot ? pivot : note)->tie_to) ? 1 : 0); // start_tie?
    }
    
    if (should_output_note_graphics(r_ob, note, mode))
        llll_appendllll(out_llll, note_get_graphic_values_as_llll(r_ob, note), 0, WHITENULL_llll);
    
    // see if we need breakpoint extras
    if (mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_BEGINNING && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE) {
        t_note *note_for_bpts = note;
        if (mode == k_CONSIDER_FOR_SAMPLING && r_ob->dl_spans_ties)
            note_for_bpts = note_get_first_in_tieseq(note);
        if (note_breakpoints_are_nontrivial(r_ob, note_for_bpts)) {
            llll_appendllll(out_llll, note_get_breakpoint_values_as_llll(r_ob, note_for_bpts, mode, &new_mc, &new_vel), 0, WHITENULL_llll);
            if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_SAMPLING) {
                hatom_setdouble(&out_llll->l_head->l_hatom, new_mc);
                hatom_setlong(&out_llll->l_head->l_next->l_hatom, round(new_vel));
                if (mode == k_CONSIDER_FOR_SAMPLING)
                    llll_betail(out_llll); // don't need breakpoints
            }
        }
    }
    
    // see if we need slots extras (if there's AT LEAST 1 slot, we put them all, so it's practical: slot n is at place n in the list
    if (notation_item_has_slot_content(r_ob, (t_notation_item *)note, mode) && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END)
        llll_appendllll(out_llll, note_get_slots_values_as_llll(r_ob, note, mode, false), 0, WHITENULL_llll);    

    // see if we need articulations
    if (note->num_articulations > 0 && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END && 
        mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)
        llll_appendllll(out_llll, note_get_articulation_values_as_llll(r_ob, note), 0, WHITENULL_llll);    

    if (mode == k_CONSIDER_FOR_UNDO || (note->r_it.names->l_size >0 && mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)) 
        llll_appendllll(out_llll, get_names_as_llll((t_notation_item *)note, true), 0, WHITENULL_llll);

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)note);

#ifdef BACH_NOTES_HAVE_ID
    if (mode == k_CONSIDER_FOR_UNDO) 
        llll_appendllll(out_llll, get_ID_as_llll((t_notation_item *)note), 0, WHITENULL_llll);
#endif
    
    return out_llll;
}

t_chord *chord_get_next(t_chord *chord)
{ // for roll & score
    t_measure *meas;
    
    if (!chord) 
        return NULL;
    
    if (!chord->is_score_chord)    // for ROLL
        return chord->next;
        
    if (chord->next)
        return chord->next;
    
    if (!chord->parent) // special case, only happens for chords created a bit "on the fly" and not inserted in measures
        return NULL;
    
    meas = chord->parent->next; 
    while (meas) {
        if (meas->firstchord)
            return meas->firstchord;
        meas = meas->next;
    }
    
    return NULL;
}


t_chord *chord_get_prev(t_chord *chord)
{ // for score & roll
    if (!chord) 
        return NULL;

    if (!chord->is_score_chord)
        return chord->prev;

    t_measure *meas = chord->parent->prev;

    if (chord->prev)
        return chord->prev;
    
    while (meas) {
        if (meas->lastchord)
            return meas->lastchord;
        meas = meas->prev;
    }

    return NULL;
}


t_chord *chord_get_prev_nonrest(t_chord *chord)
{
    t_chord *ch = chord_get_prev(chord);
    while (ch && ch->r_sym_duration.r_num < 0)
        ch = chord_get_prev(ch);
    return ch;
}

t_chord *chord_get_next_nonrest(t_chord *chord){
    t_chord *ch = chord_get_next(chord);
    while (ch && ch->r_sym_duration.r_num < 0)
        ch = chord_get_next(ch);
    return ch;
}


t_chord *chord_get_next_with_dynamics(t_notation_obj *r_ob, t_chord *chord, long *curr_hairpin_type, char return_last_one_in_any_case, char include_this_chord)
{
    long s = r_ob->link_dynamics_to_slot - 1;
    if (s >= 0 && s < CONST_MAX_SLOTS) {
        for (t_chord *temp = include_this_chord ? chord : chord_get_next(chord); temp; ) {
            t_chord *next_temp = chord_get_next(temp);
            if (chord_has_dynamics(temp)) {
                return temp;
            } else if (return_last_one_in_any_case && !next_temp) {
                return temp;
            }
            temp = next_temp;
        }
    }
    return NULL;
}


t_notation_item *notation_item_get_at_left(t_notation_obj *r_ob, t_notation_item *item, char skip_rests)
{
    t_notation_item *res = NULL;
    if (item->type == k_NOTE) {
        t_chord *prevch = skip_rests ? chord_get_prev_nonrest(((t_note *)item)->parent) : chord_get_prev(((t_note *)item)->parent);
        res = (t_notation_item *)(!prevch ? NULL : nth_note(prevch, CLAMP(note_get_position(r_ob, (t_note *)item) - 1, 0, prevch->num_notes - 1)));
    } else if (item->type == k_CHORD) {
        res = skip_rests ? (t_notation_item *)chord_get_prev_nonrest((t_chord *)item) : (t_notation_item *)chord_get_prev((t_chord *)item);
    } else if (item->type == k_TEMPO) {
        res = (t_notation_item *)tempo_get_prev((t_tempo *)item);
    } else if (item->type == k_MEASURE) {
        res = (t_notation_item *)((t_measure *)item)->prev;
    } else if (item->type == k_PITCH_BREAKPOINT) {
        res = (t_notation_item *)((t_bpt *)item)->prev;
        if (!(((t_bpt *)res)->prev))
            res = NULL; // WE NEVER SELECT the first breakpoint, since it corresponds to the note head, but actually if one wants that, one selects the note itself!
    } else if (item->type == k_MARKER) {
        res = (t_notation_item *)((t_marker *)item)->prev;
    }
    return res;
}


t_notation_item *notation_item_get_at_right(t_notation_obj *r_ob, t_notation_item *item, char skip_rests)
{
    t_notation_item *res = NULL;
    if (item->type == k_NOTE) {
        t_chord *prevch = skip_rests ? chord_get_next_nonrest(((t_note *)item)->parent) : chord_get_next(((t_note *)item)->parent);
        res = (t_notation_item *)(!prevch ? NULL : nth_note(prevch, CLAMP(note_get_position(r_ob, (t_note *)item) - 1, 0, prevch->num_notes - 1)));
    } else if (item->type == k_CHORD) {
        res = skip_rests ? (t_notation_item *)chord_get_next_nonrest((t_chord *)item) : (t_notation_item *)chord_get_next((t_chord *)item);
    } else if (item->type == k_TEMPO) {
        res = (t_notation_item *)tempo_get_next((t_tempo *)item);
    } else if (item->type == k_MEASURE) {
        res = (t_notation_item *)((t_measure *)item)->next;
    } else if (item->type == k_PITCH_BREAKPOINT) {
        res = (t_notation_item *)((t_bpt *)item)->next;
    } else if (item->type == k_MARKER) {
        res = (t_notation_item *)((t_marker *)item)->next;
    }
    return res;
}


t_notation_item *notation_item_get_at_top(t_notation_obj *r_ob, t_notation_item *item, char skip_rests)
{
    t_notation_item *res = NULL;
    if (item->type == k_NOTE) {
        res = (t_notation_item *)((t_note *)item)->next;
    } else if (item->type == k_MEASURE) {
        t_scorevoice *prevvoice = ((t_measure *)item)->voiceparent->prev;
        res = (t_notation_item *)(!prevvoice ? NULL : nth_measure_of_scorevoice(prevvoice, ((t_measure *)item)->measure_number));
    } else if (item->type == k_CHORD) {
        t_voice *prevvoice = voice_get_prev(r_ob, r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)((t_chord *)item)->voiceparent : (t_voice *)((t_chord *)item)->parent->voiceparent); 
        res = (t_notation_item *)(!prevvoice ? NULL : (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ?
                    find_ms_nearest_chord_in_rollvoice(r_ob, (t_rollvoice *)prevvoice, ((t_chord *)item)->onset) :
                                                       (skip_rests ? find_ux_nearest_nonrest_chord_in_scorevoice(r_ob, (t_scorevoice *)prevvoice, chord_get_alignment_ux(r_ob, (t_chord *)item)) : find_ux_nearest_chord_in_scorevoice(r_ob, (t_scorevoice *)prevvoice, chord_get_alignment_ux(r_ob, (t_chord *)item)))));
    } else if (item->type == k_VOICE) {
        t_voice *prev = voiceensemble_get_prev(r_ob, (t_voice *)item);
        if (prev && prev->number >= 0)
            res = (t_notation_item *)prev;
    }
    return res;
}


t_notation_item *notation_item_get_at_bottom(t_notation_obj *r_ob, t_notation_item *item, char skip_rests)
{
    t_notation_item *res = NULL;
    if (item->type == k_NOTE) {
        res = (t_notation_item *)((t_note *)item)->prev;
    } else if (item->type == k_MEASURE) {
        t_scorevoice *nextvoice = ((t_measure *)item)->voiceparent->next;
        res = (t_notation_item *)(!nextvoice ? NULL : nth_measure_of_scorevoice(nextvoice, ((t_measure *)item)->measure_number));
    } else if (item->type == k_CHORD) {
        t_voice *nextvoice = voice_get_next(r_ob, r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)((t_chord *)item)->voiceparent : (t_voice *)((t_chord *)item)->parent->voiceparent); 
        res = (t_notation_item *)(!nextvoice ? NULL : (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? find_ms_nearest_chord_in_rollvoice(r_ob, (t_rollvoice *)nextvoice, ((t_chord *)item)->onset) : 
                                                       (skip_rests ? find_ux_nearest_nonrest_chord_in_scorevoice(r_ob, (t_scorevoice *)nextvoice, chord_get_alignment_ux(r_ob, (t_chord *)item)) : find_ux_nearest_chord_in_scorevoice(r_ob, (t_scorevoice *)nextvoice, chord_get_alignment_ux(r_ob, (t_chord *)item)))));
    } else if (item->type == k_VOICE) {
        t_voice *next = voiceensemble_get_next(r_ob, (t_voice *)item);
        if (next && next->number < r_ob->num_voices) 
            res = (t_notation_item *)next;
    }
    return res;
}


t_note *get_leftmost_selected_note(t_notation_obj *r_ob)
{
    t_notation_item *it, *best = NULL;
    double best_onset = 0, this_onset = 0;
    for (it = r_ob->firstselecteditem; it; it = it->next_selected) {
        t_notation_item *nit = NULL;
        if (it->type == k_NOTE)
            nit = it;
        else if (it->type == k_CHORD)
            nit = (t_notation_item *)(((t_chord *)it)->firstnote);
        
        if (nit){
            this_onset = notation_item_get_onset_ms(r_ob, nit);
            if ((!best) || (this_onset < best_onset)) {
                best_onset = this_onset;
                best = nit;
            }
        }
    }
    return (t_note *)best;
}


t_notation_item *get_leftmost_selected_notation_item(t_notation_obj *r_ob)
{
    t_notation_item *it, *best = NULL;
    double best_onset = 0, this_onset = 0;
    for (it = r_ob->firstselecteditem; it; it = it->next_selected) {
        this_onset = notation_item_get_onset_ms(r_ob, it);
        if ((!best) || (this_onset < best_onset)) {
            best_onset = this_onset;
            best = it;
        }
    }
    return best;
}

t_notation_item *get_rightmost_selected_notation_item(t_notation_obj *r_ob)
{
    t_notation_item *it, *best = NULL;
    double best_onset = 0, this_onset = 0;
    for (it = r_ob->firstselecteditem; it; it = it->next_selected) {
        this_onset = notation_item_get_onset_ms(r_ob, it);
        if ((!best) || (this_onset > best_onset)) {
            best_onset = this_onset;
            best = it;
        }
    }
    return best;
}



void select_markers_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_marker *marker;
    lock_general_mutex(r_ob);
    for (marker = r_ob->firstmarker; marker; marker = marker->next) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)marker, r_ob->n_lexpr);
        if (hatom_gettype(res) == H_LONG && hatom_getlong(res) != 0)
            notation_item_add_to_preselection(r_ob, (t_notation_item *)marker);
        bach_freeptr(res);
    }
    move_preselecteditems_to_selection(r_ob, mode, false, false);
    unlock_general_mutex(r_ob);
}

void select_breakpoints_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode, char tails_only)
{
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    t_bpt *bpt;
    lock_general_mutex(r_ob);
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            for (note = chord->firstnote; note; note = note->next)
                for (bpt = tails_only ? note->lastbreakpoint : (note->firstbreakpoint ? note->firstbreakpoint->next : NULL); bpt; bpt = bpt->next) {
                    t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)bpt, r_ob->n_lexpr);
                    if (hatom_gettype(res) == H_LONG && hatom_getlong(res) != 0)
                        notation_item_add_to_preselection(r_ob, (t_notation_item *)bpt);
                    bach_freeptr(res);
                }
    move_preselecteditems_to_selection(r_ob, mode, false, false);
    unlock_general_mutex(r_ob);
}


void select_single_notation_item(t_notation_obj *r_ob, t_notation_item *item)
{
    lock_general_mutex(r_ob);
    lock_markers_mutex(r_ob);
    clear_selection(r_ob);
    clear_preselection(r_ob);
    notation_item_add_to_preselection(r_ob, item);
    move_preselecteditems_to_selection(r_ob, k_SELECTION_MODE_FORCE_SELECT, true, r_ob->edit_tied_notes_together);
    handle_change_selection(r_ob);
    unlock_markers_mutex(r_ob);
    unlock_general_mutex(r_ob);
}

t_notation_item *notation_item_to_notation_item_for_slot_win_opening(t_notation_obj *r_ob, t_notation_item *item)
{
    switch (item->type) {
        case k_NOTE:
            return item;
            break;
            
        case k_CHORD:
        {
            t_chord *ch = (t_chord *)item;
            if (ch->firstnote)
                return (t_notation_item *)ch->firstnote;
            else
                return item;
        }
            
        default:
            return NULL;
            break;
    }
}

void select_single_notation_item_and_force_inscreen(t_notation_obj *r_ob, t_notation_item *item)
{
    if (r_ob->force_notation_item_inscreen)
        (r_ob->force_notation_item_inscreen)(r_ob, item, NULL);
    select_single_notation_item(r_ob, item);
    
    // transfer slot window if a slot window is open
    if ((item->type == k_CHORD && ((t_chord *)item)->firstnote) || item->type == k_NOTE)
        if (r_ob->active_slot_notationitem)
            open_slot_window(r_ob, r_ob->active_slot_num, notation_item_to_notation_item_for_slot_win_opening(r_ob, item));
}

long get_element_global_flag(t_notation_obj *r_ob, t_notation_item *item){
    long val = k_FLAG_ELEMENT_LOCKED * notation_item_is_globally_locked(r_ob, item) + k_FLAG_ELEMENT_MUTED * notation_item_is_globally_muted(r_ob, item) + k_FLAG_ELEMENT_SOLO * notation_item_is_globally_solo(r_ob, item);
    
    if (item->type == k_MEASURE)
        val += k_FLAG_ELEMENT_BEAMING_TREE_LOCKED * ((t_measure *) item)->lock_rhythmic_tree;
    
    return 0;
}

long get_element_flag(t_notation_obj *r_ob, t_notation_item *item)
{
    long val = 0;
    if (item->type == k_CHORD)
        val = k_FLAG_ELEMENT_LOCKED * ((t_chord *) item)->locked + k_FLAG_ELEMENT_MUTED * ((t_chord *) item)->muted + k_FLAG_ELEMENT_SOLO * ((t_chord *) item)->solo;
    else if (item->type == k_NOTE)
        val = k_FLAG_ELEMENT_LOCKED * ((t_note *) item)->locked + k_FLAG_ELEMENT_MUTED * ((t_note *) item)->muted + k_FLAG_ELEMENT_SOLO * ((t_note *) item)->solo;
    else if (item->type == k_MEASURE)
        val = k_FLAG_ELEMENT_LOCKED * ((t_measure *) item)->locked + k_FLAG_ELEMENT_MUTED * ((t_measure *) item)->muted + k_FLAG_ELEMENT_SOLO * ((t_measure *) item)->solo + k_FLAG_ELEMENT_BEAMING_TREE_LOCKED * ((t_measure *) item)->lock_rhythmic_tree;
    else if (item->type == k_VOICE)
        val = k_FLAG_ELEMENT_LOCKED * ((t_voice *) item)->locked + k_FLAG_ELEMENT_MUTED * ((t_voice *) item)->muted + k_FLAG_ELEMENT_SOLO * ((t_voice *) item)->solo;
    return val;
}

t_symbol *get_element_flag_as_symbol(t_notation_obj *r_ob, t_notation_item *item)
{
    long flag = get_element_flag(r_ob, item);
    return notationitemflag2symbol(flag);
}

t_symbol *get_element_global_flag_as_symbol(t_notation_obj *r_ob, t_notation_item *item)
{
    long flag = get_element_global_flag(r_ob, item);
    return notationitemflag2symbol(flag);
}


void llll_append_notationitem_flag(t_notation_obj *r_ob, t_llll *ll, t_notation_item *item)
{
#ifdef BACH_OUTPUT_SYMBOLIC_FLAGS
    t_symbol *sym = get_element_flag_as_symbol(r_ob, item);
    if (sym) {
        t_llll *flags_ll = llll_get();
        llll_appendsym(flags_ll, _llllobj_sym_flags);
        llll_appendsym(flags_ll, sym);
        llll_appendllll(ll, flags_ll);
    }
#else
    llll_appendlong(ll, get_element_flag(r_ob, item));
#endif
}


void llll_append_notationitem_global_flag(t_notation_obj *r_ob, t_llll *ll, t_notation_item *item)
{
#ifdef BACH_OUTPUT_SYMBOLIC_FLAGS
    t_symbol *sym = get_element_global_flag_as_symbol(r_ob, item);
    if (sym) {
        t_llll *flags_ll = llll_get();
        llll_appendsym(flags_ll, _llllobj_sym_flags);
        llll_appendsym(flags_ll, sym);
        llll_appendllll(ll, flags_ll);
    }
#else
    llll_appendlong(ll, get_element_global_flag(r_ob, item));
#endif
}



t_llll* get_timesignature_as_llll(t_timesignature *ts)
{
    t_llll* outllll = llll_get();
    if (ts->num_numerator_elements == 1) {
        llll_appendlong(outllll, ts->numerator, 0, WHITENULL_llll);
        llll_appendlong(outllll, ts->denominator, 0, WHITENULL_llll);
    } else {
        long i; t_llll* innerllll = llll_get();
        for (i=0; i<ts->num_numerator_elements; i++)
            llll_appendlong(innerllll, ts->numerator_elements[i], 0, WHITENULL_llll);
        llll_appendllll(outllll, innerllll, 0, WHITENULL_llll);
        llll_appendlong(outllll, ts->denominator, 0, WHITENULL_llll);
    }
    return outllll;
}

t_llll* measure_get_tempi_as_llll(t_measure *measure) 
{
    t_llll* outllll = llll_get();
    t_tempo *tempo = measure->firsttempo;
    while (tempo) {
        t_llll *this_tempo_llll = llll_get();
        llll_appendrat(this_tempo_llll, tempo->tempo_figure, 0, WHITENULL_llll);
        if (tempo->figure_tempo_value.r_den == 1)
            llll_appendlong(this_tempo_llll, tempo->figure_tempo_value.r_num, 0, WHITENULL_llll);
        else
            llll_appenddouble(this_tempo_llll, rat2double(tempo->figure_tempo_value), 0, WHITENULL_llll);
        
        if (tempo->interpolation_type != 0) {
            llll_appendrat(this_tempo_llll, tempo->changepoint, 0, WHITENULL_llll);
            llll_appendlong(this_tempo_llll, tempo->interpolation_type, 0, WHITENULL_llll);
        } else if (tempo->changepoint.r_num > 0){
            llll_appendrat(this_tempo_llll, tempo->changepoint, 0, WHITENULL_llll);
        }
        llll_appendllll(outllll, this_tempo_llll, 0, WHITENULL_llll);
        tempo = tempo->next;
    }
    return outllll;
}

t_llll* measure_get_measureinfo_as_llll(t_notation_obj *r_ob, t_measure *measure) 
{
    t_llll* ts_tempo_llll = llll_get();
    
    if (!measure) 
        return ts_tempo_llll;
    
    llll_appendllll(ts_tempo_llll, get_timesignature_as_llll(&measure->timesignature), 0, WHITENULL_llll);
    llll_appendllll(ts_tempo_llll, measure_get_tempi_as_llll(measure), 0, WHITENULL_llll);
    
    if (measure->end_barline->barline_type > 0 && measure->end_barline->barline_type != 'a') {
        char mystring[2];
        t_llll *barlinellll = llll_get();
        llll_appendsym(barlinellll, _llllobj_sym_barline, 0, WHITENULL_llll);
        mystring[0] = measure->end_barline->barline_type;
        mystring[1] = 0;
        llll_appendsym(barlinellll, gensym(mystring), 0, WHITENULL_llll);
        //        llll_appendlong(barlinellll, measure->end_barline->barline_type, 0, WHITENULL_llll);
        llll_appendllll(ts_tempo_llll, barlinellll, 0, WHITENULL_llll);
    }
    
    if (measure->local_spacing_width_multiplier != 1.) {
        t_llll *widthllll = llll_get();
        llll_appendsym(widthllll, _llllobj_sym_widthfactor, 0, WHITENULL_llll);
        llll_appenddouble(widthllll, measure->local_spacing_width_multiplier, 0, WHITENULL_llll);
        llll_appendllll(ts_tempo_llll, widthllll, 0, WHITENULL_llll);
    }

    if (measure->is_spacing_fixed) {
        t_llll *spacingllll = llll_get();
        llll_appendsym(spacingllll, _llllobj_sym_width, 0, WHITENULL_llll);
        llll_appenddouble(spacingllll, measure->fixed_spacing_uwidth, 0, WHITENULL_llll);
        llll_appendllll(ts_tempo_llll, spacingllll, 0, WHITENULL_llll);
    }

    if (!measure->show_measure_number || measure->force_measure_number) {
        t_llll *measnumllll = llll_get();
        llll_appendsym(measnumllll, _llllobj_sym_shownumber, 0, WHITENULL_llll);
        if (!measure->show_measure_number)
            llll_appendsym(measnumllll, _llllobj_sym_off, 0, WHITENULL_llll);
        else
            llll_appendlong(measnumllll, measure->forced_measure_number, 0, WHITENULL_llll);
        llll_appendllll(ts_tempo_llll, measnumllll, 0, WHITENULL_llll);
    }
    
    if (measure->custom_boxing) {
        t_llll *boxesllll = llll_clone(measure->boxes);
        llll_prependsym(boxesllll, _llllobj_sym_boxes, 0, WHITENULL_llll);
        llll_appendllll(ts_tempo_llll, boxesllll, 0, WHITENULL_llll);
    }

    return ts_tempo_llll;
}

long add_g_in_front_of_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && is_level_grace(hatom_getllll(a))){
        llll_prependsym(hatom_getllll(a), _llllobj_sym_g, 0, WHITENULL_llll); // (t_rhythm_level_properties *) 0x1ce1abb0
        return 1;
    }
    return 0;
}

long add_t_after_all_tied_chords_fn(void *data, t_hatom *a, const t_llll *address){
    t_notation_obj *r_ob = (t_notation_obj *) ((void **)data)[0];
    t_llll *root = (t_llll *) ((void **)data)[1];
    if (hatom_gettype(a) == H_OBJ){
        t_chord *ch = (t_chord *)hatom_getobj(a);
        if (chord_is_all_tied_to(r_ob, ch, false, NULL)) {
            llll_insertsym_after(_llllobj_sym_t, llll_nth_one(root, (t_llll *)address), 0, WHITENULL_llll);
        }
    }
    return 0;
}


long add_level_information_fn(void *data, t_hatom *a, const t_llll *address){
    t_llll *box;
    if (hatom_gettype(a) == H_LLLL && (box = hatom_getllll(a))->l_thing.w_obj){
        t_llll *leveltype = llll_get();
        llll_appendsym(leveltype, _llllobj_sym_leveltype);
#ifdef BACH_OUTPUT_SYMBOLIC_LEVELTYPES
        t_symbol *leveltype_as_sym = leveltype2symbol(((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type);
        if (leveltype_as_sym)
            llll_appendsym(leveltype, leveltype_as_sym);
#else
        llll_appendlong(leveltype, ((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type);
#endif
        t_llllelem *leveltypeelem = llll_prependllll(hatom_getllll(a), leveltype);
        if (((t_rhythm_level_properties *)box->l_thing.w_obj)->level_type & k_RHYTHM_LEVEL_FORCE_TUPLET) {
            t_llll *tupletinfo = llll_get();
            llll_appendsym(tupletinfo, _llllobj_sym_tupletinfo);
            llll_appendrat(tupletinfo, ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_local_ratio);
            llll_appendrat(tupletinfo, ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_graphical_unit);
            llll_appendrat(tupletinfo, ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_pregressed_ratio);
            llll_appendrat(tupletinfo, ((t_rhythm_level_properties *)box->l_thing.w_obj)->tupletinfo.tuplet_multiplier);
            llll_insertllll_after(tupletinfo, leveltypeelem);
        }
    }
    return 0;
}

t_llll* measure_get_values_as_llll(t_notation_obj *r_ob, t_measure *measure, e_data_considering_types for_what, char tree, char also_get_level_information)
{
    t_llll* out_llll = llll_get();
    t_llll* body_llll = llll_get();
    t_chord *temp_chord = measure->firstchord;
    
    // measure info: ts and tempi
    llll_appendllll(out_llll, measure_get_measureinfo_as_llll(r_ob, measure), 0, WHITENULL_llll);    
    
    while (temp_chord) { // append chord lllls
        llll_appendllll(body_llll, get_scorechord_values_as_llll(r_ob, temp_chord, for_what, (tree == 0)), 0, WHITENULL_llll);    
        temp_chord = temp_chord->next;
    }
    
    if (tree) {
        llll_reshape(body_llll, measure->rhythmic_tree, clone_rhythm_level_properties_fn);
        
        // adding the "g" symbol in front of any grace level
        llll_funall(body_llll, add_g_in_front_of_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
        
        // adding level information, if requested
        if (also_get_level_information)
            llll_funall(body_llll, add_level_information_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);

        llll_free_all_l_things(body_llll);
    }
    
    llll_chain(out_llll, body_llll);

    if (for_what == k_CONSIDER_FOR_UNDO || (measure->r_it.names->l_size > 0 && for_what != k_CONSIDER_FOR_EXPORT_OM && for_what != k_CONSIDER_FOR_EXPORT_PWGL)) 
        llll_appendllll(out_llll, get_names_as_llll((t_notation_item *)measure, true), 0, WHITENULL_llll);

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)measure);

    if (for_what == k_CONSIDER_FOR_UNDO) 
        llll_appendllll(out_llll, get_ID_as_llll((t_notation_item *)measure), 0, WHITENULL_llll);

    return out_llll;
}

t_llll* get_scorechord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, char put_grace_chord_sym_duration_to_zero){
    // retrieve the chord values as a symbolic chord, i.e. for [score]
    t_llll* out_llll = llll_get(); 
    t_note *temp_note;
    t_rational r_sym_duration = (put_grace_chord_sym_duration_to_zero && chord->is_grace_chord) ? long2rat(0) : chord->r_sym_duration;
    char is_rest = (chord->r_sym_duration.r_num < 0);
     t_rational non_grace_r_sym_duration = (chord->is_grace_chord) ? long2rat(0) : rat_abs(chord->r_sym_duration);
    double ms_duration = chord->duration_ms;
    
    if (mode == k_CONSIDER_FOR_PLAYING || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_EVALUATION) {
        if ((!is_rest && !r_ob->play_tied_elements_separately) || (is_rest && !r_ob->play_rests_separately)) {
            t_chord *tmp_chord = chord;
            while (tmp_chord && (is_rest ? is_chord_followed_by_rest(r_ob, tmp_chord, 0) : chord_is_all_tied_to(r_ob, tmp_chord, 0, NULL))) {
                t_chord *next_chord = chord_get_next(tmp_chord);
                
                if (mode == k_CONSIDER_FOR_EVALUATION && !notation_item_is_globally_selected(r_ob, (t_notation_item *)next_chord))
                    break;
                
                tmp_chord = next_chord;
                if (tmp_chord) {
                    r_sym_duration = rat_rat_sum(r_sym_duration, rat_abs(tmp_chord->r_sym_duration));
                    if (!tmp_chord->is_grace_chord)
                        non_grace_r_sym_duration = rat_rat_sum(non_grace_r_sym_duration, rat_abs(tmp_chord->r_sym_duration));
                    ms_duration += tmp_chord->duration_ms;
                }
            }
        }
    }
    
    if (mode != k_CONSIDER_FOR_PLAYING 
            && mode != k_CONSIDER_FOR_PLAYING_AND_ALLOW_PARTIAL_LOOPED_NOTES
            && mode != k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE
            && mode != k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE
            && mode != k_CONSIDER_FOR_PLAYING_ONLY_IF_SELECTED 
            && mode != k_CONSIDER_FOR_EVALUATION) 
        llll_appendrat(out_llll, r_sym_duration, 0, WHITENULL_llll); // rational_duration
    else if (non_grace_r_sym_duration.r_num > 0)
        llll_appendrat(out_llll, non_grace_r_sym_duration, 0, WHITENULL_llll); // rational_duration
    else { // only in rare playout cases we do this:
        t_llll *ll = llll_get();
        llll_appendsym(ll, _llllobj_sym_g, 0, WHITENULL_llll);
        llll_appendrat(ll, r_sym_duration, 0, WHITENULL_llll); // rational_duration
        llll_appendllll(out_llll, ll, 0, WHITENULL_llll);
    }
    
    if (mode != k_CONSIDER_ALL_NOTES && mode != k_CONSIDER_FOR_UNDO && mode != k_CONSIDER_FOR_SAVING && mode != k_CONSIDER_FOR_EXPORT_OM
         && mode != k_CONSIDER_FOR_EXPORT_PWGL && mode != k_CONSIDER_FOR_SUBDUMPING) {
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE)
            llll_appenddouble(out_llll, ms_duration - (r_ob->play_head_start_ms - chord->onset), 0, WHITENULL_llll); // ms_duration
        else
            llll_appenddouble(out_llll, ms_duration, 0, WHITENULL_llll); // ms_duration
        llll_appendrat(out_llll, chord->r_sym_onset, 0, WHITENULL_llll); // rational_onset in measure
        
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) {
            t_llll *ll = llll_get();
            llll_appendsym(ll, gensym("partial"));
            llll_appenddouble(ll, chord->onset);
            llll_appenddouble(ll, r_ob->play_head_start_ms);
            llll_appenddouble(ll, r_ob->play_head_start_ms - chord->onset);
            llll_appendllll(out_llll, ll);
        } else
            llll_appenddouble(out_llll, chord->onset, 0, WHITENULL_llll); // ms_onset
    }
    
    temp_note = chord->firstnote;
    while (temp_note) { // append notes lllls
        if (mode == k_CONSIDER_ALL_NOTES || mode == k_CONSIDER_FOR_SAVING || mode == k_CONSIDER_FOR_EXPORT_OM || mode == k_CONSIDER_FOR_EXPORT_PWGL || mode == k_CONSIDER_FOR_UNDO || mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_BEGINNING ||
            mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE || mode == k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END
            || mode == k_CONSIDER_FOR_DUMPING || mode == k_CONSIDER_FOR_SLOT_LLLL_EDITOR || mode == k_CONSIDER_FOR_EVALUATION || !notation_item_is_globally_muted(r_ob, (t_notation_item *)temp_note)) 
            llll_appendllll(out_llll, get_scorenote_values_as_llll(r_ob, temp_note, mode), 0, WHITENULL_llll);    
        temp_note = temp_note->next;
    }
    
    // see if we need slots for the rest (if there's AT LEAST 1 slot, we put them all, so it's practical: slot n is at place n in the list
    // ONLY for rests!
    if (!chord->firstnote && notation_item_has_slot_content(r_ob, (t_notation_item *)chord) && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE && mode != k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END)
        llll_appendllll(out_llll, notation_item_get_slots_values_as_llll(r_ob, (t_notation_item *)chord, mode, false), 0, WHITENULL_llll);

    if (chord->num_articulations > 0)
        llll_appendllll(out_llll, chord_get_articulation_values_as_llll(r_ob, chord), 0, WHITENULL_llll);

    if (mode == k_CONSIDER_FOR_UNDO || (chord->r_it.names->l_size > 0 && mode != k_CONSIDER_FOR_EXPORT_OM && mode != k_CONSIDER_FOR_EXPORT_PWGL)) 
        llll_appendllll(out_llll, get_names_as_llll((t_notation_item *)chord, true), 0, WHITENULL_llll);

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)chord);

    if (mode == k_CONSIDER_FOR_UNDO) 
        llll_appendllll(out_llll, get_ID_as_llll((t_notation_item *)chord), 0, WHITENULL_llll);

    return out_llll;
}


char should_play_tied_notes_separately(t_notation_obj *r_ob, t_chord *chord)
{
    if (r_ob->play_mode == k_PLAYMODE_NOTEWISE) 
        return r_ob->play_tied_elements_separately;
    else {
        if (r_ob->play_tied_elements_separately)
            return 1;
        else if (chord_is_all_tied_to(r_ob, chord, false, NULL))
            return 0;
        else
            return 1;
    }
}

t_llll* get_single_scorenote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode)
{
    t_llll* out_llll = llll_get(); 
    t_chord *chord = note->parent;
    
    t_rational r_sym_duration = chord->r_sym_duration;
    t_rational non_grace_r_sym_duration = chord->is_grace_chord ? long2rat(0) : chord->r_sym_duration;
    double ms_duration = chord->duration_ms;
    if ((mode == k_CONSIDER_FOR_PLAYING || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE || mode == k_CONSIDER_FOR_EVALUATION) && (!should_play_tied_notes_separately(r_ob, note->parent))) {
        t_note *tmpnote = note;
        while (tmpnote && tmpnote->tie_to && (tmpnote->tie_to != (t_note *) WHITENULL_llll)) {
            if (mode == k_CONSIDER_FOR_EVALUATION && !notation_item_is_globally_selected(r_ob, (t_notation_item *)tmpnote->tie_to))
                break;
            tmpnote = tmpnote->tie_to;
            if (tmpnote) {
                r_sym_duration = rat_rat_sum(r_sym_duration, tmpnote->parent->r_sym_duration);
                if (!tmpnote->parent->is_grace_chord)
                    non_grace_r_sym_duration = rat_rat_sum(non_grace_r_sym_duration, tmpnote->parent->r_sym_duration);
                ms_duration += tmpnote->parent->duration_ms;
            }
        }
    }
    
    if (mode != k_CONSIDER_FOR_PLAYING 
            && mode != k_CONSIDER_FOR_PLAYING_AND_ALLOW_PARTIAL_LOOPED_NOTES
            && mode != k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE
            && mode != k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE
            && mode != k_CONSIDER_FOR_PLAYING_ONLY_IF_SELECTED 
            && mode != k_CONSIDER_FOR_EVALUATION)
        llll_appendrat(out_llll, r_sym_duration, 0, WHITENULL_llll); // rational_duration
    else if (non_grace_r_sym_duration.r_num > 0)
        llll_appendrat(out_llll, non_grace_r_sym_duration, 0, WHITENULL_llll); // rational_duration
    else { // only in rare playout cases we do this:
        t_llll *ll = llll_get();
        llll_appendsym(ll, _llllobj_sym_g, 0, WHITENULL_llll);
        llll_appendrat(ll, r_sym_duration, 0, WHITENULL_llll); // rational_duration
        llll_appendllll(out_llll, ll, 0, WHITENULL_llll);
    }

    if (mode != k_CONSIDER_ALL_NOTES) {
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE)
            llll_appenddouble(out_llll, ms_duration - (r_ob->play_head_start_ms - chord->onset), 0, WHITENULL_llll); // ms_duration
        else
            llll_appenddouble(out_llll, ms_duration, 0, WHITENULL_llll); // ms_duration
        
        llll_appendrat(out_llll, chord->r_sym_onset, 0, WHITENULL_llll); // rational_onset in measure
        
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) {
            t_llll *ll = llll_get();
            llll_appendsym(ll, gensym("partial"));
            llll_appenddouble(ll, chord->onset);
            llll_appenddouble(ll, r_ob->play_head_start_ms);
            llll_appenddouble(ll, r_ob->play_head_start_ms - chord->onset);
            llll_appendllll(out_llll, ll);
        } else
            llll_appenddouble(out_llll, chord->onset, 0, WHITENULL_llll); // ms_onset
/*
        if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE || mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE)
            llll_appenddouble(out_llll, r_ob->play_head_start_ms, 0, WHITENULL_llll); // ms_onset
        else
            llll_appenddouble(out_llll, chord->onset, 0, WHITENULL_llll); // ms_onset */
    }
    
    llll_appendllll(out_llll, get_scorenote_values_as_llll(r_ob, note, mode), 0, WHITENULL_llll);    

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)note);

    return out_llll;
}

t_llll* get_single_rollnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode)
{
    t_llll* out_llll = llll_get();
    
    if (mode == k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE) {
        t_llll *ll = llll_get();
        llll_appendsym(ll, gensym("partial"));
        llll_appenddouble(ll, note->parent->onset);
        llll_appenddouble(ll, r_ob->play_head_start_ms);
        llll_appenddouble(ll, r_ob->play_head_start_ms - note->parent->onset);
        llll_appendllll(out_llll, ll);
    } else
        llll_appenddouble(out_llll, note->parent->onset, 0, WHITENULL_llll);
    
    llll_appendllll(out_llll, get_rollnote_values_as_llll(r_ob, note, mode), 0, WHITENULL_llll);    

    llll_append_notationitem_flag(r_ob, out_llll, (t_notation_item *)note);
    
    return out_llll;
}

void set_graphic_values_to_note(t_notation_obj *r_ob, t_note *note, long screen_midicents, t_rational accidental)
{
    if (llllobj_get_version_number((t_object *)r_ob, LLLL_OBJ_UI) <= 70910) {
        // backward compatibility, graphics sets the pitch and the midicents
        note_set_user_enharmonicity_from_screen_representation(note, screen_midicents, accidental);
        note->midicents = note->pitch_original.toMC();
    } else {
        // graphics only set the displayed pitch
        note_set_displayed_user_enharmonicity_from_screen_representation(note, screen_midicents, accidental);
    }
}

void set_graphic_values_to_note_from_pitch(t_notation_obj *r_ob, t_note *note, t_pitch pitch)
{
    if (note->pitch_original.isNaP())
        note_set_user_enharmonicity(note, pitch, false);
    note_set_displayed_user_enharmonicity(note, pitch);
}



void set_graphic_values_to_note_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* graphic){
    if (graphic && graphic->l_size >= 2)
        set_graphic_values_to_note(r_ob, note, hatom_getlong(&graphic->l_head->l_hatom), hatom_getrational(&graphic->l_tail->l_hatom));
    else if (graphic && graphic->l_head && hatom_gettype(&graphic->l_head->l_hatom) == H_PITCH)
        set_graphic_values_to_note_from_pitch(r_ob, note, hatom_getpitch(&graphic->l_head->l_hatom));
}


t_hatom *lexpr_eval_for_notation_item(t_notation_obj *r_ob, t_notation_item *it, t_lexpr *lexpr)
{
    t_hatom vars[LEXPR_MAX_VARS];
    hatom_setdouble(vars, notation_item_get_onset_ms(r_ob, it)); 
    hatom_setdouble(vars+1, notation_item_get_cents(r_ob, it)); 
    hatom_setdouble(vars+2, notation_item_get_duration_ms(r_ob, it)); 
    hatom_setlong(vars+3, it->type == k_NOTE ? ((t_note *)it)->velocity : 0); 
    hatom_setrational(vars+4, notation_item_get_symduration(r_ob, it)); 
    hatom_setrational(vars+5, notation_item_get_symonset(r_ob, it)); 
    hatom_setdouble(vars+6, notation_item_get_tail_ms(r_ob, it)); 
    hatom_setrational(vars+7, (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && it->type == k_CHORD) ? rat_rat_sum(((t_chord *)it)->r_sym_onset, ((t_chord *)it)->r_sym_duration) : long2rat(0));
    hatom_setlong(vars+8, notation_item_get_voicenumber(r_ob, it) + 1);
    hatom_setlong(vars+9, notation_item_get_measurenumber(r_ob, it) + 1);
    hatom_setlong(vars+10, notation_item_get_tie_for_lexpr(r_ob, it)); 
    hatom_setlong(vars+11, notation_item_get_noteindex_for_lexpr(r_ob, it)); 
    hatom_setlong(vars+12, notation_item_get_chordindex_for_lexpr(r_ob, it)); 
    hatom_setlong(vars+13, notation_item_get_index_for_lexpr(r_ob, it));
    hatom_setlong(vars+14, notation_item_get_grace_for_lexpr(r_ob, it));
    hatom_setpitch(vars+15, notation_item_get_pitch(r_ob, it));
    hatom_setlong(vars+16, notation_item_get_partnumber(r_ob, it) + 1);
    hatom_setlong(vars+17, notation_item_get_voiceensemble(r_ob, it) + 1);
    notation_item_get_poc(r_ob, it, vars+18);
    return lexpr_eval(lexpr, vars);
}

void change_rational_from_llllelem(t_rational *number, t_llllelem *modify)
{
    if (hatom_gettype(&modify->l_hatom) == H_LLLL) {
        t_llll *thisllll = hatom_getllll(&modify->l_hatom);
        if (thisllll->l_size > 0) {
            if (thisllll->l_size == 1)
                *number = hatom_getrational(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("plus")))
                *number += hatom_getrational(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("minus")))
                *number -= hatom_getrational(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("times")))
                *number *= hatom_getrational(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("div")))
                *number /= hatom_getrational(&thisllll->l_head->l_hatom);
            else
                *number = hatom_getrational(&thisllll->l_head->l_hatom);
        }
    } else {
        *number = hatom_getrational(&modify->l_hatom);
    }
}

void change_double_from_llllelem(double *number, t_llllelem *modify, char convert_deg2rad) { 
    if (hatom_gettype(&modify->l_hatom) == H_LLLL) {
        t_llll *thisllll = hatom_getllll(&modify->l_hatom);
        if (thisllll->l_size > 0) {
            if (thisllll->l_size == 1)
                *number = (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("plus")))
                *number += (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("minus")))
                *number -= (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("times")))
                *number *= hatom_getdouble(&thisllll->l_head->l_hatom); // we DON't do a deg2rad for moltiplicative constants: we assume it'll be a pure number
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("div")))
                *number /= hatom_getdouble(&thisllll->l_head->l_hatom);
            else
                *number = (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
        }
    } else {
        *number = (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&modify->l_hatom)) : hatom_getdouble(&modify->l_hatom);
    }
}

void change_long_from_llllelem(long *number, t_llllelem *modify, char convert_deg2rad) {
    if (hatom_gettype(&modify->l_hatom) == H_LLLL) {
        t_llll *thisllll = hatom_getllll(&modify->l_hatom);
        if (thisllll->l_size > 0) {
            if (thisllll->l_size == 1)
                *number = (convert_deg2rad == 1) ? deg2rad(hatom_getlong(&thisllll->l_head->l_hatom)) : hatom_getlong(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("plus")))
                *number += (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("minus")))
                *number -= (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(&thisllll->l_head->l_hatom)) : hatom_getdouble(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("times")))
                *number *= hatom_getdouble(&thisllll->l_head->l_hatom); 
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("div")))
                *number /= hatom_getdouble(&thisllll->l_head->l_hatom); 
            else
                *number = (convert_deg2rad == 1) ? deg2rad(hatom_getlong(&thisllll->l_head->l_hatom)) : hatom_getlong(&thisllll->l_head->l_hatom);
        }
    } else {
        *number = (convert_deg2rad == 1) ? deg2rad(hatom_getlong(&modify->l_hatom)) : hatom_getlong(&modify->l_hatom);
    }
}

void change_pitch_from_llllelem(t_notation_obj *r_ob, t_pitch *pitch, t_llllelem *modify) {
    if (hatom_gettype(&modify->l_hatom) == H_LLLL) {
        t_llll *thisllll = hatom_getllll(&modify->l_hatom);
        if (thisllll->l_size > 0) {
            if (thisllll->l_size == 1)
                *pitch = hatom_getpitch(&thisllll->l_head->l_hatom, r_ob->tone_division, r_ob->accidentals_preferences);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("plus")))
                *pitch += hatom_getpitch(&thisllll->l_head->l_hatom, r_ob->tone_division, r_ob->accidentals_preferences);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("minus")))
                *pitch -= hatom_getpitch(&thisllll->l_head->l_hatom, r_ob->tone_division, r_ob->accidentals_preferences);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("times")))
                *pitch *= hatom_getlong(&thisllll->l_head->l_hatom);
            else if ((hatom_gettype(&thisllll->l_tail->l_hatom) == H_SYM) && (hatom_getsym(&thisllll->l_tail->l_hatom) == gensym("div")))
                *pitch /= hatom_getrational(&thisllll->l_head->l_hatom);
            else
                *pitch = hatom_getpitch(&thisllll->l_head->l_hatom, r_ob->tone_division, r_ob->accidentals_preferences);
        }
    } else {
        *pitch = hatom_getpitch(&modify->l_hatom, r_ob->tone_division, r_ob->accidentals_preferences);
    }
}

void change_poc_from_llllelem(t_notation_obj *r_ob, t_hatom *poc, t_llllelem *modify) {
    if (hatom_gettype(poc) == H_PITCH) {
        t_pitch p = hatom_getpitch(poc);
        change_pitch_from_llllelem(r_ob, &p, modify);
        hatom_setpitch(poc, p);
    } else {
        double d = hatom_getdouble(poc);
        change_double_from_llllelem(&d, modify, false);
        hatom_setdouble(poc, d);
    }
}



void change_rational(t_notation_obj *r_ob, t_rational *number, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument) {
    // we modify a number via a llllelem (which could be a float itself or a list)
    // if modify is a list it can be of the type (new_value +) or (new_value *)
    // convert_deg2rad == 1 for angle treatment (needs deg2rad function), flag == 0 otherwise
    if (lexpr) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)lexpr_argument, lexpr);
        *number = hatom_getrational(res);
        bach_freeptr(res);
    } else if (modify) {
        change_rational_from_llllelem(number, modify);
    }
}

void change_double(t_notation_obj *r_ob, double *number, t_lexpr *lexpr, t_llllelem *modify, char convert_deg2rad, void *lexpr_argument) { 
// we modify a number via a llllelem (which could be a float itself or a list)
// if modify is a list it can be of the type (new_value +) or (new_value *)
// convert_deg2rad == 1 for angle treatment (needs deg2rad function), flag == 0 otherwise
    if (lexpr) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)lexpr_argument, lexpr);
        *number = (convert_deg2rad == 1) ? deg2rad(hatom_getdouble(res)) : hatom_getdouble(res);
        bach_freeptr(res);
    } else if (modify) {
        change_double_from_llllelem(number, modify, convert_deg2rad);
    }
}

void change_long(t_notation_obj *r_ob, long *number, t_lexpr *lexpr, t_llllelem *modify, char convert_deg2rad, void *lexpr_argument) { 
//same as change_double, but for long inputs. Convert_deg2rad should be always 0 a priori.
    if (lexpr) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)lexpr_argument, lexpr);
        *number = (convert_deg2rad == 1) ? deg2rad(hatom_getlong(res)) : hatom_getlong(res);
        bach_freeptr(res);
    } else if (modify) {
        change_long_from_llllelem(number, modify, convert_deg2rad);
    }
}

// returns 0 if pitch as filled or 1 if cents was filled
long change_pitch(t_notation_obj *r_ob, t_pitch *pitch, double *cents, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument) {
    // we modify a pitch via a llllelem (which could be a float itself or a list)
    // if modify is a list it can be of the type (new_value +) or (new_value *)
    long ret = 0;
    if (lexpr) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)lexpr_argument, lexpr);
        if (hatom_gettype(res) == H_PITCH) {
            *pitch = hatom_getpitch(res, r_ob->tone_division, r_ob->accidentals_preferences);
        } else {
            *cents = hatom_getdouble(res);
            ret = 1;
        }
        bach_freeptr(res);
    } else if (modify) {
        t_llll *thisllll;
        if (hatom_gettype(&modify->l_hatom) == H_PITCH || (hatom_gettype(&modify->l_hatom) == H_LLLL && (thisllll = hatom_getllll(&modify->l_hatom))->l_size > 0 && hatom_gettype(&thisllll->l_head->l_hatom) == H_PITCH)) {
            change_pitch_from_llllelem(r_ob, pitch, modify);
        } else {
            change_double_from_llllelem(cents, modify, false);
            ret = 1;
        }
    }
    return ret;
}

void change_poc(t_notation_obj *r_ob, t_hatom *poc, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument) {
    // we modify a pitch via a llllelem (which could be a float itself or a list)
    // if modify is a list it can be of the type (new_value +) or (new_value *)
    if (lexpr) {
        t_hatom *res = lexpr_eval_for_notation_item(r_ob, (t_notation_item *)lexpr_argument, lexpr);
        if (hatom_gettype(res) == H_PITCH)
            hatom_setpitch(poc, hatom_getpitch(res, r_ob->tone_division, r_ob->accidentals_preferences));
        else
            hatom_setdouble(poc, hatom_getdouble(res));
        bach_freeptr(res);
    } else if (modify) {
        change_poc_from_llllelem(r_ob, poc, modify);
    }
}



void apply_velocity_handling(t_notation_obj *r_ob, t_jrgba *color, double velocity, char is_selected, char is_played)
{
    if (r_ob->velocity_handling == k_VELOCITY_HANDLING_COLORSCALE) {
        apply_velocity_colorscale(color, velocity);
    } else if (r_ob->velocity_handling == k_VELOCITY_HANDLING_COLORSPECTRUM && !is_selected && !is_played) {
        apply_velocity_colorspectrum(color, velocity);
    } else if (r_ob->velocity_handling == k_VELOCITY_HANDLING_ALPHACHANNEL) {
        apply_velocity_alphascale(color, velocity);
    }
}




void notation_item_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_notation_item *nitem)
{
    if (r_ob->link_nitemcolor_to_slot > 0 && r_ob->link_nitemcolor_to_slot <= CONST_MAX_SLOTS) {
        long slotnum = r_ob->link_nitemcolor_to_slot - 1;
        t_slot *slot = notation_item_get_slot(r_ob, nitem, slotnum);
        if (slot) {
            if (slot->firstitem && slot->firstitem->item) {
                if ((r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_INT) || (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_INTLIST))
                    *color = long_to_color(*((long *)slot->firstitem->item));
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_FLOAT)
                    *color = double_to_color(*((double *)slot->firstitem->item), r_ob->slotinfo[slotnum].slot_range[0], r_ob->slotinfo[slotnum].slot_range[1], false);
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_FLOATLIST)
                    *color = floatlist_slot_to_color(slot);
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_COLOR)
                    *color = *((t_jrgba *)slot->firstitem->item);
            }
        }
    }
}


void note_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_note *note)
{
    if (r_ob->link_nitemcolor_to_slot > 0 && r_ob->link_nitemcolor_to_slot <= CONST_MAX_SLOTS) {
        t_note *note_to_consider = note;
        long slotnum = r_ob->link_nitemcolor_to_slot - 1;
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && r_ob->slotinfo[slotnum].slot_singleslotfortiednotes)
            note_to_consider = note_get_first_in_tieseq(note_to_consider);
        if (note_to_consider)
            notation_item_change_color_depending_on_slot_linkage(r_ob, color, (t_notation_item *)note_to_consider);
    }
}
    

void durationline_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_note *note)
{
    
    if (r_ob->link_dlcolor_to_slot > 0 && r_ob->link_dlcolor_to_slot <= CONST_MAX_SLOTS) {
        long slotnum = r_ob->link_dlcolor_to_slot - 1;
        t_note *note_to_consider = note;
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && r_ob->slotinfo[slotnum].slot_singleslotfortiednotes)
        note_to_consider = note_get_first_in_tieseq(note_to_consider);
        if (note_to_consider) {
            if (note_to_consider->slot[slotnum].firstitem && note_to_consider->slot[slotnum].firstitem->item) {
                if ((r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_INT) || (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_INTLIST))
                *color = long_to_color(*((long *)note_to_consider->slot[slotnum].firstitem->item));
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_FLOAT)
                *color = double_to_color(*((double *)note_to_consider->slot[slotnum].firstitem->item), r_ob->slotinfo[r_ob->link_nitemcolor_to_slot-1].slot_range[0], r_ob->slotinfo[slotnum].slot_range[1], false);
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_FLOATLIST)
                *color = floatlist_slot_to_color(&note_to_consider->slot[slotnum]);
                else if (r_ob->slotinfo[slotnum].slot_type == k_SLOT_TYPE_COLOR)
                *color = *((t_jrgba *)note_to_consider->slot[slotnum].firstitem->item);
            }
        }
    }
}



void change_color_according_to_llll(t_jrgba *color, t_llll *llll){
    if (llll){
        if (llll->l_head)
            change_double_from_llllelem(&color->red, llll->l_head, false);
        if (llll->l_head && llll->l_head->l_next)
            change_double_from_llllelem(&color->green, llll->l_head->l_next, false);
        if (llll->l_head && llll->l_head->l_next && llll->l_head->l_next->l_next)
            change_double_from_llllelem(&color->blue, llll->l_head->l_next->l_next, false);
        if (llll->l_head && llll->l_head->l_next && llll->l_head->l_next->l_next && llll->l_head->l_next->l_next->l_next)
            change_double_from_llllelem(&color->alpha, llll->l_head->l_next->l_next->l_next, false);
    }
}




void set_breakpoints_values_to_note_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* breakpoints){ // there's not really a TRUE checking about the validity of the breakpoints, so be careful!
    if (breakpoints){
        t_llllelem *elem;
        if (breakpoints) 
            note_delete_breakpoints(r_ob, note);
        for (elem = breakpoints->l_head; elem; elem = elem->l_next) { // elem iterates on the breakpoints
            long type = hatom_gettype(&elem->l_hatom);
            if (type == H_LLLL) { // there's a nested llll, let's verify if it's in the form (x y s velocity) (x y s) or (x y)
                t_llll *this_bpt = hatom_getllll(&elem->l_hatom); 
                if (this_bpt->l_depth == 1 && this_bpt->l_size >= 2 && this_bpt->l_size <= 4) { // valid breakpoint
                    double sslope, xx, yy, vvel = -1;
                    char auto_vvel = true;
                    t_llllelem *xval, *yval;
                    if (this_bpt->l_size == 2)
                        sslope = 0.;
                    else {
                        sslope = hatom_getdouble(&this_bpt->l_head->l_next->l_next->l_hatom);
                        if (this_bpt->l_size == 4) {
                            vvel = CLAMP(hatom_getlong(&this_bpt->l_tail->l_hatom), CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
                            auto_vvel = false;
                        }
                    }
                    xval = this_bpt->l_head;
                    yval = this_bpt->l_head->l_next;
                    xx = hatom_getdouble(&xval->l_hatom);
                    yy = hatom_getdouble(&yval->l_hatom);
                    if ((xx > 0.) && (xx < 1.)) // inner bpt
                        add_breakpoint(r_ob, note, xx, yy, sslope, 0, vvel, auto_vvel);
                    else if (xx == 1.) {
                        note->lastbreakpoint->slope = sslope;
                        note->lastbreakpoint->delta_mc = yy;
                        note->lastbreakpoint->velocity = auto_vvel ? note->velocity : vvel;
                    }
                }
            }
        }
    }
}

long articulation_symbol2id(const t_articulations_typo_preferences *atp, t_symbol *s)
{
    long i;
    for (i = 0; i < atp->num_articulations; i++) {
        t_articulation_preferences *artpref = &atp->artpref[i];
        if (s == artpref->fullname || s == artpref->shortname ||
            s == artpref->alias[0] || s == artpref->alias[1] || s == artpref->alias[2])
            return i;
    }
    return k_ARTICULATION_NONE;

}

t_symbol* articulation_id2symbol(const t_articulations_typo_preferences *atp, long ID)
{
    if (ID >= 0 && ID < atp->num_articulations)
        return atp->artpref[ID].shortname;
    return _sym_none;

}

t_symbol* notationobj_articulation_id2symbol(t_notation_obj *r_ob, long ID)
{
    return articulation_id2symbol(&r_ob->articulations_typo_preferences, ID);
}

long notationobj_articulation_symbol2id(t_notation_obj *r_ob, t_symbol *s)
{
    return articulation_symbol2id(&r_ob->articulations_typo_preferences, s);
}


long notehead_symbol2id(t_noteheads_typo_preferences *ntp, t_symbol *s)
{
    long i;
    for (i = 0; i < ntp->num_noteheads; i++) {
        t_notehead_preferences *nhpref = &ntp->nhpref[i];
        if (s == nhpref->fullname || s == nhpref->shortname ||
            s == nhpref->alias[0] || s == nhpref->alias[1] || s == nhpref->alias[2])
            return i;
    }
    return k_ARTICULATION_NONE;
    
}

t_symbol* notehead_id2symbol(t_noteheads_typo_preferences *ntp, long ID)
{
    if (ID >= 0 && ID < ntp->num_noteheads)
        return ntp->nhpref[ID].shortname;
    return _sym_none;
    
}

t_symbol* notationobj_notehead_id2symbol(t_notation_obj *r_ob, long ID)
{
    return notehead_id2symbol(&r_ob->noteheads_typo_preferences, ID);
}

long notationobj_notehead_symbol2id(t_notation_obj *r_ob, t_symbol *s)
{
    return notehead_symbol2id(&r_ob->noteheads_typo_preferences, s);
}

long notationobj_notehead_id2unicodechar(t_notation_obj *r_ob, long id, t_rational rdur)
{
    if (r_ob->obj_type != k_NOTATION_OBJECT_SCORE)
        return r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_black;
    
    if (rat_rat_cmp(rdur, long2rat(2)) >= 0)
        return r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_doublewhole;

    if (rat_rat_cmp(rdur, long2rat(1)) >= 0)
        return r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_whole;

    if (rat_rat_cmp(rdur, RAT_1OVER2) >= 0)
        return r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_white;

     return r_ob->noteheads_typo_preferences.nhpref[id].unicode_character_black;
}



char *articulation_to_text_buf(t_articulations_typo_preferences *atp, long artic_ID)
{
    long out_len;
    return charset_unicodetoutf8_debug(&atp->artpref[artic_ID].main_char, 1, &out_len);
}


char *notehead_to_text_buf(t_notation_obj *r_ob, long artic_ID, t_rational rdur)
{
    long out_len;
    unicodeChar uchar = notationobj_notehead_id2unicodechar(r_ob, artic_ID, rdur);
    return charset_unicodetoutf8_debug(&uchar, 1, &out_len);
}



void set_articulations_to_element_from_hatom(t_notation_obj *r_ob, t_notation_item *item, t_hatom* hatom){ 
    long htype = hatom_gettype(hatom);
    if (htype == H_LONG || htype == H_DOUBLE || htype == H_RAT || htype == H_SYM) {
        t_llll *dummy = llll_get();
        llll_appendhatom_clone(dummy, hatom, 0, WHITENULL_llll);
        set_articulations_to_element_from_llll(r_ob, item, dummy);
        llll_free(dummy);
    } else if (htype == H_LLLL) {
        set_articulations_to_element_from_llll(r_ob, item, hatom_getllll(hatom));
    }
}

void set_articulations_to_element_from_llll(t_notation_obj *r_ob, t_notation_item *item, t_llll* articulations){ 
    void *element = item;
    char type = item->type;

    if (articulations){
        t_llllelem *elem;
        long this_num_articulations = articulations->l_size;
        t_articulation **array = NULL;
        
        if (type == k_NOTE) {
            ((t_note *) element)->num_articulations = this_num_articulations;
            array = &((t_note *) element)->articulation;
        } else if (type == k_CHORD) {
            ((t_chord *) element)->num_articulations = this_num_articulations;
            array = &((t_chord *) element)->articulation;
        } else {
            return;
        }

        
        if (*array)
            bach_freeptr(*array);
        *array = NULL;
        
        if (this_num_articulations > 0) {
            *array = (t_articulation *)bach_newptrclear(this_num_articulations * sizeof(t_articulation));
            long i = 0;
            for (elem = articulations->l_head; elem && i < this_num_articulations; elem = elem->l_next, i++) { // elem iterates on the breakpoints
                (*array)[i].articulation_ID = k_ARTICULATION_NONE;
                (*array)[i].need_recompute_position = true;
                (*array)[i].number = i;
                (*array)[i].owner = item;
                (*array)[i].parent = NULL;
                notation_item_init(&((*array)[i].r_it), k_ARTICULATION);

                if (hatom_gettype(&elem->l_hatom) == H_LONG){
                    (*array)[i].articulation_ID = hatom_getlong(&elem->l_hatom);
                } else if (hatom_gettype(&elem->l_hatom) == H_SYM){
                    (*array)[i].articulation_ID = articulation_symbol2id(&r_ob->articulations_typo_preferences, hatom_getsym(&elem->l_hatom));
                }
            }
        }
    }
}

//check mode: 0 = no check; 1 = check min; 2 = check min and max
void notation_item_check_slot_domain(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem, double min, double max, char check_mode)
{
    t_slotitem *it, *delete_from_this = NULL;
    for (it = notation_item_get_slot_firstitem(r_ob, nitem, slot_num); it; it = it->next){
        if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_FUNCTION){
            t_pts *pts = (t_pts *) it->item;
            if (pts) {
                if (check_mode == 2) {
                    if (!delete_from_this && pts->x > max && it->next)
                        delete_from_this = it->next;
                    clip_double(&pts->x, min, max);
                } else if (check_mode == 1)
                    pts->x = MAX(pts->x, min);
            }
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_3DFUNCTION){
            t_pts3d *pts = (t_pts3d *) it->item;
            if (pts) {
                if (check_mode == 2) {
                    if (!delete_from_this && pts->x > max && it->next)
                        delete_from_this = it->next;
                    clip_double(&pts->x, min, max);
                } else if (check_mode == 1)
                    pts->x = MAX(pts->x, min);
            }
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_SPAT){
            t_spatpt *pts = (t_spatpt *) it->item;
            if (pts) {
                if (check_mode == 2) {
                    if (!delete_from_this && pts->t > max && it->next)
                        delete_from_this = it->next;
                    clip_double(&pts->t, min, max);
                } else if (check_mode == 1)
                    pts->t = MAX(pts->t, min);
            }
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_DYNFILTER){
            t_biquad *pts = (t_biquad *) it->item;
            if (pts){
                if (check_mode == 2) {
                    if (!delete_from_this && pts->t > max && it->next)
                        delete_from_this = it->next;
                    clip_double(&pts->t, min, max);
                } else if (check_mode == 1)
                    pts->t = MAX(pts->t, min);
            }
        }
    }
    
    if (delete_from_this) {
        t_slotitem *tempitem = delete_from_this, *next = NULL;
        while (tempitem) {
            next = tempitem->next;
            slotitem_delete(r_ob, slot_num, tempitem);
            tempitem = next;
        }
    }
}


void notation_item_check_slot_zrange(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem, double min, double max){
    t_slotitem *it;
    for (it = notation_item_get_slot_firstitem(r_ob, nitem, slot_num); it; it = it->next){
        if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_3DFUNCTION){
            t_pts3d *pts = (t_pts3d *) it->item;
            if (pts)
                clip_double(&pts->z, min, max);
        }
    }
}

void notation_item_check_slot_range(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem, double min, double max){
    t_slotitem *it;
    for (it = notation_item_get_slot_firstitem(r_ob, nitem, slot_num); it; it = it->next){
        if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_FUNCTION){
            t_pts *pts = (t_pts *) it->item;
            if (pts)
                clip_double(&pts->y, min, max);
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_3DFUNCTION){
            t_pts3d *pts = (t_pts3d *) it->item;
            if (pts)
                clip_double(&pts->y, min, max);
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_SPAT){
                t_spatpt *pts = (t_spatpt *) it->item;
                if (pts)
                    clip_double(&pts->radius, min, max);
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_INT || r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_INTLIST) {
            long *val = (long *) it->item;
            if (val)
                clip_long(val, min, max);
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_FLOAT || r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_FLOATLIST) {
            double *val = (double *) it->item;
            if (val)
                clip_double(val, min, max);
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_INTMATRIX) {
            t_llll *llll = (t_llll *) it->item;
            if (llll) {
                t_llllelem *row;
                for (row = llll->l_head; row; row = row->l_next){
                    if (hatom_gettype(&row->l_hatom) == H_LLLL){
                        t_llll *rowllll = hatom_getllll(&row->l_hatom);
                        t_llllelem *elem;
                        for (elem = rowllll->l_head; elem; elem = elem->l_next){
                            if (is_hatom_number(&elem->l_hatom))
                                hatom_setlong(&elem->l_hatom, CLAMP(hatom_getlong(&elem->l_hatom), min, max));
                        }
                    }
                }
            }
        } else if (r_ob->slotinfo[slot_num].slot_type == k_SLOT_TYPE_FLOATMATRIX) {
            t_llll *llll = (t_llll *) it->item;
            if (llll) {
                t_llllelem *row;
                for (row = llll->l_head; row; row = row->l_next){
                    if (hatom_gettype(&row->l_hatom) == H_LLLL){
                        t_llll *rowllll = hatom_getllll(&row->l_hatom);
                        t_llllelem *elem;
                        for (elem = rowllll->l_head; elem; elem = elem->l_next){
                            if (is_hatom_number(&elem->l_hatom))
                                hatom_setdouble(&elem->l_hatom, CLAMP(hatom_getdouble(&elem->l_hatom), min, max));
                        }
                    }
                }
            }
        }
    }
}

void slot_check_range(t_notation_obj *r_ob, long slot_num){
    char obj_type = r_ob->obj_type;
    long num_voices = r_ob->num_voices;
    void *firstvoice = r_ob->firstvoice;
    double min = r_ob->slotinfo[slot_num].slot_range[0];
    double max = r_ob->slotinfo[slot_num].slot_range[1];

    if (obj_type == k_NOTATION_OBJECT_ROLL){
        t_rollvoice *voice;
        for (voice = (t_rollvoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_chord *ch;
            for (ch = voice->firstchord; ch; ch = ch->next){
                t_note *nt;
                for (nt = ch->firstnote; nt; nt = nt->next)
                    notation_item_check_slot_range(r_ob, slot_num, (t_notation_item *)nt, min, max);
            }
        }
    } else if (obj_type == k_NOTATION_OBJECT_SCORE){
        t_scorevoice *voice;
        for (voice = (t_scorevoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_measure *meas;
            for (meas = voice->firstmeasure; meas; meas = meas->next) {
                t_chord *ch;
                for (ch = meas->firstchord; ch; ch = ch->next){
                    t_note *nt;
                    if (ch->firstnote) {
                        for (nt = ch->firstnote; nt; nt = nt->next)
                            notation_item_check_slot_range(r_ob, slot_num, (t_notation_item *)nt, min, max);
                    } else {
                        notation_item_check_slot_range(r_ob, slot_num, (t_notation_item *)ch, min, max);
                    }
                }
            }
        }
    }
}


void slot_check_zrange(t_notation_obj *r_ob, long slot_num){
    char obj_type = r_ob->obj_type;
    long num_voices = r_ob->num_voices;
    void *firstvoice = r_ob->firstvoice;
    double min = r_ob->slotinfo[slot_num].slot_zrange[0];
    double max = r_ob->slotinfo[slot_num].slot_zrange[1];

    if (obj_type == k_NOTATION_OBJECT_ROLL){
        t_rollvoice *voice;
        for (voice = (t_rollvoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_chord *ch;
            for (ch = voice->firstchord; ch; ch = ch->next){
                t_note *nt;
                for (nt = ch->firstnote; nt; nt = nt->next)
                    notation_item_check_slot_zrange(r_ob, slot_num, (t_notation_item *)nt, min, max);
            }
        }
    } else if (obj_type == k_NOTATION_OBJECT_SCORE){
        t_scorevoice *voice;
        for (voice = (t_scorevoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_measure *meas;
            for (meas = voice->firstmeasure; meas; meas = meas->next) {
                t_chord *ch;
                for (ch = meas->firstchord; ch; ch = ch->next){
                    t_note *nt;
                    if (ch->firstnote) {
                        for (nt = ch->firstnote; nt; nt = nt->next)
                            notation_item_check_slot_zrange(r_ob, slot_num, (t_notation_item *)nt, min, max);
                    } else {
                        notation_item_check_slot_zrange(r_ob, slot_num, (t_notation_item *)ch, min, max);
                    }
                }
            }
        }
    }
}


void slot_check_domain(t_notation_obj *r_ob, long slot_num)
{
    char obj_type = r_ob->obj_type;
    long num_voices = r_ob->num_voices;
    void *firstvoice = r_ob->firstvoice;
    double min = r_ob->slotinfo[slot_num].slot_domain[0];
    double max = r_ob->slotinfo[slot_num].slot_domain[1];
    char max_is_note_duration = (r_ob->slotinfo[slot_num].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS);

    char check_mode = slot_can_extend_beyond_note_tail(r_ob, slot_num) ? 1 : 2;
    
    if (obj_type == k_NOTATION_OBJECT_ROLL){
        t_rollvoice *voice;
        for (voice = (t_rollvoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_chord *ch;
            for (ch = voice->firstchord; ch; ch = ch->next){
                t_note *nt;
                for (nt = ch->firstnote; nt; nt = nt->next) {
                    notation_item_check_slot_domain(r_ob, slot_num, (t_notation_item *)nt, max_is_note_duration ? 0 : min, max_is_note_duration ? notation_item_get_duration_ms(r_ob, (t_notation_item *)nt) : max, check_mode);
                }
            }
        }
    } else if (obj_type == k_NOTATION_OBJECT_SCORE){
        t_scorevoice *voice;
        for (voice = (t_scorevoice *) firstvoice; voice && voice->v_ob.number < num_voices; voice = voice->next){
            t_measure *meas;
            for (meas = voice->firstmeasure; meas; meas = meas->next) {
                t_chord *ch;
                for (ch = meas->firstchord; ch; ch = ch->next){
                    t_note *nt;
                    if (ch->firstnote) {
                        for (nt = ch->firstnote; nt; nt = nt->next)
                            notation_item_check_slot_domain(r_ob, slot_num, (t_notation_item *)nt, max_is_note_duration ? 0 : min, max_is_note_duration ? notation_item_get_duration_ms(r_ob, (t_notation_item *)nt) : max, check_mode);
                    } else {
                        notation_item_check_slot_domain(r_ob, slot_num, (t_notation_item *)ch, max_is_note_duration ? 0 : min, max_is_note_duration ? notation_item_get_duration_ms(r_ob, (t_notation_item *)ch) : max, check_mode);
                    }
                }
            }
        }
    }
}

void slot_check_access(t_notation_obj *r_ob, long slot_num)
{
    if (r_ob->active_slot_num == slot_num && slot_num >= 0 && slot_num < CONST_MAX_SLOTS && r_ob->slotinfo[slot_num].access_type == k_SLOT_ACCESS_CANT) {
        char found = false;
        for (long i = 0; i < CONST_MAX_SLOTS; i++)
            if (r_ob->slotinfo[i].access_type != k_SLOT_ACCESS_CANT) {
                open_slot_window(r_ob, i, r_ob->obj_type == k_NOTATION_OBJECT_SLOT ? (t_notation_item *)r_ob->dummynote : r_ob->active_slot_notationitem, false);
                found = true;
                break;
            }
        if (!found)
            close_slot_window(r_ob);
    }
}



void set_commands_from_llll(t_notation_obj *r_ob, t_llll* commands){
    if (commands) {
        t_llllelem *mainelem; 
        
//        dev_llll_print(commands, NULL, 0, 2, NULL);
        
        for (mainelem = commands->l_head; mainelem; mainelem = mainelem->l_next) { // elem iterates on the chords
            long type = hatom_gettype(&mainelem->l_hatom);
            if (type == H_LLLL) { // there's a nested llll, so specifications for the single slot
                t_llll *single_command = hatom_getllll(&mainelem->l_hatom); 
                // here we should have : (commandnumber command_note_name command_chord_name command_key)
                if (hatom_gettype(&single_command->l_head->l_hatom) == H_LONG) {
                    
                    long j = hatom_getlong(&single_command->l_head->l_hatom) - 1; // commands number is 1-based in the interface, 0-based inside the code
                    if (j >= 0 && j < CONST_MAX_COMMANDS) {
                        
                        // OLD WAY:
                        if (single_command->l_depth == 1 && single_command->l_size >= 4 && hatom_gettype(&single_command->l_head->l_next->l_hatom) == H_SYM) {
                            
                            r_ob->command_note[j] = (hatom_gettype(&single_command->l_head->l_next->l_hatom) == H_SYM) ? hatom_getsym(&single_command->l_head->l_next->l_hatom) : NULL;
                            r_ob->command_chord[j] = (hatom_gettype(&single_command->l_head->l_next->l_next->l_hatom) == H_SYM) ? hatom_getsym(&single_command->l_head->l_next->l_next->l_hatom) : NULL;
                            
                            if (hatom_gettype(&single_command->l_head->l_next->l_next->l_next->l_hatom) == H_LONG)
                                r_ob->command_key[j] = hatom_getlong(&single_command->l_head->l_next->l_next->l_next->l_hatom);
                            else if (hatom_gettype(&single_command->l_head->l_next->l_next->l_next->l_hatom) == H_SYM)
                                r_ob->command_key[j] = hatom_getsym(&single_command->l_head->l_next->l_next->l_next->l_hatom)->s_name[0];
                            
                        } else {
                            // new way, as for slots
                            t_llllelem *elem;
                            for (elem = single_command->l_head->l_next; elem; elem = elem->l_next) {
                                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                                    t_llll *this_llll = hatom_getllll(&elem->l_hatom);
                                    
                                    t_symbol *router = (this_llll && this_llll->l_head && hatom_gettype(&this_llll->l_head->l_hatom) == H_SYM) ? hatom_getsym(&this_llll->l_head->l_hatom) : NULL;
                                    if (router){
                                        
                                        if (router == _llllobj_sym_chord && this_llll->l_head->l_next){
                                            t_symbol *sym = (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM) ? hatom_getsym(&this_llll->l_head->l_next->l_hatom) : _llllobj_sym_chord;
                                            r_ob->command_chord[j] = sym;
                                            
                                        } else if (router == _llllobj_sym_note && this_llll->l_head->l_next){
                                            t_symbol *sym = (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM) ? hatom_getsym(&this_llll->l_head->l_next->l_hatom) : _llllobj_sym_note;
                                            r_ob->command_note[j] = sym;
                                            
                                        } else if (router == _llllobj_sym_rest && this_llll->l_head->l_next){
                                            t_symbol *sym = (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM) ? hatom_getsym(&this_llll->l_head->l_next->l_hatom) : _llllobj_sym_rest;
                                            r_ob->command_rest[j] = sym;
                                            
                                        } else if (router == _llllobj_sym_key && this_llll->l_head->l_next){
                                            if (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_LONG)
                                                r_ob->command_key[j] = hatom_getlong(&this_llll->l_head->l_next->l_hatom);
                                            else if (hatom_gettype(&this_llll->l_head->l_next->l_hatom) == H_SYM)
                                                r_ob->command_key[j] = hatom_getsym(&this_llll->l_head->l_next->l_hatom)->s_name[0];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void atom_set_from_llllelem(t_atom *atom, t_llllelem *elem)
{
    if (!elem) 
        atom_setsym(atom, _llllobj_sym_none);
    else if (hatom_gettype(&elem->l_hatom) == H_LONG)
        atom_setlong(atom, hatom_getlong(&elem->l_hatom));
    else if (hatom_gettype(&elem->l_hatom) == H_DOUBLE)
        atom_setfloat(atom, hatom_getdouble(&elem->l_hatom));
    else if (hatom_gettype(&elem->l_hatom) == H_SYM)
        atom_setsym(atom, hatom_getsym(&elem->l_hatom));
    else
        atom_setsym(atom, _llllobj_sym_none);
}

void set_rollnote_values_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* notevalues){
// notevalues has the form 
// ( midicents duration velocity ( graphic screen_midicents  screen_accidental )
//                                 ( breakpoints  (ms1 mc1 slope1) (ms2 mc2 slope2) (ms3 mc3 slope3)... )
//                                 ( slots (SLOT1_VALUES) (SLOT2_VALUES) ... )
    if (notevalues) {
        
        if (notevalues->l_size >= 3) {
            int i;
            t_llllelem *elem;
            
            long centstype = hatom_gettype(&notevalues->l_head->l_hatom);
            t_pitch pitch_in = t_pitch::NaP;
            
            if ((centstype == H_LONG) || (centstype == H_DOUBLE) || (centstype == H_RAT)) {
                note->midicents = hatom_getdouble(&notevalues->l_head->l_hatom);
                modify_cents_if_nan_or_inf_and_warn(r_ob, &note->midicents);
            } else if (centstype == H_PITCH) {
                pitch_in = hatom_getpitch(&notevalues->l_head->l_hatom);
                note->midicents = pitch_in.toMC();
            } else
                note->midicents = CONST_DEFAULT_NEW_NOTE_CENTS;

            note->duration = is_hatom_number(&notevalues->l_head->l_next->l_hatom) ? hatom_getdouble(&notevalues->l_head->l_next->l_hatom) : CONST_DEFAULT_NEW_NOTE_DURATION;
            note_set_velocity(r_ob, note, is_hatom_number(&notevalues->l_head->l_next->l_next->l_hatom) ? hatom_getlong(&notevalues->l_head->l_next->l_next->l_hatom) : CONST_DEFAULT_NEW_NOTE_VELOCITY);
            clip_long(&note->velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
            
            // Old flag compatibility
            t_llllelem *temp = notevalues->l_size >= 4 ? notevalues->l_head->l_next->l_next->l_next : NULL;
            while (temp && hatom_gettype(&temp->l_hatom) == H_LLLL)
                temp = temp->l_next;
            notation_item_set_flags_from_llllelem(r_ob, temp, (t_notation_item *)note, true);
            
            // now the extras. first: we erase the slots, the graphic and the breakpoints
            note_delete_breakpoints(r_ob, note);
            for (i=0; i< CONST_MAX_SLOTS; i++) 
                note_clear_slot(r_ob, note, i);

            note_set_enharmonicity(note, pitch_in); // we set the enharmonicity

            // then, we RE-create them, if needed
            elem = notevalues->l_head->l_next->l_next->l_next;
            while (elem) { // cycle on the extras
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *extras = hatom_getllll(&elem->l_hatom);
                    t_llllelem *pivot = extras->l_head;
                    if (hatom_gettype(&pivot->l_hatom) == H_SYM) { // the pivot ("graphic", "breakpoints", "slots") must be a symbol!
                        t_symbol *pivotsym = hatom_getsym(&pivot->l_hatom);
                        if (pivotsym == _llllobj_sym_graphic) {
                            llll_destroyelem(pivot);
                            set_graphic_values_to_note_from_llll(r_ob, note, extras); 
                        } else if (pivotsym == _llllobj_sym_name) {
                            llll_destroyelem(pivot);
                            notation_item_set_names_from_llll(r_ob, (t_notation_item *)note, extras);
                        } else if (pivotsym == _llllobj_sym_flags) {
                            llll_destroyelem(pivot);
                            notation_item_set_flags_from_llllelem(r_ob, extras->l_head, (t_notation_item *)note, false);
                        } else if (pivotsym == _llllobj_sym_breakpoints) {
                            llll_destroyelem(pivot);
                            set_breakpoints_values_to_note_from_llll(r_ob, note, extras);
                        } else if (pivotsym == _llllobj_sym_slots) {
                            llll_destroyelem(pivot);
                            set_slots_values_to_note_from_llll(r_ob, note, extras);
                        } else if (pivotsym == _llllobj_sym_articulations) {
                            llll_destroyelem(pivot);
                            set_articulations_to_element_from_llll(r_ob, (t_notation_item *)note, extras);
                        }
                    }
                }
                elem = elem->l_next;
            }
        }    
    }
}


char is_symbol_attribute(t_symbol *sym)
{
    if (sym == _llllobj_sym_ID ||
        sym == _llllobj_sym_name ||
        sym == _llllobj_sym_articulations ||
        sym == _llllobj_sym_graphic ||
        sym == _llllobj_sym_breakpoints ||
        sym == _llllobj_sym_slots ||
        sym == _llllobj_sym_lyrics)
        return 1;
    return 0;
}

t_llllelem *get_next_llll_no_first_attribute_sym_elem(t_llllelem *elem){
    t_llllelem *res = elem->l_next;
    while (res && (hatom_gettype(&res->l_hatom) != H_LLLL || (res->l_hatom.h_w.w_llll->l_head && hatom_gettype(&res->l_hatom.h_w.w_llll->l_head->l_hatom) == H_SYM &&
                    is_symbol_attribute(hatom_getsym(&res->l_hatom.h_w.w_llll->l_head->l_hatom)))))
        res = res->l_next;
    return res;
}

long get_num_llll_no_first_attribute_sym_in_llll(t_llll *inllll) {
//returns the number of elements of a given llll which are also lllls and DON't have a sym as head
    long count = 0;
    if (inllll) {
        t_llllelem *elem;
        for (elem = inllll->l_head; elem; elem = elem->l_next)
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *this_llll = hatom_getllll(&elem->l_hatom);
                if (this_llll && this_llll->l_head && 
                    (hatom_gettype(&this_llll->l_head->l_hatom) != H_SYM || !is_symbol_attribute(hatom_getsym(&this_llll->l_head->l_hatom))))
                    count++;
            }
    }
    
    return count;
}



// onset_delta is a general shift for the onset. Leave it at 0. if you want to preserve the llll onsets!
void set_rollchord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll* chordvalues, double onset_delta, char always_from_scratch, char also_recompute_total_length, char also_check_notes_order)
{
    // chordvalues has the form
    // ( onset ( NOTE1 ) ( NOTE2 ) ( NOTE3 ) ... locked/unlocked)
    if (chordvalues) {
        if (chordvalues->l_size >= 2) {
            t_llllelem *elem;
            t_note *note = NULL;
            unsigned long forced_chord_ID;
            
            chord->onset = hatom_getdouble(&chordvalues->l_head->l_hatom) + onset_delta;
            if (chord->onset < 0)
                chord->onset = 0;
            
            forced_chord_ID = notation_item_get_ID_from_llll(chordvalues);
            if (forced_chord_ID && forced_chord_ID != chord->r_it.ID){
                shashtable_chuck_thing(r_ob->IDtable, chord->r_it.ID);
                shashtable_insert_with_key(r_ob->IDtable, chord, forced_chord_ID, 1);
                chord->r_it.ID = forced_chord_ID;
            }
    
#ifndef BACH_OUTPUT_SYMBOLIC_FLAGS
            notation_item_find_and_set_names(r_ob, (t_notation_item *)chord, chordvalues);
#endif
            
            // Old flag compatibility
            t_llllelem *temp = chordvalues->l_head->l_next;
            while (temp && hatom_gettype(&temp->l_hatom) == H_LLLL)
                temp = temp->l_next;
            notation_item_set_flags_from_llllelem(r_ob, temp, (t_notation_item *)chord, true);
    
#ifdef BACH_OUTPUT_SYMBOLIC_FLAGS
            notation_item_find_and_set_names_and_flags(r_ob, (t_notation_item *)chord, chordvalues);
#endif

            // now the cycle on the notes
            elem = chordvalues->l_head->l_next; 
            note = chord->firstnote;
            while (elem) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *elemllll = hatom_getllll(&elem->l_hatom);
                    if (note) { // there's already a note
                        set_rollnote_values_from_llll(r_ob, note, elemllll);
                        note = note->next;
                    } else { // we gotta create a note within the same chord
                        t_note *this_nt = build_default_note(r_ob);
                        long forced_note_ID = notation_item_get_ID_from_llll(elemllll);
                        
                        note_insert(r_ob, chord, this_nt, forced_note_ID);
                        set_rollnote_values_from_llll(r_ob, this_nt, elemllll);
                    }
                }
                elem = elem->l_next;
            }
            
            if (always_from_scratch) {    // deleting remaining notes
                while (note) {
                    t_note *next = note->next;
                    note_delete(r_ob, note, false);
                    note = next;
                }
            }

            if (also_check_notes_order)
                check_notes_order(chord); // user might have inserted notes in the wrong order. If s/he hasn't, this won't take long
            
            chord->need_recompute_parameters = true; // we have to recalculate chord parameters

            if (also_recompute_total_length) {
                double max_dur = chord_get_max_duration(r_ob, chord);
                update_total_length_from_length_ms_till_last_note(r_ob, chord->onset + max_dur);
//                recompute_total_length(r_ob); 
            }
        }
    }
}


void set_voicenames_from_llll(t_notation_obj *r_ob, t_llll* voicenames, char also_update_notation_obj_voicenames_llll)
{
    if (voicenames) {
        t_voice *voice;
        t_llllelem *elem;
        
//        dev_llll_print(voicenames, NULL, 0, 2, NULL);
        
        if (also_update_notation_obj_voicenames_llll) {
            llll_free(r_ob->voicenames_as_llll);
            r_ob->voicenames_as_llll = llll_get();
        }
        for (elem = voicenames->l_head, voice = r_ob->firstvoice; voice && ((t_voice *)voice)->number < CONST_MAX_VOICES; elem = elem ? elem->l_next : NULL, voice = voice_get_next(r_ob, voice)) {
            if (elem) {
                t_llll *names = get_names_from_llllelem(r_ob, elem);
                change_notation_item_names(r_ob, (t_notation_item *)voice, names, false);
                if (also_update_notation_obj_voicenames_llll && (r_ob->creatingnewobj || ((t_voice *)voice)->number < r_ob->num_voices))
                    llll_appendhatom_clone(r_ob->voicenames_as_llll, &elem->l_hatom, 0, WHITENULL_llll);
                llll_free(names);
            } else {
                change_notation_item_names(r_ob, (t_notation_item *)voice, NULL, false);
                if (also_update_notation_obj_voicenames_llll && (r_ob->creatingnewobj || ((t_voice *)voice)->number < r_ob->num_voices))
                    llll_appendllll(r_ob->voicenames_as_llll, llll_get(), 0, WHITENULL_llll);
            }
        }
        
        // recalculate needed 
        recalculate_voicenames_width(r_ob);
        update_hscrollbar(r_ob, 0);
        notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    }
}


void set_stafflines_from_llll(t_notation_obj *r_ob, t_llll* stafflines, char also_update_notation_obj_stafflines_llll)
{
    if (stafflines) {
        t_voice *voice;
        t_llllelem *elem;
        
        if (also_update_notation_obj_stafflines_llll) {
            llll_free(r_ob->stafflines_as_llll);
            r_ob->stafflines_as_llll = llll_get();
        }
        
        for (elem = stafflines->l_head, voice = r_ob->firstvoice; 
             voice && ((t_voice *)voice)->number < (r_ob->creatingnewobj ? CONST_MAX_VOICES : r_ob->num_voices); 
             elem = elem ? elem->l_next : NULL, voice = voice_get_next(r_ob, voice)) {
            
            set_stafflines_to_voice_from_llllelem(r_ob, (t_voice *)voice, elem, false, stafflines);
            if (also_update_notation_obj_stafflines_llll && (!r_ob->creatingnewobj || ((t_voice *)voice)->number < r_ob->num_voices)) {
                if (elem)
                    llll_appendhatom_clone(r_ob->stafflines_as_llll, &elem->l_hatom, 0, WHITENULL_llll);
                else
                    llll_appendlong(r_ob->stafflines_as_llll, 5, 0, WHITENULL_llll);
            }
        }
        
        // recalculate needed 
        recalculate_voicenames_width(r_ob);
        update_hscrollbar(r_ob, 0);
        notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    }
}


void recalculate_voicenames_width(t_notation_obj *r_ob) {
    if (!r_ob->show_voice_names) {
        r_ob->there_are_voice_names = false;
        r_ob->voice_names_uwidth = 0.;
    } else {
        void *voice = r_ob->firstvoice; 
        double max_width = 0.; 
        char there_is_some_name = false;
        t_jfont *jf_text_names = jfont_create_debug("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, r_ob->voice_names_font_size);
        while (voice && ((t_voice *)voice)->number < r_ob->num_voices) {
            double width, height;
            if (((t_voice *)voice)->r_it.names->l_size == 0 || name_is_abr_none_abr(((t_voice *)voice)->r_it.names))
                width = 0.;
            else {
                char buf[1000];
                get_names_as_text(((t_voice *)voice)->r_it.names, buf, 1000);
                jfont_text_measure(jf_text_names, buf, &width, &height);
            }
            if (!there_is_some_name && width > 0.)
                there_is_some_name = true;
            if (width > max_width) max_width = width;
            voice = voice_get_next(r_ob, (t_voice *) voice);
        } 
        if (there_is_some_name) {
            r_ob->there_are_voice_names = true;
            max_width += CONST_USPACE_BEFORE_VOICENAMES + CONST_USPACE_AFTER_VOICENAMES;
        } else
            r_ob->there_are_voice_names = false;
        
        jfont_destroy_debug(jf_text_names);
        r_ob->voice_names_uwidth = max_width;
    }
}


// won't accept "automatic"
double get_barline_ux_width(t_notation_obj *r_ob, char barline_type)
{
    switch (barline_type) {
        case k_BARLINE_NORMAL:
        case k_BARLINE_DASHED:
        case k_BARLINE_POINTS:
        case k_BARLINE_TICK:
        case k_BARLINE_INTERVOICES:
            return 1;
        case k_BARLINE_HIDDEN:
            return 0;
        case k_BARLINE_SOLID:
            return 3;
        case k_BARLINE_DOUBLE:
            return 4;
        case k_BARLINE_FINAL:
            return 6;
    }
    return 0;
}

double measure_get_barline_ux_width(t_notation_obj *r_ob, t_measure *meas)
{
    char barline_type = meas->end_barline->barline_type;
    
    if (barline_type == 0 || barline_type == k_BARLINE_AUTOMATIC)
        barline_type = meas->next ? k_BARLINE_NORMAL : k_BARLINE_FINAL;
    
    return get_barline_ux_width(r_ob, barline_type);
}


// only used by roll
void recompute_total_length(t_notation_obj *r_ob){
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        double q; 
        double tot_len = 0; 
        char last_elem_is_marker = false;
        t_rollvoice *voice;
        t_chord *curr_ch;
        voice = (t_rollvoice *)r_ob->firstvoice;
        while (voice && (voice->v_ob.number < r_ob->num_voices)) {
            curr_ch = voice->firstchord;
            while(curr_ch){ // cycle on the chords
                long max_duration = 0; //max duration of a note within the chord
                t_note *curr_nt = curr_ch->firstnote;
                while (curr_nt) {
                    if (curr_nt->duration > max_duration)
                        max_duration = curr_nt->duration;
                    curr_nt = curr_nt->next;
                }
                q = curr_ch->onset + max_duration;
                if (q > tot_len) 
                    tot_len = q;
                curr_ch = curr_ch->next;
            }
            voice = voice->next;
        }

        // markers?
        if (r_ob->lastmarker && r_ob->lastmarker->position_ms > tot_len) {
            last_elem_is_marker = true;
            tot_len = r_ob->lastmarker->position_ms;
        } 

        if (tot_len < r_ob->minimum_length) {
            tot_len = r_ob->minimum_length;
            last_elem_is_marker = false;
        }
        
        r_ob->length_ms_till_last_note = tot_len;

        if (r_ob->show_loop_region && r_ob->loop_region.end.position_ms > tot_len) {
            last_elem_is_marker = false;
            tot_len = r_ob->loop_region.end.position_ms;
        }
        
        r_ob->length_ms = tot_len + (last_elem_is_marker ? CONST_TOTAL_ULENGTH_MARKER_ADD : CONST_TOTAL_ULENGTH_ADD) * r_ob->zoom_y;
        if (!r_ob->creatingnewobj)
            r_ob->length_ux = r_ob->length_ms * CONST_X_SCALING; // new total length in unscaled x values
        
        //    post("Stotal length: %ld", tot_len);
        //  redraw_hscrollbar(r_ob, 0, obj_type);

        recalculate_num_systems(r_ob);
    }
}

void update_total_length_from_length_ms_till_last_note(t_notation_obj *r_ob, double total_length_ms_till_last_note)
{
    if (r_ob->length_ms_till_last_note < total_length_ms_till_last_note) {
        r_ob->length_ms_till_last_note = total_length_ms_till_last_note;
        recalculate_num_systems(r_ob);
    }
    
    if (r_ob->length_ms < total_length_ms_till_last_note + CONST_TOTAL_ULENGTH_ADD * r_ob->zoom_y) {
        r_ob->length_ms = total_length_ms_till_last_note + CONST_TOTAL_ULENGTH_ADD * r_ob->zoom_y;
        r_ob->length_ux = r_ob->length_ms * CONST_X_SCALING; // new total length in unscaled x values
    }

}

// from_what:
// 0 = we have the information on the x of the scrollbar;
// 1 = we have the information from 0. to 1. (relative: 0=start/1=end);
// 2 = we have the information about the starting ms of the window
// 3 = like 2, but don't autocorrect the screen_starting_ms ever
void update_hscrollbar(t_notation_obj *r_ob, char from_what)
{
    char obj_type = r_ob->obj_type;
    char need_hscrollbar = false;

    if (r_ob->zoom_x == 0. || r_ob->zoom_y == 0.) 
        return; // something is still not initialized
    
    if (obj_type == k_NOTATION_OBJECT_ROLL) {
        
        if (r_ob->view != k_VIEW_SCROLL) 
            return;
        
        if (r_ob->domain == DBL_MIN)
            return; // we are in the initialization routine! no view has been painted yet
        
        update_domain(r_ob);

        // OLD CODE, when ux wasn't supported in bach.roll
//        need_hscrollbar = ((r_ob->domain / r_ob->length_ms) < 1.);
//        r_ob->hscrollbar_width = r_ob->inner_width * (r_ob->domain/ r_ob->length_ms);
        need_hscrollbar = ((r_ob->domain_ux / r_ob->length_ux) < 1.);
         r_ob->hscrollbar_width = r_ob->inner_width * (r_ob->domain_ux/ r_ob->length_ux);
        
        if (!need_hscrollbar) // was:    if (r_ob->hscrollbar_width >= r_ob->inner_width && r_ob->screen_ms_start > 0)
            r_ob->screen_ms_start = r_ob->screen_ux_start = 0;
        else if (r_ob->hscrollbar_width < CONST_XSCROLLBAR_MIN_UWIDTH * r_ob->zoom_y)
            r_ob->hscrollbar_width = CONST_XSCROLLBAR_MIN_UWIDTH * r_ob->zoom_y;
        
    } else if (obj_type == k_NOTATION_OBJECT_SCORE) {
        
        update_domain(r_ob);

        need_hscrollbar = ((r_ob->domain_ux / r_ob->length_ux) < 1.);
        r_ob->hscrollbar_width = r_ob->inner_width * (r_ob->domain_ux / r_ob->length_ux);
        if (r_ob->hscrollbar_width >= r_ob->inner_width && r_ob->screen_ux_start > 0)
            r_ob->screen_ux_start = 0;
        else if (r_ob->hscrollbar_width < CONST_XSCROLLBAR_MIN_UWIDTH * r_ob->zoom_y)
            r_ob->hscrollbar_width = CONST_XSCROLLBAR_MIN_UWIDTH * r_ob->zoom_y;
    }
    
    if (!need_hscrollbar) {
        // we don't need a scrollbar
        if (obj_type == k_NOTATION_OBJECT_SCORE)
            r_ob->screen_ux_end = r_ob->screen_ux_start + r_ob->domain_ux;
        else if (obj_type == k_NOTATION_OBJECT_ROLL) {
            r_ob->screen_ms_end = r_ob->screen_ms_start + r_ob->domain;
            r_ob->screen_ux_end = r_ob->screen_ux_start + r_ob->domain_ux;
        }
        r_ob->hscrollbar_width = r_ob->inner_width;
        r_ob->need_hscrollbar = 0;
    } else { // we do need a scroll bar
        r_ob->need_hscrollbar = 1;

        if (from_what == 2 || from_what == 3){ // we have the information about the starting ms of the window
            // r_ob->scrollbarpos must be 0 at screen_start_ms = 0,  1 at screen_start_ms = length_ms - domain
            if (obj_type == k_NOTATION_OBJECT_ROLL) {
                if (r_ob->lambda_spacing)
                    r_ob->hscrollbar_pos = ((float)r_ob->screen_ux_start) / (r_ob->length_ux - r_ob->domain_ux);
                else
                    r_ob->hscrollbar_pos = ((float)r_ob->screen_ms_start) / (r_ob->length_ms - r_ob->domain);
            } else if (obj_type == k_NOTATION_OBJECT_SCORE)
                r_ob->hscrollbar_pos = r_ob->screen_ux_start / (r_ob->length_ux - r_ob->domain_ux);
            if (r_ob->hscrollbar_pos < 0.) { //we're at zero!
                r_ob->hscrollbar_pos = 0.;
                r_ob->hscrollbar_x = r_ob->j_inset_x;
            } else if (r_ob->hscrollbar_pos > 1.) { //we're at the end
                r_ob->hscrollbar_pos = 1.;
                r_ob->hscrollbar_x = r_ob->j_inset_x + r_ob->inner_width - r_ob->hscrollbar_width;
            } else { // we stay in the middle
                r_ob->hscrollbar_x =  r_ob->j_inset_x + r_ob->hscrollbar_pos * (r_ob->inner_width - r_ob->hscrollbar_width);
            }

        } else if (from_what == 1){ // we have the information from 0. to 1. 
            if (r_ob->hscrollbar_pos < 0.) { //we're at zero!
                r_ob->hscrollbar_pos = 0.;
                r_ob->hscrollbar_x = r_ob->j_inset_x;
            } else if (r_ob->hscrollbar_pos > 1.) { //we're at the end
                r_ob->hscrollbar_pos = 1.;
                r_ob->hscrollbar_x = r_ob->j_inset_x + r_ob->inner_width - r_ob->hscrollbar_width;
            } else { // we stay in the middle
                r_ob->hscrollbar_x =  r_ob->j_inset_x + r_ob->hscrollbar_pos * (r_ob->inner_width - r_ob->hscrollbar_width);
            }

        } else { // we have the information on the x of the scrollbar
            if (r_ob->hscrollbar_x < r_ob->j_inset_x) { //we're at zero!
                r_ob->hscrollbar_x = r_ob->j_inset_x ;
                r_ob->hscrollbar_pos = 0.;
            } else if (r_ob->hscrollbar_x + r_ob->hscrollbar_width > r_ob->j_inset_x + r_ob->inner_width) { //we're at the end
                r_ob->hscrollbar_x = r_ob->j_inset_x + r_ob->inner_width - r_ob->hscrollbar_width;
                r_ob->hscrollbar_pos = 1.;
            } else { // we stay in the middle
                r_ob->hscrollbar_pos = ((double)(r_ob->hscrollbar_x - r_ob->j_inset_x)) / ((double)(r_ob->inner_width - r_ob->hscrollbar_width));
            }
        }
        
//        post("new scrollbar position: pos: %.2f, r_ob->hscrollbar_x = %d", r_ob->hscrollbar_pos, r_ob->hscrollbar_x);
        if (obj_type == k_NOTATION_OBJECT_ROLL) {
            r_ob->screen_ux_start = (r_ob->length_ux - r_ob->domain_ux)*r_ob->hscrollbar_pos;
            r_ob->screen_ux_end = r_ob->screen_ux_start + r_ob->domain_ux;
            if (from_what < 3) {
                if (r_ob->lambda_spacing)
                    r_ob->screen_ms_start = xposition_to_onset(r_ob, unscaled_xposition_to_xposition(r_ob, r_ob->screen_ux_start), 0);
                else
                    r_ob->screen_ms_start = (r_ob->length_ms - r_ob->domain) * r_ob->hscrollbar_pos;
            }
//            dev_post("scrollbar pos: %.2f, domain: %.2f, screen_ms_start = %.2f", r_ob->hscrollbar_pos, r_ob->domain, r_ob->screen_ms_start);
            r_ob->screen_ms_end = r_ob->screen_ms_start + r_ob->domain;
        } else if (obj_type == k_NOTATION_OBJECT_SCORE) {
            if (from_what < 3)
                r_ob->screen_ux_start = (r_ob->length_ux - r_ob->domain_ux)*r_ob->hscrollbar_pos;
            r_ob->screen_ux_end = r_ob->screen_ux_start + r_ob->domain_ux;
        }
    }
    
//    dev_post("ms_start: %.2f, ms_end: %.2f", r_ob->screen_ms_start, r_ob->screen_ms_end);

 }

void redraw_hscrollbar(t_notation_obj *r_ob, char from_pos){
    update_hscrollbar(r_ob, from_pos);
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
}


// *** vertical scrollbar ***
void update_vscrollbar(t_notation_obj *r_ob, char from_what){
    double needed_height;
    char need_vscrollbar = false;
    char need_vscrollbar_prev = r_ob->need_vscrollbar;
    double vspace_for_hscrollbar = r_ob->need_hscrollbar && r_ob->show_hscrollbar ? (CONST_XSCROLLBAR_UHEIGHT + 2 + CONST_XSCROLLBAR_WHITE_UPAD_UPON) * r_ob->zoom_y + fabs(CONST_XSCROLLBAR_Y_SHIFT) : 0;
    

    if (r_ob->view == k_VIEW_SCROLL && r_ob->link_vzoom_to_height) {
        r_ob->need_vscrollbar = false;
        return;
    }

    needed_height = r_ob->needed_uheight * r_ob->zoom_y;
    need_vscrollbar = ((r_ob->height / needed_height) < 1.);
    r_ob->vscrollbar_height = (r_ob->inner_height - 2 * CONST_YSCROLLBAR_INNER_PAD - vspace_for_hscrollbar) * (r_ob->height / needed_height);
    if (r_ob->vscrollbar_height < CONST_YSCROLLBAR_MIN_UHEIGHT * r_ob->zoom_y)
        r_ob->vscrollbar_height = CONST_YSCROLLBAR_MIN_UHEIGHT * r_ob->zoom_y;

    if (!need_vscrollbar) {
        // we don't need a yscrollbar
        r_ob->vscrollbar_height = r_ob->inner_height;
        r_ob->need_vscrollbar = 0;
        r_ob->vscrollbar_pos = 0.;
        r_ob->vscrollbar_pixnudge = 0;
    } else { // we do need a scroll bar
        r_ob->need_vscrollbar = 1;

        if (from_what == 1){ // we have the information from 0. to 1. 
            if (r_ob->vscrollbar_pos < 0.) { //we're at zero!
                r_ob->vscrollbar_pos = 0.;
                r_ob->vscrollbar_y = r_ob->j_inset_y + CONST_YSCROLLBAR_INNER_PAD;
            } else if (r_ob->vscrollbar_pos > 1.) { //we're at the end
                r_ob->vscrollbar_pos = 1.;
                r_ob->vscrollbar_y = r_ob->j_inset_y + r_ob->inner_height - r_ob->vscrollbar_height - CONST_YSCROLLBAR_INNER_PAD;
            } else { // we stay in the middle
                r_ob->vscrollbar_y =  r_ob->j_inset_y + CONST_YSCROLLBAR_INNER_PAD + r_ob->vscrollbar_pos * (r_ob->inner_height - r_ob->vscrollbar_height);
            }
            
        } else { // we have the information on the y of the yscrollbar
            if (r_ob->vscrollbar_y < r_ob->j_inset_y + CONST_YSCROLLBAR_INNER_PAD) { //we're at zero!
                r_ob->vscrollbar_y = r_ob->j_inset_y + CONST_YSCROLLBAR_INNER_PAD;
                r_ob->vscrollbar_pos = 0.;
            } else if (r_ob->vscrollbar_y + r_ob->vscrollbar_height > r_ob->j_inset_y + r_ob->inner_height - vspace_for_hscrollbar - CONST_YSCROLLBAR_INNER_PAD) { //we're at the end
                r_ob->vscrollbar_y = r_ob->j_inset_y + r_ob->inner_height - r_ob->vscrollbar_height - vspace_for_hscrollbar - CONST_YSCROLLBAR_INNER_PAD; //r_ob->height
                r_ob->vscrollbar_pos = 1.;
            } else { // we stay in the middle
                r_ob->vscrollbar_pos = ((double)(r_ob->vscrollbar_y - r_ob->j_inset_y - CONST_YSCROLLBAR_INNER_PAD)) / 
                                            ((double)(r_ob->inner_height - 2 * CONST_YSCROLLBAR_INNER_PAD - vspace_for_hscrollbar - r_ob->vscrollbar_height));
            }
        }
        // calculating first_shown_system and last_shown_system
        r_ob->first_shown_system = 0;
        r_ob->last_shown_system = r_ob->num_systems - 1;
        r_ob->vscrollbar_pixnudge = round(-r_ob->vscrollbar_pos * (r_ob->needed_uheight * r_ob->zoom_y - r_ob->height));
    }
    
    if (need_vscrollbar_prev != r_ob->need_vscrollbar){
        calculate_ms_on_a_line(r_ob);
        recalculate_num_systems(r_ob);
    }
}

void redraw_vscrollbar(t_notation_obj *r_ob, char from_pos){
    update_vscrollbar(r_ob, from_pos);
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
}



void change_zoom(t_notation_obj *r_ob, double new_zoom_0_to_100){
    //zoom clip
    if (new_zoom_0_to_100 < CONST_MIN_ZOOM) new_zoom_0_to_100 = CONST_MIN_ZOOM;
    if (new_zoom_0_to_100 > CONST_MAX_ZOOM) new_zoom_0_to_100 = CONST_MAX_ZOOM;

    r_ob->horizontal_zoom = new_zoom_0_to_100;
    r_ob->zoom_x = r_ob->horizontal_zoom / 100.;
    
    set_all_label_families_update_contour(r_ob);
}


// ************* NAME <---> NOTE CONVERSIONS **************

// also allocates the memory for outname if outname is NULL; a safe allocation is 100 chars
void midicents2notename(long middleC_octave, long screen_mc, t_rational screen_acc, char name_style, char print_octave, char **outname){
    char notename[5], accidental[100];
    long octave = floor(screen_mc / 1200.);
    long note = (screen_mc - 1200 * octave)/100;

    if (!*outname)
        *outname = (char *)bach_newptr(110 * sizeof(char));
    
    if (note == 0) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Do" : "C");
    else if (note == 2) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Re" : "D");
    else if (note == 4) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Mi" : "E");
    else if (note == 5) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Fa" : "F");
    else if (note == 7) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Sol" : "G");
    else if (note == 9) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "La" : "A");
    else if (note == 11) snprintf_zero(notename, 5, name_style == k_NOTE_NAMES_LATIN ? "Si" : "B");
    else snprintf_zero(notename, 5, "??");
    
    t_rational screen_acc_representable = screen_acc; // part of the accidental representable by standard signs like + # b x...
    t_rational screen_acc_mod = long2rat(0);

    if (screen_acc.r_den != 4 && screen_acc.r_den != 2 && screen_acc.r_den != 1) {
        // if the alteration is less than a quartertone, we might need to use also arrows to be added to standard signs
        screen_acc_mod = rat_rat_mod(screen_acc, RAT_1OVER4, false);
        screen_acc_representable = rat_rat_diff(screen_acc, screen_acc_mod);
    }
    
    int cur = 0;
    char sign = screen_acc_representable.r_num >= 0 ? 1 : -1;
    t_rational acc = rat_abs(screen_acc_representable);
    t_rational HALF = RAT_1OVER2;
    t_rational QUARTER = RAT_1OVER4;
    while (rat_long_cmp(acc, 0) > 0 && cur < 97) {
        if (sign == 1 && rat_long_cmp(acc, 1) >= 0) {
            acc = rat_long_diff(acc, 1);
            strncpy(accidental + cur, "x", 1);
            cur++;
        } else if (rat_rat_cmp(acc, HALF) >= 0) {
            acc = rat_rat_diff(acc, HALF);
            strncpy(accidental + cur, sign > 0 ? "#" : "b", 1);
            cur++;
        } else if (rat_rat_cmp(acc, QUARTER) >= 0) {
            acc = rat_rat_diff(acc, QUARTER);
            strncpy(accidental + cur, sign > 0 ? "q" : "d", 1);
            cur++;
        } else {
            strncpy(accidental + cur, sign > 0 ? "^" : "v", 1);
            cur++;
            break;
        }
    }
    
    if (screen_acc_mod.r_num != 0) {
        strncpy(accidental + cur, screen_acc_mod.r_num > 0 ? "^" : "v", 1);
        cur++;
    }

    accidental[cur] = 0;

    // handling octave
    octave = (octave - 5) + middleC_octave;
    if (print_octave)
        snprintf_zero(*outname, 110, "%s%s%ld", notename, accidental, octave);
    else
        snprintf_zero(*outname, 110, "%s%s", notename, accidental);
}


void ezmidicents2notename(long middleC_octave, double midicents, char name_style, char print_octave, char **outname, long tonedivision){
    long screen_mc = 6000;
    t_rational screen_acc = genrat(0, 1);
    mc_to_screen_approximations_do(tonedivision, k_ACC_AUTO, midicents, &screen_mc, &screen_acc, NULL, NULL);
    midicents2notename(middleC_octave, screen_mc, screen_acc, name_style, print_octave, outname);
}



void key_and_mode_to_step_and_accidental(char key, char mode, t_rational *acc_pattern, char *step, t_rational *accidental){
    if (mode == k_MODE_MAJOR){
        switch (key) {
            case 0:
                *step = 0;
                *accidental = long2rat(0);
                return;
            case 1:
                *step = 4;
                *accidental = long2rat(0);
                return;
            case 2:
                *step = 1;
                *accidental = long2rat(0);
                return;
            case 3:
                *step = 5;
                *accidental = long2rat(0);
                return;
            case 4:
                *step = 2;
                *accidental = long2rat(0);
                return;
            case 5:
                *step = 6;
                *accidental = long2rat(0);
                return;
            case 6:
                *step = 3;
                *accidental = RAT_1OVER2;
                return;
            case 7:
                *step = 0;
                *accidental = RAT_1OVER2;
                return;
            case -1:
                *step = 3;
                *accidental = long2rat(0);
                return;
            case -2:
                *step = 6;
                *accidental = genrat(-1, 2);
                return;
            case -3:
                *step = 2;
                *accidental = genrat(-1, 2);
                return;
            case -4:
                *step = 5;
                *accidental = genrat(-1, 2);
                return;
            case -5:
                *step = 1;
                *accidental = genrat(-1, 2);
                return;
            case -6:
                *step = 4;
                *accidental = genrat(-1, 2);
                return;
            default:
                *step = -1;
                *accidental = long2rat(0);
                return;
        }
    } else if (mode == k_MODE_MINOR){
        switch (key) {
            case 0:
                *step = 5;
                *accidental = long2rat(0);
                return;
            case 1:
                *step = 2;
                *accidental = long2rat(0);
                return;
            case 2:
                *step = 6;
                *accidental = long2rat(0);
                return;
            case 3:
                *step = 3;
                *accidental = RAT_1OVER2;
                return;
            case 4:
                *step = 0;
                *accidental = RAT_1OVER2;
                return;
            case 5:
                *step = 4;
                *accidental = RAT_1OVER2;
                return;
            case 6:
                *step = 1;
                *accidental = RAT_1OVER2;
                return;
            case 7:
                *step = 5;
                *accidental = RAT_1OVER2;
                return;
            case -1:
                *step = 1;
                *accidental = long2rat(0);
                return;
            case -2:
                *step = 4;
                *accidental = long2rat(0);
                return;
            case -3:
                *step = 0;
                *accidental = long2rat(0);
                return;
            case -4:
                *step = 3;
                *accidental = long2rat(0);
                return;
            case -5:
                *step = 6;
                *accidental = genrat(-1, 2);
                return;
            case -6:
                *step = 2;
                *accidental = genrat(-1, 2);
                return;
            default:
                *step = -1;
                *accidental = long2rat(0);
                return;
        }
    } else {
        *step = -1;
        *accidental = long2rat(0);
        return;
    }
}

void diatonicstep_and_accidental2notename(long step, t_rational acc, char name_style, char **outname){
    long len;
    midicents2notename(3, diatonicstep2midicents(step, 3), acc, name_style, true, outname);
    if (*outname){
        len = strlen(*outname);
        if (len > 0)
            (*outname)[len - 1] = 0;
    }
}

long midicents2diatonicstep(long mc){
    long step = (mc / 100) % 12; 
    if (step == 0) 
        return 0; //C
    if (step == 2) 
        return 1; //D
    if (step == 4) 
        return 2; //E
    if (step == 5) 
        return 3; //F
    if (step == 7) 
        return 4; //G
    if (step == 9) 
        return 5; //A
    if (step == 11) 
        return 6; //B
    return -1;
}

long diatonicstep2midicents(long step, long octave){
    long mc = octave * 1200; 
    if (step == 0) 
        return mc; //C
    if (step == 1) 
        return mc + 200; //D
    if (step == 2) 
        return mc + 400; //E
    if (step == 3) 
        return mc + 500; //F
    if (step == 4) 
        return mc + 700; //G
    if (step == 5) 
        return mc + 900; //A
    if (step == 6) 
        return mc + 1100; //B
    return mc;
}

// returns 1 if the interval between degree and degree+1 is a tone.
// e.g. with degree = 1 --> 0, with degree = 2 ->1 (mi-fa is a semitone)
char is_diatonic_step_after_degree_semitone(long degree){
    if (degree == 2 || degree == 6) 
        return 1;
    else
        return 0;
}

void fill_full_repr_talea_for_major_scale(t_rational *talea, char accidental_preferences)
{
    t_rational zero = long2rat(0), one_over_two = RAT_1OVER2, minus_one_over_two = genrat(-1, 2),
                one_over_four = RAT_1OVER4, minus_one_over_four = genrat(-1, 4), one_over_eight = RAT_1OVER8,
                minus_one_over_eight = genrat(-1, 8), three_over_eight = genrat(3, 8), minus_three_over_eight = genrat(-3, 8),
                five_over_eight = genrat(5, 8), minus_five_over_eight = genrat(-5, 8),
                seven_over_eight = genrat(7, 8), minus_seven_over_eight = genrat(-7, 8),
                three_over_four = genrat(3, 4), minus_three_over_four = genrat(-3, 4);
    
    char sharps = accidental_preferences == k_ACC_SHARPS;
    char flats = accidental_preferences == k_ACC_FLATS;
    
    talea[0] = zero;
    talea[1] = flats ? minus_seven_over_eight : one_over_eight;
    talea[2] = flats ? minus_three_over_four : one_over_four;
    talea[3] = flats ? minus_five_over_eight : three_over_eight;
    talea[4] = flats ? minus_one_over_two : one_over_two;
    talea[5] = sharps ? five_over_eight : minus_three_over_eight;
    talea[6] = sharps ? three_over_four : minus_one_over_four;
    talea[7] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[8] = zero;
    talea[9] = flats ? minus_seven_over_eight : one_over_eight;
    talea[10] = flats ? minus_three_over_four : one_over_four;
    talea[11] = flats ? minus_five_over_eight : three_over_eight;
    talea[12] = sharps ? one_over_two : minus_one_over_two;
    talea[13] = sharps ? five_over_eight : minus_three_over_eight;
    talea[14] = sharps ? three_over_four : minus_one_over_four;
    talea[15] = sharps ? seven_over_eight : minus_one_over_eight;
    
    talea[16] = zero;
    talea[17] = flats ? minus_three_over_eight : one_over_eight;
    talea[18] = flats ? minus_one_over_four : one_over_four;
    talea[19] = sharps ? three_over_eight : minus_one_over_eight;

    talea[20] = zero;
    talea[21] = flats ? minus_seven_over_eight : one_over_eight;
    talea[22] = flats ? minus_three_over_four : one_over_four;
    talea[23] = flats ? minus_five_over_eight : three_over_eight;
    talea[24] = flats ? minus_one_over_two : one_over_two;
    talea[25] = sharps ? five_over_eight : minus_three_over_eight;
    talea[26] = sharps ? three_over_four : minus_one_over_four;
    talea[27] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[28] = zero;
    talea[29] = flats ? minus_seven_over_eight : one_over_eight;
    talea[30] = flats ? minus_three_over_four : one_over_four;
    talea[31] = flats ? minus_five_over_eight : three_over_eight;
    talea[32] = sharps ? one_over_two : minus_one_over_two;
    talea[33] = sharps ? five_over_eight : minus_three_over_eight;
    talea[34] = sharps ? three_over_four : minus_one_over_four;
    talea[35] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[36] = zero;
    talea[37] = flats ? minus_seven_over_eight : one_over_eight;
    talea[38] = flats ? minus_three_over_four : one_over_four;
    talea[39] = flats ? minus_five_over_eight : three_over_eight;
    talea[40] = sharps ? one_over_two : minus_one_over_two;
    talea[41] = sharps ? five_over_eight : minus_three_over_eight;
    talea[42] = sharps ? three_over_four : minus_one_over_four;
    talea[43] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[44] = zero;
    talea[45] = flats ? minus_three_over_eight : one_over_eight;
    talea[46] = flats ? minus_one_over_four : one_over_four;
    talea[47] = sharps ? three_over_eight : minus_one_over_eight;
}



void fill_full_repr_talea_for_minor_scale(t_rational *talea, char accidental_preferences)
{
    t_rational zero = long2rat(0), one_over_two = RAT_1OVER2, minus_one_over_two = genrat(-1, 2),
                one_over_four = RAT_1OVER4, minus_one_over_four = genrat(-1, 4), one_over_eight = RAT_1OVER8,
                minus_one_over_eight = genrat(-1, 8), three_over_eight = genrat(3, 8), minus_three_over_eight = genrat(-3, 8),
                five_over_eight = genrat(5, 8), minus_five_over_eight = genrat(-5, 8),
                seven_over_eight = genrat(7, 8), minus_seven_over_eight = genrat(-7, 8),
                three_over_four = genrat(3, 4), minus_three_over_four = genrat(-3, 4);
    
    char sharps = accidental_preferences == k_ACC_SHARPS;
    char flats = accidental_preferences == k_ACC_FLATS;
    
    talea[0] = zero;
    talea[1] = flats ? minus_seven_over_eight : one_over_eight;
    talea[2] = flats ? minus_three_over_four : one_over_four;
    talea[3] = flats ? minus_five_over_eight : three_over_eight;
    talea[4] = sharps ? one_over_two : minus_one_over_two;
    talea[5] = sharps ? five_over_eight : minus_three_over_eight;
    talea[6] = sharps ? three_over_four : minus_one_over_four;
    talea[7] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[8] = zero;
    talea[9] = flats ? minus_three_over_eight : one_over_eight;
    talea[10] = flats ? minus_one_over_four : one_over_four;
    talea[11] = sharps ? three_over_eight : minus_one_over_eight;

    talea[12] = zero;
    talea[13] = flats ? minus_seven_over_eight : one_over_eight;
    talea[14] = flats ? minus_three_over_four : one_over_four;
    talea[15] = flats ? minus_five_over_eight : three_over_eight;
    talea[16] = flats ? minus_one_over_two : one_over_two;
    talea[17] = sharps ? five_over_eight : minus_three_over_eight;
    talea[18] = sharps ? three_over_four : minus_one_over_four;
    talea[19] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[20] = zero;
    talea[21] = flats ? minus_seven_over_eight : one_over_eight;
    talea[22] = flats ? minus_three_over_four : one_over_four;
    talea[23] = flats ? minus_five_over_eight : three_over_eight;
    talea[24] = flats ? minus_one_over_two : one_over_two;
    talea[25] = sharps ? five_over_eight : minus_three_over_eight;
    talea[26] = sharps ? three_over_four : minus_one_over_four;
    talea[27] = sharps ? seven_over_eight : minus_one_over_eight;
    
    talea[28] = zero;
    talea[29] = flats ? minus_three_over_eight : one_over_eight;
    talea[30] = flats ? minus_one_over_four : one_over_four;
    talea[31] = sharps ? three_over_eight : minus_one_over_eight;

    talea[32] = zero;
    talea[33] = flats ? minus_seven_over_eight : one_over_eight;
    talea[34] = flats ? minus_three_over_four : one_over_four;
    talea[35] = flats ? minus_five_over_eight : three_over_eight;
    talea[36] = flats ? minus_one_over_two : one_over_two;
    talea[37] = sharps ? five_over_eight : minus_three_over_eight;
    talea[38] = sharps ? three_over_four : minus_one_over_four;
    talea[39] = sharps ? seven_over_eight : minus_one_over_eight;

    talea[40] = zero;
    talea[41] = flats ? minus_seven_over_eight : one_over_eight;
    talea[42] = flats ? minus_three_over_four : one_over_four;
    talea[43] = flats ? minus_five_over_eight : three_over_eight;
    talea[44] = flats ? minus_one_over_two : one_over_two;
    talea[45] = sharps ? five_over_eight : minus_three_over_eight;
    talea[46] = sharps ? three_over_four : minus_one_over_four;
    talea[47] = sharps ? seven_over_eight : minus_one_over_eight;
}


long diatonic_step_and_accidental_to_chromatic_step(char diatonic_step, t_rational accidental, long tonedivision)
{
    long chromatic_base_step = 0;
    long tdd2 = tonedivision / 2;
    switch (diatonic_step) {
        case 0:        chromatic_base_step = 0;            break;
        case 1:        chromatic_base_step = 2 * tdd2;        break;
        case 2:        chromatic_base_step = 4 * tdd2;        break;
        case 3:        chromatic_base_step = 5 * tdd2;        break;
        case 4:        chromatic_base_step = 7 * tdd2;        break;
        case 5:        chromatic_base_step = 9 * tdd2;        break;
        case 6:        chromatic_base_step = 11 * tdd2;    break;
        default:    break;
    }
    return positive_mod(chromatic_base_step + rat_long_prod(accidental, 2 * tdd2).r_num, 6 * tonedivision);
}

// base_step must be between 0 and 6
void superimpose_full_repr_talea_to_acc_pattern(t_rational *result, t_rational *full_repr_talea, t_rational *acc_pattern, char base_step, t_rational base_acc, long tonedivision)
{
    long start_pos = diatonic_step_and_accidental_to_chromatic_step(base_step, base_acc, 8);
    long i, count, j = base_step; t_rational prev_talea_acc = long2rat(0);
    for (i = start_pos, count = 0; count < 48; count++, i = i < 47 ? i + 1 : 0){
        t_rational this_talea_acc = full_repr_talea[count];
        if (count > 0 && rat_rat_cmp(this_talea_acc, prev_talea_acc) <= 0)
            j = positive_mod(j + 1, 7);
        result[i] = rat_rat_sum(acc_pattern[j], this_talea_acc);
        prev_talea_acc = this_talea_acc;
    }
}

void check_all_voices_fullaccpatterns(t_notation_obj *r_ob)
{
    t_voice *tempvoice;
    long v;
    for (v = 0, tempvoice = r_ob->firstvoice; v < r_ob->num_voices && tempvoice && tempvoice->number < r_ob->num_voices; v++, tempvoice = voice_get_next(r_ob,tempvoice))
        if (r_ob->full_acc_repr[v] != _llllobj_sym_default)
            r_ob->full_acc_repr[v] = full_repr_to_symbol(r_ob, tempvoice);
    parse_fullaccpattern_to_voices(r_ob);
}

void fill_default_full_repr(t_notation_obj *r_ob, t_rational *full_repr, char key, char mode, t_rational *acc_pattern)
{
    t_rational talea[48];
    long i;

    if ((mode == k_MODE_MAJOR || mode == k_MODE_MINOR) && acc_pattern) {
        char base_step;
        t_rational base_acc;
        key_and_mode_to_step_and_accidental(key, mode, acc_pattern, &base_step, &base_acc);
        
        if (base_step >= 0) {
            if (base_acc.r_den == 1 || base_acc.r_den == 2 || base_acc.r_den == 4 || base_acc.r_den == 8) {
                if (mode == k_MODE_MAJOR)
                    fill_full_repr_talea_for_major_scale(talea, r_ob->accidentals_preferences);
                else
                    fill_full_repr_talea_for_minor_scale(talea, r_ob->accidentals_preferences);
                superimpose_full_repr_talea_to_acc_pattern(full_repr, talea, acc_pattern, base_step, base_acc, r_ob->tone_division);
                //            char *buf = rat_array_to_string(full_repr, 48, false);
                //            dev_post(buf);
                //            bach_freeptr(buf);
                return;
            }
        }
    }

    // else: a standard configuration
    for (i = 0; i < 12; i++){
        if (i == 1 || i == 3 || i == 6 || i == 8 || i == 10)
            continue;
        if (i == 4 || i == 11) {
            full_repr[4*i] = long2rat(0);
            full_repr[4*i + 1] = RAT_1OVER8;
            full_repr[4*i + 2] = RAT_1OVER4;
            full_repr[4*i + 3] = genrat(-1, 8);
        } else {
            full_repr[4*i] = long2rat(0);
            full_repr[4*i + 1] = RAT_1OVER8;
            full_repr[4*i + 2] = RAT_1OVER4;
            full_repr[4*i + 3] = genrat(3, 4);
            full_repr[4*i + 4] = RAT_1OVER2;
            full_repr[4*i + 5] = genrat(-3, 8);
            full_repr[4*i + 6] = genrat(-1, 4);
            full_repr[4*i + 7] = genrat(-1, 8);
        }    
    }
}


// returns the key
char basenote2key(t_notation_obj *r_ob, double screen_midicents, t_rational screen_acc, char mode, t_rational *acc_pattern){
    long step = midicents2diatonicstep(screen_midicents); // step is now
    t_rational curr_acc = screen_acc;
    char mode_t_st[7]; 
    long i;
    for (i = 0; i < 6; i++) 
        mode_t_st[i] = 0; // tone
    
    if (mode < 0) { // minor
        mode_t_st[1] = 1;
        mode_t_st[4] = 1;
    } else if (mode > 0) { // major
        mode_t_st[2] = 1;
        mode_t_st[6] = 1;
    } else
        return -100;
    
    if (step < 0)
        return -100;
        
    // filling acc_pattern
    for (i = 0; i < 7; i++){
        char dst = is_diatonic_step_after_degree_semitone((step + i) % 7);
        char diff = dst - mode_t_st[i]; // -1 if a semitone was expected, but a tone is there; 1 if a tone was expected and a semitone was there; 0 if we get what we need
        acc_pattern[(step + i) % 7] = curr_acc;
        curr_acc = rat_rat_sum(curr_acc, rat_long_prod(RAT_1OVER2, diff));
    }
    
    // finding key as 5th-circle-position
    if ((step == 0 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 5 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return 0;
    if ((step == 4 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 2 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return 1;
    if ((step == 1 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 6 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return 2;
    if ((step == 5 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 3 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode < 0))
        return 3;
    if ((step == 2 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 0 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode < 0))
        return 4;
    if ((step == 6 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 4 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode < 0))
        return 5;
    if ((step == 3 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode > 0) ||
        (step == 1 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode < 0))
        return 6;
    if ((step == 0 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode > 0) ||
        (step == 6 && rat_rat_cmp(screen_acc, RAT_1OVER2) == 0 && mode < 0))
        return 7;

    if ((step == 3 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode > 0) ||
        (step == 1 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return -1;
    if ((step == 6 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 4 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return -2;
    if ((step == 2 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 0 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return -3;
    if ((step == 5 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 3 && rat_rat_cmp(screen_acc, long2rat(0)) == 0 && mode < 0))
        return -4;
    if ((step == 1 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 6 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode < 0))
        return -5;
    if ((step == 4 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 2 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode < 0))
        return -6;
    if ((step == 0 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode > 0) ||
        (step == 5 && rat_rat_cmp(screen_acc, genrat(-1,2)) == 0 && mode < 0))
        return -7;
        
    return -100; // nonstandard
}




double notename2midicents(long middleC_octave, long *last_used_octave, char *name, long *screen_mc, t_rational *screen_acc){
// fills screen_mc and screen_acc;
    long note = 0, octave = 5;
    t_rational acc = long2rat(0);
    char err = false;
    long len = strlen(name);
    long cursor = 0;

    if (len < 1)
        err = true;
    
    if (!err) {
        if (strncmp(name, "do", 2) == 0 || strncmp(name, "DO", 2) == 0 || strncmp(name, "Do", 2) == 0 ||
            (strncmp(name, "ut", 2) == 0 || strncmp(name, "UT", 2) == 0 || strncmp(name, "Ut", 2) == 0)) {
            note = 0;
            cursor += 2;
        } else if (strncmp(name, "re", 2) == 0 || strncmp(name, "RE", 2) == 0 || strncmp(name, "Re", 2) == 0) {
            note = 2;
            cursor += 2;
        } else if (strncmp(name, "mi", 2) == 0 || strncmp(name, "MI", 2) == 0 || strncmp(name, "Mi", 2) == 0) {
            note = 4;
            cursor += 2;
        } else if (strncmp(name, "fa", 2) == 0 || strncmp(name, "FA", 2) == 0 || strncmp(name, "Fa", 2) == 0) {
            note = 5;
            cursor += 2;
        } else if (strncmp(name, "sol", 3) == 0 || strncmp(name, "SOL", 3) == 0 || strncmp(name, "Sol", 3) == 0) {
            note = 7;
            cursor += 3;
        } else if (strncmp(name, "la", 2) == 0 || strncmp(name, "LA", 2) == 0 || strncmp(name, "La", 2) == 0) {
            note = 9;
            cursor += 2;
        } else if (strncmp(name, "si", 2) == 0 || strncmp(name, "SI", 2) == 0 || strncmp(name, "Si", 2) == 0) {
            note = 11;
            cursor += 2;
        } else if (strncmp(name, "a", 1) == 0 || strncmp(name, "A", 1) == 0) {
            note = 9;
            cursor += 1;
        } else if (strncmp(name, "b", 1) == 0 || strncmp(name, "B", 1) == 0) {
            note = 11;
            cursor += 1;
        } else if (strncmp(name, "c", 1) == 0 || strncmp(name, "C", 1) == 0) {
            note = 0;
            cursor += 1;
        } else if (strncmp(name, "d", 1) == 0 || strncmp(name, "D", 1) == 0) {
            note = 2;
            cursor += 1;
        } else if (strncmp(name, "e", 1) == 0 || strncmp(name, "E", 1) == 0) {
            note = 4;
            cursor += 1;
        } else if (strncmp(name, "f", 1) == 0 || strncmp(name, "F", 1) == 0) {
            note = 5;
            cursor += 1;
        } else if (strncmp(name, "g", 1) == 0 || strncmp(name, "G", 1) == 0) {
            note = 7;
            cursor += 1;
        } else {
            err = true;
        }
    }
    
    if (!err) {
        while (cursor < len &&
                (name[cursor] == '#' || name[cursor] == 'b' || name[cursor] == 'x' || name[cursor] == '+' || name[cursor] == 'q'
                    || name[cursor] == '-' || name[cursor] == 'd' || name[cursor] == '^' || name[cursor] == 'v')) {
            switch (name[cursor]) {
                case '#':
                    acc = rat_rat_sum(acc, RAT_1OVER2);
                    break;
                case 'b':
                    acc = rat_rat_sum(acc, genrat(-1,2));
                    break;
                case 'x':
                    acc = rat_long_sum(acc, 1);
                    break;
                case '+':
                case 'q':
                    acc = rat_rat_sum(acc, RAT_1OVER4);
                    break;
                case '-':
                case 'd':
                    acc = rat_rat_sum(acc, genrat(-1,4));
                    break;
                case '^':
                    acc = rat_rat_sum(acc, RAT_1OVER8);
                    break;
                case 'v':
                    acc = rat_rat_sum(acc, genrat(-1, 8));
                    break;
            }
            cursor++; 
        }
    }
    
    if (!err && cursor < len){
        octave = atoi(&name[cursor]) + (5 - middleC_octave);
        if (octave < CONST_MIN_OCTAVE || octave > CONST_MAX_OCTAVE) octave = 5;
        if (last_used_octave)
            *last_used_octave = octave;
    } else if (last_used_octave && (*last_used_octave >= CONST_MIN_OCTAVE && *last_used_octave <= CONST_MAX_OCTAVE)) {
        octave = *last_used_octave;
    }
    
    if (err){
        if (screen_mc)
            *screen_mc = CONST_DEFAULT_NEW_NOTE_CENTS;
        if (screen_acc)
            *screen_acc = long2rat(0);
        return CONST_DEFAULT_NEW_NOTE_CENTS;
    } else {
        if (screen_mc)
            *screen_mc = octave * 1200 + note * 100;
        if (screen_acc)
            *screen_acc = acc;
        return octave * 1200 + note * 100 + rat2double(acc)*200;
    }
}


t_llll *get_default_slots_to_transfer_1based(t_notation_obj * r_ob)
{
    t_llll *res = llll_get();
    if (r_ob->link_dynamics_to_slot > 0)
        llll_appendlong(res, r_ob->link_dynamics_to_slot);
    if (r_ob->link_lyrics_to_slot > 0)
        llll_appendlong(res, r_ob->link_lyrics_to_slot);
    if (r_ob->link_articulations_to_slot > 0)
        llll_appendlong(res, r_ob->link_articulations_to_slot);
    if (r_ob->link_annotation_to_slot > 0)
        llll_appendlong(res, r_ob->link_annotation_to_slot);
    return res;
}


t_llll *notation_item_get_slots_to_be_copied(t_notation_obj *r_ob, t_notation_item *from, t_llll *which_slots_1based, char even_if_empty)
{
    t_llll *temp = NULL;
    
    // we copy the entire slot
    if (hatom_gettype(&which_slots_1based->l_head->l_hatom) == H_SYM && hatom_getsym(&which_slots_1based->l_head->l_hatom) == _llllobj_sym_all)
        temp = notation_item_get_slots_values_as_llll(r_ob, from, k_CONSIDER_FOR_DUMPING, even_if_empty);
    else if (hatom_gettype(&which_slots_1based->l_head->l_hatom) == H_SYM && hatom_getsym(&which_slots_1based->l_head->l_hatom) == _llllobj_sym_auto) {
        t_llll *sl = get_default_slots_to_transfer_1based(r_ob);
        temp = notation_item_get_multiple_slots_values_as_llll(r_ob, from, k_CONSIDER_FOR_DUMPING, even_if_empty, sl);
        llll_free(sl);
    } else
        temp = notation_item_get_multiple_slots_values_as_llll(r_ob, from, k_CONSIDER_FOR_DUMPING, even_if_empty, which_slots_1based);
    return temp;
}

void notation_item_copy_slots(t_notation_obj *r_ob, t_notation_item *from, t_notation_item *to, t_llll *which_slots_1based, char even_if_empty)
{
    if (!which_slots_1based || !which_slots_1based->l_head)
        return;
    
    t_llll *temp = notation_item_get_slots_to_be_copied(r_ob, from, which_slots_1based, even_if_empty);
    set_slots_values_to_notationitem_from_llll(r_ob, to, temp);
    llll_free(temp);
}


void note_transfer_slots_to_siebling(t_notation_obj *r_ob, t_note *nt, t_llll *which_slots_1based, char even_if_empty, char even_to_rests)
{
    if (which_slots_1based) {
        t_notation_item *dest_it = NULL;
        if (nt->next)
            dest_it = (t_notation_item *)nt->next;
        else if (nt->prev)
            dest_it = (t_notation_item *)nt->prev;
        if (dest_it)
            notation_item_copy_slots(r_ob, (t_notation_item *)nt, dest_it, which_slots_1based, even_if_empty);
        else if (even_to_rests && r_ob->obj_type == k_NOTATION_OBJECT_SCORE && !nt->prev && !nt->next) {
            // transfer slots to rest!!!
            notation_item_copy_slots(r_ob, (t_notation_item *)nt, (t_notation_item *)nt->parent, which_slots_1based, even_if_empty);
        }
    }
}



// returns 1 if needs to check correct scheduling, 0 otherwise
void note_delete(t_notation_obj *r_ob, t_note *note, char need_recompute_total_length)
{
    // delete a note from a chord
    if (note){
        t_chord *chord = note->parent;
        char note_is_at_the_end = false;
        char need_check_solos = is_solo_with_progeny(r_ob, (t_notation_item *)note);
        
        if (need_recompute_total_length)
            note_is_at_the_end = (chord->onset + note->duration > r_ob->length_ms_till_last_note - 10) ? 1 : 0;
        
        if (!chord)
            return;
        
        note_check_dependencies_before_deleting_it(r_ob, note, true);
         
        chord->num_notes--; 
        if (note->prev) {
            // not the first note
            if (note->next) {
                // not the last note
                note->prev->next = note->next;
                note->next->prev = note->prev;
            } else {
                // last note
                note->prev->next = NULL;
                chord->lastnote = note->prev;
            }
        } else {
            // first note
            if (note->next) {
                // some notes remain
                note->next->prev = NULL;
                chord->firstnote = note->next;
            } else {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
                    // there was just 1 note: gotta delete the whole chord
                    if (chord_delete(r_ob, chord, chord_get_prev(chord), need_recompute_total_length))
                        check_correct_scheduling(r_ob, false);
                    close_slot_window(r_ob); // if we were in slot view...
                    return;
                } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                    // there was just 1 note: gotta make the whole chord become a rest!
                    chord->r_sym_duration = rat_long_prod(rat_abs(chord->r_sym_duration), -1);
                    chord->firstnote = NULL;
                    chord->lastnote = NULL;
                }
            }
        }
        
        // freeing memory
        free_note(r_ob, note);
        
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
            chord->need_recompute_parameters = true; // we have to recalculate chord parameters 
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            recompute_all_measure_chord_parameters(r_ob, chord->parent); // we have to recalculate chord parameters
            chord->parent->need_recompute_beams_positions = true;
            chord->parent->need_check_ties = true;
            chord->parent->need_check_autocompletion = true; 
            if (chord->parent->tuttipoint_reference) 
                chord->parent->tuttipoint_reference->need_recompute_spacing = k_SPACING_RECALCULATE;
            set_need_perform_analysis_and_change_flag(r_ob);
        }
        
        if (need_recompute_total_length && note_is_at_the_end)
            recompute_total_length(r_ob);
        
        if (need_check_solos)
            update_solos(r_ob);
    
    }
    return;
}


void set_scorenote_values_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* notevalues, char always_from_scratch){
// notevalues has the form 
// ( midicents velocity tie ( graphic screen_midicents  screen_accidental )
//                                 ( breakpoints  (ms1 mc1 slope1) (ms2 mc2 slope2) (ms3 mc3 slope3)... )
//                                 ( slots (SLOT1_VALUES) (SLOT2_VALUES) ... )

    if (always_from_scratch) 
        delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)note);

    if (notevalues) {
        
        if (notevalues->l_size >= 1) {

            long centstype = hatom_gettype(&notevalues->l_head->l_hatom);
            t_pitch pitch_in = t_pitch::NaP;
            int i;
            if ((centstype == H_LONG) || (centstype == H_DOUBLE) || (centstype == H_RAT)) {
                note->midicents = hatom_getdouble(&notevalues->l_head->l_hatom);
                modify_cents_if_nan_or_inf_and_warn(r_ob, &note->midicents);
            } else if (centstype == H_PITCH) {
                pitch_in = hatom_getpitch(&notevalues->l_head->l_hatom);
                note->midicents = pitch_in.toMC();
            } else
                note->midicents = CONST_DEFAULT_NEW_NOTE_CENTS;

            note_set_velocity(r_ob, note, (notevalues->l_size >= 2 && is_hatom_number(&notevalues->l_head->l_next->l_hatom)) ? hatom_getlong(&notevalues->l_head->l_next->l_hatom) : CONST_DEFAULT_NEW_NOTE_VELOCITY);
            
            // Handling ties
            note->tie_to = NULL;
            if (notevalues->l_size >= 3) {
                if (is_hatom_number(&notevalues->l_head->l_next->l_next->l_hatom)) {
                    if (hatom_getlong(&notevalues->l_head->l_next->l_next->l_hatom) > 0)
                        note->tie_to = (t_note *) WHITENULL;
                    
                } else if (hatom_gettype(&notevalues->l_head->l_next->l_next->l_hatom) == H_LLLL) {
                    // special case which is reserved for undo. a negative value means: note must have a tie_from, and the negative value is the opposite of the ID of the note starting such tie
                    t_llll *ties_ll = hatom_getllll(&notevalues->l_head->l_next->l_next->l_hatom);
                    if (ties_ll->l_size >= 2 && is_hatom_number(&ties_ll->l_head->l_hatom) && is_hatom_number(&ties_ll->l_head->l_next->l_hatom)) {
                        long l1 = hatom_getlong(&ties_ll->l_head->l_hatom);
                        long l2 = hatom_getlong(&ties_ll->l_head->l_next->l_hatom);
                        if (l1 > 0)
                            note->tie_to = (t_note *) WHITENULL;
                        if (l2 > 0) {
                            t_notation_item *tie_from_this = notation_item_retrieve_from_ID(r_ob, l2);
                            if (tie_from_this && tie_from_this->type == k_NOTE) {
                                ((t_note *)tie_from_this)->tie_to = (t_note *) WHITENULL;
                                ((t_note *)tie_from_this)->parent->parent->need_check_ties = true;
                            }
                        }
                    }
                }
            }

            
            // Old flag compatibility
            t_llllelem *temp = notevalues->l_size >= 4 ? notevalues->l_head->l_next->l_next->l_next : NULL;
            while (temp && hatom_gettype(&temp->l_hatom) == H_LLLL)
                temp = temp->l_next;
            notation_item_set_flags_from_llllelem(r_ob, temp, (t_notation_item *)note, true);
            
            
            // now the extras. first: we erase the slots, the graphic and the breakpoints
            note->pitch_displayed.set(0, long2rat(0), 0);
            note_set_enharmonicity(note, pitch_in);

            note_delete_breakpoints(r_ob, note);
            
            for (i=0; i< CONST_MAX_SLOTS; i++) 
                note_clear_slot(r_ob, note, i);

            if (notevalues->l_size >= 4) {
                t_llllelem *elem;
                
                elem = notevalues->l_head->l_next->l_next->l_next;
                while (elem) { // cycle on the extras
                    if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                        t_llll *extras = hatom_getllll(&elem->l_hatom);
                        t_llllelem *pivot = extras->l_head;
                        if (pivot && hatom_gettype(&pivot->l_hatom) == H_SYM) { // the pivot ("graphic", "breakpoints", "slots") must be a symbol!
                            t_symbol *pivotsym = hatom_getsym(&pivot->l_hatom);
                            if (pivotsym == _llllobj_sym_graphic) {
                                llll_destroyelem(pivot);
                                set_graphic_values_to_note_from_llll(r_ob, note, extras); 
                            } else if (pivotsym == _llllobj_sym_name) {
                                llll_destroyelem(pivot);
                                notation_item_set_names_from_llll(r_ob, (t_notation_item *)note, extras);
                            } else if (pivotsym == _llllobj_sym_flags) {
                                llll_destroyelem(pivot);
                                notation_item_set_flags_from_llllelem(r_ob, extras->l_head, (t_notation_item *)note, false);
                            } else if (pivotsym == _llllobj_sym_breakpoints) {
                                llll_destroyelem(pivot);
                                set_breakpoints_values_to_note_from_llll(r_ob, note, extras);
                            } else if (pivotsym == _llllobj_sym_slots) {
                                llll_destroyelem(pivot);
                                set_slots_values_to_note_from_llll(r_ob, note, extras);
                            } else if (pivotsym == _llllobj_sym_articulations) {
                                llll_destroyelem(pivot);
                                set_articulations_to_element_from_llll(r_ob, (t_notation_item *)note, extras);
                            }
                        }
                    }
                    elem = elem->l_next;
                }
            }
        }    
    }
}

void set_scorechord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll* chordvalues, char always_from_scratch, char also_check_notes_order)
{
    // chordvalues has the form
    // ( r_sym_duration ( NOTE1 ) ( NOTE2 ) ( NOTE3 ) ... locked)
    if (chordvalues) {
        if (chordvalues->l_size >= 1) {
            t_llllelem *elem;
            t_note *note;
            unsigned long forced_chord_ID;
            
            chord->r_sym_duration = hatom_getrational(&chordvalues->l_head->l_hatom);

            if (chord->r_sym_duration.r_den == 0) 
                chord->r_sym_duration = RAT_1OVER4;


            forced_chord_ID = notation_item_get_ID_from_llll(chordvalues);
            if (forced_chord_ID && forced_chord_ID != chord->r_it.ID){
                shashtable_chuck_thing(r_ob->IDtable, chord->r_it.ID);
                shashtable_insert_with_key(r_ob->IDtable, chord, forced_chord_ID, 1);
                chord->r_it.ID = forced_chord_ID;
            }

#ifndef BACH_OUTPUT_SYMBOLIC_FLAGS
            notation_item_find_and_set_names(r_ob, (t_notation_item *)chord, chordvalues);
#endif
            
            // Old flag compatibility
            t_llllelem *temp = chordvalues->l_head->l_next;
            while (temp && hatom_gettype(&temp->l_hatom) == H_LLLL)
                temp = temp->l_next;
            notation_item_set_flags_from_llllelem(r_ob, temp, (t_notation_item *)chord, true);

            
#ifdef BACH_OUTPUT_SYMBOLIC_FLAGS
            notation_item_find_and_set_names_and_flags(r_ob, (t_notation_item *)chord, chordvalues);
#endif

            if (always_from_scratch)
                delete_all_articulations_from_notation_item(r_ob, (t_notation_item *)chord);

#ifdef BACH_CHORDS_HAVE_SLOTS
            if (always_from_scratch)
                erase_all_notationitem_slots(r_ob, (t_notation_item *)chord);
#endif

            // now the cycle on the notes
            note = chord->firstnote;
            for (elem = chordvalues->l_head->l_next; elem; elem = elem->l_next) {
                t_llll *elemllll = hatom_getllll(&elem->l_hatom);
                if (!elemllll || !elemllll->l_head) {
                    //                    char debug[1000];
                    //                    llll_to_char_array(chordvalues, debug, 999);
                    if (note) 
                        note = note->next;
                    continue;
                }
                
                
                if (hatom_gettype(&elemllll->l_head->l_hatom) == H_SYM && hatom_getsym(&elemllll->l_head->l_hatom) == _llllobj_sym_articulations) {
                    // chord-attached articulations
                    t_llll* nohead = llll_clone(elemllll);
                    if (nohead && nohead->l_head) {
                        llll_destroyelem(nohead->l_head);
                        set_articulations_to_element_from_llll(r_ob, (t_notation_item *)chord, nohead);
                    }
                    if (nohead) 
                        llll_free(nohead);
#ifdef BACH_CHORDS_HAVE_SLOTS
                } else if (hatom_gettype(&elemllll->l_head->l_hatom) == H_SYM && hatom_getsym(&elemllll->l_head->l_hatom) == _llllobj_sym_slots) {
                    // chord-attached slots (should be for rests only!!!!)
                    set_slots_values_to_notationitem_from_llll(r_ob, (t_notation_item *)chord, elemllll);
#endif
                } else if (chord->r_sym_duration.r_num >= 0){
                    if (note) { // there's already a note
                        
                        set_scorenote_values_from_llll(r_ob, note, elemllll, always_from_scratch);
                        note = note->next;
                    } else { // we gotta create a note within the same chord
                        t_note *this_nt = build_default_note(r_ob);
                        unsigned long forced_note_ID = notation_item_get_ID_from_llll(elemllll);
                        
                        note_insert(r_ob, chord, this_nt, forced_note_ID);
                        set_scorenote_values_from_llll(r_ob, this_nt, elemllll, always_from_scratch);
                    }
                }
            }
            
            if (always_from_scratch) {
                while (note) {
                    t_note *next = note->next;
                    note_delete(r_ob, note, false);
                    note = next;
                }
            }
            
            if (also_check_notes_order)
                check_notes_order(chord);
            
            chord->need_recompute_parameters = true; // we have to recalculate chord parameters 
            set_need_perform_analysis_and_change_flag(r_ob);
        }
    }
}


t_llll* get_default_time_signature() {
    t_llll *ts = llll_get();
    llll_appendlong(ts, 4, 0, WHITENULL_llll);
    llll_appendlong(ts, 4, 0, WHITENULL_llll);
    return ts;
}



void change_pitch_to_note_from_diatonic_step_fn(t_notation_obj *r_ob, t_note *note, void *diatonic_step){
    long oct = note->midicents / 1200;
    long mc = diatonicstep2midicents(*((long *) diatonic_step), oct);
    if (fabs((mc + 1200) - note->midicents) < fabs(mc - note->midicents))
        mc += 1200;
    else if (fabs((mc - 1200) - note->midicents) < fabs(mc - note->midicents))
        mc -= 1200;
    
    create_simple_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_UNDO_MODIFICATION_CHANGE);
    
    note_set_user_enharmonicity_from_screen_representation(note, mc, long2rat(0));
    note->midicents = note->pitch_original.toMC();
    
    note_set_auto_enharmonicity(note);
    note_compute_approximation(r_ob, note);
    check_notes_order(note->parent);
    note->parent->need_recompute_parameters = true;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, note->parent->parent, false);
}

void snap_onset_to_grid_for_marker(t_notation_obj *r_ob, t_marker *mk, void *dummy){
    mk->position_ms = r_ob->current_first_grid_ms + r_ob->current_grid_subdivision_ms * round((mk->position_ms - r_ob->current_first_grid_ms)/r_ob->current_grid_subdivision_ms);
    if (mk->position_ms < 0)
        mk->position_ms = 0;
}

void snap_onset_to_grid_for_chord(t_notation_obj *r_ob, t_chord *ch, void *dummy){
    double new_onset = r_ob->current_first_grid_ms + r_ob->current_grid_subdivision_ms * round((ch->onset - r_ob->current_first_grid_ms)/r_ob->current_grid_subdivision_ms);
    if (new_onset < 0)
        new_onset = 0;
    
    t_note *nt;
    for (nt = ch->firstnote; nt; nt = nt->next)
        add_amount_to_all_trimlinked_slots(r_ob, (t_notation_item *)nt, new_onset - ch->onset);
    
    ch->onset = new_onset;
}

void snap_tail_to_grid_for_note(t_notation_obj *r_ob, t_note *nt, void *dummy){
    nt->duration = r_ob->current_first_grid_ms + r_ob->current_grid_subdivision_ms * round((nt->parent->onset + nt->duration - r_ob->current_first_grid_ms)/r_ob->current_grid_subdivision_ms) - nt->parent->onset;
    if (nt->duration <= 0)
        nt->duration = r_ob->current_grid_subdivision_ms;
}


char snap_tail_to_grid_for_selection(t_notation_obj *r_ob){ 
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && (r_ob->show_grid == 1 || r_ob->ruler > 0)) {
        char res = iterate_notewise_changes_on_selection(r_ob, (notation_obj_note_fn) snap_tail_to_grid_for_note, NULL, true, k_CHORD, true);
        recompute_total_length(r_ob);
        return res;
    }
    return 0;
}


char change_pitch_to_selection_from_diatonic_step(t_notation_obj *r_ob, long diatonic_step){ 
    long ds = diatonic_step;
    return iterate_notewise_changes_on_selection(r_ob, (notation_obj_note_fn) change_pitch_to_note_from_diatonic_step_fn, &ds, true, k_CHORD, false);
}

char snap_pitch_to_grid_for_selection(t_notation_obj *r_ob){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items

        if (curr_it->type == k_NOTE) { // it is a note
            t_note *nt = (t_note *) curr_it;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                snap_pitch_to_grid_for_note(r_ob, nt);
                changed = 1;
            }
        } else if (curr_it->type == k_CHORD) {
            t_note *temp_nt = ((t_chord *)curr_it)->firstnote;
            while (temp_nt) {
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    snap_pitch_to_grid_for_note(r_ob, temp_nt);
                    changed = 1;
                }
                temp_nt = temp_nt->next;
            }
        } else if (curr_it->type == k_MEASURE) {
            t_chord *temp_ch = ((t_measure *)curr_it)->firstchord;
            while (temp_ch) {
                t_note *temp_nt = temp_ch->firstnote;
                while (temp_nt) {
                    if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                        create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                        snap_pitch_to_grid_for_note(r_ob, temp_nt);
                        changed = 1;
                    }
                    temp_nt = temp_nt->next;
                }
                temp_ch = temp_ch->next;
            }
        } else if (curr_it->type == k_PITCH_BREAKPOINT) {
            t_bpt *bpt = (t_bpt *)curr_it;
            t_note *nt = bpt->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                snap_pitch_to_grid_for_breakpoint(r_ob, bpt);
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}


char enharmonically_respell_selection(t_notation_obj *r_ob){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE) { // it is a note
            t_note *nt = (t_note *) curr_it;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                enharmonically_retranscribe_note(r_ob, nt, true, 0, long2rat(0));
                if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                    nt->parent->parent->need_recompute_beams_positions = true;
                changed = 1;
            }
        } else if (curr_it->type == k_CHORD) {
            t_note *temp_nt = ((t_chord *)curr_it)->firstnote;
            while (temp_nt) {
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    enharmonically_retranscribe_note(r_ob, temp_nt, true, 0, long2rat(0));
                    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                        ((t_chord *)curr_it)->parent->need_recompute_beams_positions = true;
                    changed = 1;
                }
                temp_nt = temp_nt->next;
            }
        } else if (curr_it->type == k_MEASURE) {
            t_chord *temp_ch = ((t_measure *)curr_it)->firstchord;
            while (temp_ch) {
                t_note *temp_nt = temp_ch->firstnote;
                while (temp_nt) {
                    if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                        create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                        enharmonically_retranscribe_note(r_ob, temp_nt, true, 0, long2rat(0));
                        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                            ((t_measure *)curr_it)->need_recompute_beams_positions = true;
                        changed = 1;
                    }
                    temp_nt = temp_nt->next;
                }
                temp_ch = temp_ch->next;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);
    return changed;
}

void recompute_all_measure_chord_parameters(t_notation_obj *r_ob, t_measure *measure)
{
    // recalculate all the chords parameters in the measure *measure
    t_chord *temp_ch = measure->firstchord;
    while (temp_ch) {
        temp_ch->need_recompute_parameters = true; // we have to recalculate chord parameters 
        temp_ch = temp_ch->next;
    }
    set_need_perform_analysis_and_change_flag(r_ob);
}

void check_tuttipoint(t_notation_obj *r_ob, t_tuttipoint *tpt)
{
#ifdef BACH_CHECK_NOTATION_ITEMS
    if (!tpt)
        return;
    
    char found = 0;
    t_tuttipoint *tmp = *((t_tuttipoint **)((long)r_ob + sizeof(t_notation_obj)));
    while (tmp) {
        if (tmp == tpt) {
            found = 1;
            break;
        }
        tmp = tmp->next;
    }
    
    if (found == 0) {
        long foo = 7;
        foo++;
        bach_breakpoint(0);
    }
#endif
}

void notation_obj_check_all_measure_tuttipoints(t_notation_obj *r_ob)
{
#ifdef BACH_CHECK_NOTATION_ITEMS
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_voice *voice;
        t_measure *meas;
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) {
                check_tuttipoint(r_ob, meas->tuttipoint_reference);
            }
        }
    }
#endif
}




void recompute_all_for_measure_ext(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings, char also_check_autocompletion)
{
    if (!meas)
        return;
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    if (also_check_autocompletion)
        meas->need_check_autocompletion = true;

    if (also_recompute_beamings) {
        meas->need_recompute_beamings = true;
    } else
        meas->need_recompute_beams_positions = true;

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    recompute_all_measure_chord_parameters(r_ob, meas);

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
    notation_obj_check(r_ob);
#endif

    check_ties_around_measure(meas);

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
    notation_obj_check(r_ob);
    check_tuttipoint(r_ob, meas->tuttipoint_reference);
#endif

    if (meas->tuttipoint_reference)
        meas->tuttipoint_reference->need_recompute_spacing = k_SPACING_RECALCULATE;

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
    notation_obj_check(r_ob);
#endif

    set_need_perform_analysis_and_change_flag(r_ob);
    
    // recomputing domain_ux // WHY ON EARTH DID WE DO THAT HERE???
    r_ob->domain_ux = (r_ob->inner_width + r_ob->j_inset_x - (r_ob->j_inset_x + get_ux_left_start(r_ob) * r_ob->zoom_y)) / (CONST_X_SCALING_SCORE * r_ob->zoom_x * r_ob->zoom_y);
}

void recompute_all_for_measure(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings)
{
    recompute_all_for_measure_ext(r_ob, meas, also_recompute_beamings, also_recompute_beamings);
}

void recompute_all_for_measures_in_voiceensemble(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings)
{
    t_voice *voice = (t_voice *)meas->voiceparent;
    t_voice *first = voiceensemble_get_firstvoice(r_ob, voice);
    t_voice *last = voiceensemble_get_lastvoice(r_ob, voice);
    t_voice *temp;
    double measure_onset_ms = notation_item_get_onset_ms(r_ob, (t_notation_item *)meas);
    long measure_num = meas->measure_number;
    for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
        t_measure *m = nth_measure_of_scorevoice((t_scorevoice *)temp, measure_num);
        if (m && notation_item_get_onset_ms(r_ob, (t_notation_item *)m) == measure_onset_ms);
            recompute_all_for_measure(r_ob, m, also_recompute_beamings);
        if (temp == last)
            break;
    }
}

void recompute_all_for_measure_and_neighbor_measures(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings)
{
    recompute_all_for_measure(r_ob, meas, also_recompute_beamings);
    if (meas->prev)
        recompute_all_for_measure(r_ob, meas->prev, also_recompute_beamings);
    if (meas->next)
        recompute_all_for_measure(r_ob, meas->next, also_recompute_beamings);
}

void recompute_all_for_tuttipoint_region(t_notation_obj *r_ob, t_tuttipoint *tpt, char also_recompute_beamings) 
{
    if (tpt){
        long i;
        for (i = 0; i < r_ob->num_voices && i < CONST_MAX_VOICES; i++){
            t_measure *tmp_meas;
            for (tmp_meas = tpt->measure[i]; (tpt->next && tmp_meas != tpt->next->measure[i]) || (!tpt->next && tmp_meas); tmp_meas = tmp_meas->next) {
                recompute_all_for_measure(r_ob, tmp_meas, also_recompute_beamings);
            }
        }
    }
}

char reset_note_enharmonicity(t_notation_obj *r_ob, t_note *note){
    char changed = (note_is_enharmonicity_userdefined(note)) ? 1 : 0;

//    t_voice *voice = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? (t_voice *)note->parent->voiceparent : (t_voice *)note->parent->parent->voiceparent);

    note_set_auto_enharmonicity(note);
    note_compute_approximation(r_ob, note);
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, note->parent->parent, false);
    else
        note->parent->need_recompute_parameters = true;
    set_need_perform_analysis_and_change_flag(r_ob);

    return changed;
}

char reset_all_enharmonicity(t_notation_obj *r_ob, char ignore_locked_notes)
{
    char changed = 0, undo_done = 0;
    for (t_voice *voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (t_chord *ch = chord_get_first(r_ob, voice); ch; ch = chord_get_next(ch)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            for (t_note *nt = ch->firstnote; nt; nt = nt->next) {
                if (!ignore_locked_notes || !notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                    if (!undo_done) {
                        undo_done = 1;
                        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    }
                    changed |= reset_note_enharmonicity(r_ob, nt);
                }
            }
        }
    return changed;
}

char reset_selection_enharmonicity(t_notation_obj *r_ob, char ignore_locked_notes)
{
    // retranscribe and delete all the "graphic" extras for the selection (revert the accidentals to k_ACCIDENTALS_AUTO)
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);
    while (curr_it) { // cycle on the selected items

        if (curr_it->type == k_NOTE) { // it is a note
            t_note *nt = (t_note *) curr_it;
            if (!ignore_locked_notes || !notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                changed |= reset_note_enharmonicity(r_ob, nt);
            }
        } else if (curr_it->type == k_CHORD) {
            t_note *temp_nt = ((t_chord *)curr_it)->firstnote;
            while (temp_nt) {
                if (!ignore_locked_notes || !notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    changed |= reset_note_enharmonicity(r_ob, temp_nt);
                }
                temp_nt = temp_nt->next;
            }
        } else if (curr_it->type == k_MEASURE) {
            t_chord *temp_ch = ((t_measure *)curr_it)->firstchord;
            while (temp_ch) {
                t_note *temp_nt = ((t_chord *)curr_it)->firstnote;
                while (temp_nt) {
                    if (!ignore_locked_notes || !notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                        create_simple_selected_notation_item_undo_tick(r_ob, curr_it, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                        changed |= reset_note_enharmonicity(r_ob, temp_nt);
                    }
                    temp_nt = temp_nt->next;
                }
                temp_ch = temp_ch->next;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);

    return changed;
}


// voice_number is 0-based!!!
void initialize_rollvoice(t_notation_obj *r_ob, t_rollvoice *voice, long voice_number, t_symbol *key)
{
    voice->num_chords = 0;
    r_ob->voiceuspacing_as_floatlist[voice_number+1] = CONST_DEFAULT_ROLLVOICES_SPACING_UY;
    r_ob->keys_as_symlist[voice_number] = key;
    initialize_voice_by_default(r_ob, (t_voice *)voice, voice_number);
    voice->firstchord = voice->lastchord = NULL;
    parse_sym_to_key_and_mode(r_ob, r_ob->keys_as_symlist[voice_number], &voice->v_ob.key, &voice->v_ob.mode, voice->v_ob.acc_pattern);
    voice->v_ob.r_it.ID = shashtable_insert(r_ob->IDtable, voice);
}



// voice_number is 0-based!!!
void initialize_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, long voice_number, t_symbol *key)
{
    initialize_voice_by_default(r_ob, (t_voice *) voice, voice_number);
    r_ob->voiceuspacing_as_floatlist[voice_number+1] = CONST_DEFAULT_SCOREVOICES_SPACING_UY;
    r_ob->keys_as_symlist[voice_number] = key;
    voice->num_measures = 0;
    voice->firstmeasure = voice->lastmeasure = NULL; 
    parse_sym_to_key_and_mode(r_ob, r_ob->keys_as_symlist[voice_number], &voice->v_ob.key, &voice->v_ob.mode, voice->v_ob.acc_pattern);
    voice->v_ob.r_it.ID = shashtable_insert(r_ob->IDtable, voice);
}


void initialize_voice_by_default(t_notation_obj *r_ob, t_voice *v_ob, long number)
{
    long i;
    
    notation_item_init(&v_ob->r_it, k_VOICE);
    
    v_ob->clef = k_CLEF_WRONG; // needed HERE in order to draw correctly the last used staff combination. 
    v_ob->number = number;
    v_ob->part_index = 0;
    v_ob->voiceensemble_index = 0;
    
    change_single_midichannel(r_ob, v_ob, number + 1, false);
    v_ob->hidden = 0;
    v_ob->key = 0;
    v_ob->mode = 0;
    v_ob->determines_spacing = 1;
    v_ob->vertical_uspacing = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) ? CONST_DEFAULT_ROLLVOICES_SPACING_UY : CONST_DEFAULT_SCOREVOICES_SPACING_UY;
    v_ob->key = 1; // major
    for (i = 0; i < 7; i++)
        v_ob->acc_pattern[i] = long2rat(0);
    fill_default_full_repr(r_ob, v_ob->full_repr, 0, k_MODE_MAJOR, NULL);
    v_ob->solo = false;
    v_ob->muted = false;
    v_ob->locked = false;
    
    v_ob->are_staff_lines_standard = true;
    v_ob->num_staff_lines = 5;
    v_ob->staff_lines[0] = 1;
    v_ob->staff_lines[1] = 2;
    v_ob->staff_lines[2] = 3;
    v_ob->staff_lines[3] = 4;
    v_ob->staff_lines[4] = 5;    
    v_ob->min_staff_line = 1;
    v_ob->max_staff_line = 5;
}

//// ************************** ////
//// ***** PAGE VIEW STUFF **** ////
//// ************************** ////

void recalculate_num_systems(t_notation_obj *r_ob){
    if (r_ob->view == k_VIEW_SCROLL) {
        r_ob->num_systems = 1;
    } else if (r_ob->view == k_VIEW_PAGE) {
        r_ob->num_systems = (long)floor(r_ob->height/(r_ob->needed_uheight_for_one_system * r_ob->zoom_y));
    } else { // papyrus view
        calculate_ms_on_a_line(r_ob);
        r_ob->num_systems = (long)ceil(r_ob->length_ms_till_last_note/r_ob->ms_on_a_line);
        if (r_ob->num_systems <= 0) r_ob->num_systems = 1;
    }
    r_ob->last_shown_system = r_ob->first_shown_system + r_ob->num_systems - 1;
}

double get_system_jump(t_notation_obj *r_ob){
    return round((r_ob->needed_uheight_for_one_system + CONST_SYSTEM_JUMP_USHIFT) * r_ob->zoom_y); // space from one staff to the same staff in the next system 
}

// for [roll]
long onset_to_system_index(t_notation_obj *r_ob, double onset) {
    if (r_ob->view == k_VIEW_SCROLL)
        return 0;
    else {
        long system = (long)floor(onset/r_ob->ms_on_a_line); 
        return (system < 0) ? 0 : system;
    }
}

double system_index_to_system_start_ms(t_notation_obj *r_ob, long index){
    return index * r_ob->ms_on_a_line;
}

double system_index_to_system_end_ms(t_notation_obj *r_ob, long index){
    return (index + 1) * r_ob->ms_on_a_line;
}


////// **** QUANTIZATION TOOLS ***** //////

void approximate_for_too_high_rationals(t_llll *box_durations, t_rational box_width){
    if (box_durations && box_durations->l_size > 0){
        t_llllelem *elem; t_rational sum = long2rat(0);
        for (elem = box_durations->l_head; elem; elem = elem->l_next) {
            if (elem != box_durations->l_tail || box_width.r_num <= 0) {
                t_rational new_rational = approx_rat_with_rat(hatom_getrational(&elem->l_hatom), CONST_RAT_MAX_NUM_SAFETY, CONST_RAT_MAX_DEN_SAFETY);
                hatom_setrational(&elem->l_hatom, new_rational);
                if (box_width.r_num > 0) sum = rat_rat_sum(sum, rat_abs(new_rational));
            } else {
                char sign = (hatom_getrational(&elem->l_hatom).r_num >= 0) ? 1 : -1;
                hatom_setrational(&elem->l_hatom, rat_long_prod(rat_rat_diff(box_width, sum), sign));
            }
        }
    }
} 

void approximate_for_too_high_rationals_fixed_den(t_llll *box_durations, t_rational box_width, long fixed_den){
    if (box_durations && box_durations->l_size > 0){
        t_llllelem *elem; t_rational sum = long2rat(0);
        for (elem = box_durations->l_head; elem; elem = elem->l_next) {
            if (elem != box_durations->l_tail || box_width.r_num <= 0) {
                t_rational new_rational = approx_rat_with_rat_fixed_den(hatom_getrational(&elem->l_hatom), fixed_den);
                t_rational possible_sum = rat_rat_sum(sum, rat_abs(new_rational));
                if (box_width.r_num > 0 && rat_rat_cmp(possible_sum, box_width) >= 0){ // box width exceeded
                    char sign = (new_rational.r_num >= 0) ? 1 : -1;
                     possible_sum = box_width;
                    new_rational = rat_long_prod(rat_rat_diff(box_width, sum), sign);
                }
                if (box_width.r_num > 0) 
                    sum = possible_sum; // rat_rat_sum(sum, rat_abs(new_rational));
                hatom_setrational(&elem->l_hatom, new_rational);
            } else {
                char sign = (hatom_getrational(&elem->l_hatom).r_num >= 0) ? 1 : -1;
                hatom_setrational(&elem->l_hatom, rat_long_prod(rat_rat_diff(box_width, sum), sign));
            }
        }
    }
} 

// a small function just like get_sym_durations_between_timepoints but with no need of *voice
t_rational get_sym_durations_between_timepoints_from_measure_symdurations(t_llll *measure_symdurations, t_timepoint tp1, t_timepoint tp2) {
    if (timepoints_compare(tp1, tp2) >= 0)
        return long2rat(0);
    else {
        long start_meas = tp1.measure_num;
        long end_meas = tp2.measure_num;
        t_rational start_pim = tp1.pt_in_measure;
        t_rational end_pim = tp2.pt_in_measure;
        if (start_meas == end_meas)
            return rat_rat_diff(end_pim, start_pim);
        else if (start_meas + 1 == end_meas)
            return rat_rat_sum(rat_rat_diff(hatom_getrational(&llll_getindex(measure_symdurations, start_meas + LLLL_IDX_BASE, I_NON_NEGATIVE)->l_hatom), start_pim), end_pim);
        else {
            long meas_num = start_meas + 1;
            t_llllelem *meas_elem = llll_getindex(measure_symdurations, start_meas + 1 + LLLL_IDX_BASE, I_NON_NEGATIVE);
            t_rational intermediate_measures = long2rat(0);
            while (meas_elem && (meas_num < end_meas)) {
                intermediate_measures = rat_rat_sum(intermediate_measures, hatom_getrational(&meas_elem->l_hatom));
                meas_elem = meas_elem->l_next;
                meas_num++;
            }
            return rat_rat_sum(rat_rat_sum(rat_rat_diff(hatom_getrational(&llll_getindex(measure_symdurations, start_meas + LLLL_IDX_BASE, I_NON_NEGATIVE)->l_hatom), start_pim), end_pim), intermediate_measures);
        }
    }
}



// converts a list of durations into a list of ratios, with respect to the tempi.
t_llll *ms_to_rat_durations(t_llll *measure_symdurations, t_llll *tempi, t_llll *durations, long *how_many_measures_to_append, long const_approx_double_with_rat_fixed_den, char fixed_approximations) 
{
    t_llll *rat_durations = llll_get();
    t_tempo *defaulttempo;
    t_llllelem *curr_tempo_llllelem;
    t_tempo *curr_tempo, *next_tempo;
    double curr_tempo_onset = 0;
    double next_tempo_onset = 0;
    double duration_sum = 0;
    double this_err = 0, tot_err = 0;
    t_llllelem *thisdur;
    t_rational total_supposed_symduration, last_symduration;
    double total_symduration_double = 0; 
    t_llllelem *elem;
    
    if (!durations || !durations->l_head) 
        return rat_durations;
    
    defaulttempo = build_tempo(long2rat(0), long2rat(60), RAT_1OVER4, 0);
    
    curr_tempo_llllelem = tempi->l_head; // (t_tempo *)hatom_getobj(&tempi->l_head->l_hatom)
    curr_tempo = curr_tempo_llllelem ? (t_tempo *)hatom_getobj(&curr_tempo_llllelem->l_hatom) : defaulttempo;
    next_tempo = (curr_tempo_llllelem && curr_tempo_llllelem->l_next) ? (t_tempo *)hatom_getobj(&curr_tempo_llllelem->l_next->l_hatom) : NULL;
    curr_tempo_llllelem = curr_tempo_llllelem ? curr_tempo_llllelem->l_next : NULL;

    for (thisdur = durations->l_head; thisdur; thisdur = thisdur->l_next) {
        if (hatom_gettype(&thisdur->l_hatom) == H_DOUBLE || hatom_gettype(&thisdur->l_hatom) == H_RAT || hatom_gettype(&thisdur->l_hatom) == H_LONG) {
            
            double thisdur_double = hatom_getdouble(&thisdur->l_hatom); // in ms seconds!
            char sign = thisdur_double >= 0 ? 1 : -1;
            const double CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS = const_approx_double_with_rat_fixed_den; //CONST_RAT_SINGLE_DEN; // was: 40000;
            
            if (!next_tempo) { 
            
                //easy case
                t_rational approx = approx_double_with_rat_fixed_den(fabs(thisdur_double)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                t_rational this_contribution_rat = rat_long_prod(approx, sign);
                llll_appendrat(rat_durations, this_contribution_rat, 0, WHITENULL_llll);
                duration_sum += fabs(thisdur_double);
                tot_err += this_err;
                
            } else { 

                // harder case
                t_rational delta_sym_tempi = get_sym_durations_between_timepoints_from_measure_symdurations(measure_symdurations, build_timepoint(curr_tempo->owner ? curr_tempo->owner->measure_number : curr_tempo->hack_measure_number, curr_tempo->changepoint), build_timepoint(next_tempo->owner ? next_tempo->owner->measure_number : next_tempo->hack_measure_number, next_tempo->changepoint));
                double delta_t_tempi = (curr_tempo->interpolation_type == 0) ?
                    240 * rat2double(delta_sym_tempi)/rat2double(curr_tempo->tempo_value) : 
                    120 * rat2double(delta_sym_tempi) * (1/rat2double(curr_tempo->tempo_value) + 1/rat2double(next_tempo->tempo_value)); // in sec!
                double to_achieve = duration_sum + fabs(thisdur_double);
                next_tempo_onset = curr_tempo_onset + delta_t_tempi;
                
                
                if (to_achieve <= next_tempo_onset * 1000.) { // stays completely within this tempo

                    if (curr_tempo->interpolation_type == 0) { // easy case, no interpolation
                    
                        t_rational approx = approx_double_with_rat_fixed_den(fabs(thisdur_double)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                        t_rational total_rat_duration = rat_long_prod(approx, sign);
                        llll_appendrat(rat_durations, total_rat_duration, 0, WHITENULL_llll);
                        duration_sum += fabs(thisdur_double);
                        tot_err += this_err;
                    
                    } else { // interpolated case
                    
                        double sym_diff1 = get_sym_diff_from_onset_ms(duration_sum, curr_tempo_onset * 1000, rat2double(curr_tempo->tempo_value), 
                                                                      next_tempo_onset * 1000, rat2double(next_tempo->tempo_value), delta_sym_tempi);
                        double sym_diff2 = get_sym_diff_from_onset_ms(to_achieve, curr_tempo_onset * 1000, rat2double(curr_tempo->tempo_value), 
                                                                      next_tempo_onset * 1000, rat2double(next_tempo->tempo_value), delta_sym_tempi);
                        t_rational this_contribution_rat = approx_double_with_rat_fixed_den(sym_diff2 - sym_diff1, CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                        llll_appendrat(rat_durations, rat_long_prod(this_contribution_rat, sign), 0, WHITENULL_llll);
                        duration_sum += fabs(thisdur_double);
                        tot_err += this_err;
                    
                    }
                    
                    if (to_achieve == next_tempo_onset * 1000.) {
                        curr_tempo = next_tempo;
                        curr_tempo_onset = next_tempo_onset;
                        curr_tempo_llllelem = curr_tempo_llllelem ? curr_tempo_llllelem->l_next : NULL;
                        next_tempo = curr_tempo_llllelem ? (t_tempo *)hatom_getobj(&curr_tempo_llllelem->l_hatom) : NULL;
                    }
                    
                } else {

                    // - first part -
                    t_rational total_rat_duration = long2rat(0);
                    if (curr_tempo->interpolation_type == 0) { // no interpolation
                        t_rational approx = approx_double_with_rat_fixed_den((next_tempo_onset * 1000 - duration_sum)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                        total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                        tot_err += this_err;
                    } else { // interpolation
                        double sym_diff1 = get_sym_diff_from_onset_ms(duration_sum, curr_tempo_onset * 1000, rat2double(curr_tempo->tempo_value), 
                                                                      next_tempo_onset * 1000, rat2double(next_tempo->tempo_value), delta_sym_tempi);
                        double tau1 = get_intermediate_tempo_double(sym_diff1/rat2double(delta_sym_tempi), curr_tempo, next_tempo);
                        double tau2 = rat2double(next_tempo->tempo_value);
                        double this_contribution = (next_tempo_onset * 1000 - duration_sum) / (120000 * (1/tau1 + 1/tau2));
                        t_rational approx = approx_double_with_rat_fixed_den(this_contribution, CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                        total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                        tot_err += this_err;
                    }
                    // updating tempi
                    curr_tempo = next_tempo;
                    curr_tempo_onset = next_tempo_onset;
                    curr_tempo_llllelem = curr_tempo_llllelem ? curr_tempo_llllelem->l_next : NULL;
                    next_tempo = curr_tempo_llllelem ? (t_tempo *)hatom_getobj(&curr_tempo_llllelem->l_hatom) : NULL;
                    
                    if (!next_tempo) {
                        t_rational approx = approx_double_with_rat_fixed_den((to_achieve - curr_tempo_onset * 1000)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                        total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                        tot_err += this_err;
                    } else {
                        double delta_t_tempi;
                        delta_sym_tempi = get_sym_durations_between_timepoints_from_measure_symdurations(measure_symdurations, build_timepoint(curr_tempo->owner ? curr_tempo->owner->measure_number : curr_tempo->hack_measure_number, curr_tempo->changepoint), build_timepoint(next_tempo->owner ? next_tempo->owner->measure_number : next_tempo->hack_measure_number, next_tempo->changepoint));
                        delta_t_tempi = (curr_tempo->interpolation_type == 0) ?
                                        240 * rat2double(delta_sym_tempi)/rat2double(curr_tempo->tempo_value) : 
                                        120 * rat2double(delta_sym_tempi) * (1/rat2double(curr_tempo->tempo_value) + 1/rat2double(next_tempo->tempo_value)); // in sec!
                        next_tempo_onset = curr_tempo_onset + delta_t_tempi;
                        // - middle part -
                        while (next_tempo && next_tempo_onset * 1000. <= to_achieve) {
                            if (curr_tempo->interpolation_type == 0) { // no interpolation
                                t_rational approx = approx_double_with_rat_fixed_den((next_tempo_onset - curr_tempo_onset) * 1000 * rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                                total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                                tot_err += this_err;
                            } else {
                                double tau1 = rat2double(curr_tempo->tempo_value);
                                double tau2 = rat2double(next_tempo->tempo_value);
                                double this_contribution = (next_tempo_onset - curr_tempo_onset) / (120 * (1/tau1 + 1/tau2));
                                t_rational approx = approx_double_with_rat_fixed_den(this_contribution, CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                                total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                                tot_err += this_err;
                            }
                            // updating tempi
                            curr_tempo = next_tempo;
                            curr_tempo_onset = next_tempo_onset;
                            curr_tempo_llllelem = curr_tempo_llllelem ? curr_tempo_llllelem->l_next : NULL;
                            next_tempo = curr_tempo_llllelem ? (t_tempo *)hatom_getobj(&curr_tempo_llllelem->l_hatom) : NULL;
                            if (next_tempo) {
                                delta_sym_tempi = get_sym_durations_between_timepoints_from_measure_symdurations(measure_symdurations, build_timepoint(curr_tempo->owner ? curr_tempo->owner->measure_number : curr_tempo->hack_measure_number, curr_tempo->changepoint), build_timepoint(next_tempo->owner ? next_tempo->owner->measure_number : next_tempo->hack_measure_number, next_tempo->changepoint));
                                delta_t_tempi = (curr_tempo->interpolation_type == 0) ? 
                                    240 * rat2double(delta_sym_tempi)/rat2double(curr_tempo->tempo_value) :
                                    120 * rat2double(delta_sym_tempi) * (1/rat2double(curr_tempo->tempo_value) + 1/rat2double(next_tempo->tempo_value)); // in sec!
                                next_tempo_onset = curr_tempo_onset + delta_t_tempi;
                            }
                        }
                        
                        // last part
                        if (!next_tempo) {
                            t_rational approx = approx_double_with_rat_fixed_den((to_achieve - curr_tempo_onset * 1000)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                            total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                            tot_err += this_err;
                        } else {
                            if (next_tempo_onset * 1000 > to_achieve){
                                if (curr_tempo->interpolation_type == 0) { // no interpolation
                                    t_rational approx = approx_double_with_rat_fixed_den((to_achieve - curr_tempo_onset * 1000)*rat2double(curr_tempo->tempo_value)/(60*4000), CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                                    total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                                    tot_err += this_err;
                                } else {
                                    double sym_diff2 = get_sym_diff_from_onset_ms(to_achieve, curr_tempo_onset * 1000, rat2double(curr_tempo->tempo_value), 
                                                                                  next_tempo_onset * 1000, rat2double(next_tempo->tempo_value), delta_sym_tempi);
                                    double tau1 = rat2double(curr_tempo->tempo_value);
                                    double tau2 = get_intermediate_tempo_double(sym_diff2/rat2double(delta_sym_tempi), curr_tempo, next_tempo);
                                    double this_contribution = (to_achieve - curr_tempo_onset * 1000) / (120000 * (1/tau1 + 1/tau2));
                                    t_rational approx = approx_double_with_rat_fixed_den(this_contribution, CONST_approx_double_with_rat_fixed_den_FOR_SYMDURATIONS, fsign(tot_err), &this_err);
                                    total_rat_duration = rat_rat_sum(total_rat_duration, approx);
                                    tot_err += this_err;
                                }
                            }
                        }
                        duration_sum += fabs(thisdur_double);
                    }

                    llll_appendrat(rat_durations, rat_long_prod(total_rat_duration, sign), 0, WHITENULL_llll);
                }
            }
            
        }
    }
    
    // calculating the number of measure to append at the end
//    char debug[1000];
//    llll_to_char_array(rat_durations, debug, 999);

    // do we approximate with a single very high denominator? It is extremely useful for quantization.
    if (fixed_approximations)
        approximate_for_too_high_rationals_fixed_den(rat_durations, long2rat(-1), const_approx_double_with_rat_fixed_den);

    total_supposed_symduration = llll_sum_of_rat_llll(measure_symdurations);
    last_symduration = (measure_symdurations && measure_symdurations->l_tail) ? hatom_getrational(&measure_symdurations->l_tail->l_hatom) : long2rat(1);

    for (elem = rat_durations->l_head; elem; elem = elem->l_next)
        total_symduration_double += rat2double(rat_abs(hatom_getrational(&elem->l_hatom)));
    *how_many_measures_to_append = ceil((total_symduration_double - rat2double(total_supposed_symduration))/rat2double(last_symduration));
    
//    *how_many_measures_to_append = ceil(rat2double(rat_rat_div(rat_rat_diff(total_symduration, total_supposed_symduration), last_symduration))); // OBSOLETE

    if (*how_many_measures_to_append < 0) *how_many_measures_to_append = 0; 
    
    free_tempo(NULL, defaulttempo);
    return rat_durations;
}



void append_note_breakpoints_formatted_for_pwgl(t_notation_obj *r_ob, t_llll *this_note_llll, t_note *note){    
    t_bpt *bpt;
    t_llll *bp_llll1 = llll_get();
    t_llll *bp_llll2 = llll_get();
    t_llll *bp_llll3 = llll_get();

    llll_appendsym(this_note_llll, gensym(":note-head"), 0, WHITENULL_llll);

    llll_appendsym(bp_llll1, gensym(":bpf-notehead"), 0, WHITENULL_llll);
    llll_appendsym(bp_llll1, gensym(":break-point-functions"), 0, WHITENULL_llll);

    for (bpt = note->firstbreakpoint; bpt; bpt = bpt->next){
        t_llll *this_bpt_llll = llll_get();
        llll_appenddouble(this_bpt_llll, bpt->rel_x_pos, 0, WHITENULL_llll);
        llll_appenddouble(this_bpt_llll, bpt->delta_mc / 100., 0, WHITENULL_llll);
        llll_appendsym(this_bpt_llll, gensym(":slope"), 0, WHITENULL_llll);
        llll_appenddouble(this_bpt_llll, bpt->slope, 0, WHITENULL_llll);
        llll_appendllll(bp_llll3, this_bpt_llll, 0, WHITENULL_llll);
    }

    llll_appendllll(bp_llll2, bp_llll3, 0, WHITENULL_llll);
    llll_appendllll(bp_llll1, bp_llll2, 0, WHITENULL_llll);
    llll_appendllll(this_note_llll, bp_llll1, 0, WHITENULL_llll);
}


void decide_dragging_direction(t_notation_obj *r_ob, t_pt pt){
    if (fabs(pt.x - (r_ob->j_mousedown_point).x) > fabs(pt.y - (r_ob->j_mousedown_point).y)) {
        r_ob->j_dragging_direction = 1; // x direction
    } else {
        r_ob->j_dragging_direction = -1; // y direction
    }
}


// *************
// CHANGES
// *************

char change_selection_velocity(t_notation_obj *r_ob, double delta_velocity){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);
    while (curr_it) { // cycle on the selected items
        switch (curr_it->type) {
                
            case k_NOTE:
            {
                t_note *note = ((t_note *)curr_it);
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
                    double new_vel = CLAMP(note->draggingvelocity + delta_velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
                    
                    if (!(note->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    
                    note->draggingvelocity = new_vel;
                    note_set_velocity(r_ob, note, round(new_vel));
                    if (r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE) {
                        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                            recompute_all_for_measure(r_ob, note->parent->parent, false);
                        else
                            note->parent->need_recompute_parameters = true;
                    }
                    changed = 1;
                }
            }
                break;
                
            case k_CHORD:
            {
                t_chord *chord = (t_chord *)curr_it;
                t_note *temp = chord->firstnote;
                while (temp){
                    if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp)) {
                        double new_vel = CLAMP(temp->draggingvelocity + delta_velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
                        
                        if (!(chord->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                        
                        temp->draggingvelocity = new_vel;
                        note_set_velocity(r_ob, temp, round(new_vel));
                        changed = 1;
                    }
                    temp = temp->next;
                }
                if (r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                        recompute_all_for_measure(r_ob, chord->parent, false);
                    else
                        chord->need_recompute_parameters = true;
                }
            }
                break;
                
            case k_PITCH_BREAKPOINT:
            {
                t_bpt *bpt = ((t_bpt *)curr_it);
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)bpt->owner)) {
                    double new_vel = CLAMP(bpt->draggingvelocity + delta_velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
                    
                    if (!(bpt->owner->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)bpt->owner->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                    
                    bpt->draggingvelocity = new_vel;
                    bpt->velocity = round(new_vel);
                    changed = 1;
                }
            }
                break;
                
            
            default:
                break;
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);
    return changed;
}

char change_selection_breakpoint_slope(t_notation_obj *r_ob, double delta_slope_abs, char direction)
{
    double delta_slope = delta_slope_abs * direction; // this is NOT the real delta slope, but the GRAPHICAL one (this is positive when the graphical slope goes up and negative when the graphical slope goes down)
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_PITCH_BREAKPOINT && ((t_bpt *)curr_it)->next) { // it is a breakpoint
            t_bpt *bpt = ((t_bpt *)curr_it);
            t_note *note = bpt->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
                double this_mc = bpt->delta_mc, prev_mc = bpt->prev ? bpt->prev->delta_mc : 0;
                double new_sl = CLAMP(bpt->slope + (this_mc <= prev_mc ? 1 : -1) * delta_slope, -1, 1);

                if (!(note->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);

                ((t_bpt *)curr_it)->slope = new_sl;
                
                if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                    recompute_all_for_measure(r_ob, note->parent->parent, false); 
                
                changed = 1;
            }
        } else if (curr_it->type == k_PITCH_BREAKPOINT && !((t_bpt *)curr_it)->next) { // note tail
            t_note *note = ((t_bpt *)curr_it)->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
                double this_mc = note->lastbreakpoint->delta_mc, prev_mc = note->lastbreakpoint->prev ? note->lastbreakpoint->prev->delta_mc : 0;
                double new_sl = CLAMP(note->lastbreakpoint->slope + (this_mc <= prev_mc ? 1 : -1) * delta_slope, -1, 1);

                if (!(note->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);

                note->lastbreakpoint->slope = new_sl;

                if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                    recompute_all_for_measure(r_ob, note->parent->parent, false);
                    
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}

char change_breakpoint_slope(t_notation_obj *r_ob, t_bpt *bpt, double delta_slope_abs, char direction)
{
    double delta_slope = delta_slope_abs * direction; // this is NOT the real delta slope, but the GRAPHICAL one (this is positive when the graphical slope goes up and negative when the graphical slope goes down)
    t_note *note = bpt->owner;
    if (note && !notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
        double this_mc = bpt->delta_mc, prev_mc = bpt->prev ? bpt->prev->delta_mc : 0;
        double new_sl = CLAMP(bpt->slope + (this_mc <= prev_mc ? 1 : -1) * delta_slope, -1, 1);
        
        if (!(note->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        
        bpt->slope = new_sl;
        
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            recompute_all_for_measure(r_ob, note->parent->parent, false);
        
        return 1;
    }
    return 0;
}


char change_selection_breakpoint_pitch(t_notation_obj *r_ob, double delta_mc){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_PITCH_BREAKPOINT) { // it is a breakpoint
            t_bpt *bpt = ((t_bpt *)curr_it);
            t_note *note = bpt->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
                if (!(note->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                bpt->delta_mc += delta_mc;
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}



char change_breakpoint_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_cents){
    char changed = 0;
    t_note *note = bpt->owner;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_cents && new_cents->l_head))) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        double mc = bpt->delta_mc + note->midicents;
        change_double(r_ob, &mc, lexpr, new_cents ? new_cents->l_head : NULL, 0, (t_notation_item *)bpt);
        bpt->delta_mc = mc - note->midicents;
        changed = 1;
    }
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    
    return changed;
}

char change_note_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_cents){
    char changed = 0;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_cents && new_cents->l_head))) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        change_double(r_ob, &note->midicents, lexpr, new_cents ? new_cents->l_head : NULL, 0, (t_notation_item *)note);
        note_set_auto_enharmonicity(note);
        changed = 1;
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        note->parent->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, note->parent->parent, false);
    
    set_need_perform_analysis_and_change_flag(r_ob);

    return changed;
}


char change_chord_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_cents){
    char changed = 0;
    t_note *nt; 
    t_llllelem *thiselem = new_cents ? new_cents->l_head : NULL;
    for (nt=chord->firstnote; nt; nt = nt->next) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            change_double(r_ob, &nt->midicents, lexpr, thiselem, 0, (t_notation_item *)nt);
            note_set_auto_enharmonicity(nt);
            if (thiselem && thiselem->l_next)
                thiselem = thiselem->l_next;
            changed = 1;
        }
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        chord->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, chord->parent, false);

    set_need_perform_analysis_and_change_flag(r_ob);

    return changed;
}

char change_note_pitch_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_pitch)
{
    char changed = 0;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_pitch && new_pitch->l_head))) {
        t_pitch pitch = note_get_pitch(r_ob, note);
        double cents = note->midicents;
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        if (change_pitch(r_ob, &pitch, &cents, lexpr, new_pitch ? new_pitch->l_head : NULL, (t_notation_item *)note)) {
            note->midicents = cents;
            note_set_auto_enharmonicity(note);
            note_compute_approximation(r_ob, note);
        } else {
            note_set_user_enharmonicity(note, pitch);
        }
        changed = 1;
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        note->parent->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, note->parent->parent, false);
    
    set_need_perform_analysis_and_change_flag(r_ob);
    
    return changed;
}

char change_chord_pitch_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_pitch){
    char changed = 0;
    t_note *nt;
    t_llllelem *thiselem = new_pitch ? new_pitch->l_head : NULL;
    for (nt=chord->firstnote; nt; nt = nt->next) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
            t_pitch pitch = note_get_pitch(r_ob, nt);
            double cents = nt->midicents;
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            if (change_pitch(r_ob, &pitch, &cents, lexpr, thiselem, (t_notation_item *)nt)) {
                nt->midicents = cents;
                note_set_auto_enharmonicity(nt);
                note_compute_approximation(r_ob, nt);
            } else {
                note_set_user_enharmonicity(nt, pitch);
            }
            if (thiselem && thiselem->l_next)
                thiselem = thiselem->l_next;
            changed = 1;
        }
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        chord->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, chord->parent, false);
    
    set_need_perform_analysis_and_change_flag(r_ob);
    
    return changed;
}



char change_note_poc_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_poc)
{
    char changed = 0;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_poc && new_poc->l_head))) {
        t_hatom poc;
        note_get_poc(r_ob, note, &poc);
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        change_poc(r_ob, &poc, lexpr, new_poc ? new_poc->l_head : NULL, (t_notation_item *)note);
        if (hatom_gettype(&poc) == H_PITCH)
            note_set_user_enharmonicity(note, hatom_getpitch(&poc));
        else {
            note_set_auto_enharmonicity(note);
            note->midicents = hatom_getdouble(&poc);
        }
        changed = 1;
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        note->parent->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, note->parent->parent, false);
    
    set_need_perform_analysis_and_change_flag(r_ob);
    
    return changed;
}

char change_chord_poc_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_poc){
    char changed = 0;
    t_note *nt;
    t_llllelem *thiselem = new_poc ? new_poc->l_head : NULL;
    for (nt=chord->firstnote; nt; nt = nt->next) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
            t_hatom poc;
            note_get_poc(r_ob, nt, &poc);
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            change_poc(r_ob, &poc, lexpr, thiselem, (t_notation_item *)nt);
            if (hatom_gettype(&poc) == H_PITCH)
                note_set_user_enharmonicity(nt, hatom_getpitch(&poc));
            else {
                note_set_auto_enharmonicity(nt);
                nt->midicents = hatom_getdouble(&poc);
            }
            if (thiselem && thiselem->l_next)
                thiselem = thiselem->l_next;
            changed = 1;
        }
    }
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        chord->need_recompute_parameters = true;
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        recompute_all_for_measure(r_ob, chord->parent, false);
    
    set_need_perform_analysis_and_change_flag(r_ob);
    
    return changed;
}



char change_note_duration_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_duration){
    char changed = 0;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_duration && new_duration->l_head))) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            change_double(r_ob, &note->duration, lexpr, new_duration ? new_duration->l_head : NULL, 0, (t_notation_item *)note);
            if (note->duration <= 0) 
                note->duration = 0;
            changed = 1;
        }
    }
    return changed;
}

char change_chord_duration_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_duration){
    char changed = 0;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_note *nt; 
        t_llllelem *thiselem = (new_duration) ? new_duration->l_head : NULL;
        for (nt=chord->firstnote; nt; nt = nt->next) {
            if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                change_double(r_ob, &nt->duration, lexpr, thiselem, 0, (t_notation_item *)nt);
                if (nt->duration <= 0) 
                    nt->duration = 0;
                if (thiselem && thiselem->l_next) 
                    thiselem = thiselem->l_next;
                changed = 1;
            }
        }
    }
    return changed;
}

void ts_adapt_to_symduration(t_timesignature *ts, t_rational new_measure_duration, char also_simplify)
{
    long old_den = ts->denominator;
    long g = 1;
    
    if (old_den % new_measure_duration.r_den == 0) {
        // the new denominator is a divisor of the old one. E.g. adapting (7 4) to a duration of 5/2
        ts->numerator = new_measure_duration.r_num * (old_den / new_measure_duration.r_den);
    } else if (perfect_log2(new_measure_duration.r_den) > 0) {
        // binary case: the denominator is a power of two. E.g. adapting anything to a duration of n/2^k
        ts->denominator = MAX(4, new_measure_duration.r_den);
        ts->numerator = new_measure_duration.r_num * (ts->denominator / new_measure_duration.r_den);
    } else if (new_measure_duration.r_den % old_den == 0) {
        // the denominator is a MULTIPLE of the old one. E.g. adapting (7 4) to a duration of 11/8
        ts->denominator = new_measure_duration.r_den;
        ts->numerator = new_measure_duration.r_num;
    } else {
        // don't really know what to do here. E.g. adapting (5 8) to a duration of 11/12
        ts->denominator = new_measure_duration.r_den < 6 ? new_measure_duration.r_den * 2 : new_measure_duration.r_den;
        ts->numerator = new_measure_duration.r_num * (ts->denominator / new_measure_duration.r_den);
    }
    
    
    if (also_simplify && (g = gcd(ts->numerator, ts->denominator)) > 1) {
        ts->numerator /= g;
        ts->denominator /= g;
        switch (ts->denominator) {
            case 1:
                ts->numerator *= 4;
                ts->denominator *= 4;
                break;
            case 2:
            case 3:
            case 5:
                ts->numerator *= 2;
                ts->denominator *= 2;
                break;
            default:
                break;
        }
    }
}

char change_chord_symduration_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_symduration, char autoadapt_ts, char autoadapt_scope, char autoadapt_simplify)
{
    char changed = 0;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_llllelem *thiselem = (new_symduration) ? new_symduration->l_head : NULL;
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)chord)) && chord->parent && (lexpr || thiselem)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord->parent, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
            t_rational old_sym_dur = chord->r_sym_duration;
            change_rational(r_ob, &chord->r_sym_duration, lexpr, thiselem, (t_notation_item *)chord);
            if (chord->r_sym_duration <= 0)
                toggle_grace_for_chord(r_ob, chord, 1);
            if (old_sym_dur.r_num < 0)
                chord->r_sym_duration = rat_long_prod(rat_abs(chord->r_sym_duration), -1);
            changed = 1;
            
            if (autoadapt_ts) {
                t_measure *meas = chord->parent;
                t_rational measure_dur = measure_get_sym_duration(meas);
                t_rational measure_content_dur = measure_get_content_sym_duration(meas);
                if (((autoadapt_ts % 2) && (measure_content_dur > measure_dur)) ||
                    ((autoadapt_ts / 2) && (measure_content_dur < measure_dur))) {
                    if (!(meas->tuttipoint_reference->simple_single_measure_tuttipoint && autoadapt_scope > 0)) {
                        r_ob->need_recompute_tuttipoints = true;
                        r_ob->need_reassign_local_spacing = true;
                    }
                    
                    if (autoadapt_scope > 0) {
                        t_llll *meas_ll = measure_get_aligned_measures_as_llll(r_ob, meas);
                        for (t_llllelem *el = meas_ll->l_head; el; el = el->l_next) {
                            t_measure *thismeas = (t_measure *)hatom_getobj(&el->l_hatom);
                            t_timesignature ts = thismeas->timesignature;
                            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)thismeas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
                            ts_adapt_to_symduration(&ts, measure_content_dur, autoadapt_simplify);
                            measure_set_ts(r_ob, thismeas, &ts);
                            recompute_all_for_measure(r_ob, thismeas, true);
                        }
                        llll_free(meas_ll);
                    } else {
                        t_timesignature ts = meas->timesignature;
                        ts_adapt_to_symduration(&ts, measure_content_dur, autoadapt_simplify);
                        measure_set_ts(r_ob, meas, &ts);
                        recompute_all_for_measure(r_ob, meas, true);
                    }
                }
            }
        }
    }
    return changed;
}

void note_change_tail_for_glissando_till_next(t_notation_obj *r_ob, t_note *note, double slope)
{
    if (note && note->parent) {
        if (r_ob->dl_spans_ties == 0 || !note->tie_from) {
            t_chord *ch = note->parent;
            t_chord *nextch = NULL;
            if (r_ob->dl_spans_ties > 0) {
                t_note *last_tied_note = note_get_last_in_tieseq(note);
                if (last_tied_note && last_tied_note->parent)
                    nextch = chord_get_next(last_tied_note->parent);
            } else
                nextch = chord_get_next(ch);
            if (nextch && nextch->firstnote) {
                // pick the appropriate note in the chord
                long pos = CLAMP(note_get_position(r_ob, note), 1, nextch->num_notes);
                t_note *nextnt = nth_note(nextch, pos - 1);
                note->lastbreakpoint->delta_mc = nextnt->midicents - note->midicents;
                note->lastbreakpoint->slope = slope;
            }
        }
    }
}

char change_note_tail_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_tail)
{
    char changed = 0;
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_tail && new_tail->l_head))) {
            double tail_position = note->parent->onset + note->duration;
            char is_sym = (hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM);
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            if (!lexpr && is_sym) {
                if (hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_legato) {
                    if (note->parent->next)
                        tail_position = note->parent->next->onset;
                } else if (!lexpr && hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM && hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_legatotrim) {
                    if (note->parent->next && tail_position > note->parent->next->onset)
                        tail_position = note->parent->next->onset;
                } else if (!lexpr && hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM && hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_legatoextend) {
                    if (note->parent->next && tail_position < note->parent->next->onset)
                        tail_position = note->parent->next->onset;
                } else if (hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_glissando) {
                    if (note->parent->next) {
                        tail_position = note->parent->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, note, new_tail->l_head->l_next && is_hatom_number(&new_tail->l_head->l_next->l_hatom) ? hatom_getdouble(&new_tail->l_head->l_next->l_hatom) : 0.);
                    }
                } else if (!lexpr && hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM && hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_glissandotrim) {
                    if (note->parent->next && tail_position > note->parent->next->onset) {
                        tail_position = note->parent->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, note, new_tail->l_head->l_next && is_hatom_number(&new_tail->l_head->l_next->l_hatom) ? hatom_getdouble(&new_tail->l_head->l_next->l_hatom) : 0.);
                    }
                } else if (!lexpr && hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM && hatom_getsym(&new_tail->l_head->l_hatom) == _llllobj_sym_glissandoextend) {
                    if (note->parent->next && tail_position < note->parent->next->onset) {
                        tail_position = note->parent->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, note, new_tail->l_head->l_next && is_hatom_number(&new_tail->l_head->l_next->l_hatom) ? hatom_getdouble(&new_tail->l_head->l_next->l_hatom) : 0.);
                    }
                }
            } else
                change_double(r_ob, &tail_position, lexpr, new_tail ? new_tail->l_head : NULL, 0, (t_notation_item *)note);
            note->duration = tail_position - note->parent->onset;
            if (note->duration <= 0) 
                note->duration = 0;
            changed = 1;
        }
    }
    return changed;
}

char change_chord_tail_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_tail){
    char changed = 0;
    char with_sym = 0, tail_legato = 0, tail_legato_trim = 0, tail_legato_extend = 0, tail_glissando = 0, tail_glissando_trim = 0, tail_glissando_extend = 0;
    double slope = 0;

    if (new_tail && hatom_gettype(&new_tail->l_head->l_hatom) == H_SYM) {
        t_symbol *s = hatom_getsym(&new_tail->l_head->l_hatom);
        with_sym = true;
        if (s == _llllobj_sym_legato) tail_legato = true;
        else if (s == _llllobj_sym_legatotrim) tail_legato_trim = true;
        else if (s == _llllobj_sym_legatoextend) tail_legato_extend = true;
        else if (s == _llllobj_sym_glissando) tail_glissando = true;
        else if (s == _llllobj_sym_glissandotrim) tail_glissando_trim = true;
        else if (s == _llllobj_sym_glissandoextend) tail_glissando_extend = true;
        
        slope = new_tail->l_head->l_next && is_hatom_number(&new_tail->l_head->l_next->l_hatom) ? hatom_getdouble(&new_tail->l_head->l_next->l_hatom) : 0.;
    }
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_note *nt; 
        t_llllelem *thiselem = (new_tail) ? new_tail->l_head : NULL;
        for (nt=chord->firstnote; nt; nt = nt->next) {
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt) && (lexpr || thiselem)) {
                double tail_position = nt->parent->onset + nt->duration;
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
                if (with_sym) {
                    if (tail_legato && chord->next) {
                        tail_position = chord->next->onset;
                    } else if (tail_legato_trim && chord->next && tail_position > chord->next->onset) {
                        tail_position = chord->next->onset;
                    } else if (tail_legato_extend && chord->next && tail_position < chord->next->onset) {
                        tail_position = chord->next->onset;
                    } else if (tail_glissando && chord->next) {
                        tail_position = chord->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, nt, slope);
                    } else if (tail_glissando_trim && chord->next && tail_position > chord->next->onset) {
                        tail_position = chord->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, nt, slope);
                    } else if (tail_glissando_extend && chord->next && tail_position < chord->next->onset) {
                        tail_position = chord->next->onset;
                        note_change_tail_for_glissando_till_next(r_ob, nt, slope);
                    }
                } else
                    change_double(r_ob, &tail_position, lexpr, thiselem, 0, (t_notation_item *)nt);
                nt->duration = tail_position - nt->parent->onset;
                if (nt->duration <= 0)
                    nt->duration = 0;
                if (thiselem && thiselem->l_next)
                    thiselem = thiselem->l_next;
                changed = 1;
            }
        }    
    }
    return changed;
}

char change_breakpoint_onset_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_onset){
    char changed = 0;
    t_note *note = bpt->owner;
    if (bpt->prev && (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_onset && new_onset->l_head))) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        double bpt_onset = notation_item_get_onset_ms(r_ob, (t_notation_item *)bpt);
        double orig_bpt_onset = bpt_onset;
        change_double(r_ob, &bpt_onset, lexpr, new_onset ? new_onset->l_head : NULL, 0, (t_notation_item *)bpt);
        if (bpt->next) {
            double rel_x_pos = CLAMP((bpt_onset - notation_item_get_onset_ms(r_ob, (t_notation_item *)note->parent))/(notation_item_get_duration_ms(r_ob, (t_notation_item *)note)), 0, 1);
            rel_x_pos = CLAMP(rel_x_pos, bpt->prev->rel_x_pos, bpt->next->rel_x_pos);
            bpt->rel_x_pos = rel_x_pos;
            if (bpt->next && bpt->rel_x_pos == 1.) {
                object_warn((t_object *) r_ob, "Warning: breakpoints can't trespass the note tail, last-but-one breakpoint nudged left");
                bpt->rel_x_pos = MAX(bpt->prev ? bpt->prev->rel_x_pos : 0, 1. - CONST_EPSILON_DOUBLE_EQ);
            }
        } else {
            // change duration
            trim_note_end(r_ob, note, bpt_onset - orig_bpt_onset);
        }
        changed = 1;
    }
    return changed;
}


char change_breakpoint_onset(t_notation_obj *r_ob, t_bpt *bpt, double new_onset)
{
    t_llll *temp = llll_get();
    llll_appenddouble(temp, new_onset);
    char res = change_breakpoint_onset_from_lexpr_or_llll(r_ob, bpt, NULL, temp);
    llll_free(temp);
    return res;
}


// THESE FUNCTION IS UNDOCUMENTED (among other things, it depends on the selection order, which is normally undefined!!!)
char change_chord_ioi_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_ioi)
{
    char changed = 0;
    char legato = (new_ioi && hatom_gettype(&new_ioi->l_head->l_hatom) == H_SYM && hatom_getsym(&new_ioi->l_head->l_hatom) == _llllobj_sym_legato);
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if (chord->next && (!notation_item_is_globally_locked(r_ob, (t_notation_item *)chord->next)) && (lexpr || (new_ioi && new_ioi->l_head))) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord->next, k_CHORD, k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER);
            if (legato)
                chord->next->onset = chord->onset + chord_get_max_duration(r_ob, chord);
            else {
                double ioi = chord->next->onset - chord->onset;
                change_double(r_ob, &ioi, lexpr, new_ioi ? new_ioi->l_head : NULL, 0, (t_notation_item *)chord);
                chord->next->onset = chord->onset + ioi;
            }
            changed = 1;
        }
    }
    return changed;
}



char change_chord_onset_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_onset){
    char changed = 0;
    char legato = (new_onset && hatom_gettype(&new_onset->l_head->l_hatom) == H_SYM && hatom_getsym(&new_onset->l_head->l_hatom) == _llllobj_sym_legato);
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)chord)) && (lexpr || (new_onset && new_onset->l_head))) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER);
// THESE TWO LINES BELOW ARE UNDOCUMENTED (LEGATO FOR ONSETS IS UNDOCUMENTED, since it depends on the selection order, which is normally undefined.
            if (legato) 
                chord->onset = (!chord->prev) ? 0 : chord->prev->onset + chord_get_max_duration(r_ob, chord->prev);
            else
                change_double(r_ob, &chord->onset, lexpr, new_onset ? new_onset->l_head : NULL, 0, (t_notation_item *)chord);
            changed = 1;
        }
    }
    return changed;
}

char change_breakpoint_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_velocity){
    char changed = 0;
    t_note *note = bpt->owner;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_velocity && new_velocity->l_head))) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        change_long(r_ob, &bpt->velocity, lexpr, new_velocity ? new_velocity->l_head : NULL, 0, (t_notation_item *)bpt);
        bpt->velocity = CLAMP(bpt->velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY);
        changed = 1;
    }
    return changed;
}

char change_note_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_velocity){
    char changed = 0;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_velocity && new_velocity->l_head))) {
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)note, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
        change_long(r_ob, &note->velocity, lexpr, new_velocity ? new_velocity->l_head : NULL, 0, (t_notation_item *)note);
        note_set_velocity(r_ob, note, CLAMP(note->velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY));
        if (r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE)
            note->parent->need_recompute_parameters = true;
        changed = 1;
    }
    return changed;
}

char change_chord_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_velocity){
    char changed = 0;
    t_note *nt; 
    t_llllelem *thiselem = (new_velocity) ? new_velocity->l_head : NULL;
    for (nt=chord->firstnote; nt; nt = nt->next) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)chord, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
            change_long(r_ob, &nt->velocity, lexpr, thiselem, 0, (t_notation_item *)nt);
            note_set_velocity(r_ob, nt, CLAMP(nt->velocity, CONST_MIN_VELOCITY, CONST_MAX_VELOCITY));
            if (thiselem && thiselem->l_next)
                thiselem = thiselem->l_next;
            changed = 1;
        }
        if (r_ob->velocity_handling == k_VELOCITY_HANDLING_NOTEHEADSIZE)
            chord->need_recompute_parameters = true;
    }
    return changed;
}

long tie_to_long(t_notation_obj *r_ob, t_note *note)
{
    return (note->tie_to != NULL) + 2 * (note->tie_from != NULL);
}

void assign_tie_from_long(t_notation_obj *r_ob, t_note *note, long new_tie)
{
    note->tie_to = note->tie_from = NULL;
    
    if (new_tie % 2)
        tie_note(note);

    if (new_tie >= 2)
        tie_note_from(note);
}


char change_note_tie_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_tie)
{
    char changed = 0;
    if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) && (lexpr || (new_tie && new_tie->l_head))) {
        
        // adding undo tick
        t_measure *meas = note->parent->parent;
        if (meas->prev) // ties might affect previous and following measure!
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas->prev, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
        if (meas->next)
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas->next, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);

        long curr_tie = tie_to_long(r_ob, note);
        change_long(r_ob, &curr_tie, lexpr, new_tie ? new_tie->l_head : NULL, 0, (t_notation_item *)note);
        curr_tie = CLAMP(curr_tie, 0, 3);
        assign_tie_from_long(r_ob, note, curr_tie);
        changed = 1;
    }
    return changed;
}

char change_chord_tie_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_tie)
{
    char changed = 0;
    t_note *nt;
    t_llllelem *thiselem = (new_tie ? new_tie->l_head : NULL);
    for (nt=chord->firstnote; nt; nt = nt->next) {
        if ((!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) && (lexpr || thiselem)) {
            
            // adding undo tick
            t_measure *meas = chord->parent;
            if (meas->prev) // ties might affect previous and following measure!
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas->prev, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
            create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
            if (meas->next)
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas->next, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);

            long curr_tie = tie_to_long(r_ob, nt);
            change_long(r_ob, &curr_tie, lexpr, thiselem, 0, (t_notation_item *)nt);
            curr_tie = CLAMP(curr_tie, 0, 3);
            assign_tie_from_long(r_ob, nt, curr_tie);
            if (thiselem && thiselem->l_next)
                thiselem = thiselem->l_next;
            changed = 1;
        }
    }
    return changed;
}



// *************
// MARKERS
// *************

long compare_markers(void *data, t_llllelem *a, t_llllelem *b){
    if (hatom_gettype(&a->l_hatom) == H_LLLL && hatom_gettype(&b->l_hatom) == H_LLLL) {
        t_llll *a_llll = hatom_getllll(&a->l_hatom);
        t_llll *b_llll = hatom_getllll(&b->l_hatom);
        if (hatom_gettype(&a_llll->l_head->l_hatom) == H_LLLL && hatom_gettype(&b_llll->l_head->l_hatom) == H_LLLL) {
            t_llll *pos_a_llll = hatom_getllll(&a_llll->l_head->l_hatom);
            t_llll *pos_b_llll = hatom_getllll(&b_llll->l_head->l_hatom);
            if (pos_a_llll->l_head && pos_b_llll->l_head && hatom_getdouble(&pos_a_llll->l_head->l_hatom) <= hatom_getdouble(&pos_b_llll->l_head->l_hatom))
                return 1;
            else
                return 0;
        }
    }
    return 0;
}

t_llllelem *get_marker_ms_llllelem(t_llllelem *marker){
    if (hatom_gettype(&marker->l_hatom) == H_LLLL) {
        t_llll *marker_llll = hatom_getllll(&marker->l_hatom);
        if (marker_llll && marker_llll->l_head && hatom_gettype(&marker_llll->l_head->l_hatom) == H_LLLL) {
            t_llll *pos_marker_llll = hatom_getllll(&marker_llll->l_head->l_hatom);
            if (pos_marker_llll && pos_marker_llll->l_head)
                return pos_marker_llll->l_head; 
        }
    }
    return NULL;
}

char *atom_to_buffer(t_atom *atom)
{
    long size;
    char *buf = NULL;
    atom_gettext_debug(1, atom, &size, &buf, 0);
    return buf;
}

void recalculate_marker_name_uwidth(t_notation_obj *r_ob, t_marker *marker)
{
    if (marker) {
        double width = 0, height = 0;
        t_jfont *jf_text_markers = jfont_create_debug(r_ob->markers_font->s_name, JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_BOLD, r_ob->markers_font_size);
        if (marker->role == k_MARKER_ROLE_NONE) {
            if (marker->r_it.names->l_size > 0) {
                char buf[1000];
                get_names_as_text(marker->r_it.names, buf, 1000);
                jfont_text_measure(jf_text_markers, buf, &width, &height);
            }
        } else {
            if (marker->content) {
                char *buf = NULL;
                llll_to_text_buf(marker->content, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
                jfont_text_measure(jf_text_markers, buf, &width, &height);
                bach_freeptr(buf);
            }
        }
        marker->name_uwidth = width;
        jfont_destroy_debug(jf_text_markers);
    }
}

t_marker *build_marker(t_notation_obj *r_ob, t_llll *names, double ms, t_timepoint tp, char attach_to, e_marker_roles role, t_llll *content){
    t_marker *marker = (t_marker *) bach_newptrclear(sizeof(t_marker));
    notation_item_init(&marker->r_it, k_MARKER);
    
    change_notation_item_names(r_ob, &marker->r_it, names, false);
//    llll_free(marker->r_it.names);
//    marker->r_it.names = llll_clone(names);
    
    marker->position_ms = ms;
    marker->name_uwidth = 0;
    marker->need_update_name_uwidth = 0;
    marker->attach_to = attach_to;
    marker->role = role;
    marker->content = content;
    marker->name_painted_direction = 0;
    marker->measure_attach_ID = 0;
    marker->name_line = 0;
    marker->r_sym_pim_attach = long2rat(0);

    if (attach_to == k_MARKER_ATTACH_TO_MEASURE) {
        t_voice *voice = nth_voice(r_ob, tp.voice_num);
        if (voice) {
            t_measure *meas = nth_measure_of_scorevoice((t_scorevoice *)voice, tp.measure_num);
            if (meas) {
                marker->measure_attach_ID = meas->r_it.ID;
                marker->r_sym_pim_attach = tp.pt_in_measure;
            }
        }
    }
    
    marker->ux_difference_with_mousedown_marker = 0;
    return marker;
}

void insert_marker(t_notation_obj *r_ob, t_marker *marker, unsigned long force_ID){
    t_marker *after_this_marker = r_ob->lastmarker;
    if (r_ob->firstmarker) { // not at the beginning
        // gotta find where to put it
        t_marker *temp = r_ob->firstmarker;
        while (temp) {
            if (temp->position_ms > marker->position_ms) {
                after_this_marker = temp->prev;
                break;
            }
            temp = temp->next;
        }
    }
        
    if (r_ob->firstmarker) { // not at the beginning
        if (after_this_marker) {
            if (after_this_marker->next) { // insert between these
                after_this_marker->next->prev = marker;
                marker->next = after_this_marker->next;
                marker->prev = after_this_marker;
                after_this_marker->next = marker;
            } else { // insert at the end
                marker->next = NULL;
                marker->prev = after_this_marker;
                after_this_marker->next = marker;
                r_ob->lastmarker = marker;
            }
        } else { // at the beginning
            marker->prev = NULL;
            marker->next = r_ob->firstmarker;
            r_ob->firstmarker->prev = marker;
            r_ob->firstmarker = marker;
        }
    } else { // no markers in the voices yet
        marker->next = NULL;
        marker->prev = NULL;
        r_ob->firstmarker = marker;
        r_ob->lastmarker = marker;
    }

#ifdef BACH_MARKERS_HAVE_ID
    if (force_ID > 0) {
        shashtable_insert_with_key(r_ob->IDtable, marker, force_ID, 1);
        marker->r_it.ID = force_ID;
    } else
        marker->r_it.ID = shashtable_insert(r_ob->IDtable, marker);
#endif

    // increase the # of markers
    r_ob->num_markers++; 
}

// build and insert
t_marker *add_marker(t_notation_obj *r_ob, t_llll *names, double ms, t_timepoint tp, char attach_to, e_marker_roles role, t_llll *content, unsigned long force_ID)
{
    t_marker *marker = build_marker(r_ob, names, ms, tp, attach_to, role, content);
    if (marker) {
        insert_marker(r_ob, marker, force_ID);
        marker->need_update_name_uwidth = r_ob->need_update_markers_uwidth = true;
//        recalculate_marker_name_uwidth(r_ob, marker);
    }
    return marker;
}

char delete_marker_by_llllelem(t_notation_obj *r_ob, t_llllelem *marker){
    if (marker) {
        if (!NOGOOD(marker)) {
            llll_destroyelem(marker);
        } else 
            object_error((t_object *) r_ob, "Marker is a wrong object!");
        return 1;
    }
    return 0;
}

void marker_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_marker *marker){
    
    if (notation_item_is_selected(r_ob, (t_notation_item *)marker))
        notation_item_delete_from_selection(r_ob, (t_notation_item *)marker);

    if (notation_item_is_preselected(r_ob, (t_notation_item *)marker))
        notation_item_delete_from_preselection(r_ob, (t_notation_item *)marker);

    if (r_ob->m_inspector.active_bach_inspector_obj_type == k_MARKER && r_ob->m_inspector.active_bach_inspector_item == marker)
        close_bach_inspector(r_ob, &r_ob->m_inspector);

    if (r_ob->playing){
        if (r_ob->scheduled_item == (t_notation_item *)marker) {
            r_ob->scheduled_item = NULL;
            check_correct_scheduling(r_ob, false);
        }

        if (r_ob->marker_play_cursor == marker)
            r_ob->marker_play_cursor = marker->prev;
    }
}


void delete_marker(t_notation_obj *r_ob, t_marker *marker){
    if (marker){
        
        marker_check_dependencies_before_deleting_it(r_ob, marker);
        
        r_ob->num_markers --;
        if (marker->prev) { // not the first marker
            if (marker->next) { // not the last marker
                marker->prev->next = marker->next;
                marker->next->prev = marker->prev;
            } else { // last marker
                marker->prev->next = NULL;
                r_ob->lastmarker = marker->prev;
            }
        } else { // first marker
            if (marker->next) { // some tempi remain
                marker->next->prev = NULL;
                r_ob->firstmarker = marker->next;
            } else { // there was just 1 marker
                r_ob->firstmarker = NULL;
                r_ob->lastmarker = NULL;
                r_ob->num_markers = 0;
            }
        }
        free_marker(r_ob, marker);
    }
}

char delete_marker_by_name(t_notation_obj *r_ob, t_llll *names){
    char changed = false;
    t_marker *marker;
    for (marker = r_ob->firstmarker; marker; marker = marker->next) {
        if (are_all_names_contained(names, marker->r_it.names)) {
            changed = true;
            delete_marker(r_ob, marker);
            break;
        }
    }
    return changed;
}

// get the FIRST marker having as name a given name (or a set of given names)
t_marker *markername2marker(t_notation_obj *r_ob, t_llll *names){
    t_marker *marker;
    for (marker = r_ob->firstmarker; marker; marker = marker->next)
        if (are_all_names_contained(names, marker->r_it.names))
            return marker;
    return NULL;
}

// get the FIRST notation item having as name a given name (or a set of given names)
t_notation_item *names_to_single_notation_item(t_notation_obj *r_ob, t_llll *names){
    t_notation_item *res = NULL;
    t_llll *items = notationobj_names_to_notation_items(r_ob, names);
    
    if (items && items->l_head)
        res = (t_notation_item *)hatom_getobj(&items->l_head->l_hatom);
    
    llll_free(items);
    return res;
}

long change_marker_names(t_notation_obj *r_ob, t_marker *marker, t_llll *new_names)
{
    if (marker) {
        if (are_names_equal(marker->r_it.names, new_names))
            return 0;
        change_notation_item_names(r_ob, (t_notation_item *)marker, new_names, false);
        marker->need_update_name_uwidth = r_ob->need_update_markers_uwidth = true;
//        recalculate_marker_name_uwidth(r_ob, marker);
        return 1;
    }
    return 0;
}


char check_markers_order(t_notation_obj *r_ob){
    char changed = false;
    t_marker *curr_mk = r_ob->firstmarker;
    while(curr_mk && curr_mk->next) {
        if (curr_mk->next->position_ms < curr_mk->position_ms){ // we have to swap them
            if (curr_mk->prev){
                if (curr_mk->next->next) { // swap between two inner markers
                    t_marker *temp1, *temp2, *temp3, *temp4;
                    temp1 = curr_mk->prev; 
                    temp2 = curr_mk; 
                    temp3 = curr_mk->next; 
                    temp4 = curr_mk->next->next;
                    curr_mk->next->next->prev = temp2;
                    curr_mk->prev->next = temp3;
                    curr_mk->next->next = temp2;
                    curr_mk->next->prev = temp1;
                    curr_mk->next = temp4;
                    curr_mk->prev = temp3;
                    changed = true;
                } else { // swap between the last two curr_mk
                    t_marker *temp1, *temp2, *temp3, *temp4;
                    temp1 = curr_mk->prev; 
                    temp2 = curr_mk; 
                    temp3 = curr_mk->next;
                    temp4 = NULL;
                    curr_mk->prev->next = temp3;
                    curr_mk->next->next = temp2;
                    curr_mk->next->prev = temp1;
                    curr_mk->next = NULL;
                    curr_mk->prev = temp3;
                    r_ob->lastmarker = temp2;
                    changed = true;
                }
            } else { // swap between 1st and 2nd note
                t_marker *temp1, *temp2, *temp3, *temp4;
                temp1 = NULL; 
                temp2 = curr_mk; 
                temp3 = curr_mk->next; 
                temp4 = curr_mk->next->next;
                if (!temp4) // we have just 2 notes:
                    r_ob->lastmarker = temp2;
                else
                    curr_mk->next->next->prev = temp2;
                curr_mk->next->next = temp2;
                curr_mk->next->prev = NULL;
                curr_mk->next = temp4;
                curr_mk->prev = temp3;
                r_ob->firstmarker = temp3;
                changed = true;
            }
            //... and to restart to check from the beginning
            curr_mk = r_ob->firstmarker;
        } else 
            curr_mk = curr_mk->next;
    }
    
    return changed;
}

t_timepoint measure_attached_marker_to_timepoint(t_notation_obj *r_ob, t_marker *marker){
    t_timepoint tp = build_timepoint(0, long2rat(0));
    if (marker->measure_attach_ID > 0) {
        t_notation_item *it = notation_item_retrieve_from_ID(r_ob, marker->measure_attach_ID);
        if (it && it->type == k_MEASURE) {
            t_measure *meas = (t_measure *)it;
            if (meas){
                tp.measure_num = meas->measure_number;
                tp.voice_num = meas->voiceparent->v_ob.number;
                tp.pt_in_measure = marker->r_sym_pim_attach;
            }
        }
    }
    return tp;
}

t_symbol *marker_role_to_sym(e_marker_roles marker_role){
    switch (marker_role) {
        case k_MARKER_ROLE_NONE:
            return _llllobj_sym_none;
            break;
        case k_MARKER_ROLE_TEMPO:
            return _llllobj_sym_tempo;
            break;
        case k_MARKER_ROLE_MEASURE_BARLINE:
            return _llllobj_sym_barline;
            break;
        case k_MARKER_ROLE_MEASURE_DIVISION:
            return _llllobj_sym_division;
            break;
        case k_MARKER_ROLE_MEASURE_SUBDIVISION:
            return _llllobj_sym_subdivision;
            break;
        case k_MARKER_ROLE_TIME_SIGNATURE:
            return _llllobj_sym_timesig;
            break;
    }
    return _llllobj_sym_none;
}

e_marker_roles sym_to_marker_role(t_symbol *s){
    if (s == _llllobj_sym_none)
        return k_MARKER_ROLE_NONE;
    else if (s == _llllobj_sym_tempo)
        return k_MARKER_ROLE_TEMPO;
    else if (s == _llllobj_sym_timesig)
        return k_MARKER_ROLE_TIME_SIGNATURE;
    else if (s == _llllobj_sym_measure || s == _llllobj_sym_barline)
        return k_MARKER_ROLE_MEASURE_BARLINE;
    else if (s == _llllobj_sym_division)
        return k_MARKER_ROLE_MEASURE_DIVISION;
    else if (s == _llllobj_sym_subdivision)
        return k_MARKER_ROLE_MEASURE_SUBDIVISION;
    return k_MARKER_ROLE_NONE;
}

void change_marker_role(t_notation_obj *r_ob, t_marker *marker, e_marker_roles new_role, t_llll *new_value)
{
    lock_markers_mutex(r_ob);
    marker->role = new_role;
    if (marker->content)
        llll_free(marker->content);
    if (new_value)
        marker->content = llll_clone(new_value);
    else
        marker->content = NULL;
    unlock_markers_mutex(r_ob);
    notationobj_invalidate_notation_static_layer_and_redraw((t_notation_obj *)r_ob);
}

void change_marker_ms(t_notation_obj *r_ob, t_marker *marker, double new_ms, char delta_mode, char also_check_sorting){
    lock_markers_mutex(r_ob);
    if (marker) {
        double old_ms = marker->position_ms;
        marker->position_ms = MAX(delta_mode ? old_ms + new_ms : new_ms, 0);
        if (also_check_sorting) 
            check_markers_order(r_ob);
    }
    unlock_markers_mutex(r_ob);
}




double unscaled_xposition_snap_to_nearest_chord(t_notation_obj *r_ob, double ux, char snap_to_note_tails_also, char snap_to_breakpoints_also)
{
    t_notation_item *best_approx = NULL;
    double best_approx_ux = 0;
    double best_approx_fabs = 0;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        t_rollvoice *voice;
        for (voice = (t_rollvoice *)r_ob->firstvoice; voice && voice->v_ob.number < r_ob->num_voices; voice = voice->next) {
            t_chord *chord;
            for (chord = voice->firstchord; chord; chord = chord->next) {
                double chord_ux = onset_to_unscaled_xposition(r_ob, chord->onset);
                double chord_fabs = fabs(chord_ux - ux);
                if (!best_approx || chord_fabs < best_approx_fabs) {
                    best_approx = (t_notation_item *)chord;
                    best_approx_fabs = chord_fabs;
                    best_approx_ux = chord_ux;
                }
                if (snap_to_note_tails_also || snap_to_breakpoints_also) {
                    t_note *note;
                    for (note = chord->firstnote; note; note = note->next) {
                        if (snap_to_breakpoints_also) {
                            double note_ux = onset_to_unscaled_xposition(r_ob, chord->onset + note->duration);
                            double note_fabs = fabs(note_ux - ux);
                            if (!best_approx || note_fabs < best_approx_fabs) {
                                best_approx = (t_notation_item *)note;
                                best_approx_fabs = note_fabs;
                                best_approx_ux = note_ux;
                            }
                        }
                        if (snap_to_breakpoints_also) {
                            t_bpt *bpt;
                            for (bpt = note->firstbreakpoint; bpt; bpt = bpt->next) {
                                if (bpt->prev && bpt->next) { // internal pitch breakpoint
                                    double bpt_ux = onset_to_unscaled_xposition(r_ob, breakpoint_get_absolute_onset(r_ob, bpt));
                                    double bpt_fabs = fabs(bpt_ux - ux);
                                    if (!best_approx || bpt_fabs < best_approx_fabs) {
                                        best_approx = (t_notation_item *)bpt;
                                        best_approx_fabs = bpt_fabs;
                                        best_approx_ux = bpt_ux;
                                    }
                                }
                            }
                        }
                    }
                }
                if (chord_ux > ux)
                    break;
            }
        }
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_scorevoice *voice;
        for (voice = (t_scorevoice *)r_ob->firstvoice; voice && voice->v_ob.number < r_ob->num_voices; voice = voice->next) {
            
            t_measure *measure = ux_to_measure(r_ob, ux, (t_voice *)voice, NULL);
            if (measure) {
                t_chord *chord;
                for (chord = measure->firstchord; chord; chord = chord->next) {
                    double chord_ux = chord_get_alignment_ux(r_ob, chord);
                    double chord_fabs = fabs(chord_ux - ux);
                    if (!best_approx || chord_fabs < best_approx_fabs) {
                        best_approx = (t_notation_item *)chord;
                        best_approx_fabs = chord_fabs;
                        best_approx_ux = chord_ux;
                    }
                    if (chord_ux > ux)
                        break;
                }
            } else {
                // too late or too soon: take first and last chord!
                t_chord *firstchord = chord_get_first(r_ob, (t_voice *)voice);
                t_chord *lastchord = chord_get_last(r_ob, (t_voice *)voice);
                
                if (firstchord) {
                    double firstchord_ux = chord_get_alignment_ux(r_ob, firstchord);
                    double firstchord_fabs = fabs(firstchord_ux - ux);
                    if (!best_approx || firstchord_fabs < best_approx_fabs) {
                        best_approx = (t_notation_item *)firstchord;
                        best_approx_fabs = firstchord_fabs;
                        best_approx_ux = firstchord_ux;
                    }
                }
                
                if (lastchord) {
                    double lastchord_ux = chord_get_alignment_ux(r_ob, lastchord);
                    double lastchord_fabs = fabs(lastchord_ux - ux);
                    if (!best_approx || lastchord_fabs < best_approx_fabs) {
                        best_approx = (t_notation_item *)lastchord;
                        best_approx_fabs = lastchord_fabs;
                        best_approx_ux = lastchord_ux;
                    }
                }
                
            }
        }
    }
    
    return best_approx ? best_approx_ux : ux;
}

char move_selected_ms_attached_markers(t_notation_obj *r_ob, double marker_withmousedown_ux, char magnetic, double *delta_ms)
{
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    
    lock_general_mutex(r_ob);
    
    // First of all: we detect if we should actually change anything: 0ms is indeed a barrier, and if we are dragging leftwards stuff which
    // has already hit the barrier, nothing should happen
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        if (curr_it->type == k_MARKER && ((t_marker *)curr_it)->attach_to == k_MARKER_ATTACH_TO_MS) {
            double ux = marker_withmousedown_ux + ((t_marker *)curr_it)->ux_difference_with_mousedown_marker;
            double ms = unscaled_xposition_to_ms(r_ob, ux, 1);
            if (ms <= 0) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                    double new_ux = ms_to_unscaled_xposition(r_ob, 0, 1);
                    marker_withmousedown_ux = new_ux - ((t_marker *)curr_it)->ux_difference_with_mousedown_marker;
                } else {
                    marker_withmousedown_ux += deltaxpixels_to_deltauxpixels(r_ob, deltaonset_to_deltaxpixels(r_ob, -ms));
                }
            }
        }
    }
    
    
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        if (curr_it->type == k_MARKER && ((t_marker *)curr_it)->attach_to == k_MARKER_ATTACH_TO_MS) {
            double ux = marker_withmousedown_ux + ((t_marker *)curr_it)->ux_difference_with_mousedown_marker;
            if (magnetic)
                ux = unscaled_xposition_snap_to_nearest_chord(r_ob, ux, true, true);
            changed = true;
            double new_position_ms = MAX(0, unscaled_xposition_to_ms(r_ob, ux, 1));
            if (delta_ms && ((t_marker *)curr_it)->ux_difference_with_mousedown_marker == 0)
                *delta_ms = new_position_ms - ((t_marker *)curr_it)->position_ms;
            ((t_marker *)curr_it)->position_ms = new_position_ms;
        }
    }
    
    if (changed)
        check_markers_order(r_ob);
    unlock_general_mutex(r_ob);
    return changed;
}

char move_selected_ms_attached_markers_delta(t_notation_obj *r_ob, double delta_ms)
{
    t_notation_item *curr_it;
    char changed = 0;
    
    lock_general_mutex(r_ob);
    
    // First of all: we detect if we should actually change anything: 0ms is indeed a barrier, and if we are dragging leftwards stuff which
    // has already hit the barrier, nothing should happen
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        if (curr_it->type == k_MARKER && ((t_marker *)curr_it)->attach_to == k_MARKER_ATTACH_TO_MS) {
            double this_onset = notation_item_get_onset_ms(r_ob, curr_it);
            if (this_onset + delta_ms < 0) 
                delta_ms = -this_onset; // < we modify the delta onset, should an element be nearer the barrier than the required delta onset
        }
    }
    
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        if (curr_it->type == k_MARKER && ((t_marker *)curr_it)->attach_to == k_MARKER_ATTACH_TO_MS) { // it is a marker : let's move it
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_marker *)curr_it)->position_ms + delta_ms > r_ob->length_ms)
                delta_ms = r_ob->length_ms - ((t_marker *)curr_it)->position_ms;
            change_marker_ms(r_ob, (t_marker *) curr_it, delta_ms, true, false);
            changed = 1;
        }
    }
    
    if (changed)
        check_markers_order(r_ob);
    
    unlock_general_mutex(r_ob);
    
    return changed;
}


void set_selected_markers_flags(t_notation_obj *r_ob, long flags)
{
    t_notation_item *item;
    for (item = r_ob->firstselecteditem; item; item = item->next_selected)
        if (item->type == k_MARKER)
            item->flags |= flags;
}

void unset_selected_markers_flags(t_notation_obj *r_ob, long flags)
{
    t_notation_item *item;
    for (item = r_ob->firstselecteditem; item; item = item->next_selected)
        if (item->type == k_MARKER)
            item->flags &= ~flags;
}

char change_selected_markers_name(t_notation_obj *r_ob, t_llll *new_names, char incremental)
{
    t_notation_item *curr_it;
    char changed = 0;
    lock_markers_mutex(r_ob);
    lock_general_mutex(r_ob);
    if (!new_names->l_head) {
        for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
            if (curr_it->type == k_MARKER) 
                change_marker_names(r_ob, (t_marker *) curr_it, new_names);
        }
    } else {
        set_selected_markers_flags(r_ob, k_FLAG_TO_BE_MODIFIED);
        for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
            if (curr_it->type == k_MARKER) { 
                t_llll *out_names = NULL;
                if (incremental && ((t_marker *)curr_it)->role == k_MARKER_ROLE_NONE)
                    out_names = find_unused_marker_names(r_ob, &new_names->l_head->l_hatom, (t_marker *) curr_it);
                else {
                    out_names = llll_get();
                    llll_appendhatom_clone(out_names, &new_names->l_head->l_hatom, 0, WHITENULL_llll);
                }
                change_marker_names(r_ob, (t_marker *) curr_it, out_names);
                curr_it->flags &= ~k_FLAG_TO_BE_MODIFIED;
                changed = 1;
                llll_free(out_names);
            }
        }
        unset_selected_markers_flags(r_ob, k_FLAG_TO_BE_MODIFIED);
    }
    unlock_general_mutex(r_ob);
    unlock_markers_mutex(r_ob);
    return changed;
}



t_llll *find_unused_marker_names(t_notation_obj *r_ob, t_hatom *default_name, t_marker *ignore_this_marker){
    long i = 1;
    char is_ok = true;
    t_marker *marker;
    
    
    for (i = 1; i < 100000; i++) {
        t_llll *names_try = llll_get();
        if (default_name && hatom_gettype(default_name) == H_SYM) {
            llll_appendsym(names_try, hatom_getsym(default_name), 0, WHITENULL_llll);
            llll_appendlong(names_try, i, 0, WHITENULL_llll);
        } else if (default_name && hatom_gettype(default_name) == H_LONG) {
            llll_appendlong(names_try, hatom_getlong(default_name) + i, 0, WHITENULL_llll);
        } else {
            llll_appendsym(names_try, r_ob->default_markername, 0, WHITENULL_llll);
            llll_appendlong(names_try, i, 0, WHITENULL_llll);
        }
        
        is_ok = true;
        
        for (marker = r_ob->firstmarker; marker; marker = marker->next) {
            if (marker == ignore_this_marker)
                continue;
            if (marker->r_it.selected && marker->r_it.flags & k_FLAG_TO_BE_MODIFIED)
                continue;
            if (are_all_names_contained(names_try, marker->r_it.names)) {
                is_ok = false;
                break;
            }
        }
        
        if (is_ok) {
            return names_try;
        }
        
        llll_free(names_try);
    }
    
    t_llll *out_names = llll_get();

    if (default_name)
        llll_appendhatom_clone(out_names, default_name, 0, WHITENULL_llll);
    else
        llll_appendsym(out_names, r_ob->default_markername, 0, WHITENULL_llll);
    return out_names;
}

t_llll *make_marker_name_unique(t_notation_obj *r_ob, t_llll *names){
    // retrieving name without number at the end
    if (names->l_size == 0) {
        t_llll *temp = llll_get();
        llll_appendsym(temp, r_ob->default_markername, 0, WHITENULL_llll);
        t_llll *out = make_marker_name_unique(r_ob, temp);
        llll_free(temp);
        return out;
    } else {    
        char namestr[100];
        long i, len;
        t_hatom name_wk;
        t_hatom *name = &names->l_head->l_hatom;
        
        if (hatom_gettype(name) == H_SYM) {
            strncpy(namestr, hatom_getsym(name)->s_name, 98);
            len = MIN(strlen(namestr), 99);
            namestr[99] = 0;
            for (i = len; i > 0; i--)
                if (namestr[i] >= 48 && namestr[i] <= 57)
                    namestr[i] = 0;
            hatom_setsym(&name_wk, gensym(namestr));
        } else if (hatom_gettype(name) == H_LLLL) {
            hatom_setsym(&name_wk, r_ob->default_markername);
        } else
            name_wk = *name;
        
        return find_unused_marker_names(r_ob, &name_wk, NULL);
    }
}

void select_all_markers(t_notation_obj *r_ob, e_selection_modes mode, long only_this_marker_role)
{
    t_marker *marker;
    for (marker = r_ob->firstmarker; marker; marker = marker->next)
        if (only_this_marker_role < 0 || marker->role == only_this_marker_role)
            notation_item_add_to_preselection(r_ob, (t_notation_item *)marker);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}

void select_all_voices(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        notation_item_add_to_preselection(r_ob, (t_notation_item *)voice);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}

void select_all_notes(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_voice *voice;
    t_chord *chord;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            if (chord->firstnote)
                notation_item_add_to_preselection(r_ob, (t_notation_item *)chord);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}

void select_all_rests(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_voice *voice;
    t_chord *chord;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            if (!chord->firstnote)
                notation_item_add_to_preselection(r_ob, (t_notation_item *)chord);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}


void select_all_chords(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_voice *voice;
    t_chord *chord;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            notation_item_add_to_preselection(r_ob, (t_notation_item *)chord);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}

void select_all_breakpoints(t_notation_obj *r_ob, e_selection_modes mode, char tails_only)
{
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    t_bpt *bpt;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord))
            for (note = chord->firstnote; note; note = note->next)
                for (bpt = tails_only ? note->lastbreakpoint : (note->firstbreakpoint ? note->firstbreakpoint->next : NULL); bpt; bpt = bpt->next)
                    notation_item_add_to_preselection(r_ob, (t_notation_item *)bpt);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}

void select_all_measures(t_notation_obj *r_ob, e_selection_modes mode)
{
    t_voice *voice;
    t_measure *measure;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        for (measure = ((t_scorevoice *)voice)->firstmeasure; measure; measure = measure->next)
            notation_item_add_to_preselection(r_ob, (t_notation_item *)measure);
    move_preselecteditems_to_selection(r_ob, mode, false, false);
}


void change_marker_from_llll(t_notation_obj *r_ob, t_marker *marker, t_llll* llll){
    if (llll && llll->l_head && is_hatom_number(&llll->l_head->l_hatom)) {
        marker->position_ms = hatom_getdouble(&llll->l_head->l_hatom);
        notation_item_set_names_from_llllelem(r_ob, (t_notation_item *)marker, llll->l_head->l_next);
    }
    marker->need_update_name_uwidth = r_ob->need_update_markers_uwidth = true;
//    recalculate_marker_name_uwidth(r_ob, marker);
    check_markers_order(r_ob);
}

// returns the nth (0-based) voice of a notation object
t_voice* nth_voice(t_notation_obj *r_ob, long n)
{ 
    t_voice *curr = r_ob->firstvoice; 
    
    long i;
    
    if (n < 0) 
        return curr;
    
    if (n >= r_ob->num_voices) 
        n = r_ob->num_voices;
    
    for (i = 0; i < n; i++)
        curr = voice_get_next(r_ob, curr);
    return curr;
    // to be improved: if the note# is > n/2, pass the list the other way round!
}


void timepoint_handle_voice_numbers(t_notation_obj *r_ob, t_timepoint *arguments_tp, char also_clip)
{
    // handling negative voice numbers
    if (arguments_tp->voice_num < -1)
        arguments_tp->voice_num += r_ob->num_voices + 1;
    
    // clipping voice to existing ones
    if (also_clip) {
        if (r_ob->num_voices > 0)
            clip_long(&arguments_tp->voice_num, 0, r_ob->num_voices - 1);
        else
            *arguments_tp = build_timepoint(0, long2rat(0));
    }
}



void timepoint_handle_measure_numbers(t_notation_obj *r_ob, t_timepoint *arguments_tp, char also_clip)
{
    t_scorevoice *sv = (arguments_tp->voice_num >= 0 && arguments_tp->voice_num < r_ob->num_voices) ? (t_scorevoice *)nth_voice(r_ob, arguments_tp->voice_num) : NULL;
    
    // handling negative measure numbers
    if (sv && arguments_tp->measure_num < -1)
        arguments_tp->measure_num += sv->num_measures + 1;
    
    // clipping measures to existing ones
    if (also_clip) {
        if (r_ob->num_voices > 0 && sv->num_measures > 0)
            clip_long(&arguments_tp->measure_num, 0, sv->num_measures - 1);
        else
            *arguments_tp = build_timepoint(0, long2rat(0));
    }
}


void timepoint_handle_pim(t_notation_obj *r_ob, t_timepoint *arguments_tp, char also_clip)
{
    t_scorevoice *sv = (arguments_tp->voice_num >= 0 && arguments_tp->voice_num < r_ob->num_voices) ? (t_scorevoice *)nth_voice(r_ob, arguments_tp->voice_num) : NULL;
    t_measure *meas = (sv && arguments_tp->measure_num >= 0 && arguments_tp->measure_num < sv->num_measures) ? nth_measure_of_scorevoice(sv, arguments_tp->measure_num) : NULL;
    
    // handling negative pim
    if (rat_long_cmp(arguments_tp->pt_in_measure, 0) < 0) {
        if (meas) {
            arguments_tp->pt_in_measure = rat_rat_sum(arguments_tp->pt_in_measure, measure_get_sym_duration(meas));
        } else
            *arguments_tp = build_timepoint(0, long2rat(0));
    }
    
    
    if (also_clip) {
        if (meas)
            clip_rat(&arguments_tp->pt_in_measure, long2rat(0), measure_get_sym_duration(meas));
        else
            *arguments_tp = build_timepoint(0, long2rat(0));
    }

}

t_timepoint llll_to_timepoint(t_notation_obj *r_ob, t_llll *innerllll, char *is_voice_defined, char also_clip) {
    t_timepoint arguments_tp; 
    t_measure *meas = NULL;
    char voice_defined = false;
    
    arguments_tp.voice_num = 0;
    arguments_tp.measure_num = 0;
    arguments_tp.pt_in_measure = long2rat(0);
    
    if (innerllll && (innerllll->l_size == 1) && (hatom_gettype(&innerllll->l_head->l_hatom) == H_LONG || hatom_gettype(&innerllll->l_head->l_hatom) == H_RAT)) {
        // (<measure_num>)

        arguments_tp.measure_num = hatom_getlong(&innerllll->l_head->l_hatom) - 1;
        timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);
        
    } else if (innerllll && (innerllll->l_size == 1) && (hatom_gettype(&innerllll->l_head->l_hatom) == H_DOUBLE)){
        // (<float_measure_num>)
        
        double val = hatom_getdouble(&innerllll->l_head->l_hatom);
        t_measure *meas;

        arguments_tp.measure_num = floor(val) - 1;
        timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);

        meas = nth_measure_of_scorevoice((t_scorevoice *)r_ob->firstvoice, arguments_tp.measure_num);
        if (meas)
            arguments_tp.pt_in_measure = rat_rat_prod(approx_double_with_rat_fixed_den(val - floor(val), 100, 0, NULL), measure_get_sym_duration(meas));
        timepoint_handle_pim(r_ob, &arguments_tp, also_clip);
        
    } else if (innerllll && innerllll->l_size == 2 && (is_hatom_number(&innerllll->l_head->l_hatom) && is_hatom_number(&innerllll->l_head->l_next->l_hatom))) {
        // (<measure_num> <point_in_measure>)
        
        arguments_tp.measure_num = hatom_getlong(&innerllll->l_head->l_hatom) - 1;
        timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);
        
        if (r_ob->firstvoice && hatom_gettype(&innerllll->l_head->l_next->l_hatom) == H_DOUBLE && r_ob->firstvoice &&
            (meas = nth_measure_of_scorevoice((t_scorevoice *)r_ob->firstvoice, arguments_tp.measure_num))) {
            double val = hatom_getdouble(&innerllll->l_head->l_next->l_hatom);
            arguments_tp.pt_in_measure = rat_rat_prod(approx_double_with_rat_fixed_den(val, 100, 0, NULL), measure_get_sym_duration(meas));
        } else {
            arguments_tp.pt_in_measure = hatom_getrational(&innerllll->l_head->l_next->l_hatom);
        }
        timepoint_handle_pim(r_ob, &arguments_tp, also_clip);

    } else if (innerllll && innerllll->l_size >= 3 && is_hatom_number(&innerllll->l_head->l_hatom)
               && is_hatom_number(&innerllll->l_head->l_next->l_hatom)  && is_hatom_number(&innerllll->l_head->l_next->l_hatom)) {
        
        if (r_ob->old_timepoint_syntax_bw_compatibility) { //bw-compatibile timepoint syntax (before bach 0.7.3)
            // (<measure_num> <pim> <voice_number>)
            arguments_tp.voice_num = hatom_getlong(&innerllll->l_head->l_next->l_next->l_hatom) - 1;
            timepoint_handle_voice_numbers(r_ob, &arguments_tp, also_clip);
            arguments_tp.measure_num = hatom_getlong(&innerllll->l_head->l_hatom) - 1;
            timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);
            voice_defined = true;
            
            t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, arguments_tp.voice_num);
            if (voice && hatom_gettype(&innerllll->l_head->l_next->l_hatom) == H_DOUBLE && (meas = nth_measure_of_scorevoice(voice, arguments_tp.measure_num))) {
                double val = hatom_getdouble(&innerllll->l_head->l_next->l_hatom);
                arguments_tp.pt_in_measure = rat_rat_prod(approx_double_with_rat_fixed_den(val, 100, 0, NULL), measure_get_sym_duration(meas));
            } else {
                arguments_tp.pt_in_measure = hatom_getrational(&innerllll->l_head->l_next->l_hatom);
            }
            timepoint_handle_pim(r_ob, &arguments_tp, also_clip);
            
        } else { // new timepoint syntax, from bach 0.7.3
            // (<voice_number> <measure_num> <pim>)
            arguments_tp.voice_num = hatom_getlong(&innerllll->l_head->l_hatom) - 1;
            timepoint_handle_voice_numbers(r_ob, &arguments_tp, also_clip);
            arguments_tp.measure_num = hatom_getlong(&innerllll->l_head->l_next->l_hatom) - 1;
            timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);
            voice_defined = true;
            
            t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, arguments_tp.voice_num);
            if (voice && hatom_gettype(&innerllll->l_head->l_next->l_next->l_hatom) == H_DOUBLE && (meas = nth_measure_of_scorevoice(voice, arguments_tp.measure_num))) {
                double val = hatom_getdouble(&innerllll->l_head->l_next->l_next->l_hatom);
                arguments_tp.pt_in_measure = rat_rat_prod(approx_double_with_rat_fixed_den(val, 100, 0, NULL), measure_get_sym_duration(meas));
            } else {
                arguments_tp.pt_in_measure = hatom_getrational(&innerllll->l_head->l_next->l_next->l_hatom);
            }
            timepoint_handle_pim(r_ob, &arguments_tp, also_clip);
        }
        
        
    } else if (innerllll && (innerllll->l_size == 2 || innerllll->l_size == 3) &&
               ((hatom_gettype(&innerllll->l_tail->l_prev->l_hatom) == H_LLLL && hatom_getllll(&innerllll->l_tail->l_prev->l_hatom)->l_size == 0 && is_hatom_number(&innerllll->l_tail->l_hatom)) ||
                (hatom_gettype(&innerllll->l_tail->l_prev->l_hatom) == H_SYM && hatom_getsym(&innerllll->l_tail->l_prev->l_hatom) == _llllobj_sym_any && is_hatom_number(&innerllll->l_tail->l_hatom)))){
        // (any <global_sym_onset>) or ( <voicenumber> any <global_sym_onset>)
        
        t_rational global_sym_onset = hatom_getrational(&innerllll->l_tail->l_hatom);
        arguments_tp.voice_num = (innerllll->l_size == 2 ? 0 : hatom_getlong(&innerllll->l_head->l_hatom) - 1);
        if (innerllll->l_size == 2)
            voice_defined = false;
        else
            voice_defined = true;
        
        timepoint_handle_voice_numbers(r_ob, &arguments_tp, also_clip);
        
        // detecting measure
        t_voice *voice = nth_voice(r_ob, arguments_tp.voice_num);
        if (voice) {
            long i = 0;
            char found = false;
            t_rational temp = global_sym_onset;
            for (t_measure *meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next, i++) {
                t_rational meas_dur = measure_get_sym_duration(meas);
                if (rat_rat_cmp(temp, meas_dur) < 0) {
                    arguments_tp.measure_num = i;
                    arguments_tp.pt_in_measure = temp;
                    found = true;
                    break;
                } else {
                    if (!meas->next) {
                        arguments_tp.measure_num = i;
                        arguments_tp.pt_in_measure = temp;
                        break;
                    } else
                        temp = rat_rat_diff(temp, meas_dur);
                }
            }
        } else {
            arguments_tp.measure_num = 0;
            arguments_tp.pt_in_measure = global_sym_onset;
        }

        timepoint_handle_measure_numbers(r_ob, &arguments_tp, also_clip);
        timepoint_handle_pim(r_ob, &arguments_tp, also_clip);
    }
    
    if (is_voice_defined)
        *is_voice_defined = voice_defined;

    return arguments_tp;
}

/*
 t_timepoint llll_to_timepoint(t_notation_obj *r_ob, t_llll *ll){
    t_timepoint tp = build_timepoint(0, long2rat(0));
    if (r_ob->num_voices > 0) {
        if (ll->l_head && is_hatom_number(&ll->l_head->l_hatom)){
            tp.measure_num = hatom_getlong(&ll->l_head->l_hatom) - 1;
            if (ll->l_head->l_next && is_hatom_number(&ll->l_head->l_next->l_hatom)) {
                tp.pt_in_measure = hatom_getrational(&ll->l_head->l_next->l_hatom);
                if (ll->l_head->l_next->l_next && is_hatom_number(&ll->l_head->l_next->l_next->l_hatom))
                    tp.voice_num = hatom_getlong(&ll->l_head->l_next->l_next->l_hatom) - 1;
            }
        }
        
        clip_long(&tp.voice_num, 0, r_ob->num_voices - 1);
        clip_long(&tp.measure_num, 0, ((t_scorevoice *)nth_voice(r_ob, tp.voice_num))->num_measures - 1);
    }
    return tp;
} */

void change_marker_onset_from_lexpr_or_llllelem(t_notation_obj *r_ob, t_marker *marker, t_lexpr *lexpr, t_llllelem *elem){
    if (lexpr) {
        marker->attach_to = k_MARKER_ATTACH_TO_MS;
        change_double(r_ob, &marker->position_ms, lexpr, NULL, false, (t_notation_item *)marker);
    } else if (elem) {
        if (is_hatom_number(&elem->l_hatom)) {
            marker->attach_to = k_MARKER_ATTACH_TO_MS;
            change_double(r_ob, &marker->position_ms, lexpr, elem, false, (t_notation_item *)marker);
//            marker->position_ms = hatom_getdouble(&elem->l_hatom);
        } else if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
            t_llll *this_llll = hatom_getllll(&elem->l_hatom);
            t_timepoint tp = llll_to_timepoint(r_ob, this_llll, NULL, false);
            marker->attach_to = k_MARKER_ATTACH_TO_MEASURE;
            t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, tp.voice_num);
            t_measure *meas = nth_measure_of_scorevoice(voice, tp.measure_num);
            if (meas) {
                marker->measure_attach_ID = meas->r_it.ID;
                marker->r_sym_pim_attach = tp.pt_in_measure;
            }
        }
    }
}

t_marker *add_marker_from_llllelem(t_notation_obj *r_ob, t_llllelem *elem)
{
    t_marker *res = NULL;
    if (hatom_gettype(&elem->l_hatom) == H_DOUBLE || hatom_gettype(&elem->l_hatom) == H_LONG) {
        t_llll *names = find_unused_marker_names(r_ob, NULL, NULL);
        res = add_marker(r_ob, names, hatom_getdouble(&elem->l_hatom), build_timepoint(0, long2rat(0)), k_MARKER_ATTACH_TO_MS, k_MARKER_ROLE_NONE, NULL, 0);
        llll_free(names);
    } else if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
        t_llll *this_llll = hatom_getllll(&elem->l_hatom);
        double ms = 0; 
        char attach_to = k_MARKER_ATTACH_TO_MS;
        e_marker_roles mkrole = k_MARKER_ROLE_NONE;
        t_timepoint tp = build_timepoint(0, long2rat(0));
        t_llll *mknames = NULL;
        t_llll *content = NULL;
        char has_explicit_name = false;
        
        unsigned long forced_marker_ID = notation_item_get_ID_from_llll(this_llll);

        if (this_llll && this_llll->l_head && is_hatom_number(&this_llll->l_head->l_hatom)) {
            ms = hatom_getdouble(&this_llll->l_head->l_hatom);
        } else if (this_llll && this_llll->l_head && hatom_gettype(&this_llll->l_head->l_hatom) == H_LLLL) {
            tp = llll_to_timepoint(r_ob, hatom_getllll(&this_llll->l_head->l_hatom), NULL, false);
            attach_to = k_MARKER_ATTACH_TO_MEASURE;
        }
        
        if (this_llll->l_head && this_llll->l_head->l_next) {
            has_explicit_name = true;
            mknames = get_names_from_llllelem(r_ob, this_llll->l_head->l_next);
        }

        if (this_llll->l_head && this_llll->l_head->l_next && this_llll->l_head->l_next->l_next && hatom_gettype(&this_llll->l_head->l_next->l_next->l_hatom) == H_SYM)
            mkrole = sym_to_marker_role(hatom_getsym(&this_llll->l_head->l_next->l_next->l_hatom));
        if (this_llll->l_head && this_llll->l_head->l_next && this_llll->l_head->l_next->l_next && this_llll->l_head->l_next->l_next->l_next && hatom_gettype(&this_llll->l_head->l_next->l_next->l_next->l_hatom) == H_LLLL) {
            content = llll_clone(hatom_getllll(&this_llll->l_head->l_next->l_next->l_next->l_hatom));
        }
        
        if (!has_explicit_name) 
            mknames = find_unused_marker_names(r_ob, NULL, NULL);

        res = add_marker(r_ob, mknames, ms, tp, attach_to, mkrole, content, forced_marker_ID);
        llll_free(mknames);
    }
    return res;
}

// beware: destructive!!
void set_markers_from_llll(t_notation_obj *r_ob, t_llll* markers, char add_mode, char select)
{
    if (markers) {
        t_llllelem *elem;
        if (select)
            lock_general_mutex(r_ob);
        lock_markers_mutex(r_ob);

        if (!add_mode && r_ob->firstmarker)
            clear_all_markers(r_ob);

        for (elem = markers->l_head; elem; elem = elem->l_next)  {
            t_marker *mk = add_marker_from_llllelem(r_ob, elem);
            if (select)
                notation_item_add_to_preselection(r_ob, (t_notation_item *)mk);
        }
        
        unlock_markers_mutex(r_ob);
        if (select) {
            unlock_general_mutex(r_ob);
            move_preselecteditems_to_selection(r_ob, k_SELECTION_MODE_FORCE_SELECT, false, false);
        }
    }
}

void erase_articulation_preferences(t_articulation_preferences *artpr)
{
    artpr->font = _llllobj_sym_default;
    artpr->base_pt = 24;
    artpr->extension_line_char = 0;
    artpr->main_char = artpr->flipped_char = artpr->extension_line_char = 0;
    artpr->flipped_char_ux_shift = artpr->flipped_char_uy_shift = 0;
    artpr->main_char_ux_shift = artpr->main_char_uy_shift = 0;
    artpr->outside_staff_uy_nudge = 0;
    artpr->shortname = artpr->fullname = artpr->alias[0] = artpr->alias[1] = artpr->alias[2] = artpr->alias[3] = artpr->alias[4] = NULL;
    artpr->main_uheight = artpr->flipped_uheight = artpr->main_uy_center = artpr->flipped_uy_center = 0;
    artpr->extension_line_uy_offset = 0;
    artpr->options = 0;
    artpr->positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
    artpr->xmlarticulations = gensym("custom");
    artpr->xmltechnical = artpr->xmlornament = _llllobj_sym_none;
}

void add_custom_articulation_from_llllelem(t_object *x, t_articulations_typo_preferences *atp, t_llllelem *elem)
{
    long a = atp->num_articulations;
    if (hatom_gettype(&elem->l_hatom) == H_LLLL && a < CONST_MAX_ARTICULATIONS) {
        t_llll *this_llll = hatom_getllll(&elem->l_hatom);
        t_llll *alias = NULL, *options_ll = NULL;
        t_symbol *position = NULL;
        t_articulation_preferences *artpr = &atp->artpref[a];
        
        erase_articulation_preferences(artpr);
        llll_parseargs(x, this_llll, "sdiiidddddssldddddlssss",
                       gensym("font"), &artpr->font,
                       gensym("basept"), &artpr->base_pt,
                       gensym("mainchar"), &artpr->main_char,
                       gensym("flippedchar"), &artpr->flipped_char,
                       gensym("extchar"), &artpr->extension_line_char,
                       gensym("mainxshift"), &artpr->main_char_ux_shift,
                       gensym("mainyshift"), &artpr->main_char_uy_shift,
                       gensym("flippedxshift"), &artpr->flipped_char_ux_shift,
                       gensym("flippedyshift"), &artpr->flipped_char_uy_shift,
                       gensym("outsidestaffynudge"), &artpr->outside_staff_uy_nudge,
                       gensym("fullname"), &artpr->fullname,
                       gensym("shortname"), &artpr->shortname,
                       gensym("alias"), &alias,
                       gensym("mainheight"), &artpr->main_uheight,
                       gensym("flippedheight"), &artpr->flipped_uheight,
                       gensym("mainycenter"), &artpr->main_uy_center,
                       gensym("flippedycenter"), &artpr->flipped_uy_center,
                       gensym("extyshift"), &artpr->extension_line_uy_offset,
                       gensym("options"), &options_ll,
                       gensym("position"), &position,
                       gensym("xmlornament"), &artpr->xmlornament,
                       gensym("xmltechnical"), &artpr->xmltechnical,
                       gensym("xmlarticulations"), &artpr->xmlarticulations);
        
        // checking names
        if (artpr->fullname != NULL) {
        
            if (artpr->shortname == NULL)
                artpr->shortname = artpr->fullname;
            
            // position
            if (position == gensym("manual")) artpr->positioning = k_ARTICULATION_POSITIONING_MANUAL;
            else if (position == gensym("noteside")) artpr->positioning = k_ARTICULATION_POSITIONING_NOTE_SIDE;
            else if (position == gensym("stemside") || position == gensym("stemsidenearnotehead")) artpr->positioning = k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD;
            else if (position == gensym("stemsidenearflag")) artpr->positioning = k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG;
            else if (position == gensym("abovenote")) artpr->positioning = k_ARTICULATION_POSITIONING_ABOVE_NOTE;
            else if (position == gensym("belownote")) artpr->positioning = k_ARTICULATION_POSITIONING_BELOW_NOTE;
            else artpr->positioning = k_ARTICULATION_POSITIONING_MANUAL;
            
            // options
            if (is_symbol_in_llll_first_level(options_ll, gensym("avoidlines")))
                artpr->options |= k_ARTICULATION_OPTION_AVOID_STAFF_LINES;
            if (is_symbol_in_llll_first_level(options_ll, gensym("outsidestaff")))
                artpr->options |= k_ARTICULATION_OPTION_OUTSIDE_STAFF;
            if (is_symbol_in_llll_first_level(options_ll, gensym("centerovernote")))
                artpr->options |= k_ARTICULATION_OPTION_CENTER_OVER_NOTE;
            if (is_symbol_in_llll_first_level(options_ll, gensym("centeroverstem")))
                artpr->options |= k_ARTICULATION_OPTION_CENTER_OVER_STEM;
            if (is_symbol_in_llll_first_level(options_ll, gensym("spanties")))
                artpr->options |= k_ARTICULATION_OPTION_SPAN_TIES;
            if (is_symbol_in_llll_first_level(options_ll, gensym("copywhencloned")))
                artpr->options |= k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD;
            if (is_symbol_in_llll_first_level(options_ll, gensym("copywhenclonedtosamechord")))
                artpr->options |= k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD;
            if (is_symbol_in_llll_first_level(options_ll, gensym("copywhensplit")))
                artpr->options |= k_ARTICULATION_OPTION_COPY_WHEN_SPLIT;
            if (is_symbol_in_llll_first_level(options_ll, gensym("shiftwithbeams")))
                artpr->options |= k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS;
            
            
            // aliases
            t_llllelem *el;
            if (alias) {
                long i;
                for (i = 0, el = alias->l_head; el && i < 5; el = el->l_next) {
                    if (hatom_gettype(&el->l_hatom) == H_SYM) {
                        artpr->alias[i] = hatom_getsym(&el->l_hatom);
                        i++;
                    }
                }
            }
            
            atp->num_articulations++;
            
        }
        
        llll_free(options_ll);
        llll_free(alias);
    }
}

void reassign_all_articulations_ids(t_notation_obj *r_ob)
{
    long s;
    for (s = 0; s < CONST_MAX_SLOTS; s++) {
        if (r_ob->slotinfo[s].slot_type == k_SLOT_TYPE_ARTICULATIONS) {
            
            t_voice *voice; t_chord *chord; t_note *note; t_slotitem *item;
            for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
                for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord)) {
                    for (note = chord->firstnote; note; note = note->next) {
                        for (item = note->slot[s].firstitem; item; item = item->next) {
                            ((t_articulation *)item->item)->articulation_ID = notationobj_articulation_symbol2id(r_ob, ((t_articulation *)item->item)->original_name);
                        }
                    }
                }
            }
        }
    }
}


// works also with r_ob = NULL, this is designed to have bach.quantize also take advantage of the articulationinfo system
void set_articulationinfo_from_llll(t_notation_obj *r_ob, t_articulations_typo_preferences *atp, t_llll* art_ll, char add_mode)
{
    if (art_ll) {
        t_llllelem *elem;
        if (!add_mode) // delete existing ones
            atp->num_articulations = k_NUM_STANDARD_ARTICULATIONS;
        
        for (elem = art_ll->l_head; elem; elem = elem->l_next)
            add_custom_articulation_from_llllelem((t_object *)r_ob, atp, elem);
        
        if (r_ob) {
            reassign_all_articulations_ids(r_ob);
            reset_all_articulations_positions(r_ob);
        }
    }
}

t_llll *get_articulationinfo_as_llll(t_notation_obj *r_ob)
{
    long i;
    t_llll *ll = llll_get();
    llll_appendsym(ll, _llllobj_sym_articulationinfo);
    for (i = k_NUM_STANDARD_ARTICULATIONS; i < r_ob->articulations_typo_preferences.num_articulations; i++) {
        t_articulation_preferences *artpr = &r_ob->articulations_typo_preferences.artpref[i];
        if (artpr->fullname != NULL) {
            t_llll *this_art = llll_get();
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("fullname"), artpr->fullname));
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("shortname"), artpr->shortname ? artpr->shortname : artpr->fullname));
            {
                t_llll *aliases = llll_get();
                llll_appendsym(aliases, gensym("alias"));
                if (artpr->alias[0]) llll_appendsym(aliases, artpr->alias[0]);
                if (artpr->alias[1]) llll_appendsym(aliases, artpr->alias[1]);
                if (artpr->alias[2]) llll_appendsym(aliases, artpr->alias[2]);
                if (artpr->alias[3]) llll_appendsym(aliases, artpr->alias[3]);
                if (artpr->alias[4]) llll_appendsym(aliases, artpr->alias[4]);
                llll_appendllll(this_art, aliases);
            }
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("font"), artpr->font));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("basept"), artpr->base_pt));
            llll_appendllll(this_art, symbol_and_long_to_llll(gensym("mainchar"), artpr->main_char));
            llll_appendllll(this_art, symbol_and_long_to_llll(gensym("flippedchar"), artpr->flipped_char));
            llll_appendllll(this_art, symbol_and_long_to_llll(gensym("extchar"), artpr->extension_line_char));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("mainxshift"), artpr->main_char_ux_shift));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("mainyshift"), artpr->main_char_uy_shift));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("flippedxshift"), artpr->flipped_char_ux_shift));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("flippedyshift"), artpr->flipped_char_uy_shift));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("outsidestaffynudge"), artpr->outside_staff_uy_nudge));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("mainheight"), artpr->main_uheight));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("flippedheight"), artpr->flipped_uheight));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("mainycenter"), artpr->main_uy_center));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("flippedycenter"), artpr->flipped_uy_center));
            llll_appendllll(this_art, symbol_and_double_to_llll(gensym("extyshift"), artpr->extension_line_uy_offset));
            
            {
                t_llll *options = llll_get();
                llll_appendsym(options, gensym("options"));
                if (artpr->options & k_ARTICULATION_OPTION_AVOID_STAFF_LINES) llll_appendsym(options, gensym("avoidlines"));
                if (artpr->options & k_ARTICULATION_OPTION_OUTSIDE_STAFF) llll_appendsym(options, gensym("outsidestaff"));
                if (artpr->options & k_ARTICULATION_OPTION_CENTER_OVER_NOTE) llll_appendsym(options, gensym("centerovernote"));
                if (artpr->options & k_ARTICULATION_OPTION_CENTER_OVER_STEM) llll_appendsym(options, gensym("centeroverstem"));
                if (artpr->options & k_ARTICULATION_OPTION_SPAN_TIES) llll_appendsym(options, gensym("spanties"));
                if (artpr->options & k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD) llll_appendsym(options, gensym("copywhencloned"));
                if (artpr->options & k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD) llll_appendsym(options, gensym("copywhenclonedtosamechord"));
                if (artpr->options & k_ARTICULATION_OPTION_COPY_WHEN_SPLIT) llll_appendsym(options, gensym("copywhensplit"));
                if (artpr->options & k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS) llll_appendsym(options, gensym("shiftwithbeams"));
                llll_appendllll(this_art, options);
            }
            
            {
                t_llll *position = llll_get();
                llll_appendsym(position, gensym("position"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_MANUAL) llll_appendsym(position, gensym("manual"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_NOTE_SIDE) llll_appendsym(position, gensym("noteside"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD) llll_appendsym(position, gensym("stemsidenearnotehead"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG) llll_appendsym(position, gensym("stemsidenearflag"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_ABOVE_NOTE) llll_appendsym(position, gensym("abovenote"));
                if (artpr->positioning == k_ARTICULATION_POSITIONING_BELOW_NOTE) llll_appendsym(position, gensym("belownote"));
                llll_appendllll(this_art, position);
            }
            
            // xml export
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("xmlornament"), artpr->xmlornament));
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("xmltechincal"), artpr->xmltechnical));
            llll_appendllll(this_art, symbol_and_symbol_to_llll(gensym("xmlarticulations"), artpr->xmlarticulations));
            
            llll_appendllll(ll, this_art);
        }
    }
    
    return ll;
}




void erase_notehead_preferences(t_notehead_preferences *nhpr)
{
    nhpr->font = _llllobj_sym_default;
    nhpr->base_pt = 24;
    nhpr->shortname = nhpr->fullname = nhpr->alias[0] = nhpr->alias[1] = nhpr->alias[2] = nhpr->alias[3] = nhpr->alias[4] = NULL;
    nhpr->durationline_start_ux_shift = 0;
    nhpr->ux_shift = nhpr->uy_shift = nhpr->small_ux_shift = nhpr->small_uy_shift = 0;
    nhpr->uwidth = 0;
    nhpr->unicode_character_black = 0;
    nhpr->unicode_character_white = 0;
    nhpr->unicode_character_whole = 0;
    nhpr->unicode_character_doublewhole = 0;
}

void add_custom_notehead_from_llllelem(t_notation_obj *r_ob, t_llllelem *elem)
{
    long a = r_ob->noteheads_typo_preferences.num_noteheads;
    if (hatom_gettype(&elem->l_hatom) == H_LLLL && a < CONST_MAX_NOTEHEADS) {
        t_llll *this_llll = hatom_getllll(&elem->l_hatom);
        t_llll *alias = NULL, *unicode_chars = NULL;
        t_notehead_preferences *nhpr = &r_ob->noteheads_typo_preferences.nhpref[a];
        t_llllelem *el;

        erase_notehead_preferences(nhpr);
        
        llll_parseargs((t_object *)r_ob, this_llll, "sdlddddddssl",
                       gensym("font"), &nhpr->font,
                       gensym("basept"), &nhpr->base_pt,
                       gensym("char"), &unicode_chars,
                       gensym("xshift"), &nhpr->ux_shift,
                       gensym("yshift"), &nhpr->uy_shift,
                       gensym("xshiftsmall"), &nhpr->small_ux_shift,
                       gensym("yshiftsmall"), &nhpr->small_uy_shift,
                       gensym("width"), &nhpr->uwidth,
                       gensym("dlstartxshift"), &nhpr->durationline_start_ux_shift,
                       gensym("fullname"), &nhpr->fullname,
                       gensym("shortname"), &nhpr->shortname,
                       gensym("alias"), &alias);
        
        // parsing unicode chars
        if (unicode_chars) {
            long last_char = 0;
            long i;
            for (i = 0, el = unicode_chars->l_head; i < 4; el = el ? el->l_next : NULL, i++) {
                
                if (el && hatom_gettype(&el->l_hatom) == H_SYM) {
                    t_symbol *s = hatom_getsym(&el->l_hatom);
                    long outlen = 0;
                    unsigned short *s_unicode = charset_utf8tounicode_debug(s->s_name, &outlen);
                    last_char = outlen > 0 ? s_unicode[0] : 0;
                    bach_freeptr(s_unicode);
                } else if (el)
                    last_char = hatom_getlong(&el->l_hatom);
                
                switch (i) {
                    case 0:
                        nhpr->unicode_character_black = last_char;
                        break;
                    case 1:
                        nhpr->unicode_character_white = last_char;
                        break;
                    case 2:
                        nhpr->unicode_character_whole = last_char;
                        break;
                    default:
                        nhpr->unicode_character_doublewhole = last_char;
                        break;
                }
            }
            llll_free(unicode_chars);
        }
        
        // aliases
        if (alias) {
            long i;
            for (i = 0, el = alias->l_head; el && i < 5; el = el->l_next) {
                if (hatom_gettype(&el->l_hatom) == H_SYM) {
                    nhpr->alias[i] = hatom_getsym(&el->l_hatom);
                    i++;
                }
            }
        }
        
        r_ob->noteheads_typo_preferences.num_noteheads++;
        
        llll_free(alias);
    }
}

void set_noteheadinfo_from_llll(t_notation_obj *r_ob, t_llll *nh_ll, char add_mode)
{
    if (nh_ll) {
        t_llllelem *elem;
        if (!add_mode) // delete existing ones
            r_ob->noteheads_typo_preferences.num_noteheads = k_NUM_STANDARD_NOTEHEADS;
        
        for (elem = nh_ll->l_head; elem; elem = elem->l_next)  {
            add_custom_notehead_from_llllelem(r_ob, elem);
        }
        
        implicitely_recalculate_all(r_ob, false);
    }
}


t_llll *get_noteheadinfo_as_llll(t_notation_obj *r_ob)
{
    long i;
    t_llll *ll = llll_get();
    llll_appendsym(ll, _llllobj_sym_noteheadinfo);
    for (i = k_NUM_STANDARD_NOTEHEADS; i < r_ob->noteheads_typo_preferences.num_noteheads; i++) {
        t_llll *this_nh = llll_get();
        t_notehead_preferences *nhpr = &r_ob->noteheads_typo_preferences.nhpref[i];
        llll_appendllll(this_nh, symbol_and_symbol_to_llll(gensym("fullname"), nhpr->fullname));
        llll_appendllll(this_nh, symbol_and_symbol_to_llll(gensym("shortname"), nhpr->shortname));
        {
            t_llll *aliases = llll_get();
            llll_appendsym(aliases, gensym("alias"));
            if (nhpr->alias[0]) llll_appendsym(aliases, nhpr->alias[0]);
            if (nhpr->alias[1]) llll_appendsym(aliases, nhpr->alias[1]);
            if (nhpr->alias[2]) llll_appendsym(aliases, nhpr->alias[2]);
            if (nhpr->alias[3]) llll_appendsym(aliases, nhpr->alias[3]);
            if (nhpr->alias[4]) llll_appendsym(aliases, nhpr->alias[4]);
            llll_appendllll(this_nh, aliases);
        }
        llll_appendllll(this_nh, symbol_and_symbol_to_llll(gensym("font"), nhpr->font));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("basept"), nhpr->base_pt));
        
        t_llll *unicode_chars = llll_get();
        llll_appendsym(unicode_chars, gensym("char"));
        llll_appendlong(unicode_chars, nhpr->unicode_character_black);
        if (nhpr->unicode_character_white != nhpr->unicode_character_black ||
            nhpr->unicode_character_whole != nhpr->unicode_character_black ||
            nhpr->unicode_character_doublewhole != nhpr->unicode_character_black) {
            llll_appendlong(unicode_chars, nhpr->unicode_character_white);
            
            if (nhpr->unicode_character_whole != nhpr->unicode_character_white ||
                nhpr->unicode_character_doublewhole != nhpr->unicode_character_white) {
                llll_appendlong(unicode_chars, nhpr->unicode_character_whole);
                
                if (nhpr->unicode_character_doublewhole != nhpr->unicode_character_whole)
                    llll_appendlong(unicode_chars, nhpr->unicode_character_doublewhole);
            }
        }
        
        llll_appendllll(this_nh, unicode_chars);
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("xshift"), nhpr->ux_shift));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("yshift"), nhpr->uy_shift));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("xshiftsmall"), nhpr->small_ux_shift));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("yshiftsmall"), nhpr->small_uy_shift));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("width"), nhpr->uwidth));
        llll_appendllll(this_nh, symbol_and_double_to_llll(gensym("dlstartxshift"), nhpr->durationline_start_ux_shift));
        
        llll_appendllll(ll, this_nh);
    }
    
    return ll;
}


// DEPRECATED: USE get_numparts_as_llll() for supported stuff
t_llll *get_parts_as_llll(t_notation_obj *r_ob)
{
    t_llll *ll = llll_get();
    llll_appendsym(ll, _llllobj_sym_parts);
    t_llll *subll = NULL;
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        if (voice->part_index == 0) {
            if (subll)
                llll_appendllll(ll, subll);
            subll = llll_get();
        }
        llll_appendlong(subll, voice->part_index + 1);
    }
    if (subll)
        llll_appendllll(ll, subll);
    
    return ll;
}


t_llll *get_numparts_as_llll(t_notation_obj *r_ob)
{
    t_llll *ll = llll_get();
    llll_appendsym(ll, _llllobj_sym_numparts);
    t_voice *voice;
    long temp_count = 1;
    for (voice = voice_get_next(r_ob, r_ob->firstvoice); voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        if (voice->part_index == 0) {
            llll_appendlong(ll, temp_count);
            temp_count = 1;
        } else
            temp_count++;
    }
    if (temp_count)
        llll_appendlong(ll, temp_count);
    
    return ll;
}




void check_alignment_points(t_alignmentpoint *firstalignmentpoint, t_alignmentpoint *lastalignmentpoint){
#ifdef CONFIGURATION_Development
    t_alignmentpoint *al;
    for (al = firstalignmentpoint; al; )
        al = al->next;
    for (al = lastalignmentpoint; al; )
        al = al->prev;
#endif
}


void tuttipoint_free_alignmentpoints(t_notation_obj *r_ob, t_tuttipoint *tpt){
    // free all the alignment points
    t_alignmentpoint *temp2, *temp1 = tpt->lastalignmentpoint; // firstalignmentpoint
    check_alignment_points(tpt->firstalignmentpoint, tpt->lastalignmentpoint);
    while (temp1) { // num_align_pt
        temp2 = temp1->prev;
        bach_freeptr(temp1);
        temp1 = temp2;
    }
    tpt->firstalignmentpoint = tpt->lastalignmentpoint = NULL;
    tpt->num_alignmentpoints = 0;
}


t_jrgba partidx_to_color(long part_idx)
{
    if (part_idx == 0)
        part_idx = CONST_NUM_PART_COLORS;

    return double_to_color(((double)part_idx - 1)/CONST_NUM_PART_COLORS, 0., 1., false);
}

void notation_obj_init(t_notation_obj *r_ob, char obj_type, rebuild_fn rebuild, notation_obj_fn whole_undo_tick, notation_obj_notation_item_fn force_notation_item_inscreen, notation_obj_undo_redo_fn undo_redo_fn, bach_paint_ext_fn paint_extended)
{
    long i;
    
    for (i = 0; i < CONST_NUM_PART_COLORS; i++)
        r_ob->part_colors[i] = partidx_to_color(i);
    
    r_ob->obj_type = obj_type;
    r_ob->bwcompatible = bach_get_current_version();

    systhread_mutex_new_debug(&r_ob->c_general_mutex, 0);
    systhread_mutex_new_debug(&r_ob->c_deparse_mutex, SYSTHREAD_MUTEX_RECURSIVE);
    systhread_mutex_new_debug(&r_ob->c_markers_mutex, 0);
    systhread_mutex_new_debug(&r_ob->c_undo_mutex, 0);
    
    // randomizing
    srand(time(NULL));

    // Inspector is bach inspector
    r_ob->m_inspector.bach_managing = true;
    
    r_ob->last_undo_marker = NULL;
    r_ob->need_send_automessage = false;
    r_ob->need_send_changed_bang = false;
    r_ob->last_event_number = -1;
    r_ob->show_ties = true;
    r_ob->show_beams = true;
    r_ob->show_flags = true;
    r_ob->show_dots = true;
    r_ob->show_stems = k_SHOW_STEMS_MAIN_AND_AUXILIARY;
    r_ob->voicenames_as_llll = get_nilnil();
    
    if (obj_type == k_NOTATION_OBJECT_ROLL) {
        r_ob->loop_region.start.position_ms = 0;
        r_ob->loop_region.end.position_ms = 1000;
        r_ob->loop_region_as_llll = llll_from_text_buf("0 1000");
    } else if (obj_type == k_NOTATION_OBJECT_SCORE) {
        r_ob->loop_region.start.timepoint = build_timepoint_with_voice(0, long2rat(0), 0);
        r_ob->loop_region.end.timepoint = build_timepoint_with_voice(1, long2rat(0), 0);
        r_ob->loop_region_as_llll = llll_from_text_buf("(1 1 0) (1 2 0)");
    } else
        r_ob->loop_region_as_llll = llll_get();
    
    
    r_ob->constraint_pitches_when_editing = llll_get();
    r_ob->stafflines_as_llll = llll_get();
    llll_appendlong(r_ob->stafflines_as_llll, 5, 0, WHITENULL_llll);
    
    r_ob->default_markername = _llllobj_sym_marker;
    r_ob->default_noteslots = llll_get();
    r_ob->default_velocity = CONST_DEFAULT_NEW_NOTE_VELOCITY;
    
    r_ob->big_time_signatures_ratio = 2.;

    r_ob->force_diatonic_step = -1;
    r_ob->linear_edit_last_inserted_dur = '4';

    r_ob->m_labels.families = llll_get();
    
    r_ob->notation_cursor.touched_measures = llll_get();
    r_ob->to_preschedule = llll_get();

    // surfaces
    r_ob->quarternotehead_surface = NULL;
    r_ob->selected_quarternotehead_surface = NULL;
    r_ob->lock_quarternotehead_surface = NULL;
    r_ob->mute_quarternotehead_surface = NULL;
    r_ob->solo_quarternotehead_surface = NULL;

    r_ob->clef_gradient_surface = NULL;
    notationobj_build_clef_gradient_surface(r_ob);
    
    // *****************
    // ALLOCATING MEMORY
    // *****************

    // Voice-related stuff
    r_ob->clefs_as_symlist = (t_symbol **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_symbol *));
    r_ob->keys_as_symlist = (t_symbol **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_symbol *));
    r_ob->hidevoices_as_charlist = (char *)bach_newptrclear(CONST_MAX_VOICES * sizeof(char));
    r_ob->midichannels_as_longlist = (long *)bach_newptrclear(CONST_MAX_VOICES * sizeof(long));
    r_ob->voiceuspacing_as_floatlist = (double *)bach_newptrclear((CONST_MAX_VOICES + 1) * sizeof(double));
    r_ob->show_measure_numbers = (char *)bach_newptrclear(CONST_MAX_VOICES * sizeof(char));
    r_ob->full_acc_repr = (t_symbol **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_symbol *));
    r_ob->chord_play_cursor = (t_chord **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_chord *));
    r_ob->tempo_play_cursor = (t_tempo **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_tempo *));
    r_ob->measure_play_cursor = (t_measure **)bach_newptrclear(CONST_MAX_VOICES * sizeof(t_measure *));
    r_ob->voice_part = (long *)bach_newptrclear(CONST_MAX_VOICES * sizeof(long));

    // Slot-related stuff
    r_ob->background_slots = (long *)bach_newptrclear(CONST_MAX_SLOTS * sizeof(long));
    r_ob->popup_menu_slots = (long *)bach_newptrclear(CONST_MAX_SLOTS * sizeof(long));
    r_ob->slotinfo = (t_slotinfo *)bach_newptrclear(CONST_MAX_SLOTS * sizeof(t_slotinfo));
    
    // Prevent-editing-related stuff
    r_ob->prevent_editing_atom = (t_atom *)bach_newptrclear((CONST_MAX_BACH_ELEMENT_TYPES + 10) * sizeof(t_atom));
    
    // Attribute manager
    r_ob->m_inspector.attr_manager = (t_bach_attr_manager *)bach_newptrclear(sizeof(t_bach_attr_manager));
    r_ob->m_inspector.owner = (t_object *)r_ob;
    
    // Obsolete stuff, kept for compatibility with old undo system
    r_ob->old_undo_llll = (t_llll **)bach_newptrclear(CONST_MAX_UNDO_STEPS * sizeof(t_llll *));
    r_ob->old_redo_llll = (t_llll **)bach_newptrclear(CONST_MAX_UNDO_STEPS * sizeof(t_llll *));
    
    
    
    // ************************
    // INITIALIZING OTHER STUFF
    // ************************
    
    for (i = 0; i < CONST_MAX_VOICES; i++)
        r_ob->full_acc_repr[i] = _llllobj_sym_default;
        
    clear_prevent_edit(&r_ob->prevent_edit);
    r_ob->num_prevent_editing_elems = 0;
    r_ob->allow_linear_edit = true;

    r_ob->onset_in_domain = 0;
    
    r_ob->rebuild_function = rebuild;
    r_ob->whole_obj_undo_tick_function = whole_undo_tick;
    r_ob->force_notation_item_inscreen = force_notation_item_inscreen;
    r_ob->undo_redo_function = undo_redo_fn;
    r_ob->paint_ext_function = paint_extended;
    
    r_ob->selected_slot_items = llll_make();
    r_ob->item_changed_at_mousedown = 0;
    r_ob->allow_undo = true;
    r_ob->firstgroup = r_ob->lastgroup = NULL;
    r_ob->num_groups = 0;

    r_ob->firstmarker = r_ob->lastmarker = NULL;
    r_ob->num_markers = 0;

    r_ob->playing = false;
    r_ob->playing_scheduling_type = k_SCHEDULING_STANDARD;
    r_ob->notes_being_played = llll_get();
    
    r_ob->inhibited_undo = false;
    r_ob->send_undo_redo_bang = true;
    r_ob->undo_llll = llll_get();
    r_ob->redo_llll = llll_get();
    r_ob->num_undo_steps = r_ob->num_redo_steps = 0;
    r_ob->undo_notation_items_under_tick = llll_get();
    r_ob->header_undo_flags = 0;
    
    r_ob->notation_cursor.measure = NULL;    // This means: NO cursor
    r_ob->notation_cursor.chord = NULL;
    r_ob->notation_cursor.midicents = 6000;
    r_ob->notation_cursor.step = 0;
    
    r_ob->output_slot_names = 0;
    r_ob->j_linear_edit_rgba = build_jrgba(0.78, 0.63, 0.04, 1);

    r_ob->slot_window_hzoom_factor = 1.;
    r_ob->slot_window_zoomed_start = 0.;

//    r_ob->firstpreselecteditem = r_ob->lastpreselecteditem = r_ob->firstselecteditem = r_ob->lastselecteditem = NULL;
    
    initialize_attr_manager(r_ob->m_inspector.attr_manager);
    r_ob->m_inspector.active_bach_inspector_item = NULL;
    r_ob->m_inspector.active_bach_inspector_obj_type = k_NONE;
    r_ob->m_inspector.active_bach_inspector_item = NULL;
    notation_obj_declare_bach_attributes(r_ob);
    r_ob->m_inspector.bach_inspector_scrollbar_pos = 0;
    r_ob->m_inspector.bach_inspector_scrollbar_delta_y = 0;
    r_ob->m_inspector.active_inspector_enumindex = NULL;
    r_ob->m_inspector.there_is_miniature_in_inspector = false;
    r_ob->m_inspector.active_inspector_miniature_rect = build_rect(0, 0, 0, 0);

    // load typographical infos
    r_ob->noteheads_font = gensym("November for bach");
    r_ob->accidentals_font = gensym("November for bach");
    r_ob->articulations_font = gensym("November for bach");
    
    load_notation_typo_preferences(r_ob, r_ob->noteheads_font);
    load_accidentals_typo_preferences(r_ob, r_ob->accidentals_font);

    r_ob->articulations_typo_preferences.num_articulations = k_NUM_STANDARD_ARTICULATIONS;
    r_ob->articulations_typo_preferences.artpref = (t_articulation_preferences *)bach_newptrclear(CONST_MAX_ARTICULATIONS * sizeof(t_articulation_preferences));
    load_articulations_typo_preferences(&r_ob->articulations_typo_preferences, r_ob->articulations_font);

    r_ob->noteheads_typo_preferences.num_noteheads = k_NUM_STANDARD_NOTEHEADS;
    r_ob->noteheads_typo_preferences.nhpref = (t_notehead_preferences *)bach_newptrclear(CONST_MAX_NOTEHEADS * sizeof(t_notehead_preferences));
    load_noteheads_typo_preferences(r_ob, r_ob->noteheads_font);

    
    
#ifdef BACH_MAX
    r_ob->n_qelem_send_rebuild_done = qelem_new_debug(r_ob, (method)do_send_rebuild_done);
#endif
    r_ob->firsttime = true;
    r_ob->tone_division = 2;
    r_ob->accidentals_display_type = k_ACCIDENTALS_CENTS; //was: k_ACCIDENTALS_CLASSICAL; but we set it at k_ACCIDENTALS_CENTS to avoid warnings at startup!

    r_ob->num_voices = 1;
    r_ob->num_voices_plus_one = 2;
    
    r_ob->show_playhead = false; // we don't show the playhead cursor;
    r_ob->play_head_start_ms = 0.; // initialize playhead cursor
    r_ob->play_head_start_ux = 0.; // idem for score
    r_ob->link_nitemcolor_to_slot = 0;
    r_ob->j_mouse_cursor = BACH_CURSOR_DEFAULT; // initial mouse cursor
    r_ob->slot_minimum_window_uwidth = 0; // no minimum
    r_ob->last_used_octave = 5; 
    r_ob->head_vertical_additional_uspace = 0.;
    r_ob->key_signature_uwidth = 0.;
    r_ob->postdomain_width = 0.;
    r_ob->there_are_voice_names = false;
    r_ob->voice_names_uwidth = 0.;
    r_ob->lambda_selected_item_ID = 0;
    r_ob->are_there_solos = false;
    r_ob->n_lexpr = NULL;
    r_ob->ruler_mode = 0; // fixed ruler
    r_ob->additional_ux_start_pad = 0.;
    r_ob->hide_tempi_when_equal_on_all_voices = 1;
    r_ob->need_send_rebuild_done_after_paint = false;
    r_ob->j_mouse_is_over = true;
    r_ob->num_selecteditems = 0;
    r_ob->is_editing_type = k_NONE;
    r_ob->is_editing_voice_name = -1;
    r_ob->only_play_selection = false;
    r_ob->automessage_ac = 0;
    r_ob->is_sending_automessage = false;
    r_ob->show_barlines = 1;
    r_ob->show_barline_locks = 1;
    r_ob->all_voices_end_together = true; //only used by score
    r_ob->vscrollbar_pixnudge = 0;
    r_ob->vscrollbar_pos = r_ob->hscrollbar_pos = 0;
    r_ob->vscrollbar_y = r_ob->hscrollbar_x = 0;
    r_ob->show_dilation_rectangle = 0;
    r_ob->num_speedy_tuplets = 0;
    r_ob->old_timepoint_syntax_bw_compatibility = false;
    r_ob->old_playout_syntax_bw_compatibility = false;
    
    r_ob->popup_voice = NULL;
    r_ob->popup_voice_clefs = NULL;
    r_ob->popup_voice_keys = NULL;
    r_ob->popup_voice_keys_major = NULL;
    r_ob->popup_voice_keys_minor = NULL;
    r_ob->popup_voice_midichannels = NULL;
    r_ob->popup_note = NULL;
    r_ob->popup_note_slots = NULL;
    r_ob->popup_note_enharmonicity = NULL;
    r_ob->popup_note_copy = r_ob->popup_note_paste = r_ob->popup_note_copy_slot = r_ob->popup_note_paste_slot = NULL;
    r_ob->popup_measure = NULL;
    r_ob->popup_measure_timesignature = NULL;
    r_ob->popup_background = NULL;
    r_ob->popup_articulations = NULL;
    r_ob->popup_barline = NULL;
    r_ob->popup_filters = NULL;
    r_ob->popup_main_font = r_ob->popup_secondary_font = NULL;

    r_ob->firstgroup = r_ob->lastgroup = NULL;
    
    r_ob->current_first_grid_ms = 0;
    r_ob->current_grid_subdivision_ms = 1000;
    r_ob->current_num_grid_subdivisions = 10;


    for (i = 0; i < CONST_MAX_SLOTS; i++)
        r_ob->slotinfo[i].slot_repr = r_ob->slotinfo[i].slot_ysnap = NULL;
    
    for (i = 0; i < CONST_MAX_VOICES; i++)
        r_ob->show_measure_numbers[i] = true;
    
    r_ob->link_vzoom_to_height = true;
    atom_setsym(&r_ob->vertical_zoom, _llllobj_sym_Auto);    

    r_ob->sampling_freq = 44100;
    r_ob->dynfilter_interp_mode = 1; // won't allow user to change!
    
    set_mousedown(r_ob, NULL, k_NONE);
    r_ob->slot_top_right_color = build_jrgba(1,0,0,1);
    
    // scrollbar
    r_ob->hscrollbar_pos = 0.;
    r_ob->hscrollbar_x = r_ob->j_inset_x;
    
    // setclock
    r_ob->setclock = gensym("");
    
    // simple hash table
    r_ob->IDtable = shashtable_new(1);
    
    // loop    region
    notation_item_init(&r_ob->loop_region.start.r_it, k_LOOP_START);
    r_ob->loop_region.start.timepoint = build_timepoint_with_voice(0, long2rat(0), 0);
    notation_item_init(&r_ob->loop_region.end.r_it, k_LOOP_END);
    r_ob->loop_region.end.timepoint = build_timepoint_with_voice(0, long2rat(0), 0);
    notation_item_init(&r_ob->loop_region.r_it, k_LOOP_REGION);
    r_ob->dont_schedule_loop_start = r_ob->dont_schedule_loop_end = false;
}


void set_mousedown(t_notation_obj *r_ob, void *item, e_element_types type, char also_set_last_fields)
{
    r_ob->j_mousedown_ptr = item;
    r_ob->j_mousedown_obj_type = type;
    
    if (also_set_last_fields) {
        r_ob->j_last_mousedown_ptr = item;
        r_ob->j_last_mousedown_obj_type = type;
    }
    
    if (r_ob->j_mousedown_obj_type == k_BACH_INSPECTOR_ITEM && r_ob->j_mousedown_ptr)
        r_ob->m_inspector.mousedown_attribute = (t_bach_attribute *)r_ob->j_mousedown_ptr;
    else
        r_ob->m_inspector.mousedown_attribute = NULL;
}


double notation_item_get_center_y(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
//        case k_NOTE: return ((t_note *)it)->center.y;
        case k_NOTE: return mc_to_yposition(r_ob, note_get_screen_midicents((t_note *)it), notation_item_get_voice(r_ob, it));
        case k_CHORD:
        {
            t_chord *ch = (t_chord *)it;
            if (ch->firstnote) {
                notation_item_get_center_y(r_ob, (t_notation_item *)ch->firstnote);
            } else {
                return mc_to_yposition(r_ob, rest_get_dummy_mc(r_ob, ch), notation_item_get_voice(r_ob, it));
            }
        }
        case k_PITCH_BREAKPOINT:
            return notation_item_get_center_y(r_ob, (t_notation_item *)((t_bpt *)it)->owner); // WRONG, TO DO
        case k_DURATION_LINE:
            return notation_item_get_center_y(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_LYRICS:
            return notation_item_get_center_y(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS:
            return notation_item_get_center_y(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_MEASURE:
            return 0;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: case k_LOOP_REGION: return 0;
        case k_LOOP_END: return 0;
        default: return 0;
    }
}

double notation_item_get_onset_ms(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return ((t_note *)it)->parent->onset;
        case k_CHORD: return ((t_chord *)it)->onset;
        case k_PITCH_BREAKPOINT: return ((t_bpt *)it)->owner->parent->onset + ((t_bpt *)it)->owner->duration * ((t_bpt *)it)->rel_x_pos;
        case k_DURATION_LINE: return ((t_duration_line *)it)->owner->parent->onset;
        case k_LYRICS: return ((t_lyrics *)it)->owner->onset;
        case k_DYNAMICS: return notation_item_get_onset_ms(r_ob, ((t_dynamics *)it)->owner_item);
        case k_MEASURE: return ((t_measure *)it)->tuttipoint_onset_ms + ((t_measure *)it)->tuttipoint_reference->onset_ms;
        case k_TEMPO: return ((t_tempo *)it)->onset;
        case k_VOICE: return 0;
        case k_MARKER:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_marker *)it)->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
                t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, (t_marker *)it);
                return timepoint_to_ms(r_ob, tp, tp.voice_num);
            } else
                return ((t_marker *)it)->position_ms;
        case k_LOOP_START: case k_LOOP_REGION: return r_ob->loop_region.start.position_ms;
        case k_LOOP_END: return r_ob->loop_region.end.position_ms;
        default: return 0;
    }
}


double notation_item_get_tail_ms(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return ((t_note *)it)->parent->onset + ((t_note *)it)->duration;
        case k_CHORD: return ((t_chord *)it)->onset + chord_get_max_duration(r_ob, (t_chord *)it);
        case k_PITCH_BREAKPOINT: return notation_item_get_onset_ms(r_ob, it);
        case k_DURATION_LINE: return ((t_duration_line *)it)->owner->parent->onset + ((t_duration_line *)it)->owner->duration;
        case k_LYRICS: return notation_item_get_onset_ms(r_ob, it);
        case k_DYNAMICS: return notation_item_get_onset_ms(r_ob, it);
        case k_MEASURE: return ((t_measure *)it)->tuttipoint_onset_ms + ((t_measure *)it)->tuttipoint_reference->onset_ms + ((t_measure *)it)->total_duration_ms;
        case k_TEMPO: return notation_item_get_onset_ms(r_ob, it);
        case k_VOICE: {
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *lastchord = chord_get_last(r_ob, (t_voice *)it);
                return lastchord ? notation_item_get_tail_ms(r_ob, (t_notation_item *)lastchord) : 0;
            } else if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
                double tail = 0;
                for (t_chord *ch = chord_get_first(r_ob, (t_voice *)it); ch; ch = ch->next) {
                    double this_ms = ch->onset + chord_get_max_duration(r_ob, ch);
                    if (this_ms > tail)
                        tail = this_ms;
                }
                return tail;
            } else
                return 0;
        }
        case k_MARKER: return notation_item_get_onset_ms(r_ob, it);
        case k_LOOP_START: return notation_item_get_onset_ms(r_ob, it);
        case k_LOOP_END: return notation_item_get_onset_ms(r_ob, it);
        case k_LOOP_REGION: return r_ob->loop_region.end.position_ms;
        default: return 0;
    }
}


/// "MORE ACCURATE VERSIONS" of the two previous functions.
/// This function is more reliable with synchronicities than notation_item_get_onset_ms,
// because it's based on rational onsets for score, hence avoiding floating point arithmetic issues
double notation_item_get_onset_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE: return notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                temp = rat_rat_sum(((t_chord *)it)->parent->tuttipoint_reference->r_onset_sec, ((t_chord *)it)->r_tuttipoint_onset_sec);
                temp.r_num *= 1000;
                return rat2double(temp);
            } else {
                return ((t_chord *)it)->onset;
            }
        case k_LYRICS: return notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_PITCH_BREAKPOINT:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *ch = ((t_bpt *)it)->owner->parent;
                temp = rat_rat_sum(ch->parent->tuttipoint_reference->r_onset_sec, ch->r_tuttipoint_onset_sec);
                temp.r_num *= 1000;
                return rat2double(temp) + rat2double(rat_long_prod(ch->r_duration_sec, 1000)) * ((t_bpt *)it)->rel_x_pos;
            } else {
                return ((t_bpt *)it)->owner->parent->onset + ((t_bpt *)it)->owner->duration * ((t_bpt *)it)->rel_x_pos;
            }
        case k_DURATION_LINE: return notation_item_get_onset_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_MEASURE:
            temp = rat_rat_sum(((t_measure *)it)->tuttipoint_reference->r_onset_sec, ((t_measure *)it)->r_tuttipoint_onset_sec);
            temp.r_num *= 1000;
            return rat2double(temp);
        case k_TEMPO:
            temp = rat_rat_sum(((t_tempo *)it)->owner->tuttipoint_reference->r_onset_sec, ((t_tempo *)it)->r_tuttipoint_onset_sec);
            temp.r_num *= 1000;
            return rat2double(temp);
        case k_VOICE: return 0;
        case k_MARKER: return ((t_marker *)it)->position_ms;
        case k_LOOP_START: case k_LOOP_REGION: return r_ob->loop_region.start.position_ms;
        case k_LOOP_END: return r_ob->loop_region.end.position_ms;
        default: return 0;
    }
}



double notation_item_get_duration_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return notation_item_get_duration_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
            else
                return ((t_note *)it)->duration;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                temp = ((t_chord *)it)->r_duration_sec;
                temp.r_num *= 1000;
                return rat2double(temp);
            } else
                return chord_get_max_duration(r_ob, (t_chord *)it);
        case k_LYRICS: return notation_item_get_duration_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_duration_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_DURATION_LINE: return notation_item_get_duration_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_PITCH_BREAKPOINT: return 0;
        case k_MEASURE:
            temp = ((t_measure *)it)->r_total_duration_sec;
            temp.r_num *= 1000;
            return rat2double(temp);
        case k_TEMPO: return 0;
        case k_VOICE: {
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *lastchord = chord_get_last(r_ob, (t_voice *)it);
                return lastchord ? notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)lastchord) : 0;
            } else
                return notation_item_get_tail_ms(r_ob, it);
        }
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return 0;
        default: return 0;
    }
}


double notation_item_get_duration_ms_for_slots_account_for_ties(t_notation_obj *r_ob, long slotnum, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE:
        {
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && r_ob->slotinfo[slotnum].slot_singleslotfortiednotes) {
                t_note *nt = (t_note *)it;
                double duration = nt->duration;
                while (nt->tie_to && nt->tie_to != WHITENULL) {
                    nt = nt->tie_to;
                    duration += nt->duration;
                }
                return duration;
            } else {
                return ((t_note *)it)->duration;
            }
        }
        case k_CHORD:
        {
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && r_ob->slotinfo[slotnum].slot_singleslotfortiednotes) {
                t_chord *ch = (t_chord *)it;
                double duration = chord_get_max_duration(r_ob, ch);
                while (ch && chord_is_all_tied_to(r_ob, ch, false, NULL)) {
                    ch = chord_get_next(ch);
                    duration += chord_get_max_duration(r_ob, ch);
                }
                return duration;
            } else {
                return chord_get_max_duration(r_ob, (t_chord *)it);
            }
        }
        case k_PITCH_BREAKPOINT: return 0;
        case k_DURATION_LINE: return notation_item_get_duration_ms_for_slots_account_for_ties(r_ob, slotnum, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return ((t_measure *)it)->total_duration_ms;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return r_ob->loop_region.end.position_ms - r_ob->loop_region.start.position_ms;
        default: return 0;
    }
}




double notation_item_get_tail_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
            else
                return ((t_note *)it)->parent->onset + ((t_note *)it)->duration;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                temp = rat_rat_sum(rat_rat_sum(((t_chord *)it)->parent->tuttipoint_reference->r_onset_sec, ((t_chord *)it)->r_tuttipoint_onset_sec),
                                   ((t_chord *)it)->r_duration_sec);
                temp.r_num *= 1000;
                return rat2double(temp);
            } else
                return ((t_chord *)it)->onset + chord_get_max_duration(r_ob, (t_chord *)it);
        case k_LYRICS: return notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_PITCH_BREAKPOINT: return notation_item_get_onset_ms_accurate(r_ob, it);
        case k_DURATION_LINE: return notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_MEASURE:
            temp = rat_rat_sum(rat_rat_sum(((t_measure *)it)->tuttipoint_reference->r_onset_sec, ((t_measure *)it)->r_tuttipoint_onset_sec), ((t_measure *)it)->r_total_duration_sec);
            temp.r_num *= 1000;
            return rat2double(temp);
        case k_TEMPO: notation_item_get_onset_ms_accurate(r_ob, it);
        case k_VOICE: {
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *lastchord = chord_get_last(r_ob, (t_voice *)it);
                return lastchord ? notation_item_get_tail_ms_accurate(r_ob, (t_notation_item *)lastchord) : 0;
            } else
                return notation_item_get_tail_ms(r_ob, it);
        }
        case k_MARKER: return notation_item_get_onset_ms_accurate(r_ob, it);
        case k_LOOP_START: return notation_item_get_onset_ms_accurate(r_ob, it);
        case k_LOOP_END: return notation_item_get_onset_ms_accurate(r_ob, it);
        case k_LOOP_REGION: return r_ob->loop_region.end.position_ms;
        default: return 0;
    }
}




/// "PLAY" version, accounting for grace notes play offsets!
double notation_item_get_play_onset_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE: return notation_item_get_play_onset_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                temp = rat_rat_sum(rat_rat_sum(((t_chord *)it)->parent->tuttipoint_reference->r_onset_sec,
                                   ((t_chord *)it)->parent->r_tuttipoint_onset_sec),
                                   ((t_chord *)it)->play_r_measure_onset_sec);
                temp.r_num *= 1000;
                return rat2double(temp);
            } else {
                return ((t_chord *)it)->onset;
            }
        case k_LYRICS: return notation_item_get_play_onset_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_play_onset_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_PITCH_BREAKPOINT:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *ch = ((t_bpt *)it)->owner->parent;
                temp = rat_rat_sum(rat_rat_sum(ch->parent->tuttipoint_reference->r_onset_sec,
                                               ch->parent->r_tuttipoint_onset_sec),
                                   ch->play_r_measure_onset_sec);
                temp.r_num *= 1000;
                return rat2double(temp) + rat2double(rat_long_prod(ch->r_duration_sec, 1000)) * ((t_bpt *)it)->rel_x_pos;
            } else {
                return ((t_bpt *)it)->owner->parent->onset + ((t_bpt *)it)->owner->duration * ((t_bpt *)it)->rel_x_pos;
            }
        case k_DURATION_LINE: return notation_item_get_play_onset_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_MEASURE:
        case k_TEMPO:
        case k_VOICE:
        case k_MARKER: 
        case k_LOOP_START:
        case k_LOOP_END:
        case k_LOOP_REGION:
            notation_item_get_onset_ms_accurate(r_ob, it);
        default: return 0;
    }
}

double notation_item_get_play_duration_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return notation_item_get_play_duration_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
            else
                return ((t_note *)it)->duration;
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                temp = ((t_chord *)it)->play_r_duration_sec;
                temp.r_num *= 1000;
                return rat2double(temp);
            } else
                return chord_get_max_duration(r_ob, (t_chord *)it);
        case k_LYRICS: return notation_item_get_play_duration_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_play_duration_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_DURATION_LINE: return notation_item_get_play_duration_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_PITCH_BREAKPOINT: return 0;
        case k_MEASURE:
        case k_TEMPO:
        case k_VOICE:
        case k_MARKER:
        case k_LOOP_START:
        case k_LOOP_END:
        case k_LOOP_REGION:
            return notation_item_get_duration_ms_accurate(r_ob, it);
        default: return 0;
    }
}


double notation_item_get_play_tail_ms_accurate(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational temp;
    switch (it->type) {
        case k_NOTE:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return notation_item_get_play_tail_ms_accurate(r_ob, (t_notation_item *)((t_note *)it)->parent);
            else
                return notation_item_get_tail_ms_accurate(r_ob, it);
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                t_chord *ch = (t_chord *)it;
                temp = rat_rat_sum(rat_rat_sum(rat_rat_sum(ch->parent->tuttipoint_reference->r_onset_sec,
                                                           ch->parent->r_tuttipoint_onset_sec),
                                               ch->play_r_measure_onset_sec),
                                   ch->play_r_duration_sec);
                temp.r_num *= 1000;
                return rat2double(temp);
            } else
                return notation_item_get_tail_ms_accurate(r_ob, it);
        case k_LYRICS: return notation_item_get_play_tail_ms_accurate(r_ob, (t_notation_item *)((t_lyrics *)it)->owner);
        case k_DYNAMICS: return notation_item_get_play_tail_ms_accurate(r_ob, (t_notation_item *)((t_dynamics *)it)->owner_item);
        case k_PITCH_BREAKPOINT: return notation_item_get_play_onset_ms_accurate(r_ob, it);
        case k_DURATION_LINE: return notation_item_get_play_tail_ms_accurate(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_MEASURE:
        case k_TEMPO:
        case k_VOICE:
        case k_MARKER:
        case k_LOOP_START:
        case k_LOOP_END:
        case k_LOOP_REGION:
            notation_item_get_tail_ms_accurate(r_ob, it);
        default: return 0;
    }
}









double notation_item_get_cents(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return ((t_note *)it)->midicents;
        case k_CHORD: return ((t_chord *)it)->firstnote ? ((t_chord *)it)->firstnote->midicents : 0;
        case k_PITCH_BREAKPOINT: return ((t_bpt *)it)->owner->midicents + ((t_bpt *)it)->delta_mc;
        case k_DURATION_LINE: return ((t_duration_line *)it)->owner->midicents;
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return 0;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return 0;
        default: return 0;
    }
}

t_pitch notation_item_get_pitch(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return note_get_pitch(r_ob, (t_note *)it);
        case k_CHORD: return ((t_chord *)it)->firstnote ? note_get_pitch(r_ob, ((t_chord *)it)->firstnote) : t_pitch::NaP;
        case k_PITCH_BREAKPOINT: return t_pitch::fromMC(((t_bpt *)it)->owner->midicents + ((t_bpt *)it)->delta_mc);
        case k_DURATION_LINE: return note_get_pitch(r_ob, ((t_duration_line *)it)->owner);
        case k_LYRICS: return t_pitch::NaP;
        case k_DYNAMICS: return t_pitch::NaP;
        case k_MEASURE: return t_pitch::NaP;
        case k_TEMPO: return t_pitch::NaP;
        case k_VOICE: return t_pitch::NaP;
        case k_MARKER: return t_pitch::NaP;
        case k_LOOP_START: return t_pitch::NaP;
        case k_LOOP_END: return t_pitch::NaP;
        case k_LOOP_REGION: return t_pitch::NaP;
        default: return t_pitch::NaP;
    }
}

void notation_item_get_poc(t_notation_obj *r_ob, t_notation_item *it, t_hatom *poc)
{
    switch (it->type) {
        case k_NOTE:
            note_get_poc(r_ob, (t_note *)it, poc);
            return;
        case k_CHORD:
            if (((t_chord *)it)->firstnote)
                note_get_poc(r_ob, ((t_chord *)it)->firstnote, poc);
            else
                hatom_setdouble(poc, 0);
            return;
        case k_PITCH_BREAKPOINT:
            hatom_setdouble(poc, ((t_bpt *)it)->owner->midicents + ((t_bpt *)it)->delta_mc);
            return;
        case k_DURATION_LINE:
            note_get_poc(r_ob, ((t_duration_line *)it)->owner, poc);
            return;
        case k_LYRICS:
        case k_DYNAMICS:
        case k_MEASURE:
        case k_TEMPO:
        case k_VOICE:
        case k_MARKER:
        case k_LOOP_START:
        case k_LOOP_END:
        case k_LOOP_REGION:
        default:
            hatom_setdouble(poc, 0);
            return;
    }
}


double notation_item_get_duration_ms(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return ((t_note *)it)->duration;
        case k_CHORD: return chord_get_max_duration(r_ob, (t_chord *)it);
        case k_PITCH_BREAKPOINT: return 0;
        case k_DURATION_LINE: return ((t_duration_line *)it)->owner->duration;
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return ((t_measure *)it)->total_duration_ms;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return r_ob->loop_region.end.position_ms - r_ob->loop_region.start.position_ms;
        default: return 0;
    }
}

t_rational notation_item_get_symonset(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational zero = long2rat(0);
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        switch (it->type) {
            case k_NOTE: return ((t_note *)it)->parent->r_sym_onset;
            case k_CHORD: return ((t_chord *)it)->r_sym_onset;
            case k_PITCH_BREAKPOINT: return zero;
            case k_DURATION_LINE: return zero;
            case k_LYRICS: return zero;
            case k_DYNAMICS: return zero;
            case k_MEASURE: return zero;
            case k_TEMPO: return ((t_tempo *)it)->changepoint;
            case k_VOICE: return zero;
            case k_MARKER: 
                if (((t_marker *)it)->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
                    t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, (t_marker *)it);
                    return tp.pt_in_measure;
                } else
                    return zero;
            case k_LOOP_START: return r_ob->loop_region.start.timepoint.pt_in_measure;
            case k_LOOP_END: return r_ob->loop_region.end.timepoint.pt_in_measure;
            case k_LOOP_REGION: return r_ob->loop_region.start.timepoint.pt_in_measure;
            default: return zero;
        }
    } else
        return zero;
}

t_rational notation_item_get_symduration(t_notation_obj *r_ob, t_notation_item *it)
{
    t_rational zero = long2rat(0);
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        switch (it->type) {
            case k_NOTE: return ((t_note *)it)->parent->r_sym_duration;
            case k_CHORD: return rat_abs(((t_chord *)it)->r_sym_duration);
            case k_PITCH_BREAKPOINT: return zero;
            case k_DURATION_LINE: return zero;
            case k_LYRICS: return zero;
            case k_DYNAMICS: return zero;
            case k_MEASURE: return zero;
            case k_TEMPO: return zero;
            case k_VOICE: return zero;
            case k_MARKER: return zero;
            case k_LOOP_START: return zero;
            case k_LOOP_END: return zero;
            case k_LOOP_REGION: {
                t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, r_ob->loop_region.start.timepoint.voice_num);
                if (voice)
                    return get_sym_durations_between_timepoints(voice, r_ob->loop_region.start.timepoint, r_ob->loop_region.end.timepoint);
                else
                    return zero;
            }
            default: return zero;
        }
    } else
        return zero;
}

t_voice *notation_item_get_voice(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return notation_item_get_voice(r_ob, (t_notation_item *)(((t_note *)it)->parent));
        case k_CHORD:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return (t_voice *)(((t_chord *)it)->parent->voiceparent);
            else
                return (t_voice *)(((t_chord *)it)->voiceparent);
        case k_PITCH_BREAKPOINT: return notation_item_get_voice(r_ob, (t_notation_item *)(((t_bpt *)it)->owner));
        case k_DURATION_LINE: return notation_item_get_voice(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner));
        case k_LYRICS: return notation_item_get_voice(r_ob, (t_notation_item *)(((t_lyrics *)it)->owner));
        case k_DYNAMICS: return notation_item_get_voice(r_ob, (t_notation_item *)(((t_dynamics *)it)->owner_item));
        case k_MEASURE: return (t_voice *)(((t_measure *)it)->voiceparent);
        case k_TEMPO: return (t_voice *)(((t_tempo *)it)->owner->voiceparent);
        case k_VOICE: return ((t_voice *)it);
        case k_MARKER:
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_marker *)it)->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
                t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, (t_marker *)it);
                return nth_voice(r_ob, tp.voice_num);
            } else
                return NULL;
        case k_LOOP_START: return NULL;
        case k_LOOP_END: return NULL;
        case k_LOOP_REGION: return NULL;
        default: return NULL;
    }
}


long notation_item_get_voicenumber(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_note *)it)->parent));
        case k_CHORD: 
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                return ((t_chord *)it)->parent->voiceparent->v_ob.number;
            else
                return ((t_chord *)it)->voiceparent->v_ob.number;
        case k_PITCH_BREAKPOINT: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_bpt *)it)->owner));
        case k_DURATION_LINE: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner));
        case k_LYRICS: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_lyrics *)it)->owner));
        case k_DYNAMICS: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_dynamics *)it)->owner_item));
        case k_MEASURE: return ((t_measure *)it)->voiceparent->v_ob.number;
        case k_TEMPO: return ((t_tempo *)it)->owner->voiceparent->v_ob.number;
        case k_VOICE: return ((t_voice *)it)->number;
        case k_MARKER: 
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_marker *)it)->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
                t_timepoint tp = measure_attached_marker_to_timepoint(r_ob, (t_marker *)it);
                return tp.voice_num;
            } else
                return -1;
        case k_LOOP_START: return -1;
        case k_LOOP_END: return -1;
        case k_LOOP_REGION: return -1;
        default: return -1;
    }
}

long notation_item_get_partnumber(t_notation_obj *r_ob, t_notation_item *it)
{
    t_voice *voice = notation_item_get_voice(r_ob, it);
    if (voice)
        return voice->part_index;
    else
        return -1;
}

long notation_item_get_voiceensemble(t_notation_obj *r_ob, t_notation_item *it)
{
    t_voice *voice = notation_item_get_voice(r_ob, it);
    if (voice)
        return voice->voiceensemble_index;
    else
        return -1;
}

// 0-based!!!
long notation_item_get_measurenumber(t_notation_obj *r_ob, t_notation_item *it)
{
    if (r_ob->obj_type != k_NOTATION_OBJECT_SCORE)
        return -1;
    
    switch (it->type) {
        case k_NOTE: return notation_item_get_measurenumber(r_ob, (t_notation_item *)(((t_note *)it)->parent->parent));
        case k_CHORD: return notation_item_get_measurenumber(r_ob, (t_notation_item *)(((t_chord *)it)->parent));
        case k_PITCH_BREAKPOINT: return notation_item_get_measurenumber(r_ob, (t_notation_item *)(((t_bpt *)it)->owner->parent->parent));
        case k_DURATION_LINE: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner->parent->parent));
        case k_LYRICS: return notation_item_get_voicenumber(r_ob, (t_notation_item *)(((t_lyrics *)it)->owner->parent));
        case k_DYNAMICS: return notation_item_get_voicenumber(r_ob, notation_item_get_ancestor_of_at_least_a_certain_type(r_ob, ((t_dynamics *)it)->owner_item, k_MEASURE));
        case k_MEASURE: {
            t_measure *meas = (t_measure *)it;
            return meas->force_measure_number ? meas->forced_measure_number : meas->measure_number;
         }
        case k_TEMPO: return notation_item_get_measurenumber(r_ob, (t_notation_item *)(((t_tempo *)it)->owner));
        case k_VOICE: return -1;
        case k_MARKER: 
            if (((t_marker *)it)->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
                t_measure *meas = (t_measure *)notation_item_retrieve_from_ID(r_ob, ((t_marker *)it)->measure_attach_ID);
                if (meas)
                    return notation_item_get_measurenumber(r_ob, (t_notation_item *)meas);
                else
                    return -1;
            } else
                return -1;
        case k_LOOP_REGION:
        case k_LOOP_START: {
            t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, r_ob->loop_region.start.timepoint.voice_num);
            if (voice) {
                t_measure *meas = (t_measure *)nth_measure_of_scorevoice(voice, r_ob->loop_region.start.timepoint.measure_num);
                if (meas) 
                    return notation_item_get_measurenumber(r_ob, (t_notation_item *)meas);
            }
            return -1;
        }
        case k_LOOP_END: {
            t_scorevoice *voice = (t_scorevoice *)nth_voice(r_ob, r_ob->loop_region.end.timepoint.voice_num);
            if (voice) {
                t_measure *meas = (t_measure *)nth_measure_of_scorevoice(voice, r_ob->loop_region.end.timepoint.measure_num);
                if (meas) 
                    return notation_item_get_measurenumber(r_ob, (t_notation_item *)meas);
            }
            return -1;
        }
        default: return -1;
    }
}

long notation_item_get_tie_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    if (r_ob->obj_type != k_NOTATION_OBJECT_SCORE)
        return 0;
    
    switch (it->type) {
        case k_NOTE: return (((t_note *)it)->tie_to != NULL) * 1 + (((t_note *)it)->tie_from != NULL) * 2;
        case k_CHORD: return chord_is_all_tied_to(r_ob, (t_chord *) it, false, NULL) * 1 + chord_is_all_tied_from((t_chord *) it, false) * 2;
        case k_PITCH_BREAKPOINT: return 0;
        case k_DURATION_LINE: return notation_item_get_tie_for_lexpr(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner));
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return 0;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return 0;
        default: return 0;
    }
}

long notation_item_get_noteindex_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return note_get_position(r_ob, (t_note *)it);
        case k_DURATION_LINE: return notation_item_get_noteindex_for_lexpr(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner));
        case k_PITCH_BREAKPOINT: return notation_item_get_noteindex_for_lexpr(r_ob, (t_notation_item *)((t_bpt *)it)->owner);
        default: return 0;
    }
}

long notation_item_get_chordindex_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_CHORD: return chord_get_position(r_ob, (t_chord *)it);
        case k_NOTE: return notation_item_get_chordindex_for_lexpr(r_ob, (t_notation_item *)(((t_note *)it)->parent));
        case k_LYRICS: return notation_item_get_chordindex_for_lexpr(r_ob, (t_notation_item *)(((t_lyrics *)it)->owner));
        case k_DYNAMICS: return notation_item_get_chordindex_for_lexpr(r_ob, (t_notation_item *)notation_item_get_parent_chord(r_ob, ((t_dynamics *)it)->owner_item));
        case k_DURATION_LINE: return notation_item_get_chordindex_for_lexpr(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner->parent));
        case k_PITCH_BREAKPOINT: return notation_item_get_chordindex_for_lexpr(r_ob, (t_notation_item *)((t_bpt *)it)->owner);
        default: return 0;
    }
}

long notation_item_get_breakpointindex_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_PITCH_BREAKPOINT: return get_breakpoint_position(r_ob, (t_bpt *)it) - 1;
        default: return 0;
    }
}

t_symbol *notation_item_get_role_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_MARKER: return marker_role_to_sym(((t_marker *)it)->role);
        default: return _llllobj_sym_none;
    }
}


long notation_item_get_index_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return note_get_position(r_ob, (t_note *)it);
        case k_CHORD: return chord_get_position(r_ob, (t_chord *)it);
        case k_PITCH_BREAKPOINT: return get_breakpoint_position(r_ob, ((t_bpt *)it)) - 1;
        case k_DURATION_LINE: return notation_item_get_index_for_lexpr(r_ob, (t_notation_item *)(((t_duration_line *)it)->owner));
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return ((t_measure *)it)->measure_number + 1;
        case k_TEMPO: return get_tempo_position(r_ob, (t_tempo *)it);
        case k_VOICE: return ((t_voice *)it)->number + 1;
        case k_MARKER: return get_marker_position(r_ob, ((t_marker *)it));
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return 0;
        default: return 0;
    }
}

long notation_item_get_grace_for_lexpr(t_notation_obj *r_ob, t_notation_item *it)
{
    switch (it->type) {
        case k_NOTE: return notation_item_get_grace_for_lexpr(r_ob, (t_notation_item *)((t_note *)it)->parent);
        case k_CHORD: return (((t_chord *)it)->is_score_chord && ((t_chord *)it)->is_grace_chord ? 1 : 0);
        case k_PITCH_BREAKPOINT: return notation_item_get_grace_for_lexpr(r_ob, (t_notation_item *)((t_bpt *)it)->owner);
        case k_DURATION_LINE: return notation_item_get_grace_for_lexpr(r_ob, (t_notation_item *)((t_duration_line *)it)->owner);
        case k_LYRICS: return 0;
        case k_DYNAMICS: return 0;
        case k_MEASURE: return 0;
        case k_TEMPO: return 0;
        case k_VOICE: return 0;
        case k_MARKER: return 0;
        case k_LOOP_START: return 0;
        case k_LOOP_END: return 0;
        case k_LOOP_REGION: return 0;
        default: return 0;
    }
}


t_marker *measure_get_first_marker(t_notation_obj *r_ob, t_measure *meas)
{
    for (t_marker *mk = r_ob->firstmarker; mk; mk = mk->next) {
        if (mk->attach_to == k_MARKER_ATTACH_TO_MEASURE && mk->measure_attach_ID == meas->r_it.ID)
            return mk;
    }
    return NULL;
}

t_marker *voice_get_first_marker(t_notation_obj *r_ob, t_voice *voice)
{
    for (t_marker *mk = r_ob->firstmarker; mk; mk = mk->next) {
        if (mk->attach_to == k_MARKER_ATTACH_TO_MEASURE) {
            t_measure *meas = (t_measure *)notation_item_retrieve_from_ID(r_ob, mk->measure_attach_ID);
            if (meas && meas->voiceparent && (t_voice *)meas->voiceparent == voice)
                return mk;
        }
    }
    return NULL;
}

t_tempo *voice_get_first_tempo(t_notation_obj *r_ob, t_voice *voice)
{
    for (t_measure *meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) {
        if (meas->firsttempo)
            return meas->firsttempo;
    }
    return NULL;
}

t_chord *voice_get_first_chord(t_notation_obj *r_ob, t_voice *voice)
{
    for (t_measure *meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) {
        if (meas->firstchord)
            return meas->firstchord;
    }
    return NULL;
}

t_chord *voice_get_last_chord(t_notation_obj *r_ob, t_voice *voice)
{
    for (t_measure *meas = ((t_scorevoice *)voice)->lastmeasure; meas; meas = meas->prev) {
        if (meas->lastchord)
            return meas->lastchord;
    }
    return NULL;
}

t_notation_item *notation_item_cast(t_notation_obj *r_ob, t_notation_item *nitem, e_element_types new_type, char also_cast_downwards)
{
    if (new_type == nitem->type)
        return nitem; // nothing need for casting
    
    if (!nitem)
        return NULL;
    
    switch (nitem->type) {
        case k_NOTE:
            switch (new_type) {
                case k_CHORD: return (t_notation_item *)((t_note *)nitem)->parent;
                case k_MEASURE: return (t_notation_item *)((t_note *)nitem)->parent->parent;
                case k_VOICE: return (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? (t_notation_item *)((t_note *)nitem)->parent->parent->voiceparent : (t_notation_item *)((t_note *)nitem)->parent->voiceparent);
                case k_PITCH_BREAKPOINT: return also_cast_downwards ? (t_notation_item *)((t_note *)nitem)->firstbreakpoint : NULL;
                case k_DURATION_LINE: return (t_notation_item *)((t_note *)nitem)->durationline;
                default: return NULL;
            }
            break;
            
        case k_PITCH_BREAKPOINT:
            switch (new_type) {
                case k_NOTE: return (t_notation_item *)((t_bpt *)nitem)->owner;
                case k_CHORD: return (t_notation_item *)((t_bpt *)nitem)->owner->parent;
                case k_MEASURE: return (t_notation_item *)((t_bpt *)nitem)->owner->parent->parent;
                case k_VOICE: return (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? (t_notation_item *)((t_bpt *)nitem)->owner->parent->parent->voiceparent : (t_notation_item *)((t_bpt *)nitem)->owner->parent->voiceparent);
                case k_DURATION_LINE: return (t_notation_item *)((t_bpt *)nitem)->owner->durationline;
                default: return NULL;
            }
            break;
            
        case k_CHORD:
            switch (new_type) {
                case k_NOTE: return also_cast_downwards ? (t_notation_item *)((t_chord *)nitem)->firstnote : NULL;
                case k_MEASURE: return (t_notation_item *)((t_chord *)nitem)->parent;
                case k_VOICE: return (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? (t_notation_item *)((t_chord *)nitem)->parent->voiceparent : (t_notation_item *)((t_chord *)nitem)->voiceparent);
                case k_PITCH_BREAKPOINT: return also_cast_downwards && ((t_chord *)nitem)->firstnote ? (t_notation_item *)((t_chord *)nitem)->firstnote->firstbreakpoint : NULL;
                case k_DURATION_LINE: return also_cast_downwards && ((t_chord *)nitem)->firstnote ? (t_notation_item *)((t_chord *)nitem)->firstnote->durationline : NULL;
                default: return NULL;
            }
            break;

        case k_MEASURE:
            switch (new_type) {
                case k_NOTE:
                case k_PITCH_BREAKPOINT:
                case k_DURATION_LINE:
                {
                    t_measure *meas = (t_measure *)nitem;
                    t_chord *ch = meas->firstchord;
                    if (!ch->firstnote)
                        ch = chord_get_next_nonrest(ch);
                    if (ch->parent != meas)
                        ch = NULL;
                    if (new_type == k_NOTE)
                        return also_cast_downwards && ch ? (t_notation_item *)ch->firstnote : NULL;
                    else
                        notation_item_cast(r_ob, (t_notation_item *)ch->firstnote, new_type, also_cast_downwards);
                }
                case k_CHORD: return also_cast_downwards ? (t_notation_item *)((t_measure *)nitem)->firstchord : NULL;
                case k_VOICE: return (t_notation_item *)((t_measure *)nitem)->voiceparent;
                case k_TEMPO: return also_cast_downwards ? (t_notation_item *)((t_measure *)nitem)->firsttempo : NULL;
                case k_MARKER: return also_cast_downwards ? (t_notation_item *)measure_get_first_marker(r_ob, (t_measure *)nitem) : NULL;
                default: return NULL;
            }
            break;

        case k_VOICE:
            switch (new_type) {
                case k_NOTE:
                case k_PITCH_BREAKPOINT:
                case k_DURATION_LINE:
                {
                    t_chord *ch = voice_get_first_chord(r_ob, (t_voice *)nitem);
                    if (!ch->firstnote)
                        ch = chord_get_next_nonrest(ch);
                    if (new_type == k_NOTE)
                        return also_cast_downwards && ch ? (t_notation_item *)ch->firstnote : NULL;
                    else
                        notation_item_cast(r_ob, (t_notation_item *)ch->firstnote, new_type, also_cast_downwards);
                }
                case k_CHORD: return also_cast_downwards ? (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? (t_notation_item *)voice_get_first_chord(r_ob, (t_voice *)nitem) : (t_notation_item *)((t_rollvoice *)nitem)->firstchord) : NULL;
                case k_MEASURE: return r_ob->obj_type == k_NOTATION_OBJECT_SCORE && also_cast_downwards ? (t_notation_item *)((t_scorevoice *)nitem)->firstmeasure : NULL;
                case k_TEMPO: return r_ob->obj_type == k_NOTATION_OBJECT_SCORE && also_cast_downwards ? (t_notation_item *)voice_get_first_tempo(r_ob, (t_voice *)nitem) : NULL;
                case k_MARKER: return r_ob->obj_type == k_NOTATION_OBJECT_SCORE && also_cast_downwards ? (t_notation_item *)voice_get_first_marker(r_ob, (t_voice *)nitem) : NULL;
                default: return NULL;
            }
            break;
            
            
        default:
            return NULL;
            break;
    }
}




// *************
// OBJECT NAMES
// *************

void notation_item_set_names_from_llll(t_notation_obj *r_ob, t_notation_item *it, t_llll *ll)
{
    change_notation_item_names(r_ob, it, ll, false);
    
}

t_llll *get_names_from_llll(t_notation_obj *r_ob, t_llll *ll)
{
    return llll_clone(ll);
}

t_llll *get_names_from_llllelem(t_notation_obj *r_ob, t_llllelem *llelem)
{
    t_llll *out_ll;
    if (hatom_gettype(&llelem->l_hatom) == H_LLLL) 
        out_ll = llll_clone(hatom_getllll(&llelem->l_hatom));
    else {
        out_ll = llll_get();
        llll_appendhatom_clone(out_ll, &llelem->l_hatom, 0, WHITENULL_llll);
    }
    return out_ll;
}


void notation_item_set_names_from_llllelem(t_notation_obj *r_ob, t_notation_item *it, t_llllelem *llelem)
{
    llll_free(it->names);

    if (!llelem) {
        it->names = llll_get();
    } else if (hatom_gettype(&llelem->l_hatom) == H_LLLL) {
        notation_item_set_names_from_llll(r_ob, it, hatom_getllll(&llelem->l_hatom));
    } else if (is_hatom_number(&llelem->l_hatom)) {
        it->names = llll_get();
        llll_appendlong(it->names, hatom_getlong(&llelem->l_hatom), 0, WHITENULL_llll);
    } else if (hatom_gettype(&llelem->l_hatom) == H_SYM) {
        it->names = llll_get();
        llll_appendsym(it->names, hatom_getsym(&llelem->l_hatom), 0, WHITENULL_llll);
    } else {
        it->names = llll_get();
    }    
}

// destructive
void notation_item_find_and_set_names(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll)
{
    t_llllelem *elem = llll->l_tail;
    t_llll *ll;
    while (elem) { 
        t_llllelem *next = elem->l_prev;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom))->l_head && 
            hatom_gettype(&ll->l_head->l_hatom) == H_SYM && hatom_getsym(&ll->l_head->l_hatom) == _llllobj_sym_name){
            if (ll->l_head->l_next) {
                llll_destroyelem(ll->l_head);
                notation_item_set_names_from_llll(r_ob, it, ll);
            } else {
                llll_free(it->names);
                it->names = llll_get();
            }
            llll_destroyelem(elem);
            break;
        }
        elem = next;
    } 
}

void notation_item_find_and_set_flags(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll)
{
    t_llllelem *elem = llll->l_tail;
    t_llll *ll;
    while (elem) {
        t_llllelem *next = elem->l_prev;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom))->l_head &&
            hatom_gettype(&ll->l_head->l_hatom) == H_SYM && hatom_getsym(&ll->l_head->l_hatom) == _llllobj_sym_flags){
            if (ll->l_head->l_next) {
                llll_destroyelem(ll->l_head);
                notation_item_set_flags_from_llllelem(r_ob, ll->l_head, it, true);
            } else {
                it->flags = 0;
            }
            llll_destroyelem(elem);
            break;
        }
        elem = next;
    } 
}

void notation_item_find_and_set_names_and_flags(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll)
{
    t_llllelem *elem = llll->l_tail;
    t_llll *ll;
    char names_found = false, flags_found = false;
    while (elem) {
        t_llllelem *next = elem->l_prev;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom))->l_head &&
            hatom_gettype(&ll->l_head->l_hatom) == H_SYM) {
            t_symbol *sym = hatom_getsym(&ll->l_head->l_hatom);
            if (sym == _llllobj_sym_name) {
                if (ll->l_head->l_next) {
                    llll_destroyelem(ll->l_head);
                    notation_item_set_names_from_llll(r_ob, it, ll);
                } else {
                    llll_free(it->names);
                    it->names = llll_get();
                }
                llll_destroyelem(elem);
                if (flags_found)
                    break;
            } else if (sym == _llllobj_sym_flags) {
                if (ll->l_head->l_next) {
                    llll_destroyelem(ll->l_head);
                    notation_item_set_flags_from_llllelem(r_ob, ll->l_head, it, true);
                } else {
                    it->flags = 0;
                }
                llll_destroyelem(elem);
                if (names_found)
                    break;
            }
        }
        elem = next;
    }
}




char are_names_equal(t_llll *names1, t_llll *names2)
{
    return llll_eq_ignoretype(names1, names2);
//    return are_atomarrays_equal(name1, size1, name2, size2);
//    return are_atoms_equal(name1, name2);
//    return name1 == name2;
}

long is_name_contained_fn(t_hatom *h, t_llll *what)
{
    return is_hatom_in_llll_root_level(h, what);
}

char is_name_contained(t_hatom *contained, t_llll *container) 
{
    char res = 0;
  
    if (!container)
        return 0;
    
    res = is_hatom_in_llll_root_level(contained, container);
 
/*    
    const long BACH_NAME_MATCHING_MAXIDX = -1;
    t_llll *dummy = llll_find(container, NULL, 1, 1, -1, 1, BACH_NAME_MATCHING_MAXIDX, 0, 0, 1, 1, 0, 1, 1, (find_fn) is_name_contained_fn, contained);
    if (dummy && dummy->l_size > 0)
        res = 1;
    llll_free(dummy);  */
    return res;
}

char are_all_names_contained(t_llll *names, t_llll *container)
{
    t_llllelem *elem;
    for (elem = names->l_head; elem; elem = elem->l_next)
        if (!is_name_contained(&elem->l_hatom, container))
            return 0;
    return 1;
}

long preselect_notation_items_by_name(t_notation_obj *r_ob, t_llll *names)
{
    t_llllelem *elem;
    t_llll *items = notationobj_names_to_notation_items(r_ob, names);
    for (elem = items->l_head; elem; elem = elem->l_next)
        notation_item_add_to_preselection(r_ob, (t_notation_item *)hatom_getobj(&elem->l_hatom));
    long num_found_elems = items->l_size;
    llll_free(items);
    return num_found_elems;
}

// Will be replaced eventually by a hashtable search
long notationobj_name_is_used(t_notation_obj *r_ob, t_hatom *name)
{
    t_llllelem *elem;
    for (elem = r_ob->m_labels.families->l_head; elem; elem = elem->l_next) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
        if (is_name_contained(name, fam->label))
            return 1;
    }
    return 0;
}


// Will be replaced eventually by a hashtable search
t_llll *notationobj_name_to_label_families_and_items(t_notation_obj *r_ob, t_hatom *name, t_llll **items)
{
    t_llllelem *elem;
    t_llll *out = llll_get();
    if (items) *items = llll_get();
    for (elem = r_ob->m_labels.families->l_head; elem; elem = elem->l_next) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
        if (is_name_contained(name, fam->label)) {
            llll_appendobj(out, fam, 0, WHITENULL_llll);
            if (items) llll_chain_clone(*items, fam->items);
        }
    }
    if (items) *items = llll_thin_simple(*items, true);
    return out;
}


// returns the number of found elements having as name all the names
// Will be replaced eventually by a hashtable search
// Returns an llll containing a list of H_OBJs (one for each notation item).
t_llll *notationobj_names_to_notation_items(t_notation_obj *r_ob, t_llll *names)
{
    if (!names->l_head)
        return llll_get();
    
    // first, we handle the first name
    t_llll *items = NULL;
    t_llllelem *names_el = names->l_head;
    t_llll *families = notationobj_name_to_label_families_and_items(r_ob, &names_el->l_hatom, &items);
    
    // then we sieve the family of items depending on other names
    for (names_el = names->l_head->l_next; names_el; names_el = names_el->l_next) {
        t_llll *this_items = NULL;
        t_llll *this_families = notationobj_name_to_label_families_and_items(r_ob, &names_el->l_hatom, &this_items);
        llll_intersection(items, this_items);
        llll_free(this_families);
    }

    llll_free(families);
    return items;
}

/*
long notationobj_names_to_notation_items(t_notation_obj *r_ob, t_llll *names, t_notation_item ***found_elems){
    long num_found = 0;
    t_marker *marker;
    const long MAX_SELECTABLE_ITEMS = 100000; // very dirty way!!! TO DO: change it
     
    if (found_elems) {
        
        *found_elems = (t_notation_item **) bach_newptr(MAX_SELECTABLE_ITEMS * sizeof (t_notation_item *));
        num_found = 0;
        
        t_voice *voice; t_measure *meas; t_chord *chord; t_note *note;
        for (voice = r_ob->firstvoice; voice && (voice->number < r_ob->num_voices) && num_found < MAX_SELECTABLE_ITEMS - 1; voice = voice_get_next(r_ob, voice)) {
            if (are_all_names_contained(names, voice->r_it.names) && num_found < MAX_SELECTABLE_ITEMS) {
                num_found++;
                (*found_elems)[num_found - 1] = (t_notation_item *)voice;
            }
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) {
                    if (are_all_names_contained(names, meas->r_it.names) && num_found < MAX_SELECTABLE_ITEMS) {
                        num_found++;
                        (*found_elems)[num_found - 1] = (t_notation_item *)meas;
                    }
                } 
            }
            for (chord = (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? ((t_scorevoice *)voice)->firstmeasure->firstchord : ((t_rollvoice *)voice)->firstchord); 
                chord; chord = chord_get_next(chord)) {
                if (are_all_names_contained(names, chord->r_it.names) && num_found < MAX_SELECTABLE_ITEMS) {
                    num_found++;
                    (*found_elems)[num_found - 1] = (t_notation_item *)chord;
                }
                for (note = chord->firstnote; note; note = note->next) {
                    if (are_all_names_contained(names, note->r_it.names) && num_found < MAX_SELECTABLE_ITEMS) {
                        num_found++;
                        (*found_elems)[num_found - 1] = (t_notation_item *)note;
                    }
                }
            }
        }
        
        if (r_ob->firstmarker) {
            for (marker = r_ob->firstmarker; marker; marker = marker->next){
                if (are_all_names_contained(names, marker->r_it.names) && num_found < MAX_SELECTABLE_ITEMS) {
                    num_found++;
                    (*found_elems)[num_found - 1] = (t_notation_item *)marker;
                }
            }
        }
    }
    return num_found;
}
*/

char notation_item_is_in_label_family(t_notation_item *item, t_bach_label_family *fam)
{
    t_llllelem *elem;
    for (elem = item->label_families->l_head; elem; elem = elem->l_next) {
        if (hatom_getobj(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == fam)
            return true;
    }
    return false;
}


void free_label_family(t_bach_label_family *fam)
{
    t_llllelem *itelem;
    for (itelem = fam->items->l_head; itelem; itelem = itelem->l_next){
        t_notation_item *it = (t_notation_item *)hatom_getobj(&itelem->l_hatom);
        if (it->label_families && it->label_families->l_size > 0)
            llll_clear(it->label_families);
    }
    llll_free(fam->label);
    llll_free(fam->items);
    beziercs_free(fam->contour);
    bach_freeptr(fam);
}


double note_get_center_ux(t_notation_obj *r_ob, t_note *nt)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        double al_ux = chord_get_alignment_ux(r_ob, nt->parent);
        double stem_x = get_stem_x_from_alignment_point_x(r_ob, nt->parent, al_ux * r_ob->zoom_x * r_ob->zoom_y);
        double note_x = stem_x + nt->notecenter_stem_delta_ux * r_ob->zoom_y;
        return note_x / (r_ob->zoom_x * r_ob->zoom_y);
    } else {
        double al_ux = chord_get_alignment_ux(r_ob, nt->parent);
        double delta_ux_stem = (nt->parent->stem_offset_ux + nt->parent->parent->tuttipoint_reference->offset_ux) - al_ux;
        return al_ux + (delta_ux_stem + nt->notecenter_stem_delta_ux)/r_ob->zoom_x;
    }
    return 0;
}



t_pt note_to_family_contour_pt(t_notation_obj *r_ob, t_note *nt, double *leftmost_in, double *rightmost_in, long *topmost_voice, long *bottommost_voice)
{
    t_pt center = build_pt(note_get_center_ux(r_ob, nt),
                      mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(nt), chord_get_voice(r_ob, nt->parent)));
 
    if (leftmost_in && (center.x < *leftmost_in || *leftmost_in == -100000))
        *leftmost_in = center.x;
    if (rightmost_in && (center.x > *rightmost_in || *rightmost_in == -100000))
        *rightmost_in = center.x;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL || r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (bottommost_voice && ((r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? nt->parent->voiceparent->v_ob.number : nt->parent->parent->voiceparent->v_ob.number) > *bottommost_voice || *bottommost_voice == -100000))
            *bottommost_voice = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? nt->parent->voiceparent->v_ob.number : nt->parent->parent->voiceparent->v_ob.number);
        if (topmost_voice && ((r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? nt->parent->voiceparent->v_ob.number : nt->parent->parent->voiceparent->v_ob.number) < *topmost_voice || *topmost_voice == -100000))
            *topmost_voice = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? nt->parent->voiceparent->v_ob.number : nt->parent->parent->voiceparent->v_ob.number);
    }
    
    return center;
}

t_llll *note_to_family_contour_pts(t_notation_obj *r_ob, t_note *nt)
{
    t_pt center = build_pt(note_get_center_ux(r_ob, nt),
                      mc_to_yposition_in_scale(r_ob, note_get_screen_midicents(nt), chord_get_voice(r_ob, nt->parent)));

    t_pt left = center, right = center, top = center, bottom = center;

    double nhuw = (notehead_get_uwidth(r_ob, nt->parent->r_sym_duration, nt, true)/r_ob->zoom_x) * 0.8;
    double nhuh = r_ob->step_y / (r_ob->zoom_y * r_ob->zoom_x);
    left.x -= nhuw;
    right.x += nhuw;
    top.x -= nhuh;
    bottom.x += nhuh;
    
    t_llll *ll = llll_get();
    llll_appendllll(ll, pt_to_llll(center, false));
    llll_appendllll(ll, pt_to_llll(left, false));
    llll_appendllll(ll, pt_to_llll(right, false));
    llll_appendllll(ll, pt_to_llll(top, false));
    llll_appendllll(ll, pt_to_llll(bottom, false));

    return ll;
}


t_pt rest_to_family_contour_pt(t_notation_obj *r_ob, t_chord *ch, double *leftmost_in, double *rightmost_in, long *topmost_voice, long *bottommost_voice)
{
    t_pt center = build_pt(0, 0);
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        double center_x = ch->stem_offset_ux + ch->parent->tuttipoint_reference->offset_ux;
        double center_y = rest_get_nonfloating_yposition(r_ob, ch, NULL, NULL) - ch->float_steps * r_ob->step_y;
        center = build_pt(center_x, center_y);
    }
    
    if (leftmost_in && (center.x < *leftmost_in || *leftmost_in == -100000))
        *leftmost_in = center.x;
    if (rightmost_in && (center.x > *rightmost_in || *rightmost_in == -100000))
        *rightmost_in = center.x;
    
    if (bottommost_voice && (ch->parent->voiceparent->v_ob.number > *bottommost_voice || *bottommost_voice == -100000))
        *bottommost_voice = ch->parent->voiceparent->v_ob.number;
    if (topmost_voice && (ch->parent->voiceparent->v_ob.number < *topmost_voice || *topmost_voice == -100000))
        *topmost_voice = ch->parent->voiceparent->v_ob.number;
    
    return center;
}

// g is for DEBUG ONLY
void update_label_family_contour(t_notation_obj *r_ob, t_bach_label_family *fam, t_jgraphics* g)
{
    if (!fam->items->l_head) {
        beziercs_free(fam->contour);
        fam->contour = beziercs_build(0, NULL, NULL, NULL);
        return;
    }
        
    t_llllelem *itel;
    t_llll *points_in = llll_get(); // points which should be taken inside the venn closed curve
    t_llll *points_out = llll_get(); // points which should be taken inside the venn closed curve
    
    
    double leftmost_in_ux = -100000, rightmost_in_ux = -100000;
    long topmost_voice = -100000, bottommost_voice = -100000;
    
    for (itel = fam->items->l_head; itel; itel = itel->l_next) {
        t_notation_item *it = (t_notation_item *)hatom_getobj(&itel->l_hatom);
        t_notation_item *voice = notation_item_get_ancestor_of_at_least_a_certain_type(r_ob, it, k_VOICE);
        
        if (voice && ((t_voice *)voice)->hidden)
            continue;
        
        switch (it->type) {
            case k_NOTE:
                llll_appendllll(points_in, pt_to_llll(note_to_family_contour_pt(r_ob, (t_note *)it, &leftmost_in_ux, &rightmost_in_ux, &topmost_voice, &bottommost_voice), false), 0, WHITENULL_llll);
                break;
            case k_CHORD:
            {
                t_chord *ch = (t_chord *)it;
                if (ch->firstnote) {
                    t_note *nt;
                    for (nt = ch->firstnote; nt; nt = nt->next) 
                        llll_appendllll(points_in, pt_to_llll(note_to_family_contour_pt(r_ob, nt, &leftmost_in_ux, &rightmost_in_ux, &topmost_voice, &bottommost_voice), false), 0, WHITENULL_llll);
                } else { // it's a rest
                    llll_appendllll(points_in, pt_to_llll(rest_to_family_contour_pt(r_ob, ch, &leftmost_in_ux, &rightmost_in_ux, &topmost_voice, &bottommost_voice), false), 0, WHITENULL_llll);
                }
                break;
            }
            case k_MEASURE:
            {
                t_measure *meas = (t_measure *)it;
                t_chord *ch; t_note *nt;
                for (ch = meas->firstchord; ch; ch = ch->next) {
                    if (ch->firstnote) {
                        for (nt = ch->firstnote; nt; nt = nt->next) 
                            llll_appendllll(points_in, pt_to_llll(note_to_family_contour_pt(r_ob, nt, &leftmost_in_ux, &rightmost_in_ux, &topmost_voice, &bottommost_voice), false), 0, WHITENULL_llll);
                    } else { // it's a rest
                        llll_appendllll(points_in, pt_to_llll(rest_to_family_contour_pt(r_ob, ch, &leftmost_in_ux, &rightmost_in_ux, &topmost_voice, &bottommost_voice), false), 0, WHITENULL_llll);
                    }
                }
                break;
            }
            default:
                break;
        }
    }
    
    
    // mapping pts_in llll to t_pt array
    t_pt *pts_in = (t_pt *)bach_newptr(points_in->l_size * sizeof(t_pt));
    long i = 0;
    for (t_llllelem *elem = points_in->l_head; elem && i < (long)points_in->l_size; elem = elem->l_next, i++) 
        pts_in[i] = llll_to_pt(hatom_getllll(&elem->l_hatom));
    
    
    if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_BOUNDINGBOX) { 
        // simple bounding box!
        beziercs_free(fam->contour);
        t_polygon *boundingbox = get_bounding_box(points_in->l_size, pts_in, build_pt(10, 10));
        fam->contour = polygon_to_bezier_closed_spline(boundingbox); 
        polygon_free(boundingbox);
    } else {
        double PAD_UX = 40;
        const char USE_MULTIPOINTS = false;
        // retrieving pts_out
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
            t_rollvoice *voice; t_chord *chord; t_note *note;
            for (voice = (t_rollvoice *)r_ob->firstvoice; voice && voice->v_ob.number < r_ob->num_voices; voice = voice->next) {
                
                if (voice->v_ob.number < topmost_voice - 1) continue;
                if (voice->v_ob.number > bottommost_voice + 1) break;

                for (chord = voice->firstchord; chord; chord = chord->next) {
                    
                    if (chord->onset * CONST_X_SCALING < leftmost_in_ux - PAD_UX) continue;
                    if (chord->onset * CONST_X_SCALING > rightmost_in_ux + PAD_UX) break;
                    if (notation_item_is_in_label_family((t_notation_item *)chord, fam)) continue;
                    
                    for (note = chord->firstnote; note; note = note->next) {
                        if (notation_item_is_in_label_family((t_notation_item *)note, fam)) continue;
                        if (USE_MULTIPOINTS)
                            llll_chain(points_out, note_to_family_contour_pts(r_ob, note));
                        else
                            llll_appendllll(points_out, pt_to_llll(note_to_family_contour_pt(r_ob, note, NULL, NULL, NULL, NULL), false));
                    }
                }
            }
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            t_scorevoice *voice; t_measure *meas; t_chord *chord; t_note *note;
            for (voice = (t_scorevoice *)r_ob->firstvoice; voice && voice->v_ob.number < r_ob->num_voices; voice = voice->next) {
                
                if (voice->v_ob.number < topmost_voice - 1) continue;
                if (voice->v_ob.number > bottommost_voice + 1) break;
                
                for (meas = voice->firstmeasure; meas; meas = meas->next) {
                    
                    if (notation_item_is_in_label_family((t_notation_item *)meas, fam)) continue;
                    if (meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux + meas->width_ux < leftmost_in_ux - PAD_UX) continue;
                    if (meas->tuttipoint_reference->offset_ux + meas->start_barline_offset_ux > rightmost_in_ux + PAD_UX) break;
                    
                    for (chord = meas->firstchord; chord; chord = chord->next) {
                        if (notation_item_is_in_label_family((t_notation_item *)chord, fam)) continue;
                        if (!chord->firstnote) {
                            if (USE_MULTIPOINTS)
                                llll_chain(points_out, note_to_family_contour_pts(r_ob, note));
                            else
                                llll_appendllll(points_out, pt_to_llll(rest_to_family_contour_pt(r_ob, chord, NULL, NULL, NULL, NULL), false));
                        } else {
                            for (note = chord->firstnote; note; note = note->next) {
                                if (notation_item_is_in_label_family((t_notation_item *)note, fam)) continue;
                                if (USE_MULTIPOINTS)
                                    llll_chain(points_out, note_to_family_contour_pts(r_ob, note));
                                else
                                    llll_appendllll(points_out, pt_to_llll(note_to_family_contour_pt(r_ob, note, NULL, NULL, NULL, NULL), false));
                            }
                        }
                    }
                }
            }
        }
            
            
        // mapping pts_out llll to t_pt array
        t_pt *pts_out = (t_pt *)bach_newptr(points_out->l_size * sizeof(t_pt));
        long i = 0;
        for (t_llllelem *elem = points_out->l_head; elem && i < (long)points_out->l_size; elem = elem->l_next, i++) 
            pts_out[i] = llll_to_pt(hatom_getllll(&elem->l_hatom));
        
        // debug
/*        if (g) {
            for (long i = 0; i < points_in->l_size; i++)
                paint_circle(g, build_jrgba(1, 0, 0, 1), build_jrgba(1, 0, 0, 1), unscaled_xposition_to_xposition(r_ob, pts_in[i].x), pts_in[i].y, 1, 1);
            for (long i = 0; i < points_out->l_size; i++)
                paint_circle(g, build_jrgba(0, 0, 1, 1), build_jrgba(0, 0, 1, 1), unscaled_xposition_to_xposition(r_ob, pts_out[i].x), pts_out[i].y, 1, 1);
        } */
        
        // applying function
        beziercs_free(fam->contour);
        
        fam->contour = get_venn_enclosure(points_in->l_size, pts_in, points_out->l_size, pts_out, NULL);

        bach_freeptr(pts_out);
    }
    
    llll_free(points_in);
    llll_free(points_out);
    bach_freeptr(pts_in);
}

void update_all_label_families_contour(t_notation_obj *r_ob)
{
    t_bach_label_manager *man = &r_ob->m_labels;
    t_llllelem *elem;
    for (elem = man->families->l_head; elem; elem = elem->l_next) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
        update_label_family_contour(r_ob, fam, NULL);
    }
}

void set_all_label_families_update_contour(t_notation_obj *r_ob)
{
    if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_BOUNDINGBOX || r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_VENN) {
        t_bach_label_manager *man = &r_ob->m_labels;
        t_llllelem *elem;
        for (elem = man->families->l_head; elem; elem = elem->l_next) {
            t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
            fam->need_update_contour = true;
        }
    }
}

void set_label_families_update_contour_flag_from_undo_ticks(t_notation_obj *r_ob)
{
    char must_unlock = true;
    
    if (systhread_mutex_trylock(r_ob->c_undo_mutex))
        must_unlock = false; // already locked

    lock_general_mutex(r_ob);
    t_llllelem *elem;
    for (elem = r_ob->undo_llll->l_head; elem; elem = elem->l_next) {
        
        if (hatom_gettype(&elem->l_hatom) == H_LONG) 
            goto end; // we've reached the next undo steps, we're done.
        
        if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
            t_undo_redo_information *info = (t_undo_redo_information *)hatom_getobj(&elem->l_hatom);
            if (info->n_it_type == k_WHOLE_NOTATION_OBJECT || info->n_it_type == k_HEADER_DATA) {
                t_llllelem *elem;
                for (elem = r_ob->m_labels.families->l_head; elem; elem = elem->l_next) {
                    t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
                    fam->need_update_contour = true;
                }
                notationobj_redraw(r_ob);
                goto end; // no longer need to verify further elements, of course, we have already set the flag for all families
            } else {
                t_notation_item *item = notation_item_retrieve_from_ID(r_ob, info->n_it_ID);
                t_llllelem *elem; 
                t_note *temp_nt;
                if (item) {
                    switch (item->type) {
                        case k_NOTE:
                            for (elem = item->label_families->l_head; elem; elem = elem->l_next) {
                                t_llll *ll = hatom_getllll(&elem->l_hatom);
                                t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
                                fam->need_update_contour = true;
                            }
                            break;
                        case k_CHORD:
                            for (elem = item->label_families->l_head; elem; elem = elem->l_next) {
                                t_llll *ll = hatom_getllll(&elem->l_hatom);
                                t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
                                fam->need_update_contour = true;
                            }
                            for (temp_nt = ((t_chord *)item)->firstnote; temp_nt; temp_nt = temp_nt->next) {
                                for (elem = temp_nt->r_it.label_families->l_head; elem; elem = elem->l_next) {
                                    t_llll *ll = hatom_getllll(&elem->l_hatom);
                                    t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
                                    fam->need_update_contour = true;
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
        }
    }

end:
    
    unlock_general_mutex(r_ob);
    if (must_unlock)
        systhread_mutex_unlock(r_ob->c_undo_mutex);    
}

void free_all_label_families(t_bach_label_manager *man)
{
    t_llllelem *elem;
    for (elem = man->families->l_head; elem; elem = elem->l_next) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
        free_label_family(fam);
    }
}


void verbose_post_label_families(t_notation_obj *r_ob)
{
#ifdef CONFIGURATION_Development
    t_llllelem *elem;
    long i;
    dev_post("---- Label families");
    for (i = 0, elem = r_ob->m_labels.families->l_head; elem; elem = elem->l_next, i++) {
        t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
        char *buf = NULL;
        llll_to_text_buf(fam->label, &buf, 0, BACH_DEFAULT_MAXDECIMALS, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
        dev_post("- Family %ld: name %s (%ld elements)", i, buf, fam->items->l_size);
        bach_freeptr(buf);
    }
#endif
}

long get_family_index(t_notation_obj *r_ob, t_bach_label_family *fam)
{
    return llllelem_retrieve_index(r_ob->m_labels.families, fam->llelem);
}

void add_label_families_data_for_notation_item(t_notation_obj *r_ob, t_notation_item *r_it)
{
    // parsing each name
    t_llll *families_ll = r_ob->m_labels.families;
    t_llllelem *name_el;
    t_llllelem *elem;
    for (name_el = r_it->names->l_head; name_el; name_el = name_el->l_next) {
        
        char found = false;
        for (elem = families_ll->l_head; elem; elem = elem->l_next) {
            t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&elem->l_hatom);
            t_hatom *label = &fam->label->l_head->l_hatom;
            if (llll_eq_hatom_ignoretype(label, &name_el->l_hatom)) {
                found = true;
                t_llllelem *app = llll_appendobj(fam->items, r_it, 0, WHITENULL_llll);
                llll_appendllll(r_it->label_families, obj_couple_to_llll(fam, app), 0, WHITENULL_llll);
                fam->need_update_contour = true;
            }
        }
        
        if (!found) {
            // add a new family;
            t_bach_label_family *new_family = (t_bach_label_family *)bach_newptrclear(sizeof(t_bach_label_family));
            new_family->items = llll_get();
            new_family->label = llll_get();
            new_family->contour = NULL; // no contour
            new_family->need_update_contour = true;
            llll_appendhatom_clone(new_family->label, &name_el->l_hatom, 0, WHITENULL_llll);

            t_llllelem *app = llll_appendobj(new_family->items, r_it, 0, WHITENULL_llll);
            llll_appendllll(r_it->label_families, obj_couple_to_llll(new_family, app), 0, WHITENULL_llll);

            new_family->llelem = llll_appendobj(families_ll, new_family, 0, WHITENULL_llll);
            
            long i;
            i = 2;
            i++;
            
        }
    }
    
//    verbose_post_label_families(r_ob);
}

void parse_label_families(t_notation_obj *r_ob)
{
    t_marker *marker; t_voice *voice; t_measure *meas; t_chord *chord; t_note *note;
    
    lock_general_mutex(r_ob);
    
    // 1. FREE MEMORY
    free_all_label_families(&r_ob->m_labels);
    
    // 2. RETRIEVE FAMILIES
    for (voice = r_ob->firstvoice; voice && (voice->number < r_ob->num_voices); voice = voice_get_next(r_ob, voice)) {
        add_label_families_data_for_notation_item(r_ob, &voice->r_it);
                                 
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next) 
                add_label_families_data_for_notation_item(r_ob, &meas->r_it);
        }

        for (chord = (r_ob->obj_type == k_NOTATION_OBJECT_SCORE ? ((t_scorevoice *)voice)->firstmeasure->firstchord : ((t_rollvoice *)voice)->firstchord); 
             chord; chord = chord_get_next(chord)) {
            add_label_families_data_for_notation_item(r_ob, &chord->r_it);

            for (note = chord->firstnote; note; note = note->next) 
                add_label_families_data_for_notation_item(r_ob, &note->r_it);
        }
    }
    
    if (r_ob->firstmarker) {
        for (marker = r_ob->firstmarker; marker; marker = marker->next)
            add_label_families_data_for_notation_item(r_ob, &marker->r_it);
    }
    
    unlock_general_mutex(r_ob);
}



void change_single_voicename_from_ac_av(t_notation_obj *r_ob, t_voice *voice, long ac, t_atom *av, char also_add_undo_tick){
    t_llll *ll = llll_parse(ac, av);
    change_single_voicename(r_ob, voice, ll, also_add_undo_tick);
    llll_free(ll);
}

void change_single_voicename(t_notation_obj *r_ob, t_voice *voice, t_llll *new_names, char also_add_undo_tick){
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_VOICENAMES);

    change_notation_item_names(r_ob, (t_notation_item *) voice, new_names, false);

    // synchronizing the llll attribute
    llll_free(r_ob->voicenames_as_llll);
    r_ob->voicenames_as_llll = get_voicenames_as_llll(r_ob, false);

    // recalculate needed 
    recalculate_voicenames_width(r_ob);
    update_hscrollbar(r_ob, 0);
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
}


t_voice *voice_get_next(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
        return (t_voice *)(((t_rollvoice *) voice)->next);
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        return (t_voice *)(((t_scorevoice *) voice)->next);
    else
        return NULL;
}


t_voice *voice_get_prev(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) 
        return (t_voice *)(((t_rollvoice *) voice)->prev);
    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        return (t_voice *)(((t_scorevoice *) voice)->prev);
    else
        return NULL;
}

t_voice *voiceensemble_get_prev(t_notation_obj *r_ob, t_voice *voice)
{
    t_voice *prev = voice_get_prev(r_ob, voice);
    while (prev && prev->number >= 0 && prev->part_index != 0)
        prev = voice_get_prev(r_ob, prev);
    return prev;
}


t_voice *voiceensemble_get_next(t_notation_obj *r_ob, t_voice *voice)
{
    t_voice *next = voice_get_next(r_ob, voice);
    while (next && next->number < r_ob->num_voices && next->part_index != 0)
        next = voice_get_next(r_ob, next);
    return next;
}



// ALSO CALCULATES NEEDED HEIGHT
void calculate_voice_offsets(t_notation_obj *r_ob)
{
    // re-setting each voice offset
    t_voice *voice = r_ob->firstvoice;
    double offset = r_ob->head_vertical_additional_uspace * r_ob->zoom_y;
    r_ob->needed_uheight = notationobj_get_supposed_standard_uheight(r_ob);
    while (voice && voice->number < r_ob->num_voices) {
        voice->offset_y = round(offset); // round is needed, in order to have non antialiased things!
        if (!voice->hidden && (voice->number == r_ob->num_voices - 1 || voice_get_next(r_ob, voice)->part_index == 0)) {
            long num_staves = get_num_staves_voice(r_ob, voice);
            offset += num_staves * 14 * CONST_STEP_UY * r_ob->zoom_y + voice->vertical_uspacing * r_ob->zoom_y;
        }
        voice = voice_get_next(r_ob, voice);
    }
    
    if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_BOUNDINGBOX || r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_VENN) 
        set_all_label_families_update_contour(r_ob);
}

void calculate_ms_on_a_line(t_notation_obj *r_ob) {
    // TODO: CONST_RIGHT_UPAD is equivalent to r_ob->postdomain_width. Harmonize them.
    r_ob->ms_on_a_line = (((r_ob->width - CONST_RIGHT_UPAD - get_max_vscrollbar_width_or_inset_x(r_ob)) / r_ob->zoom_y)  -
                          (get_ux_left_start(r_ob) + r_ob->key_signature_uwidth + r_ob->voice_names_uwidth)) / (CONST_X_SCALING * r_ob->zoom_x);
}


long get_num_staves_voice(t_notation_obj *r_ob, t_voice *voice)
{
    long clef = get_voice_clef(r_ob, voice);
    switch (clef) {
        case k_CLEF_FFGG: return 4;
        case k_CLEF_FGG: return 3;
        case k_CLEF_FFG: return 3;
        case k_CLEF_FG: return 2;
        case k_CLEF_FF: return 2;
        case k_CLEF_GG: return 2;
        default: return 1;
    }
}


long get_num_staves(t_notation_obj *r_ob, char dont_count_hidden_staves)
{
    long prev_num_staves = 0; 
    t_voice *voice = r_ob->firstvoice;
    while (voice && voice->number < r_ob->num_voices) {
        if (!dont_count_hidden_staves || !voice->hidden)
            if (voice->part_index == 0)
                prev_num_staves += get_num_staves_voice(r_ob, voice);
        voice = voice_get_next(r_ob, voice);
    }
    return prev_num_staves;
}


void change_voiceensemble_clef(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, long new_clef, char also_add_undo_tick)
{
    t_atom av[CONST_MAX_VOICES];
    long i;
    t_voice *tmpvoice;

    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_CLEFS);
    
    for (i = 0, tmpvoice = r_ob->firstvoice; i < r_ob->num_voices && tmpvoice; i++, tmpvoice = voice_get_next(r_ob, tmpvoice)) {
        if (do_voices_belong_to_same_voiceensemble(r_ob, any_voice_in_voiceensemble, tmpvoice))
            atom_setsym(av+i, clef_number_to_clef_symbol(r_ob, new_clef));
        else
            atom_setsym(av+i, r_ob->clefs_as_symlist[i]);
    }
    
    object_method_typed(r_ob, gensym("clefs"), r_ob->num_voices, av, NULL);
}

void change_single_clef(t_notation_obj *r_ob, t_voice* voice, long new_clef, char also_add_undo_tick)
{
    t_atom av[CONST_MAX_VOICES];
    long i; 
    t_voice *tmpvoice;
    
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_CLEFS);
    
    for (i = 0, tmpvoice = r_ob->firstvoice; i < r_ob->num_voices && tmpvoice; i++, tmpvoice = voice_get_next(r_ob, tmpvoice)) {
        if (tmpvoice == voice)
            atom_setsym(av+i, clef_number_to_clef_symbol(r_ob, new_clef));
        else
            atom_setsym(av+i, r_ob->clefs_as_symlist[i]);
    }
    
    object_method_typed(r_ob, gensym("clefs"), r_ob->num_voices, av, NULL);
}

void change_voiceensemble_midichannel(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, long new_midichannel, char also_add_undo_tick)
{
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_MIDICHANNELS);
    
    t_voice *first = voiceensemble_get_firstvoice(r_ob, any_voice_in_voiceensemble);
    t_voice *last = voiceensemble_get_lastvoice(r_ob, any_voice_in_voiceensemble);
    t_voice *temp;
    for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
        change_single_midichannel(r_ob, temp, new_midichannel, false);
        if (temp == last)
            break;
    }
}

void change_single_midichannel(t_notation_obj *r_ob, t_voice* voice, long new_midichannel, char also_add_undo_tick)
{
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_MIDICHANNELS);
    voice->midichannel = new_midichannel;
    r_ob->midichannels_as_longlist[voice->number] = new_midichannel;
}

void change_voiceensemble_key(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, t_symbol *new_key, char also_add_undo_tick)
{
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_KEYS);
    
    t_voice *first = voiceensemble_get_firstvoice(r_ob, any_voice_in_voiceensemble);
    t_voice *last = voiceensemble_get_firstvoice(r_ob, any_voice_in_voiceensemble);
    t_voice *temp;
    for (temp = first; temp && temp->number < r_ob->num_voices; temp = voice_get_next(r_ob, temp)) {
        change_single_key(r_ob, temp, new_key, false);
        if (temp == last)
            break;
    }
}

void change_single_key(t_notation_obj *r_ob, t_voice* voice, t_symbol *new_key, char also_add_undo_tick)
{
    if (also_add_undo_tick)
        create_header_undo_tick(r_ob, k_HEADER_KEYS);

    r_ob->keys_as_symlist[voice->number] = new_key;
    parse_sym_to_key_and_mode(r_ob, r_ob->keys_as_symlist[voice->number], &voice->key, &voice->mode, voice->acc_pattern);
    r_ob->key_signature_uwidth = get_max_key_uwidth(r_ob);
}

t_llllelem *get_voice_stafflines_as_llllelem(t_notation_obj *r_ob, t_voice *voice)
{
    t_llllelem *elem = llllelem_get();
    if (voice->are_staff_lines_standard) {
        hatom_setlong(&elem->l_hatom, voice->num_staff_lines);
    } else {
        char *string = char_array_to_string(voice->staff_lines, voice->num_staff_lines, true);
        t_llll *ll = llll_from_text_buf(string);
        if (ll)
            llll_flatten(ll, 1, 0);
        hatom_setllll(&elem->l_hatom, ll);
        if (ll)    
            ll->l_owner = elem;
        bach_freeptr(string);
    }
    return elem;
}

/*void set_stafflines_from_llll(t_notation_obj *r_ob, t_llll* stafflines){
    if (stafflines) {
        t_atom *av = NULL;
        long ac = llll_deparse(stafflines, &av, 0, 0);
        notation_obj_setattr_stafflines(r_ob, NULL, ac, av);
        bach_freeptr(av);
    }
}*/

void set_midichannels_from_llll(t_notation_obj *r_ob, t_llll* midichannels){
    if (midichannels) {
        t_llllelem *elem; 
        void *voice = r_ob->firstvoice;
        for (elem = midichannels->l_head; elem && voice && ((t_voice *)voice)->number < r_ob->num_voices; elem = elem->l_next) { 
            long type = hatom_gettype(&elem->l_hatom);
            if (type == H_LONG) {
                long midichannel = hatom_getlong(&elem->l_hatom);
                ((t_voice *)voice)->midichannel = midichannel;
                r_ob->midichannels_as_longlist[((t_voice *)voice)->number] = midichannel;
            }
            voice = voice_get_next(r_ob, (t_voice *) voice);
        }
    }
}


double get_max_key_uwidth(t_notation_obj *r_ob) {
    void *voice = r_ob->firstvoice; 
    double max_width = 0.; 
    char there_is_some_key = false;
    while (voice && ((t_voice *)voice)->number < r_ob->num_voices) {
        double this_width = get_key_uwidth(r_ob, (t_voice *)voice);
        if (!there_is_some_key && this_width > 0.)
            there_is_some_key = true;
        if (this_width > max_width) max_width = this_width;
        voice = voice_get_next(r_ob, (t_voice *) voice);
    } 
    if (there_is_some_key) max_width += CONST_USPACE_AFTER_KEY_SIGNATURE;
    return max_width;
}


void notationobj_set_voicespacing_from_llll(t_notation_obj *r_ob, t_llll* voicespacing)
{
    if (voicespacing) {
        t_atom *av = NULL;
        long ac = llll_deparse(voicespacing, &av, 0, LLLL_D_NONE);
        notation_obj_setattr_voicespacing(r_ob, NULL, ac, av);
        if (av) bach_freeptr(av);
    }
}

void notationobj_set_hidevoices_from_llll(t_notation_obj *r_ob, t_llll* hidevoices)
{
    if (hidevoices) {
        t_atom *av = NULL;
        long ac = llll_deparse(hidevoices, &av, 0, LLLL_D_NONE);
        notation_obj_setattr_hidevoices(r_ob, NULL, ac, av);
        if (av) bach_freeptr(av);
    }
}

t_max_err notation_obj_setattr_showmeasurenumbers(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    long i;
    if (ac) {
        for (i = 0; i < ac && i < CONST_MAX_VOICES; i++, av++)
            r_ob->show_measure_numbers[i] = atom_getlong(av);
    }
    
    return MAX_ERR_NONE;
}


t_max_err notation_obj_setattr_voicespacing(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    long i;
    double value[CONST_MAX_VOICES + 1];
    if (ac) {
        for (i = 0; i < ac && i < CONST_MAX_VOICES + 1; i++, av++)
            value[i] = atom_getfloat(av);
        return notation_obj_set_voicespacing(r_ob, i, value);
    } else
        return MAX_ERR_GENERIC;
}

t_max_err notation_obj_set_voicespacing(t_notation_obj *r_ob, long ac, double *value)
{
    long i;
    void *voice;
    if (ac)
        r_ob->head_vertical_additional_uspace = r_ob->voiceuspacing_as_floatlist[0] = *value++;
    
    for (i = 1, voice = r_ob->firstvoice; 
         i < ac && i <= CONST_MAX_VOICES && voice && ((t_voice *)voice)->number < CONST_MAX_VOICES; 
         i++, voice = voice_get_next(r_ob, (t_voice *) voice), value++)
        ((t_voice *) voice)->vertical_uspacing = r_ob->voiceuspacing_as_floatlist[i] = *value;
    
    if (r_ob->link_vzoom_to_height)
        auto_set_rectangle_size(r_ob);
    else
        calculate_voice_offsets(r_ob);
    return MAX_ERR_NONE;
}

t_max_err notation_obj_setattr_voicenames(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av){
    t_llll *args = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, ac, av, LLLL_PARSE_RETAIN);
    set_voicenames_from_llll(r_ob, args, true);
//    dev_post("Obj %p:", r_ob);
//    dev_llll_print(r_ob->voicenames_as_llll, NULL,0, 2, NULL);
    llll_free(args);
    return MAX_ERR_NONE;
}

void set_numvoices(t_notation_obj *r_ob, long num_voices)
{
    t_atom av;
    atom_setlong(&av, num_voices);
    notation_obj_setattr_numvoices(r_ob, NULL, 1, &av);
}

t_max_err notation_obj_setattr_numvoices(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    t_max_err err;
    if (ac && av) { 
        long new_num_voices = MAX(1, atom_getlong(av));
        t_atom *clefs = (t_atom *) bach_newptr(new_num_voices * sizeof(t_atom));
        long i;
        
        if (new_num_voices < r_ob->num_voices) {
            for (i = 0; i < new_num_voices; i++)
                atom_setsym(clefs+i, r_ob->clefs_as_symlist[i] ? r_ob->clefs_as_symlist[i] : _llllobj_sym_G);
        } else if (r_ob->num_voices < new_num_voices) {
            for (i = 0; i < r_ob->num_voices; i++)
                atom_setsym(clefs+i, r_ob->clefs_as_symlist[i] ? r_ob->clefs_as_symlist[i] : _llllobj_sym_G);
            for (; i < new_num_voices; i++)
                atom_setsym(clefs+i, r_ob->clefs_as_symlist[r_ob->num_voices - 1] ? r_ob->clefs_as_symlist[r_ob->num_voices - 1] : _llllobj_sym_G);
        }
        if (new_num_voices != r_ob->num_voices) {
            notation_obj_setattr_clefs(r_ob, NULL, new_num_voices, clefs);
            implicitely_recalculate_all(r_ob, false);
            notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
        }
        bach_freeptr(clefs);
        err = MAX_ERR_NONE;
    } else 
        err = MAX_ERR_GENERIC;

    r_ob->numvoices_handled_at_startup = true;
    return err;
}



// part is an array of 1-based indices containing the part numbers for each voice, and terminating with value < 0, e.g.
// 1, 2, 1, 2, -1
t_max_err notation_obj_set_parts(t_notation_obj *r_ob, long *part)
{
    long i;
    t_voice *voice;

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    long voiceens_count = 0;
    long prev = -1;
    for (i = 0, voice = r_ob->firstvoice;
         *part >= 0 && voice && i < CONST_MAX_VOICES && voice->number < CONST_MAX_VOICES;
         i++, part++, voice = voice_get_next(r_ob, voice)) {
        if (*part <= prev)
            voiceens_count++;
        if (*part <= 1 || i == 0) {
            r_ob->voice_part[i] = 1;
            voice->part_index = 0;
            voice->voiceensemble_index = voiceens_count;
        } else {
            r_ob->voice_part[i] = *part;
            voice->part_index = *part - 1;
            voice->voiceensemble_index = voiceens_count;
        }
        prev = *part;
    }
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    if (r_ob->link_vzoom_to_height)
        auto_set_rectangle_size(r_ob);
    else
        calculate_voice_offsets(r_ob);
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    implicitely_recalculate_all(r_ob, true);
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check(r_ob);
#endif

    return MAX_ERR_NONE;
}



t_max_err notation_obj_set_parts_from_llll(t_notation_obj *r_ob, t_llll *ll)
{
    long part[CONST_MAX_VOICES + 1];
    t_llllelem *elem;
    t_llll *cloned = llll_clone(ll);
    long i;
    if (!cloned)
        return MAX_ERR_GENERIC;
    
    llll_flatten(cloned, -1, 0);
    
    for (i = 0, elem = cloned->l_head; i < CONST_MAX_VOICES && elem; elem = elem->l_next, i++)
        part[i] = hatom_getlong(&elem->l_hatom);
    if (i < CONST_MAX_VOICES + 1)
        part[i] = -1;
    llll_free(cloned);
    return notation_obj_set_parts(r_ob, part);
    
}

t_max_err notation_obj_set_numparts_from_llll(t_notation_obj *r_ob, t_llll *ll)
{
    long part[CONST_MAX_VOICES + 1];
    long i = 0, j;
    t_llllelem *elem;
    for (elem = ll->l_head; i < CONST_MAX_VOICES && elem; elem = elem->l_next) {
        for (j = 1; i < CONST_MAX_VOICES && j <= hatom_getlong(&elem->l_hatom); j++)
            part[i++] = j;
    }
    if (i < CONST_MAX_VOICES + 1)
        part[i] = -1;
    return notation_obj_set_parts(r_ob, part);
}


t_max_err notation_obj_voice_part_getattr(t_notation_obj *r_ob, t_object *attr, long *ac, t_atom **av)
{
    lock_general_mutex(r_ob);
    t_llll *ll = get_numparts_as_llll(r_ob);
    llll_behead(ll);
    *ac = llll_deparse(ll, av, 0, 0);
    llll_free(ll);
    unlock_general_mutex(r_ob);
    return MAX_ERR_NONE;
}

t_max_err notation_obj_setattr_numparts(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    t_llll *ll = llllobj_parse_llll((t_object *)r_ob, LLLL_OBJ_UI, NULL, ac, av, LLLL_PARSE_CLONE);
    t_max_err res = notation_obj_set_numparts_from_llll(r_ob, ll);
    llll_free(ll);
    return res;
}


t_max_err notation_obj_setattr_clefs(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    t_symbol *clefs[CONST_MAX_VOICES + 1];
    long i;

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    t_llll *args = llllobj_parse_llll((t_object *)r_ob, LLLL_OBJ_UI, NULL, ac, av, LLLL_PARSE_CLONE);
    if (args && args->l_head) {
        long auto_clefs = false;
        t_llllelem *el;
        t_llll *sticky_allowed_clefs = NULL;
        for (i = 0, el = args->l_head; el && i < CONST_MAX_VOICES; i++, el = el->l_next) {
            t_symbol *clef_sym = clef_llllelem_to_symbol(el);
            t_symbol *s = NULL;
            if (clef_sym) {
                s = clef_sym;
                if (s == _llllobj_sym_Auto) {
                    if (i == 0 && args->l_size == 1)
                        auto_clefs = true;
                    s = clef_number_to_clef_symbol(r_ob, infer_most_appropriate_clef_for_voice(r_ob, nth_voice(r_ob, i), BACH_CLEF_AUTODETECT_CUTOFF_THRESHOLD));
                }
            } else if (hatom_gettype(&el->l_hatom) == H_LLLL) {
                t_llll *ll = hatom_getllll(&el->l_hatom);
                t_llll *allowed_clefs = llll_get();
                for (t_llllelem *subel = ll->l_head; subel; subel = subel->l_next) {
                    t_symbol *sub_s = clef_llllelem_to_symbol(subel);
                    if (sub_s) {
                        long sub_cl = clef_symbol_to_clef_number(r_ob, sub_s);
                        if (sub_cl != k_CLEF_NONE)
                            llll_appendlong(allowed_clefs, sub_cl);
                    }
                }
                if (i == 0 && args->l_size == 1) {
                    auto_clefs = true;
                    sticky_allowed_clefs = llll_clone(allowed_clefs);
                }
                s = clef_number_to_clef_symbol(r_ob, infer_most_appropriate_clef_for_voice(r_ob, nth_voice(r_ob, i), BACH_CLEF_AUTODETECT_CUTOFF_THRESHOLD, allowed_clefs));
                llll_free(allowed_clefs);
            } else {
                s = _llllobj_sym_none;
            }
            
            clefs[i] = s;
            
        }
        
        while (i < CONST_MAX_VOICES + 1) {
            if (auto_clefs && i < r_ob->num_voices)
                clefs[i] = clef_number_to_clef_symbol(r_ob, infer_most_appropriate_clef_for_voice(r_ob, nth_voice(r_ob, i), BACH_CLEF_AUTODETECT_CUTOFF_THRESHOLD, sticky_allowed_clefs));
            else
                clefs[i] = NULL;
            i++;
        }
        
#ifdef BACH_CHECK_NOTATION_ITEMS
        notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

        if (sticky_allowed_clefs)
            llll_free(sticky_allowed_clefs);
        llll_free(args);
        return notation_obj_set_clefs(r_ob, clefs, &r_ob->private_flag);
    } else
        return MAX_ERR_GENERIC;
}


void clear_all_measure_tuttipoint_references(t_notation_obj *r_ob)
{
    if (!r_ob) return;

    t_voice *voice;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        for (voice = r_ob->firstvoice; voice; voice = voice_get_next(r_ob, voice)) {
            t_measure *meas;
            if (!voice) return;
            for (meas = ((t_scorevoice *)voice)->firstmeasure; meas; meas = meas->next)
                meas->tuttipoint_reference = NULL;
        }
    }
}

t_max_err notation_obj_set_clefs(t_notation_obj *r_ob, t_symbol **newstaff, long *must_recompute_all)
{
    char just_choose_clef = 0;
    long new_num_voices, prev_num_voices, prev_num_staves, new_num_staves, i;
    t_voice *voice;
    if (!r_ob->firstvoice || r_ob->firstvoice->clef == k_CLEF_WRONG) // first time! 
        just_choose_clef = 1;

#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    // getting previous number of staves
    prev_num_voices = r_ob->num_voices;
    prev_num_staves = get_num_staves(r_ob, true);
    voice = r_ob->firstvoice;
    for (i = 0; *newstaff && i < CONST_MAX_VOICES; i++, newstaff++) { 
        r_ob->clefs_as_symlist[i] = *newstaff;
        
        voice->clef = clef_symbol_to_clef_number(r_ob, *newstaff);
        if (voice->clef == k_CLEF_WRONG) {
            voice->clef = k_CLEF_G;
            r_ob->clefs_as_symlist[i] = _llllobj_sym_G;
        }
        
        voice = voice_get_next(r_ob, voice);
    }
    if (!r_ob->creatingnewobj || !r_ob->numvoices_handled_at_startup) {
        long new_num_voices = CLAMP(i, 0, CONST_MAX_VOICES);
        if (r_ob->num_voices != new_num_voices) {
            clear_all_measure_tuttipoint_references(r_ob);
            if (must_recompute_all) *must_recompute_all = true;
        }
        r_ob->num_voices = new_num_voices;
        r_ob->num_voices_plus_one = i+1;
    }
    new_num_voices = r_ob->num_voices;
    if (just_choose_clef == 1)
        return MAX_ERR_NONE;
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    // getting new number of staves
    new_num_staves = 0;
    voice = r_ob->firstvoice;
    for (i = 0; i < r_ob->num_voices; i++){
        switch (voice->clef) {
            case k_CLEF_FFGG: new_num_staves += 4; break;
            case k_CLEF_FGG: new_num_staves += 3; break;
            case k_CLEF_FFG: new_num_staves += 3; break;
            case k_CLEF_FG: new_num_staves += 2; break;
            case k_CLEF_FF: new_num_staves += 2; break;
            case k_CLEF_GG: new_num_staves += 2; break;
            default: new_num_staves += 1; break;
        }
        voice = voice_get_next(r_ob, voice);
    }
    
    r_ob->add_staff = new_num_staves - prev_num_staves;
    r_ob->add_voice = new_num_voices - prev_num_voices;
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    // calculate voice offsets
    calculate_voice_offsets(r_ob);
    
    // re-setting rectangle dimension
    if (r_ob->link_vzoom_to_height) // AUTO-ZOOM
        auto_set_rectangle_size(r_ob);
    else
        calculate_voice_offsets(r_ob);
    
    r_ob->key_signature_uwidth = get_max_key_uwidth(r_ob);
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        calculate_ms_on_a_line(r_ob);
        recalculate_num_systems(r_ob);
    }
    r_ob->system_jump = get_system_jump(r_ob);
    
    llll_free(r_ob->stafflines_as_llll);
    r_ob->stafflines_as_llll = get_stafflines_as_llll(r_ob, false);

    llll_free(r_ob->voicenames_as_llll);
    r_ob->voicenames_as_llll = get_voicenames_as_llll(r_ob, false);
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    
    parse_fullaccpattern_to_voices(r_ob);

    // THIS IS NEEDED HERE, cause the function compute_chord_parameters needs some data from here, especially when it calls
    // the mc_to_yposition() function. THis is not the best ergonomy however, the calculate_chord_parameters() function
    // should do that differently.
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) 
        compute_middleC_position_for_voice(r_ob, voice);
    
    
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    
#ifdef BACH_CHECK_NOTATION_ITEMS
    notation_obj_check_all_measure_tuttipoints(r_ob);
#endif

    
    return MAX_ERR_NONE;
}



void auto_set_rectangle_size_do(t_notation_obj *r_ob)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        r_ob->needed_uheight = notationobj_get_supposed_standard_uheight(r_ob);
        r_ob->needed_uheight_for_one_system = r_ob->needed_uheight / ((r_ob->num_systems > 0) ? r_ob->num_systems : 1);
        r_ob->system_jump = get_system_jump(r_ob);
        if (r_ob->link_vzoom_to_height) {
            t_size pres_rect, patch_rect;
            jbox_get_presentation_size((t_object *)r_ob, &pres_rect);
            jbox_get_patching_size((t_object *)r_ob, &patch_rect);
            
            r_ob->itsme = true;
            pres_rect.height = patch_rect.height = MAX(1, r_ob->needed_uheight * r_ob->zoom_y);
            jbox_set_presentation_size((t_object *)r_ob, &pres_rect);
            jbox_set_patching_size((t_object *)r_ob, &patch_rect);
            //            post("zoom (known): %f  supposed: %f. this: %f.", r_ob->zoom_y, notationobj_get_supposed_standard_uheight((t_notationobj *)x), pres_rect.height);
            adjust_zoom_for_non_antialiased_lines(r_ob);
            calculate_voice_offsets(r_ob);
            r_ob->itsme = false;
            r_ob->add_staff = 0;
        }
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_size pres_rect, patch_rect;
        jbox_get_presentation_size((t_object *)r_ob, &pres_rect);
        jbox_get_patching_size((t_object *)r_ob, &patch_rect);
        
        r_ob->itsme = true;
        pres_rect.height = patch_rect.height = MAX(1, notationobj_get_supposed_standard_uheight(r_ob) * r_ob->zoom_y);
        jbox_set_presentation_size((t_object *)r_ob, &pres_rect);
        jbox_set_patching_size((t_object *)r_ob, &patch_rect);
        //            post("zoom (known): %f  supposed: %f. this: %f.", r_ob->zoom_y, notationobj_get_supposed_standard_uheight((t_notation_obj *)x), pres_rect.height);
        adjust_zoom_for_non_antialiased_lines(r_ob);
        calculate_voice_offsets(r_ob);
        r_ob->itsme = false;
        
        //        jbox_set_rect_for_view(&r_ob->j_box.b_ob, view, &rect);
        //        jbox_get_rect_for_view(&r_ob->j_box.b_ob, view, &rect);
        r_ob->add_staff = 0;
    }
}
 
void auto_set_rectangle_size(t_notation_obj *r_ob)
{
    if (!r_ob->creatingnewobj)
        auto_set_rectangle_size_do(r_ob);
}



t_max_err notation_obj_setattr_hidevoices(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    char hide[CONST_MAX_VOICES + 1];
    int i;
    if (ac && av) {
        for (i = 0; i < ac && i < CONST_MAX_VOICES; i++, av++)
            hide[i] = atom_getlong(av);
        while (i < CONST_MAX_VOICES + 1) 
            hide[i++] = -1;
        return notation_obj_set_hidevoices(r_ob, hide);
    } else
        return MAX_ERR_GENERIC;
    
}
t_max_err notation_obj_set_hidevoices(t_notation_obj *r_ob, char *hide)
{
    long i;
    void *voice;
    for (i = 0, voice = (void *) r_ob->firstvoice; 
         *hide >= 0 && voice && i < CONST_MAX_VOICES && ((t_voice *)voice)->number < CONST_MAX_VOICES; 
         i++, hide++, voice = (void *) voice_get_next(r_ob, (t_voice *) voice)) {
        switch (*hide) { 
            case 1:
                r_ob->hidevoices_as_charlist[i] = 1;
                ((t_voice *)voice)->hidden = true;
                ((t_voice *)voice)->determines_spacing = false;
                break;
            case 2:
                r_ob->hidevoices_as_charlist[i] = 1;
                ((t_voice *)voice)->hidden = true;
                ((t_voice *)voice)->determines_spacing = true;
                break;
            default:
                r_ob->hidevoices_as_charlist[i] = 0;
                ((t_voice *)voice)->hidden = false;
                ((t_voice *)voice)->determines_spacing = true;
        }
    }
    if (r_ob->link_vzoom_to_height)
        auto_set_rectangle_size(r_ob);
    else
        calculate_voice_offsets(r_ob);
    return MAX_ERR_NONE;
}


t_max_err notation_obj_setattr_keys(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av)
{
    t_symbol *keys[CONST_MAX_VOICES + 1];
    long i;
    if (ac && av) {
        for (i = 0; i < ac && i < CONST_MAX_VOICES && av->a_type == A_SYM; i++, av++)
            keys[i] = av->a_w.w_sym;
        while (i < CONST_MAX_VOICES + 1)
            keys[i++] = NULL;
        return notation_obj_set_keys(r_ob, keys);
    } else
        return MAX_ERR_GENERIC;
}

t_max_err notation_obj_set_keys(t_notation_obj *r_ob, t_symbol **keys)
{
    long i;
    t_voice *voice;
    t_symbol *lastkey = gensym("CM");
//    t_symbol **currkey = keys;
    for (i = 0, voice = r_ob->firstvoice;
         voice && i < CONST_MAX_VOICES; //  && (*keys || i < r_ob->num_voices);
         i++, voice = voice_get_next(r_ob, voice)) {
        if (*keys) {
            lastkey = r_ob->keys_as_symlist[i] = *keys;
            keys++;
        } else
            r_ob->keys_as_symlist[i] = lastkey; // last one is repeated if needed
        parse_sym_to_key_and_mode(r_ob, r_ob->keys_as_symlist[i], &voice->key, &voice->mode, voice->acc_pattern);
    }
    r_ob->key_signature_uwidth = get_max_key_uwidth(r_ob);
    calculate_ms_on_a_line(r_ob);
    recalculate_num_systems(r_ob);
    r_ob->system_jump = get_system_jump(r_ob);
    r_ob->firsttime = true;
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    return MAX_ERR_NONE;
}



/// LOCAL SPACING

void assign_local_spacing_width_multiplier(t_notation_obj *r_ob, t_tuttipoint *tpt, double new_value){
    if (tpt) {
        long i;
        for (i = 0; i < r_ob->num_voices && i < CONST_MAX_VOICES; i++){
            t_measure *tmp_meas;
            for (tmp_meas = tpt->measure[i]; (tpt->next && tmp_meas != tpt->next->measure[i]) || (!tpt->next && tmp_meas); tmp_meas = tmp_meas->next) {
                if (!tmp_meas) {
                    notationobj_throw_issue(r_ob);
                    break;
                } else
                    tmp_meas->local_spacing_width_multiplier = new_value;
            }
        }
        tpt->local_spacing_width_multiplier = new_value;
    }
}

void assign_fixed_spacing_uwidth(t_notation_obj *r_ob, t_tuttipoint *tpt, double new_value){
    if (tpt){
        long i;
        for (i = 0; i < r_ob->num_voices && i < CONST_MAX_VOICES; i++){
            t_measure *tmp_meas;
            for (tmp_meas = tpt->measure[i]; (tpt->next && tmp_meas != tpt->next->measure[i]) || (!tpt->next && tmp_meas); tmp_meas = tmp_meas->next){
                tmp_meas->fixed_spacing_uwidth = new_value;
                tmp_meas->is_spacing_fixed = true;
            }
        }
        tpt->fixed_spacing_uwidth = new_value;
        tpt->is_spacing_fixed = true;
    }
}

void remove_fixed_spacing_uwidth(t_notation_obj *r_ob, t_tuttipoint *tpt){
    if (tpt){
        long i;
        for (i = 0; i < r_ob->num_voices && i < CONST_MAX_VOICES; i++){
            t_measure *tmp_meas;
            for (tmp_meas = tpt->measure[i]; (tpt->next && tmp_meas != tpt->next->measure[i]) || (!tpt->next && tmp_meas); tmp_meas = tmp_meas->next)
                tmp_meas->is_spacing_fixed = false;
        }
        tpt->is_spacing_fixed = false;
    }
}

char fix_unfix_measure_width(t_notation_obj *r_ob, t_measure *measure){
    if (measure->tuttipoint_reference) {

        // adding undo ticks for all measure inside the tuttipoint region (they'll be ALL fixed/unfixed!!!)
        long i;
        t_measure *meas;
        for (i = 0; i < r_ob->num_voices; i++) {
            for (meas = measure->tuttipoint_reference->measure[i]; meas; meas = meas->next){
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
                if (meas->next && meas->next->tuttipoint_reference != measure->tuttipoint_reference)
                    break;
            }
        }
    
        if (measure->is_spacing_fixed)
            remove_fixed_spacing_uwidth(r_ob, measure->tuttipoint_reference);
        else {
            assign_local_spacing_width_multiplier(r_ob, measure->tuttipoint_reference, 1.);
            assign_fixed_spacing_uwidth(r_ob, measure->tuttipoint_reference, measure->tuttipoint_reference->width_ux);
        }
        recompute_all_for_measure(r_ob, measure, false);
        return 1;
    }
    return 0;
}


char reset_selected_measures_local_spacing_width_multiplier(t_notation_obj *r_ob) {
    char changed = 0;
    t_notation_item *temp = r_ob->firstselecteditem;
    lock_general_mutex(r_ob);
    while (temp) {
        if (temp->type == k_MEASURE_END_BARLINE) {
            t_measure *meas = ((t_measure_end_barline *)temp)->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)meas)) {
                create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)meas, k_MEASURE, k_UNDO_MODIFICATION_CHANGE);
                if (meas && meas->tuttipoint_reference) {
                    assign_local_spacing_width_multiplier(r_ob, meas->tuttipoint_reference, 1.);
                    recompute_all_for_measure(r_ob, meas, false);
                    changed = 1;
                }
            }
        }
        temp = temp->next_selected;
    }
    unlock_general_mutex(r_ob);
    return changed;
}




/// Returns the tuplet depth: number of tuplets in which the chord is situated.
/// If this is 0, the chord has no tuplet; otherwise, this is the number of nested tuplets under which the chord is situated.
long get_xml_chord_tuplet_info(t_notation_obj *r_ob, t_chord *chord, t_xml_chord_tuplet_info *info){

    if (rat_rat_cmp(chord->overall_tuplet_ratio, long2rat(1)) == 0) // no tuplet
        return 0;

    t_llll *level = get_innermost_tuplet_level_for_chord(chord);

    if (!level)    // no tuplet, but should never happen, should be returned before...
        return 0;

    long count = 0, idx = CONST_MAX_XML_NESTED_TUPLETS;

    while (level && idx > 0) {
        t_rational screen_duration;
        char num_dots;
        t_rhythm_level_properties *prop = (t_rhythm_level_properties *)level->l_thing.w_obj;
        t_chord *start_chord = get_level_start_chord(level, true);
        t_chord *end_chord = get_level_end_chord(level, true);
        
        count ++;
        idx --;
        
        if (chord == end_chord)
            info[idx].type = k_XML_STOP;
        else if (chord == start_chord)
            info[idx].type = k_XML_START;
        else
            info[idx].type = k_XML_CONTINUE;
        
        info[idx].placement = prop->direction;
        
        screen_duration = prop->tupletinfo.tuplet_graphical_unit;
        num_dots = 0;
        is_duration_drawable(r_ob, prop->tupletinfo.tuplet_graphical_unit, &screen_duration, &num_dots);
        
        info[idx].normal_type = screen_duration;
        info[idx].normal_dots = num_dots;
        info[idx].normal_notes = chord->overall_tuplet_ratio.r_num * prop->tupletinfo.tuplet_multiplier.r_num;
        info[idx].actual_notes = chord->overall_tuplet_ratio.r_den * prop->tupletinfo.tuplet_multiplier.r_num;
        
        info[idx].tuplet_actual_type = info[idx].tuplet_normal_type = screen_duration;
        info[idx].tuplet_actual_dots = info[idx].tuplet_normal_dots = num_dots;
        info[idx].tuplet_actual_number = prop->tupletinfo.tuplet_local_ratio.r_den * prop->tupletinfo.tuplet_multiplier.r_num;
        info[idx].tuplet_normal_number = prop->tupletinfo.tuplet_local_ratio.r_num * prop->tupletinfo.tuplet_multiplier.r_num;
        
        level = get_innermost_tuplet_level(level->l_owner);
    }
    
    bach_copyptr(&info[idx], info, count * sizeof(t_xml_chord_tuplet_info));

    return count;
}


t_xml_chord_beam_info get_xml_chord_beam_info(t_notation_obj *r_ob, t_chord *chord){
    t_xml_chord_beam_info info;
    t_llll *level = chord->rhythmic_tree_elem ? chord->rhythmic_tree_elem->l_parent : NULL;
    long last_beam_number = chord->beams_depth + 1, i = 0, chord_beam_depth = chord->beams_depth;
    char firsttime = true;
    
    info.num_beams = chord_beam_depth;
    last_beam_number = CLAMP(last_beam_number, 0, CONST_MAX_BEAMS);
    
    while (level){
        if (level->l_thing.w_obj) {
            t_rhythm_level_properties *prop = (t_rhythm_level_properties *)level->l_thing.w_obj;
            if (prop->beam_number > 0 && prop->beam_number < CONST_MAX_BEAMS){
                t_chord *level_start_chord = get_level_start_chord(level, true);
                t_chord *level_end_chord = get_level_end_chord(level, true);

                if (last_beam_number > prop->beam_number) {
                    if (last_beam_number > prop->beam_number + 1) {
                        if (firsttime) {
                            t_measure *meas = chord->parent;
                            t_beam *beam;
                            char tick_direction = 0;
                            
                            // looking for a tick 
                            for (beam = meas->firstbeam; beam; beam = beam->next) {
                                if (beam->beam_start_chord == chord && beam->is_tick){
                                    tick_direction = beam->tick_direction;
                                    break;
                                }
                            }
                            
                            for (i = last_beam_number - 1; i > prop->beam_number; i--)
                                info.beam_type[i - 1] = (tick_direction > 0 ? k_XML_HOOK_RIGHT : k_XML_HOOK_LEFT);
                        } else {
                            for (i = last_beam_number - 1; i > prop->beam_number; i--)
                                info.beam_type[i - 1] = info.beam_type[last_beam_number - 1];
                        }
                    }
                    
                    info.beam_type[prop->beam_number - 1] = (chord == level_start_chord ? k_XML_START : (chord == level_end_chord ? k_XML_STOP : k_XML_CONTINUE));
                    last_beam_number = prop->beam_number;
                } 
                
                if (firsttime)
                    firsttime = false;
            }
            if (is_level_grace(level))
                break;
        }
        level = level->l_owner ? level->l_owner->l_parent : NULL;
    }
    
    for (i = last_beam_number - 1; i > 0; i--)
        info.beam_type[i - 1] = info.beam_type[last_beam_number - 1];
        
    return info;
}



double breakpoint_get_absolute_onset(t_notation_obj *r_ob, t_bpt *bpt)
{
    if (!bpt->owner)
        return 0;
    
    if (bpt->owner->parent->is_score_chord) {
        double tot_dur = r_ob->dl_spans_ties ? get_all_tied_chord_sequence_duration_ms(bpt->owner->parent, false) : bpt->owner->parent->duration_ms;
        return chord_get_onset_ms(bpt->owner->parent) + bpt->rel_x_pos * tot_dur;
    } else
        return bpt->owner->parent->onset + bpt->rel_x_pos * bpt->owner->duration;
}


t_llll *get_header(t_llll *whole_content, char keep_notation_obj_router)
{
    t_llllelem *elem = whole_content->l_head;
    t_llll *out = llll_get();
    
    while (elem && hatom_gettype(&elem->l_hatom) == H_SYM) {
        if (keep_notation_obj_router)
            llll_appendhatom_clone(out, &elem->l_hatom, 0, WHITENULL_llll);
        elem = elem->l_next;
    }

    while (elem && hatom_gettype(&elem->l_hatom) == H_LLLL && hatom_getllll(&elem->l_hatom)->l_head && hatom_gettype(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == H_SYM){
        llll_appendhatom_clone(out, &elem->l_hatom, 0, WHITENULL_llll);
        elem = elem->l_next;
    }
    return out;
}

long header_offset(t_llllelem **first_nonheader_elem){
    t_llllelem *elem = *first_nonheader_elem;
    long count = 0;
    
    while (elem && hatom_gettype(&elem->l_hatom) == H_SYM) {
        count++;
        elem = elem->l_next;
    }
    
    while (elem && hatom_gettype(&elem->l_hatom) == H_LLLL && hatom_getllll(&elem->l_hatom)->l_head && hatom_gettype(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == H_SYM){
        count++;
        elem = elem->l_next;
    }

    *first_nonheader_elem = elem;
    
    return count;
}

t_llllelem *get_first_nonheader_elem(t_llll *ll){
    t_llllelem *elem = ll->l_head;
    header_offset(&elem);
    return elem;
}

t_llll *get_body(t_llll *ll){
    t_llllelem *elem;
    t_llll *out = llll_clone(ll); 

    elem = get_first_nonheader_elem(out);
    if (elem) 
        elem = elem->l_prev;
    while (elem) {
        t_llllelem *prev = elem->l_prev;
        llll_destroyelem(elem);
        elem = prev;
    }
    return out;
}


void notationobj_redraw(t_notation_obj *r_ob)
{
//    dev_post("->Redraw");
    jbox_redraw((t_jbox *) r_ob);
}


void notationobj_invalidate_notation_static_layer_and_redraw(t_notation_obj *r_ob)
{
    if (r_ob->obj_type != k_NOTATION_OBJECT_SLOT) {
 //       dev_post("-> Invalidate");
        jbox_invalidate_layer((t_object *)r_ob, NULL, gensym("static_layer1"));
        jbox_invalidate_layer((t_object *)r_ob, NULL, gensym("static_layer2"));
    }
    notationobj_redraw(r_ob);
}

// direction = 0: horizontal, direction = 1: vertical
void notationobj_scroll(t_notation_obj *r_ob, t_symbol *direction, double amount, t_symbol *unit, char delta)
{
    if (direction == gensym("horizontal") || direction == gensym("h")) {
        if (unit == gensym("pixel")) {
            if (delta)
                r_ob->hscrollbar_x += amount;
            else
                r_ob->hscrollbar_x = amount;
            redraw_hscrollbar(r_ob, 0);
        } else if (unit == gensym("normalizedpixel")) {
            amount *= r_ob->zoom_y;
            if (delta)
                r_ob->hscrollbar_x += amount;
            else
                r_ob->hscrollbar_x = amount;
            redraw_hscrollbar(r_ob, 0);
        } else if (unit == gensym("relative")) {
            if (delta)
                r_ob->hscrollbar_pos += amount;
            else
                r_ob->hscrollbar_pos = amount;
            redraw_hscrollbar(r_ob, 1);
        }
    } else if (direction == gensym("vertical") || direction == gensym("v")) {
        if (unit == gensym("pixel")) {
            if (delta)
                r_ob->vscrollbar_y += amount;
            else
                r_ob->vscrollbar_y = amount;
            redraw_vscrollbar(r_ob, 0);
        } else if (unit == gensym("normalizedpixel")) {
            amount *= r_ob->zoom_y;
            if (delta)
                r_ob->vscrollbar_y += amount;
            else
                r_ob->vscrollbar_y = amount;
            redraw_vscrollbar(r_ob, 0);
        } else if (unit == gensym("relative")) {
            if (delta)
                r_ob->vscrollbar_pos += amount;
            else
                r_ob->vscrollbar_pos = amount;
            redraw_vscrollbar(r_ob, 1);
        }
    }
}

void notationobj_scroll_from_gimme(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *ll = llllobj_parse_llll((t_object *)r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    t_symbol *direction = gensym("horizontal");
    t_symbol *unit = gensym("pixel");
    long delta = 0;
    llll_parseargs_and_attrs_destructive((t_object *) r_ob, ll, "ssi", gensym("direction"), &direction, gensym("unit"), &unit, gensym("delta"), &delta);
    if (ll && ll->l_head) {
        t_llllelem *el = ll->l_head;
        if (hatom_gettype(&el->l_hatom) == H_SYM) {
            direction = hatom_getsym(&el->l_hatom);
            el = el->l_next;
        }
        if (el) {
            notationobj_scroll(r_ob, direction, hatom_getdouble(&el->l_hatom), unit, delta);
        }
    }
    llll_free(ll);
}


void get_playhead_ypos(t_notation_obj *r_ob, t_rect rect, double *y1, double *y2){
    *y1 = r_ob->j_inset_y + 10 * r_ob->zoom_y;
    *y2 = rect.height - (CONST_XSCROLLBAR_UHEIGHT + 10) * r_ob->zoom_y;
}

t_notation_item *get_next_item_to_play(t_notation_obj *r_ob, double current_ms){
    t_notation_item *nextitemtoplay = NULL;
    double best_difference = 0.;
    t_voice *voice; 
    t_chord *temp_ch;
    
    if (r_ob->play_markers) {
        t_marker *marker;
        for (marker = r_ob->marker_play_cursor ? r_ob->marker_play_cursor->next : r_ob->firstmarker; marker; marker = marker->next){
            if (marker->position_ms < current_ms) {
                // we don't have to play it, but we update our chord_play_cursor
                r_ob->marker_play_cursor = marker;
            } else {
                if (should_element_be_played(r_ob, (t_notation_item *)marker)) {
                    if (marker->position_ms >= current_ms && (!nextitemtoplay || marker->position_ms - current_ms < best_difference)) {
                        best_difference = marker->position_ms - current_ms;
                        nextitemtoplay = (t_notation_item *)marker;
                    } else if (marker->position_ms >= current_ms) {
                        break;
                    }
                }
            }
        }
    }
    
    if (r_ob->play_measures && r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_measure *measure;
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)){
            for (measure = r_ob->measure_play_cursor[voice->number] ? measure_get_next(r_ob->measure_play_cursor[voice->number]) :
                 ((t_scorevoice *)voice)->firstmeasure;
                 measure; measure = measure_get_next(measure)){
                
                double measure_onset = notation_item_get_onset_ms(r_ob, (t_notation_item *)measure);
                if (measure_onset < current_ms) {
                    // we don't have to play it, but we update our chord_play_cursor
                    if (voice->number >= 0 && voice->number < CONST_MAX_VOICES)
                        r_ob->measure_play_cursor[voice->number] = measure;
                    else
                        notationobj_throw_issue(r_ob);
                } else if (should_element_be_played(r_ob, (t_notation_item *)measure)) {
                    if (measure_onset >= current_ms && (!nextitemtoplay || measure_onset - current_ms < best_difference)) {
                        best_difference = measure_onset - current_ms;
                        nextitemtoplay = (t_notation_item *)measure;
                    } else if (measure_onset >= current_ms) {
                        break;
                    }
                }
            }
        }
    }
    
    if (r_ob->play_tempi && r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        t_tempo *tempo;
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)){
            for (tempo = r_ob->tempo_play_cursor[voice->number] ? tempo_get_next(r_ob->tempo_play_cursor[voice->number]) :
                 (((t_scorevoice *)voice)->firstmeasure ? ((t_scorevoice *)voice)->firstmeasure->firsttempo : NULL);
                 tempo; tempo = tempo_get_next(tempo)){
                
                if (tempo->onset < current_ms) {
                    // we don't have to play it, but we update our chord_play_cursor
                    if (voice->number >= 0 && voice->number < CONST_MAX_VOICES)
                        r_ob->tempo_play_cursor[voice->number] = tempo;
                    else
                        notationobj_throw_issue(r_ob);
                } else if (should_element_be_played(r_ob, (t_notation_item *)tempo)) {
                    if (tempo->onset >= current_ms && (!nextitemtoplay || tempo->onset - current_ms < best_difference)) {
                        best_difference = tempo->onset - current_ms;
                        nextitemtoplay = (t_notation_item *)tempo;
                    } else if (tempo->onset >= current_ms) {
                        break;
                    }
                }
            }
        }
    }

    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)){
        for (temp_ch = r_ob->chord_play_cursor[voice->number] ? chord_get_next(r_ob->chord_play_cursor[voice->number]) : 
                                                                        (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? ((t_rollvoice *)voice)->firstchord : (((t_scorevoice *)voice)->firstmeasure ? ((t_scorevoice *)voice)->firstmeasure->firstchord : NULL));
             temp_ch; temp_ch = chord_get_next(temp_ch)){
            
//            check_chord(r_ob, temp_ch);
            
            if (temp_ch->onset < current_ms) {
                // we don't have to play it, but we update our chord_play_cursor
                if (voice->number >= 0 && voice->number < CONST_MAX_VOICES)
                    r_ob->chord_play_cursor[voice->number] = temp_ch;
                else
                    notationobj_throw_issue(r_ob);
            } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE &&
                       ((temp_ch->r_sym_duration.r_num < 0 && !r_ob->play_rests_separately && is_chord_preceded_by_rest(r_ob, temp_ch, 0)) || 
                        (temp_ch->r_sym_duration.r_num >= 0 && !r_ob->play_tied_elements_separately && chord_is_all_tied_from(temp_ch, 0)))) {
                // nothing to do, actually, this is a tied-from chord, we ignore it. 
                // but we do NOT update the cursor, since we're not sure the first of the tied-chord-sequence starts before the cursor
            } else {
                if (should_element_be_played(r_ob, (t_notation_item *)temp_ch)) {
                    if (temp_ch->onset >= current_ms && (!nextitemtoplay || temp_ch->onset - current_ms < best_difference)) {
                        best_difference = temp_ch->onset - current_ms;
                        nextitemtoplay = (t_notation_item *)temp_ch;
                    } else if (temp_ch->onset >= current_ms) {
                        break;
                    }
                }
            }
            
        }
    }
    
    if (r_ob->use_loop_region && r_ob->show_loop_region) {
        double nextitemonset = nextitemtoplay ? notation_item_get_onset_ms(r_ob, nextitemtoplay) : 0;
        if (!r_ob->dont_schedule_loop_start && r_ob->loop_region.start.position_ms >= current_ms) {
            if (!nextitemtoplay || nextitemonset >= r_ob->loop_region.start.position_ms)
                return &r_ob->loop_region.start.r_it;
        }
        if (!r_ob->dont_schedule_loop_end &&r_ob->loop_region.end.position_ms >= current_ms) {
            if (!nextitemtoplay || nextitemonset >= r_ob->loop_region.end.position_ms)
                return &r_ob->loop_region.end.r_it;
        }
    }
    
    return nextitemtoplay;
}


void check_correct_scheduling_fn(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr)
{
    t_notation_obj *r_ob = (man->bach_managing ? (t_notation_obj *)man->owner : NULL);
    check_correct_scheduling(r_ob, true);
}


void check_correct_scheduling(t_notation_obj *r_ob, char also_lock_general_mutex){
    if (r_ob->playing) {
        double this_clock_ms, supposed_next_item_to_play_onset = 0;
        t_notation_item *supposed_next_item_to_play;
        char temp1, temp2;
        
        setclock_getftime(r_ob->setclock->s_thing, &this_clock_ms);
        this_clock_ms = this_clock_ms - r_ob->start_play_time + r_ob->play_head_start_ms;
        
        if (r_ob->scheduled_item && this_clock_ms > r_ob->scheduled_ms) 
            // very special case: if there's a delay and we should have already played the scheduled_ms, so we just play them!
            return;
        
        if (also_lock_general_mutex)
            lock_general_mutex(r_ob);
        
        temp1 = r_ob->dont_schedule_loop_start, temp2 = r_ob->dont_schedule_loop_end;
        r_ob->dont_schedule_loop_start = r_ob->dont_schedule_loop_end = false;

        if (r_ob->playhead_cant_trespass_loop_end && this_clock_ms >= r_ob->loop_region.end.position_ms) {
            // we force the loop end to be scheduled. 
            // see the documentation of t_notation_obj::playhead_cant_trespass_loop_end to understand why!
            supposed_next_item_to_play = &r_ob->loop_region.end.r_it;
        } else
            supposed_next_item_to_play = get_next_item_to_play(r_ob, this_clock_ms);

        r_ob->dont_schedule_loop_start = temp1; 
        r_ob->dont_schedule_loop_end = temp2; 
        
        if (supposed_next_item_to_play)
            supposed_next_item_to_play_onset = notation_item_get_onset_ms(r_ob, supposed_next_item_to_play);
        
        if (supposed_next_item_to_play != r_ob->scheduled_item ||
            (!supposed_next_item_to_play && !r_ob->scheduled_item && (r_ob->play_head_fixed_end_ms < 0) && r_ob->length_ms - r_ob->scheduled_ms > 1) ||
            (supposed_next_item_to_play && fabs(r_ob->scheduled_ms - supposed_next_item_to_play_onset) > 1)){ // 1 ms is our threshold for not rescheduling
            
            //            post("incorrect scheduling: this_clock_ms = %.2f, old_sched_ch onset: %.2f, new_sched_ch onset: %.2f", this_clock_ms, r_ob->scheduled_chord ? r_ob->scheduled_chord->onset : -1, supposed_next_chord_to_play ? supposed_next_chord_to_play->onset : -1);
            
            double new_scheduling_ms = supposed_next_item_to_play ? supposed_next_item_to_play_onset : (r_ob->play_head_fixed_end_ms > 0 ? r_ob->play_head_fixed_end_ms : r_ob->length_ms);
            double new_scheduling_interval = new_scheduling_ms - this_clock_ms;
            
            r_ob->scheduled_item = supposed_next_item_to_play;
            r_ob->scheduled_ms = new_scheduling_ms;
            
#ifdef CONFIGURATION_Development
            {
                if (r_ob->scheduled_item && r_ob->scheduled_item->type == k_CHORD && r_ob->obj_type == k_NOTATION_OBJECT_SCORE && !((t_chord *)r_ob->scheduled_item)->is_score_chord) {
                    char foo = 8;
                    foo = 9;
                    dev_post("bruttissimo2!!!");
                }
            }
#endif
            
            if (r_ob->theoretical_play_step_ms <= 0){
                // just one step per scheduled event
                r_ob->play_num_steps = 1;
                r_ob->play_step_ms = new_scheduling_interval;
            } else {
                // fluid steps for redraw
                r_ob->play_num_steps = MAX(1, round(new_scheduling_interval / r_ob->theoretical_play_step_ms));
                r_ob->play_step_ms = new_scheduling_interval/r_ob->play_num_steps;
            }
            
            //            post("  . first_time: %f, now time: %f", r_ob->start_play_time, this_clock_ms);
            //            post("  . new_scheduled_interval: %f", r_ob->play_step_ms);
            
            r_ob->play_step_count = 0;
            r_ob->play_head_ms = this_clock_ms;
            
            r_ob->dont_schedule_loop_end = r_ob->dont_schedule_loop_start = false;
            
            if (also_lock_general_mutex)
                unlock_general_mutex(r_ob);
            setclock_unset(r_ob->setclock->s_thing, r_ob->m_clock);
            setclock_fdelay(r_ob->setclock->s_thing, r_ob->m_clock, r_ob->play_step_ms);
        } else {
            if (also_lock_general_mutex)
                unlock_general_mutex(r_ob);
        }
    }
}

t_llll *get_loop_region_as_llll(t_notation_obj *r_ob, char router_sym)
{
    t_llll *loop = llll_get();
    if (router_sym)
        llll_appendsym(loop, _llllobj_sym_loop);
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
        llll_appenddouble(loop, r_ob->loop_region.start.position_ms, 0, WHITENULL_llll);
        llll_appenddouble(loop, r_ob->loop_region.end.position_ms, 0, WHITENULL_llll);
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
        t_llll *start = get_timepoint_as_llll(r_ob, r_ob->loop_region.start.timepoint);
        t_llll *end = get_timepoint_as_llll(r_ob, r_ob->loop_region.end.timepoint);

        llll_appendllll(loop, start, 0, WHITENULL_llll);
        llll_appendllll(loop, end, 0, WHITENULL_llll);
    }
    return loop;
}

void check_unplayed_notes(t_notation_obj *r_ob, double current_ms){
    t_llllelem *playedelem = r_ob->notes_being_played->l_head;
    char must_repaint = 0;

    while (playedelem){
        t_llllelem *nextelem = playedelem->l_next;
        t_note *note = (t_note *)hatom_getobj(&playedelem->l_hatom);
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
            if (note->parent->onset + note->duration <= current_ms || note->parent->onset > current_ms) {
                note->played = false;
                note->parent->played = false;
                llll_destroyelem(playedelem);
                if (PLAY_REDRAWS_AT_NOTES_END && r_ob->highlight_played_notes)
                    must_repaint = 1;
            }
        } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
            t_note *fst_tied_note = r_ob->play_tied_elements_separately ? note : note_get_first_in_tieseq(note);
            t_note *lst_tied_note = r_ob->play_tied_elements_separately ? note : note_get_last_in_tieseq(note);
            if (lst_tied_note->parent->onset + lst_tied_note->parent->duration_ms <= current_ms || fst_tied_note->parent->onset > current_ms) {
                t_note *temp;
                for (temp = fst_tied_note; temp && temp != WHITENULL; temp = temp->tie_to){
                    temp->played = false;
                    temp->parent->played = false;
                    if (temp == lst_tied_note)
                        break;
                }
                llll_destroyelem(playedelem);
                if (PLAY_REDRAWS_AT_NOTES_END && r_ob->highlight_played_notes)
                    must_repaint = 1;
            }
        }
        playedelem = nextelem;
    }
    
    if (must_repaint)
        notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
}


t_notation_item *notation_item_get_ancestor_of_at_least_a_certain_type(t_notation_obj *r_ob, t_notation_item *item, long parent_type)
{
    
    if (item->type == parent_type)
        return item;    // easy case
    
    switch (item->type) {
        case k_MARKER:
            return item;
        case k_VOICE:
            return item;
        case k_MEASURE:
            if (parent_type == k_VOICE)
                return (t_notation_item *) ((t_measure *)item)->voiceparent;
            else
                return item;
        case k_MEASURE_END_BARLINE:
            if (parent_type == k_VOICE)
                return (t_notation_item *) ((t_measure_end_barline *)item)->owner->voiceparent;
            else
                return (t_notation_item *) ((t_measure_end_barline *)item)->owner;
        case k_TEMPO:
            if (parent_type == k_VOICE)
                return (t_notation_item *) ((t_tempo *)item)->owner->voiceparent;
            else
                return (t_notation_item *) ((t_tempo *)item)->owner;
        case k_CHORD:
            if (parent_type == k_MEASURE)
                return (t_notation_item *) ((t_chord *)item)->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) ((t_chord *)item)->voiceparent;
                else
                    return (t_notation_item *) ((t_chord *)item)->parent->voiceparent;
            } else
                return item;
        case k_LYRICS:
            if (parent_type == k_CHORD)
                return (t_notation_item *) ((t_lyrics *)item)->owner;
            else if (parent_type == k_MEASURE)
                return (t_notation_item *) ((t_lyrics *)item)->owner->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) ((t_lyrics *)item)->owner->voiceparent;
                else
                    return (t_notation_item *) ((t_lyrics *)item)->owner->parent->voiceparent;
            } else
                return item;
        case k_DYNAMICS:
            if (parent_type == k_CHORD)
                return (t_notation_item *)notation_item_get_parent_chord(r_ob, ((t_dynamics *)item)->owner_item);
            else if (parent_type == k_MEASURE)
                return (t_notation_item *) notation_item_get_parent_chord(r_ob, ((t_dynamics *)item)->owner_item)->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) notation_item_get_parent_chord(r_ob, ((t_dynamics *)item)->owner_item)->voiceparent;
                else
                    return (t_notation_item *) notation_item_get_parent_chord(r_ob, ((t_dynamics *)item)->owner_item)->parent->voiceparent;
            } else
                return item;
        case k_NOTE:
            if (parent_type == k_CHORD)
                return (t_notation_item *) ((t_note *)item)->parent;
            else if (parent_type == k_MEASURE)
                return (t_notation_item *) ((t_note *)item)->parent->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) ((t_note *)item)->parent->voiceparent;
                else
                    return (t_notation_item *) ((t_note *)item)->parent->parent->voiceparent;
            } else
                return item;
        case k_DURATION_LINE:
            if (parent_type == k_NOTE)
                return (t_notation_item *) ((t_duration_line *)item)->owner;
            else if (parent_type == k_CHORD)
                return (t_notation_item *) ((t_duration_line *)item)->owner->parent;
            else if (parent_type == k_MEASURE)
                return (t_notation_item *) ((t_duration_line *)item)->owner->parent->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) ((t_duration_line *)item)->owner->parent->voiceparent;
                else
                    return (t_notation_item *) ((t_duration_line *)item)->owner->parent->parent->voiceparent;
            } else
                return item;
        case k_PITCH_BREAKPOINT:
            if (parent_type == k_NOTE)
                return (t_notation_item *) ((t_bpt *)item)->owner;
            else if (parent_type == k_CHORD)
                return (t_notation_item *) ((t_bpt *)item)->owner->parent;
            else if (parent_type == k_MEASURE)
                return (t_notation_item *) ((t_bpt *)item)->owner->parent->parent;
            else if (parent_type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                    return (t_notation_item *) ((t_bpt *)item)->owner->parent->voiceparent;
                else
                    return (t_notation_item *) ((t_bpt *)item)->owner->parent->parent->voiceparent;
            } else
                return item;
        case k_ARTICULATION:
            if (((t_articulation *)item)->owner->type == k_NOTE) {
                if (parent_type == k_NOTE)
                    return ((t_articulation *)item)->owner;
                else if (parent_type == k_CHORD)
                    return (t_notation_item *) ((t_note *)((t_articulation *)item)->owner)->parent;
                else if (parent_type == k_MEASURE)
                    return (t_notation_item *) ((t_note *)((t_articulation *)item)->owner)->parent->parent;
                else if (parent_type == k_VOICE) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                        return (t_notation_item *) ((t_note *)((t_articulation *)item)->owner)->parent->voiceparent;
                    else
                        return (t_notation_item *) ((t_note *)((t_articulation *)item)->owner)->parent->parent->voiceparent;
                } else
                    return item;
            } else if (((t_articulation *)item)->owner->type == k_CHORD) {
                if (parent_type == k_NOTE)
                    return ((t_articulation *)item)->owner;
                else if (parent_type == k_CHORD)
                    return ((t_articulation *)item)->owner;
                else if (parent_type == k_MEASURE)
                    return (t_notation_item *) ((t_chord *)((t_articulation *)item)->owner)->parent;
                else if (parent_type == k_VOICE) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
                        return (t_notation_item *) ((t_chord *)((t_articulation *)item)->owner)->voiceparent;
                    else
                        return (t_notation_item *) ((t_chord *)((t_articulation *)item)->owner)->parent->voiceparent;
                } else
                    return item;
            } else 
                return item;
        default:
            return item;
    }
}


char notation_item_is_ancestor_of(t_notation_obj *r_ob, t_notation_item *dad, t_notation_item *son)
{
    switch (son->type) {
        case k_MARKER:
            return 0;
        case k_VOICE:
            return 0;
        case k_MEASURE:
            if (dad->type == k_VOICE && ((t_voice *)dad) == (t_voice *)((t_measure *)son)->voiceparent)
                return 1;
            else 
                return 0;
        case k_MEASURE_END_BARLINE:
            if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_measure_end_barline *)son)->owner)
                return 1;
            else if (dad->type == k_VOICE && ((t_voice *)dad) == (t_voice *)((t_measure_end_barline *)son)->owner->voiceparent)
                return 1;
            else 
                return 0;
        case k_TEMPO:
            if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_tempo *)son)->owner)
                return 1;
            else if (dad->type == k_VOICE && ((t_voice *)dad) == (t_voice *)((t_tempo *)son)->owner->voiceparent)
                return 1;
            else 
                return 0;
        case k_CHORD:
            if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_chord *)son)->parent)
                return 1;
            else if (dad->type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_chord *)son)->voiceparent)
                    return 1;
                else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_chord *)son)->parent->voiceparent)
                    return 1;
                else
                    return 0;
            } else 
                return 0;
        case k_NOTE:
            if (dad->type == k_CHORD && ((t_chord *)dad) == ((t_note *)son)->parent)
                return 1;
            else if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_note *)son)->parent->parent)
                return 1;
            else if (dad->type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_note *)son)->parent->voiceparent)
                    return 1;
                else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_note *)son)->parent->parent->voiceparent)
                    return 1;
                else
                    return 0;
            } else 
                return 0;
        case k_DURATION_LINE:
            if (dad->type == k_NOTE && ((t_note *)dad) == ((t_duration_line *)son)->owner)
                return 1;
            else if (dad->type == k_CHORD && ((t_chord *)dad) == ((t_duration_line *)son)->owner->parent)
                return 1;
            else if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_duration_line *)son)->owner->parent->parent)
                return 1;
            else if (dad->type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_duration_line *)son)->owner->parent->voiceparent)
                    return 1;
                else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_duration_line *)son)->owner->parent->parent->voiceparent)
                    return 1;
                else
                    return 0;
            } else 
                return 0;
        case k_PITCH_BREAKPOINT:
            if (dad->type == k_NOTE && ((t_note *)dad) == ((t_bpt *)son)->owner)
                return 1;
            else if (dad->type == k_CHORD && ((t_chord *)dad) == ((t_bpt *)son)->owner->parent)
                return 1;
            else if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_bpt *)son)->owner->parent->parent)
                return 1;
            else if (dad->type == k_VOICE) {
                if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_bpt *)son)->owner->parent->voiceparent)
                    return 1;
                else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_bpt *)son)->owner->parent->parent->voiceparent)
                    return 1;
                else
                    return 0;
            } else 
                return 0;
        case k_ARTICULATION:
            if (((t_articulation *)son)->owner->type == k_NOTE) {
                if (dad->type == k_NOTE && ((t_note *)dad) == (t_note *)((t_articulation *)son)->owner)
                    return 1;
                else if (dad->type == k_CHORD && ((t_chord *)dad) == ((t_note *)((t_articulation *)son)->owner)->parent)
                    return 1;
                else if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_note *)((t_articulation *)son)->owner)->parent->parent)
                    return 1;
                else if (dad->type == k_VOICE) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_note *)((t_articulation *)son)->owner)->parent->voiceparent)
                        return 1;
                    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_note *)((t_articulation *)son)->owner)->parent->parent->voiceparent)
                        return 1;
                    else
                        return 0;
                } else 
                    return 0;
            } else if (((t_articulation *)son)->owner->type == k_CHORD) {
                if (dad->type == k_CHORD && ((t_chord *)dad) == (t_chord *)((t_articulation *)son)->owner)
                    return 1;
                else if (dad->type == k_MEASURE && ((t_measure *)dad) == ((t_chord *)((t_articulation *)son)->owner)->parent)
                    return 1;
                else if (dad->type == k_VOICE) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && ((t_voice *)dad) == (t_voice *)((t_chord *)((t_articulation *)son)->owner)->voiceparent)
                        return 1;
                    else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && ((t_voice *)dad) == (t_voice *)((t_chord *)((t_articulation *)son)->owner)->parent->voiceparent)
                        return 1;
                    else
                        return 0;
                } else 
                    return 0;
            } else 
                return 0;
        default:
            return 0;
    }
}
    


// depending on the selection, returns the notation items that must 
// ingroup undo!!!
// smallest_type is the element ID of the smallest element to track. This can only be k_CHORD, k_MEASURE or k_VOICE. 
// and if this is k_MEASURE it means that chords will not be put into *undo_items, but rather their measures
long selection_to_undo_notation_items(t_notation_obj *r_ob, t_notation_item ***undo_items, long smallest_type){
    t_notation_item *item;
    long num_flagged = 0, count = 0;
    
    if (!r_ob->firstselecteditem)
        return 0;

    for (item = r_ob->firstselecteditem; item; item = item->next_selected){
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_COUNT);
        count++;
    }
        
    num_flagged = count;
    *undo_items = (t_notation_item **)bach_newptr(num_flagged * sizeof(t_notation_item *)); // can't be more than this (*undo_items)[0]

    for (count = 0, item = r_ob->firstselecteditem; item; item = item->next_selected){
        t_notation_item *item_to_save = notation_item_get_ancestor_of_at_least_a_certain_type(r_ob, item, smallest_type);
        
        if (item_to_save->flags & k_FLAG_COUNT || notation_item_is_globally_locked(r_ob, item_to_save))
            continue;    // already added
        
        // check if we have already saved a parent or a son
        long i;
        char genealogy = 0;
        for (i = 0; i < count; i++){
            if (notation_item_is_ancestor_of(r_ob, (*undo_items)[i], item_to_save)){
                genealogy = 1; // item_to_save is son of an already saved item
                break;
            } else if (notation_item_is_ancestor_of(r_ob, item_to_save, (*undo_items)[i])){
                if (i < count - 1)
                    sysmem_copyptr(&(*undo_items)[i+1], &(*undo_items)[i], (count - i - 1) * sizeof(t_notation_item *));
                genealogy = -1; // item_to_save is dad of an already existing item, we remove this item
                count--;
            }
        }
        
        if (genealogy != 1) {
            if (count < num_flagged)
                (*undo_items)[count++] = item_to_save;
            item_to_save->flags = (e_bach_internal_notation_flags) (item_to_save->flags | k_FLAG_COUNT);
        }
    }
    
    for (item = r_ob->firstselecteditem; item; item = item->next_selected)
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_COUNT);

    return count;
}


t_undo_redo_information *build_undo_redo_information(long ID, e_element_types type, e_undo_modification_types modif_type, long voice_num, long meas_num, e_header_elems header_info, t_llll *content)
{
    t_undo_redo_information *out = (t_undo_redo_information *)bach_newptr(sizeof(t_undo_redo_information));
    out->n_it_ID = ID;
    out->n_it_type = type;
    out->modification_type = modif_type;
    out->n_it_content = content;
    out->voice_num = voice_num;
    out->meas_num = meas_num;
    out->header_info = header_info;
    return out;
}

long reverse_undo_op(long undo_operation){
    if (undo_operation == k_UNDO_OP_ADD_MEASURE)
        return k_UNDO_OP_DELETE_MEASURE;
    else if (undo_operation == k_UNDO_OP_ADD_CHORD)
        return k_UNDO_OP_DELETE_CHORD;
    else if (undo_operation == k_UNDO_OP_ADD_VOICE)
        return k_UNDO_OP_DELETE_VOICE;
    else if (undo_operation == k_UNDO_OP_ADD_MEASURES)
        return k_UNDO_OP_DELETE_MEASURES;
    else if (undo_operation == k_UNDO_OP_ADD_CHORDS)
        return k_UNDO_OP_DELETE_CHORDS;
    else if (undo_operation == k_UNDO_OP_ADD_VOICES)
        return k_UNDO_OP_DELETE_VOICES;
    else if (undo_operation == k_UNDO_OP_ADD_MARKER)
        return k_UNDO_OP_DELETE_MARKER;
    return undo_operation;
}


long make_undo_op_plural_for_undo(long undo_operation){
    if (undo_operation == k_UNDO_OP_ADD_MEASURE)
        return k_UNDO_OP_ADD_MEASURES;
    else if (undo_operation == k_UNDO_OP_CHANGE_MEASURE)
        return k_UNDO_OP_CHANGE_MEASURES;
    else if (undo_operation == k_UNDO_OP_DELETE_MEASURE)
        return k_UNDO_OP_DELETE_MEASURES;
    else if (undo_operation == k_UNDO_OP_ADD_CHORD)
        return k_UNDO_OP_ADD_CHORDS;
    else if (undo_operation == k_UNDO_OP_CHANGE_CHORD)
        return k_UNDO_OP_CHANGE_CHORDS;
    else if (undo_operation == k_UNDO_OP_DELETE_CHORD)
        return k_UNDO_OP_DELETE_CHORDS;
    else if (undo_operation == k_UNDO_OP_ADD_VOICE)
        return k_UNDO_OP_ADD_VOICES;
    else if (undo_operation == k_UNDO_OP_CHANGE_VOICE)
        return k_UNDO_OP_CHANGE_VOICES;
    else if (undo_operation == k_UNDO_OP_DELETE_VOICE)
        return k_UNDO_OP_DELETE_VOICES;
    return undo_operation;
}

char* get_string_for_tick(t_hatom *h, long maxdecimals){
    if (hatom_gettype(h) == H_OBJ) {
        char *out;
        t_undo_redo_information *info = (t_undo_redo_information *)hatom_getobj(h);
        long ID = info->n_it_ID;
        long type = info->n_it_type;
        long modif = info->modification_type;
        out = (char *)bach_newptr(20 * sizeof(char));    
        snprintf_zero(out, 20, "(%s%ld%s)", 
                        type == k_WHOLE_NOTATION_OBJECT ? "w" : (type == k_HEADER_DATA ? "h" : (type == k_MEASURE ? "m" : (type == k_CHORD ? "c" : (type == k_VOICE ? "v" : (type == k_NOTE ? "n" : "?"))))),
                        ID,
                        modif == k_UNDO_MODIFICATION_ADD ? "+" : (modif == k_UNDO_MODIFICATION_DELETE ? "-" : (modif == k_UNDO_MODIFICATION_CHANGE ? "~" : (modif == k_UNDO_MODIFICATION_CHANGE_FLAG ? "^" : (modif == k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER ? "*" : (modif == k_UNDO_MODIFICATION_CHANGE_NAME ? "§" : "?"))))));
        return out;
    } else if (hatom_gettype(h) == H_LONG) {
        char *out = undo_op_to_string(hatom_getlong(h));
        return out; 
    }
    return NULL;
}


void post_undo_redo_llll(t_notation_obj *r_ob, char what)
{
    llll_print_named(what == k_UNDO ? r_ob->undo_llll : r_ob->redo_llll, what == k_UNDO ? gensym("Current Undo") : gensym("Current Redo"), 0, 0, get_string_for_tick);
}


void clear_undo_redo_llll(t_notation_obj *r_ob, char what){
    t_llll *ll = NULL;
    if (what == k_UNDO)
        ll = r_ob->undo_llll;
    else if (what == k_REDO)
        ll = r_ob->redo_llll;
    
    if (ll) {
        t_llllelem *elem;
        for (elem = ll->l_head; elem; elem = elem->l_next)
            if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
                t_undo_redo_information *thisinfo = (t_undo_redo_information *)hatom_getobj(&elem->l_hatom);
                free_undo_redo_information(thisinfo);
            }
        llll_clear(ll);
    }
    if (what == k_UNDO)
        r_ob->num_undo_steps = 0;
    else if (what == k_REDO)
        r_ob->num_redo_steps = 0;
    r_ob->last_undo_marker = NULL;
}

// the new undo tick llll will have the form
// (ID1 itemtype1 modiftype1 voicenum measnum headerinfo CONTENT)
// what = -1 undo, what = 1 redo
// fromwhat = 0 : interface, fromwhat = 1 : we're creating this event because we have just undone/redone

long create_undo_redo_tick(t_notation_obj *r_ob, char what, char from_what, t_undo_redo_information *operation, char lock_undo_mutex)
{

    char must_unlock = lock_undo_mutex;
    
    if ((atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0) ||
        (what != k_UNDO && what != k_REDO)) {
        
        dev_post("Warning: undo/redo tick asked even if unnecessary, or wrong undo/redo tick asked!");
        free_undo_redo_information(operation);
        return 1;
    
    }
        
    if (r_ob->whole_obj_under_tick) {
//        dev_post("Whole object already under tick. No need for other undo ticks.");
        free_undo_redo_information(operation);
        return 1;
    }
    
    if (operation->n_it_type == k_WHOLE_NOTATION_OBJECT)
        r_ob->whole_obj_under_tick = true;
    
    if (lock_undo_mutex)
        if (systhread_mutex_trylock(r_ob->c_undo_mutex))
            must_unlock = false; // already locked

    if (what == k_UNDO && from_what == 0 && r_ob->redo_llll->l_size > 0)
        clear_undo_redo_llll(r_ob, k_REDO); // we empty the redo list

    llll_prependobj(what == k_UNDO ? r_ob->undo_llll : r_ob->redo_llll, operation, 0, WHITENULL_llll);
    
    #ifdef BACH_UNDO_DEBUG
        object_post((t_object *) r_ob, "- %s tick added.", what == k_UNDO ? "Undo" : "Redo");
        llll_post_named(operation->n_it_content, 0, 1, 2, gensym("Content"), NULL);
    #endif

    if (lock_undo_mutex && must_unlock)
        systhread_mutex_unlock(r_ob->c_undo_mutex);    
    
    return 0;
}


void prune_last_undo_step(t_notation_obj *r_ob, char lock_undo_mutex)
{
    remove_all_free_undo_ticks(r_ob, true);
    
    if (lock_undo_mutex)
        systhread_mutex_lock(r_ob->c_undo_mutex);

    if (r_ob->undo_llll->l_head) {
        t_llllelem *elem;
        long marker_val = -1;
        for (elem = r_ob->undo_llll->l_head->l_next; elem; elem = elem->l_next) {
            if (hatom_gettype(&elem->l_hatom) == H_LONG) {
                marker_val = hatom_getlong(&elem->l_hatom);
                llll_destroyelem(elem);
                break;
            }
        }
        if (marker_val > 0)
            hatom_setlong(&r_ob->undo_llll->l_head->l_hatom, marker_val);
    }
    
    if (lock_undo_mutex)
        systhread_mutex_unlock(r_ob->c_undo_mutex);
}


void check_num_undo_steps(t_notation_obj *r_ob)
{
#ifdef CONFIGURATION_Development
    long count1 = r_ob->num_undo_steps;
    long count2 = 0;
    t_llllelem *elem;
    for (elem = r_ob->undo_llll->l_head; elem; elem = elem->l_next) {
        if (hatom_gettype(&elem->l_hatom) == H_LONG)
            count2++;
    }
    if (count1 != count2) {
        char foo = 1;
        foo++;
    }
#endif
}


t_llllelem *create_undo_redo_step_marker(t_notation_obj *r_ob, char what, char from_what, long undo_op, char lock_undo_mutex)
{
    t_llllelem *res = NULL;

    if (atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0)
        return NULL;
    
    if (what != k_UNDO && what != k_REDO) 
        return NULL;
    
    if (lock_undo_mutex)
        systhread_mutex_lock(r_ob->c_undo_mutex);
    
    if (what == k_UNDO && from_what == 0 && r_ob->redo_llll->l_size > 0) {
        llll_clear(r_ob->redo_llll); // we empty the redo list
        r_ob->num_redo_steps = 0;
    }

    if (what == k_UNDO) {
        res = llll_prependlong(r_ob->undo_llll, undo_op, 0, WHITENULL_llll);
        r_ob->num_undo_steps++;
    } else {
        res = llll_prependlong(r_ob->redo_llll, undo_op, 0, WHITENULL_llll);
        r_ob->num_redo_steps++;
    }
    
    // checking if we have too many undo steps
    if (what == k_UNDO && atom_gettype(&r_ob->max_undo_steps) == A_LONG) {
        while (r_ob->undo_llll->l_tail && r_ob->num_undo_steps > atom_getlong(&r_ob->max_undo_steps)) {
            if (hatom_gettype(&r_ob->undo_llll->l_tail->l_hatom) == H_LONG) {
                r_ob->num_undo_steps--;
                if (r_ob->last_undo_marker == r_ob->undo_llll->l_tail)
                    r_ob->last_undo_marker = NULL;
                if (res == r_ob->undo_llll->l_tail)
                    res = NULL;
            } else if (hatom_gettype(&r_ob->undo_llll->l_tail->l_hatom) == H_OBJ) {
                t_undo_redo_information *info = (t_undo_redo_information *)hatom_getobj(&r_ob->undo_llll->l_tail->l_hatom);
                free_undo_redo_information(info);
            }
            llll_destroyelem(r_ob->undo_llll->l_tail);
        }
    }

    if (what == k_UNDO) {
        llll_clear(r_ob->undo_notation_items_under_tick);
        r_ob->undo_header_elements_under_tick = 0;
    }

    r_ob->whole_obj_under_tick = false;

    #ifdef BACH_UNDO_DEBUG
        char *buf = undo_op_to_string(undo_op);
        object_post((t_object *) r_ob, "- %s marker for '%s' added.", what == k_UNDO ? "Undo" : "Redo", buf);
        object_post((t_object *) r_ob, "  Total number of undo steps: %ld", r_ob->num_undo_steps);
        object_post((t_object *) r_ob, "  Total number of redo steps: %ld", r_ob->num_redo_steps);
        post_undo_redo_llll(r_ob, k_UNDO);
        post_undo_redo_llll(r_ob, k_REDO);
        bach_freeptr(buf);
    #endif

    if (lock_undo_mutex)
        systhread_mutex_unlock(r_ob->c_undo_mutex);    
    
    return res;
}

void free_undo_redo_information(t_undo_redo_information *operation)
{
    if (operation->n_it_content)
        llll_free(operation->n_it_content);
    if (operation)
        bach_freeptr(operation);
}

void create_header_undo_tick(t_notation_obj *r_ob, e_header_elems what)
{
    if (r_ob->inhibited_undo)
        return;
    
    if (atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0)
        return;

    if (r_ob->undo_header_elements_under_tick & what) // no need to add a tick for this header element: already added!!
        return;
    
    r_ob->undo_header_elements_under_tick |= what;
    t_llll *content = get_notation_obj_header_as_llll(r_ob, what, true, true, true, k_CONSIDER_FOR_UNDO);
    t_undo_redo_information *operation = build_undo_redo_information(0, k_HEADER_DATA, k_UNDO_MODIFICATION_CHANGE, 0, 0, what, content);
    create_undo_redo_tick(r_ob, k_UNDO, 0, operation, true);
}


// only works with chords, notes and measures
t_llll *notation_item_get_values_as_llll_for_undo(t_notation_obj *r_ob, t_notation_item *item){
    if (item->type == k_MEASURE)
        return measure_get_values_as_llll(r_ob, (t_measure *)item, k_CONSIDER_FOR_UNDO, true, true);
    else if (item->type == k_CHORD) {
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
            return get_rollchord_values_as_llll(r_ob, (t_chord *)item, k_CONSIDER_FOR_UNDO);
        else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            return get_scorechord_values_as_llll(r_ob, (t_chord *)item, k_CONSIDER_FOR_UNDO, false);
    } else if (item->type == k_NOTE) {
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
            return get_rollnote_values_as_llll(r_ob, (t_note *) item, k_CONSIDER_FOR_UNDO);
        else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            return get_scorenote_values_as_llll(r_ob, (t_note *)item, k_CONSIDER_FOR_UNDO);
        else if (r_ob->obj_type == k_NOTATION_OBJECT_SLOT)
            return get_uislotnote_values_as_llll(r_ob, (t_note *)item, k_CONSIDER_FOR_UNDO);
    }
    return NULL;
}


// only works with chords, voices and measures
long notation_item_get_undo_op(t_notation_obj *r_ob, t_notation_item *item, char modif_type){
    if (item->type == k_MEASURE) {
        switch (modif_type) {
            case k_UNDO_MODIFICATION_ADD:
                return k_UNDO_OP_DELETE_MEASURE;
            case k_UNDO_MODIFICATION_DELETE:
                return k_UNDO_OP_ADD_MEASURE;
            default:
                return k_UNDO_OP_CHANGE_MEASURE;
        } 
    } else if (item->type == k_CHORD) {
        switch (modif_type) {
            case k_UNDO_MODIFICATION_ADD:
                return k_UNDO_OP_DELETE_CHORD;
            case k_UNDO_MODIFICATION_DELETE:
                return k_UNDO_OP_ADD_CHORD;
            default:
                return k_UNDO_OP_CHANGE_CHORD;
        } 
    } else if (item->type == k_VOICE) {
        switch (modif_type) {
            case k_UNDO_MODIFICATION_ADD:
                return k_UNDO_OP_DELETE_VOICE;
            case k_UNDO_MODIFICATION_DELETE:
                return k_UNDO_OP_ADD_VOICE;
            default:
                return k_UNDO_OP_CHANGE_VOICE;
        } 
    }
    return k_UNDO_OP_UNKNOWN;
}

void notation_item_to_measure_and_voice_numbers(t_notation_obj *r_ob, t_notation_item *item, long *measure_num, long *voice_num){
        
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE){
        switch (item->type) {
            case k_CHORD:
                *measure_num = ((t_chord *)item)->parent->measure_number;
                *voice_num = ((t_chord *)item)->parent->voiceparent->v_ob.number;
                return;
            case k_MEASURE:
                *measure_num = ((t_measure *)item)->measure_number;
                *voice_num = ((t_measure *)item)->voiceparent->v_ob.number;
                return;
            case k_NOTE:
                *measure_num = ((t_note *)item)->parent->parent->measure_number;
                *voice_num = ((t_note *)item)->parent->parent->voiceparent->v_ob.number;
                return;
            case k_VOICE:
                *measure_num = 0;
                *voice_num = ((t_voice *)item)->number;
                return;
            default:
                break;
        }
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL){
        switch (item->type) {
            case k_CHORD:
                *measure_num = 0;
                *voice_num = ((t_chord *)item)->voiceparent->v_ob.number;
                return;
            case k_NOTE:
                *measure_num = 0;
                *voice_num = ((t_note *)item)->parent->voiceparent->v_ob.number;
                return;
            case k_VOICE:
                *measure_num = 0;
                *voice_num = ((t_voice *)item)->number;
                return;
            case k_MARKER:
                *measure_num = 0;
                *voice_num = 0;
                return;
            default:
                break;
        }
    }
}


void create_simple_notation_item_undo_tick(t_notation_obj *r_ob, t_notation_item *item, e_undo_modification_types modif_type){
    t_undo_redo_information *operation;
    t_llll *content = NULL;
    long meas_number = 0, voice_number = 0;
    t_llllelem *tick_el = NULL;
    
    if (r_ob->inhibited_undo)
        return;

    if (!item)
        return;
        
    if (atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0)
        return;
    
    if ((tick_el = notation_item_to_undo_tick(r_ob, item)) && (tick_el->l_thing.w_long == modif_type))
        return;
    

    if (item->type != k_MEASURE && item->type != k_CHORD && !(item->type == k_NOTE && (r_ob->obj_type == k_NOTATION_OBJECT_SLOT || modif_type == k_UNDO_MODIFICATION_CHANGE_NAME))
        && !(item->type == k_VOICE && (modif_type == k_UNDO_MODIFICATION_CHANGE_FLAG || modif_type == k_UNDO_MODIFICATION_CHANGE_NAME))){
#ifdef BACH_UNDO_DEBUG
        object_post((t_object *) r_ob, "Warning! WEIRD UNDO ELEMENT!!!");
#endif
        return;
    }
    
    // We need to get the information on score structures, we need to lock the general mutex (if it wasn't locked already!)
    char must_unlock = true;
    if (trylock_general_mutex(r_ob))
        must_unlock = false; // already locked

    if (modif_type == k_UNDO_MODIFICATION_CHANGE_FLAG)
        content = get_multiple_flags_for_undo(r_ob, item);
    else if (modif_type == k_UNDO_MODIFICATION_CHANGE_NAME)
        content = get_names_as_llll(item, false);
    else if (modif_type == k_UNDO_MODIFICATION_CHANGE || modif_type == k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER || modif_type == k_UNDO_MODIFICATION_ADD)
        content = notation_item_get_values_as_llll_for_undo(r_ob, item);
    else 
        content = llll_get();
    
    if (must_unlock)
        unlock_general_mutex(r_ob);

    notation_item_to_measure_and_voice_numbers(r_ob, item, &meas_number, &voice_number);
        
    operation = build_undo_redo_information(item->ID, item->type, modif_type, voice_number, meas_number, k_HEADER_NONE, content);

    tick_el = llll_prependobj(r_ob->undo_notation_items_under_tick, item, 0, WHITENULL_llll);
    tick_el->l_thing.w_long = modif_type;
    create_undo_redo_tick(r_ob, k_UNDO, 0, operation, true);
}

void create_simple_selected_notation_item_undo_tick(t_notation_obj *r_ob, t_notation_item *item, e_element_types smallest_undoable_element, e_undo_modification_types modif_type){
    t_notation_item *undo_item;
    
    if (r_ob->obj_type == k_NOTATION_OBJECT_SLOT)
        smallest_undoable_element = k_NOTE;
        
     undo_item = notation_item_get_ancestor_of_at_least_a_certain_type(r_ob, item, smallest_undoable_element);

    if (!undo_item) {
        dev_post("Warning: wrong undo item; smallest_undoable_elem = %ld, modif_type %ld, itemtype %ld", smallest_undoable_element, modif_type, item->type); 
        return;
    }
        
    if (modif_type == k_UNDO_MODIFICATION_CHANGE_NAME && !(undo_item->flags & k_FLAG_MODIF_NAME_UNDO)){
        create_simple_notation_item_undo_tick(r_ob, undo_item, k_UNDO_MODIFICATION_CHANGE_NAME);
        undo_item->flags = (e_bach_internal_notation_flags) (undo_item->flags | k_FLAG_MODIF_NAME_UNDO);
    
    } else if (modif_type == k_UNDO_MODIFICATION_CHANGE_FLAG && !(undo_item->flags & k_FLAG_MODIF_FLAG_UNDO)){
        create_simple_notation_item_undo_tick(r_ob, undo_item, k_UNDO_MODIFICATION_CHANGE_FLAG);
        undo_item->flags = (e_bach_internal_notation_flags) (undo_item->flags | k_FLAG_MODIF_FLAG_UNDO);

    } else if (modif_type == k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER && !(undo_item->flags & k_FLAG_MODIF_CHECK_ORDER_UNDO)){
        create_simple_notation_item_undo_tick(r_ob, undo_item, modif_type);
        undo_item->flags = (e_bach_internal_notation_flags) (undo_item->flags | k_FLAG_MODIF_CHECK_ORDER_UNDO);

    } else if (modif_type != k_UNDO_MODIFICATION_CHANGE_FLAG && modif_type != k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER && 
                (modif_type == k_UNDO_MODIFICATION_ADD || modif_type == k_UNDO_MODIFICATION_DELETE || !(undo_item->flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))){
        create_simple_notation_item_undo_tick(r_ob, undo_item, modif_type);
        undo_item->flags = (e_bach_internal_notation_flags) (undo_item->flags | k_FLAG_MODIF_UNDO);
    }
}

void create_multiple_notation_items_undo_ticks(t_notation_obj *r_ob, long num_items, t_notation_item **item, e_undo_modification_types modif_type, long *undo_op){
    long i;

    if (r_ob->inhibited_undo)
        return;

    if (atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0)
        return;

    if (undo_op)
        *undo_op = k_UNDO_OP_UNKNOWN;
    
    for (i = 0; i < num_items; i++){
        t_llll *content = NULL;
        long this_undo_op = notation_item_get_undo_op(r_ob, item[i], modif_type);
        long meas_number = 0, voice_number = 0;
        t_undo_redo_information *operation;
        
        if (undo_op) {
            if (*undo_op == k_UNDO_OP_UNKNOWN)
                *undo_op = this_undo_op;
            else if (*undo_op != this_undo_op)
                *undo_op = k_UNDO_OP_MULTIPLE_CHANGES;
        }
        
        if (item[i]->type != k_MEASURE && item[i]->type != k_CHORD){
#ifdef BACH_UNDO_DEBUG
            object_post((t_object *) r_ob, "Warning! WEIRD UNDO ELEMENT!!!");
#endif
            return;
        }
        
        if (modif_type == k_UNDO_MODIFICATION_CHANGE_FLAG)
            content = get_multiple_flags_for_undo(r_ob, item[i]);
        else if (modif_type == k_UNDO_MODIFICATION_CHANGE || modif_type == k_UNDO_MODIFICATION_ADD)
            content = notation_item_get_values_as_llll_for_undo(r_ob, item[i]);
        else 
            content = llll_get();
        
        notation_item_to_measure_and_voice_numbers(r_ob, item[i], &meas_number, &voice_number);
        
        operation = build_undo_redo_information(item[i]->ID, item[i]->type, modif_type, voice_number, meas_number, k_HEADER_NONE, content);

        t_llllelem *tick_el = llll_prependobj(r_ob->undo_notation_items_under_tick, item[i], 0, WHITENULL_llll);
        tick_el->l_thing.w_long = modif_type;
        create_undo_redo_tick(r_ob, k_UNDO, 0, operation, true);
    }
    
    if (undo_op && num_items > 1)
        *undo_op = make_undo_op_plural_for_undo(*undo_op);
}

void remove_modif_undo_flag_to_last_undo_ticks(t_notation_obj *r_ob){
    t_llllelem *elem;
    for (elem = r_ob->undo_notation_items_under_tick->l_head; elem; elem = elem->l_next) {
        t_notation_item *item = (t_notation_item *)hatom_getobj(&elem->l_hatom);
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_MODIF_UNDO);
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_MODIF_FLAG_UNDO);
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_MODIF_CHECK_ORDER_UNDO);
        item->flags = (e_bach_internal_notation_flags) (item->flags & ~k_FLAG_MODIF_NAME_UNDO);
    }
    r_ob->header_undo_flags = 0;
}

char are_there_free_undo_ticks(t_notation_obj *r_ob, char also_return_true_if_undo_is_empty){
    char res = false;
    
    systhread_mutex_lock(r_ob->c_undo_mutex);    
    if ((r_ob->undo_llll && r_ob->undo_llll->l_head && hatom_gettype(&r_ob->undo_llll->l_head->l_hatom) != H_LONG) ||
        (also_return_true_if_undo_is_empty && (!r_ob->undo_llll->l_head || !r_ob->undo_llll)))    // we also set true if there are NO undos!
        res = true;
    systhread_mutex_unlock(r_ob->c_undo_mutex);    
        
    return res;
}


void remove_all_free_undo_ticks(t_notation_obj *r_ob, char also_clear_ticks_flags){
    systhread_mutex_lock(r_ob->c_undo_mutex);    
    if (also_clear_ticks_flags)
        remove_modif_undo_flag_to_last_undo_ticks(r_ob);
    while (r_ob->undo_llll->l_head && hatom_gettype(&r_ob->undo_llll->l_head->l_hatom) != H_LONG) {
        if (hatom_gettype(&r_ob->undo_llll->l_head->l_hatom) == H_OBJ) {
            t_undo_redo_information *thisinfo = (t_undo_redo_information *)hatom_getobj(&r_ob->undo_llll->l_head->l_hatom);
            free_undo_redo_information(thisinfo);
        }
        llll_destroyelem(r_ob->undo_llll->l_head);
    }
    systhread_mutex_unlock(r_ob->c_undo_mutex);    
}


long create_selection_notation_item_undo_tick(t_notation_obj *r_ob, e_element_types smallest_undoable_element, e_undo_modification_types modif_type){
    t_notation_item **undo_items = NULL;
    long num_items, i;
    
    if (atom_gettype(&r_ob->max_undo_steps) == A_LONG && atom_getlong(&r_ob->max_undo_steps) == 0)
        return 0;

    num_items = selection_to_undo_notation_items(r_ob, &undo_items, smallest_undoable_element);
    for (i = 0; i < num_items; i++)
        create_simple_notation_item_undo_tick(r_ob, undo_items[i], modif_type);
    bach_freeptr(undo_items);
    return num_items;
}


long header_types_to_undo_op(long header_types){
    switch (header_types) {
        case 0:
            return k_UNDO_OP_UNKNOWN;
        case k_HEADER_CLEFS:
            return k_UNDO_OP_CHANGE_CLEFS;
        case k_HEADER_COMMANDS:
            return k_UNDO_OP_CHANGE_COMMANDS;
        case k_HEADER_GROUPS:
            return k_UNDO_OP_CHANGE_GROUPS;
        case k_HEADER_KEYS:
            return k_UNDO_OP_CHANGE_KEYS;
        case k_HEADER_MARKERS:
            return k_UNDO_OP_CHANGE_MARKERS;
        case k_HEADER_MIDICHANNELS:
            return k_UNDO_OP_CHANGE_MIDICHANNELS;
        case k_HEADER_SLOTINFO:
            return k_UNDO_OP_CHANGE_SLOTINFO;
        case k_HEADER_VOICENAMES:
            return k_UNDO_OP_CHANGE_VOICENAMES;
        case k_HEADER_STAFFLINES:
            return k_UNDO_OP_CHANGE_STAFFLINES;
        case k_HEADER_ARTICULATIONINFO:
            return k_UNDO_OP_CHANGE_CUSTOM_ARTICULATIONS_DEFINITION;
        case k_HEADER_NOTEHEADINFO:
            return k_UNDO_OP_CHANGE_CUSTOM_NOTEHEADS_DEFINITION;
        case k_HEADER_NUMPARTS:
            return k_UNDO_OP_CHANGE_PARTS;
        case k_HEADER_LOOP:
            return k_UNDO_OP_CHANGE_LOOP;
        default:
            return k_UNDO_OP_CHANGE_HEADER;
    }
}


void post_undo_redo_tick(t_notation_obj *r_ob, long what, t_undo_redo_information *info)
{
    char *buf = NULL, *buf2 = NULL; 
    llll_to_text_buf(info->n_it_content, &buf, 0, 2, 0, LLLL_TE_SMART, LLLL_TB_SMART, NULL);
    object_post((t_object *) r_ob, " > %s", what == k_UNDO ? "UNDO" : (what == k_REDO ? "REDO" : "UNKNOWN OPERATION"));
    object_post((t_object *) r_ob, " > ID = %ld", info->n_it_ID);
    object_post((t_object *) r_ob, " > TYPE = %s", info->n_it_type == k_CHORD ? "chord" : (info->n_it_type == k_VOICE ? "voice" : (info->n_it_type == k_MEASURE ? "measure" : (info->n_it_type == k_HEADER_DATA ? "header data" : (info->n_it_type == k_WHOLE_NOTATION_OBJECT ? "whole notation object" : "unknown")))));
    object_post((t_object *) r_ob, " > MODIFICATION = %s", info->modification_type == k_UNDO_MODIFICATION_CHANGE ? "change" : (info->modification_type == k_UNDO_MODIFICATION_ADD ? "add" : (info->modification_type == k_UNDO_MODIFICATION_DELETE ? "delete" : (info->modification_type == k_UNDO_MODIFICATION_NONE ? "none" : "unknown"))));
    object_post((t_object *) r_ob, " > CONTENT = %s", buf);
    object_post((t_object *) r_ob, " > MEASURE NUMBER = %ld", info->meas_num);
    object_post((t_object *) r_ob, " > VOICE NUMBER = %ld", info->voice_num);
    buf2 = undo_op_to_string(header_types_to_undo_op(info->header_info));
    object_post((t_object *) r_ob, " > HEADER ELEMENTS = %s", buf2);
    bach_freeptr(buf);
    bach_freeptr(buf2);
}


void handle_change_if_there_are_free_undo_ticks(t_notation_obj *r_ob, int change_type, e_undo_operations undo_op) {
    if (are_there_free_undo_ticks(r_ob, true))
        handle_change(r_ob, change_type, undo_op);
}

void handle_change_selection(t_notation_obj *r_ob) {
    handle_change(r_ob, (r_ob->playing && r_ob->only_play_selection) ? k_CHANGED_CHECK_CORRECT_SCHEDULING + k_CHANGED_REDRAW_STATIC_LAYER : k_CHANGED_REDRAW_STATIC_LAYER, k_UNDO_OP_UNKNOWN);
}


char chord_has_a_tie_to(t_chord *ch)
{
    t_note *nt;
    for (nt = ch->firstnote; nt; nt = nt->next)
        if (nt->tie_to)
            return 1;
    return 0;
}

char chord_has_a_tie_from(t_chord *ch)
{
    t_note *nt;
    for (nt = ch->firstnote; nt; nt = nt->next)
        if (nt->tie_from)
            return 1;
    return 0;
}



char chord_has_dynamics(t_chord *ch)
{
    if (ch && chord_get_dynamics(ch))
        return 1;
    return 0;
}





void resync_selection_with_bach_inspector(t_notation_obj *r_ob){
    if (r_ob->m_inspector.inspector_patcher && r_ob->m_inspector.inspector_ui){
        if (r_ob->m_inspector.active_bach_inspector_obj_type == k_NOTE || r_ob->m_inspector.active_bach_inspector_obj_type == k_CHORD ||
            r_ob->m_inspector.active_bach_inspector_obj_type == k_TEMPO || r_ob->m_inspector.active_bach_inspector_obj_type == k_VOICE ||
            r_ob->m_inspector.active_bach_inspector_obj_type == k_MEASURE || r_ob->m_inspector.active_bach_inspector_obj_type == k_MARKER ||
            r_ob->m_inspector.active_bach_inspector_obj_type == k_PITCH_BREAKPOINT) {
            clear_selection(r_ob);
            notation_item_add_to_preselection(r_ob, (t_notation_item *) r_ob->m_inspector.active_bach_inspector_item);
            move_preselecteditems_to_selection(r_ob, k_SELECTION_MODE_FORCE_SELECT, false, false);
            notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
        } else if (r_ob->m_inspector.active_bach_inspector_obj_type == k_SLOTINFO){
            if (r_ob->active_slot_notationitem){
                long slot_num = ((t_slotinfo *)r_ob->m_inspector.active_bach_inspector_item)->slot_num;
                if (slot_num >= 0 && slot_num < CONST_MAX_SLOTS && r_ob->slotinfo[slot_num].access_type != k_SLOT_ACCESS_CANT) {
                    r_ob->active_slot_num = slot_num;
                    r_ob->active_slot_num_1based = r_ob->active_slot_num + 1;
                    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
                }
            }
        }
    }
}

void resync_bach_inspector_with_selection(t_notation_obj *r_ob){
    if (r_ob->m_inspector.inspector_patcher && r_ob->m_inspector.inspector_ui){
        if (r_ob->active_slot_notationitem && r_ob->active_slot_num >= 0 && r_ob->active_slot_num < CONST_MAX_SLOTS) {
            open_bach_inspector(r_ob, &r_ob->m_inspector, &r_ob->slotinfo[r_ob->active_slot_num], k_SLOTINFO);
        } else if (r_ob->num_selecteditems == 1){
            if (r_ob->firstselecteditem->type == k_CHORD && ((t_chord *)r_ob->firstselecteditem)->num_notes == 1 &&
                r_ob->m_inspector.active_bach_inspector_obj_type == k_NOTE && ((t_note *)r_ob->m_inspector.active_bach_inspector_item)->parent == (t_chord *)r_ob->firstselecteditem) {
                // nothing to do.
            } else
            open_bach_inspector(r_ob, &r_ob->m_inspector, r_ob->firstselecteditem, r_ob->firstselecteditem->type);
        } else if (r_ob->num_selecteditems > 1){
            open_bach_inspector(r_ob, &r_ob->m_inspector, NULL, k_MIXED);
        } else {
            open_bach_inspector(r_ob, &r_ob->m_inspector, NULL, k_NONE);
        }
    }
}


void send_changed_bang_and_automessage_if_needed(t_notation_obj *r_ob)
{
    if (r_ob->need_send_changed_bang) {
    
        r_ob->need_send_changed_bang = false;
    
        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
            llllobj_outlet_bang((t_object *) r_ob, LLLL_OBJ_UI, 7);
        else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
            llllobj_outlet_bang((t_object *) r_ob, LLLL_OBJ_UI, 8);
        else if (r_ob->obj_type == k_NOTATION_OBJECT_SLOT)
            llllobj_outlet_bang((t_object *) r_ob, LLLL_OBJ_UI, 2);
    }
    
    if (r_ob->need_send_automessage) {
        t_atom result;
        
        r_ob->need_send_automessage = false;
        
        r_ob->itsme = true;
        r_ob->is_sending_automessage = true;
        if (object_method_typed(r_ob, NULL, r_ob->automessage_ac, r_ob->automessage_av, &result) != MAX_ERR_NONE)
            object_error((t_object *)r_ob, "Automessage could not be sent.");
        r_ob->is_sending_automessage = false;
        r_ob->itsme = false; 
    }
}

void handle_change(t_notation_obj *r_ob, int change_actions, e_undo_operations undo_op)
{
    if (change_actions & k_CHANGED_REDRAW_STATIC_LAYER){
        jbox_invalidate_layer((t_object *) r_ob, NULL, gensym("static_layer1"));
        jbox_invalidate_layer((t_object *) r_ob, NULL, gensym("static_layer2"));
        
        if (change_actions == k_CHANGED_REDRAW_STATIC_LAYER) {
            notationobj_redraw(r_ob);
            resync_bach_inspector_with_selection(r_ob);
            return; // nothing more to do!
        }
        
        if (r_ob->m_inspector.inspector_ui)
            jbox_redraw((t_jbox *)r_ob->m_inspector.inspector_ui);
    }

    
    // need to check for families update?
    if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_BOUNDINGBOX) 
        set_label_families_update_contour_flag_from_undo_ticks(r_ob);
    else if (r_ob->show_label_families == k_SHOW_LABEL_FAMILIES_VENN) // we never know what could have been dragged inside the family. This is heavy!!!
        set_all_label_families_update_contour(r_ob);
    
    
    if (!r_ob->j_isdragging && (change_actions & k_CHANGED_CREATE_UNDO_STEP_MARKER)) { 
        if (r_ob->save_data_with_patcher && !r_ob->j_box.l_dictll)    // set dirty flag
            object_attr_setchar(r_ob->patcher_parent, gensym("dirty"), 1);
        
        systhread_mutex_lock(r_ob->c_undo_mutex);
        remove_modif_undo_flag_to_last_undo_ticks(r_ob);

#ifdef BACH_UNDO_DEBUG
        check_num_undo_steps(r_ob);
#endif

        // It used to be these three lines, however since Max 7 event numbers don't really work any more, so we've decided to rely on systime()
        // check if the new incoming event number is strictly greater than the last one (saved in the structure)
        long new_ev_number = evnum_get();
        if (r_ob->last_undo_marker && new_ev_number <= r_ob->last_event_number) { // "same event" as previous

//        double this_ev_time = systime_ms();
//        if (r_ob->last_undo_marker && this_ev_time <= r_ob->last_undo_time + 50) { // "same event" as previous if it falls within 50 ms
            
            // make compatible the last marker with this one
            if (hatom_getlong(&r_ob->last_undo_marker->l_hatom) != undo_op)
                undo_op = k_UNDO_OP_MULTIPLE_CHANGES;

            // I have to delete last step marker
            llll_destroyelem(r_ob->last_undo_marker);
            r_ob->num_undo_steps--;
        }

        
        // destroying "duplicate” ticks of k_WHOLE_NOTATION_OBJECT undo lists: if we had a undo tick step of the gloabl object, no need for other ones
        // moreover: they might even cause issues with IDs...
        t_llllelem *elem;
        for (elem = r_ob->undo_llll->l_tail; elem; elem = elem->l_prev) {
            if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
                t_undo_redo_information *info = (t_undo_redo_information *)hatom_getobj(&elem->l_hatom);
                if (info->n_it_type == k_WHOLE_NOTATION_OBJECT) {
                    t_llllelem *elem2, *prev_elem2;
                    for (elem2 = elem->l_prev; elem2; elem2 = prev_elem2) {
                        prev_elem2 = elem2->l_prev;
                        if (hatom_gettype(&elem2->l_hatom) == H_OBJ) {
                            free_undo_redo_information((t_undo_redo_information *)hatom_getobj(&elem2->l_hatom));
                            llll_destroyelem(elem2);
                        } else
                            break;
                    }
                    break;
                }
            }
        }
        
#ifdef BACH_UNDO_DEBUG
        check_num_undo_steps(r_ob);
#endif
        
//        r_ob->last_undo_time = this_ev_time;
        
        // Event number is deprecated:
        r_ob->last_event_number = new_ev_number;

        r_ob->last_undo_marker = create_undo_redo_step_marker(r_ob, k_UNDO, 0, undo_op, false);

        systhread_mutex_unlock(r_ob->c_undo_mutex);
    } 
    
    if (change_actions & k_CHANGED_CHECK_CORRECT_SCHEDULING)
        check_correct_scheduling(r_ob, true);

    // bang and automessage will be sent after repainting at the end of the paint method
    if (change_actions & k_CHANGED_SEND_BANG) 
        r_ob->need_send_changed_bang = true;
        
    if (r_ob->automessage_ac > 0 && !r_ob->itsme && (change_actions & k_CHANGED_SEND_AUTOMESSAGE))
        r_ob->need_send_automessage = true;

    // in any case:
    notationobj_redraw(r_ob);
    resync_bach_inspector_with_selection(r_ob);

}




t_llll *get_ID_as_llll(t_notation_item *it){
    t_llll *out = llll_get();
    llll_appendsym(out, _llllobj_sym_ID, 0, WHITENULL_llll);
    llll_appendlong(out, it->ID, 0, WHITENULL_llll);
    return out;
}

t_llll *get_names_as_llll(t_notation_item *it, char prepend_name_symbol){
    t_llll *out = llll_get();
    if (prepend_name_symbol)
        llll_appendsym(out, _llllobj_sym_name, 0, WHITENULL_llll);
    llll_chain_clone(out, it->names);
    return out;
}

t_llllelem *llll_append_notation_item_name(t_llll *ll, t_notation_item *it)
{
    if (it->names->l_size == 0)
        return llll_appendllll(ll, llll_get(), 0, WHITENULL_llll);
    else if (it->names->l_size == 1 && it->names->l_depth == 1)
        return llll_appendhatom(ll, &it->names->l_head->l_hatom, 0, WHITENULL_llll);
    else
        return llll_appendllll(ll, get_names_as_llll(it, false), 0, WHITENULL_llll);
}

/*
t_atom notation_item_get_name_from_llll(t_llll *llll) {
    t_atom av;
    atom_setsym(&av, _llllobj_sym_none);
    t_llllelem *elem = llll->l_tail;
    t_llll *ll;
    while (elem) { 
        t_llllelem *next = elem->l_prev;
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && (ll = hatom_getllll(&elem->l_hatom))->l_head && 
            hatom_gettype(&ll->l_head->l_hatom) == H_SYM && hatom_getsym(&ll->l_head->l_hatom) == _llllobj_sym_name && ll->l_head->l_next){
            if (hatom_gettype(&ll->l_head->l_next->l_hatom) == H_SYM) {
                atom_setsym(&av, hatom_getsym(&ll->l_head->l_next->l_hatom));
            } else if (is_hatom_number(&ll->l_head->l_next->l_hatom)) {
                atom_setlong(&av, hatom_getlong(&ll->l_head->l_next->l_hatom));
            } else {
                atom_setsym(&av, _llllobj_sym_none);
            } 
            llll_destroyelem(elem);
            break;
        }
        elem = next;
    } 
    return sym;
}*/


unsigned long notation_item_get_ID_from_llll(t_llll *llll) {
    long ID = 0;
    t_llllelem *elem = llll->l_tail;
    while (elem && hatom_gettype(&elem->l_hatom) == H_LLLL && hatom_getllll(&elem->l_hatom)->l_head && 
           hatom_gettype(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == H_SYM){
        t_llllelem *next = elem->l_prev;
        if (hatom_getsym(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == _llllobj_sym_ID &&
            hatom_getllll(&elem->l_hatom)->l_head->l_next){
            ID = hatom_getlong(&hatom_getllll(&elem->l_hatom)->l_head->l_next->l_hatom);
            llll_destroyelem(elem);
        }
        elem = next;
    } 
    return ID;
}

char *undo_op_to_string(long undo_op)
{
    char *buf = (char *)bach_newptr(200 * sizeof(char));
    switch (undo_op) {
        case k_UNDO_OP_UNKNOWN:
            sprintf(buf, "Unknown Operation");
            break;        
        case k_UNDO_OP_CHANGE_SCORE:
            sprintf(buf, "Change Score");
            break;
        case k_UNDO_OP_CHANGE_ROLL:
            sprintf(buf, "Change Roll");
            break;
        case k_UNDO_OP_CHANGE_CHORD:
            sprintf(buf, "Change Chord");
            break;
        case k_UNDO_OP_ADD_CHORD:
            sprintf(buf, "Add Chord");
            break;
        case k_UNDO_OP_DELETE_CHORD:
            sprintf(buf, "Delete Chord");
            break;
        case k_UNDO_OP_CHANGE_MEASURE:
            sprintf(buf, "Change Measure");
            break;
        case k_UNDO_OP_ADD_MEASURE:
            sprintf(buf, "Add Measure");
            break;
        case k_UNDO_OP_APPEND_MEASURE:
            sprintf(buf, "Append Measure");
            break;
        case k_UNDO_OP_APPEND_MEASURES:
            sprintf(buf, "Append Measures");
            break;
        case k_UNDO_OP_INSERT_MEASURE:
            sprintf(buf, "Inser Measure");
            break;
        case k_UNDO_OP_INSERT_MEASURES:
            sprintf(buf, "Inser Measures");
            break;
        case k_UNDO_OP_DELETE_MEASURE:
            sprintf(buf, "Delete Measure");
            break;
        case k_UNDO_OP_CHANGE_VOICE:
            sprintf(buf, "Change Voice");
            break;
        case k_UNDO_OP_ADD_VOICE:
            sprintf(buf, "Add Voice");
            break;
        case k_UNDO_OP_DELETE_VOICE:
            sprintf(buf, "Delete Voice");
            break;
        case k_UNDO_OP_INSERT_VOICE:
            sprintf(buf, "Insert Voice");
            break;
        case k_UNDO_OP_MOVE_VOICE:
            sprintf(buf, "Move Voice");
            break;
        case k_UNDO_OP_CHANGE_HEADER:
            sprintf(buf, "Change Header");
            break;
        case k_UNDO_OP_CHANGE_CLEFS:
            sprintf(buf, "Change Clefs");
            break;
        case k_UNDO_OP_CHANGE_KEYS:
            sprintf(buf, "Change Keys");
            break;
        case k_UNDO_OP_CHANGE_MARKERS:
            sprintf(buf, "Change Markers");
            break;
        case k_UNDO_OP_CHANGE_SLOTINFO:
            sprintf(buf, "Change Slotinfo");
            break;
        case k_UNDO_OP_CHANGE_COMMANDS:
            sprintf(buf, "Change Commans");
            break;
        case k_UNDO_OP_CHANGE_MIDICHANNELS:
            sprintf(buf, "Change Midichannels");
            break;
        case k_UNDO_OP_CHANGE_VOICENAMES:
            sprintf(buf, "Change Voice Names");
            break;
        case k_UNDO_OP_CHANGE_GROUPS:
            sprintf(buf, "Change Groups");
            break;
        case k_UNDO_OP_CHANGE_STAFFLINES:
            sprintf(buf, "Change Staff Lines");
            break;
        case k_UNDO_OP_CHANGE_CUSTOM_ARTICULATIONS_DEFINITION:
            sprintf(buf, "Change Custom Articulations Definition");
            break;
        case k_UNDO_OP_CHANGE_CUSTOM_NOTEHEADS_DEFINITION:
            sprintf(buf, "Change Custom Noteheads Definition");
            break;
        case k_UNDO_OP_CHANGE_PARTS:
            sprintf(buf, "Change Parts Assignment");
            break;
        case k_UNDO_OP_CHANGE_LOOP:
            sprintf(buf, "Change Loop");
            break;
        case k_UNDO_OP_MULTIPLE_CHANGES:
            sprintf(buf, "Multiple Changes");
            break;
        case k_UNDO_OP_CHANGE_CHORDS:
            sprintf(buf, "Change Chords");
            break;
        case k_UNDO_OP_ADD_CHORDS:
            sprintf(buf, "Add Chords");
            break;
        case k_UNDO_OP_DELETE_CHORDS:
            sprintf(buf, "Delete Chords");
            break;
        case k_UNDO_OP_CHANGE_MEASURES:
            sprintf(buf, "Change Measure");
            break;
        case k_UNDO_OP_ADD_MEASURES:
            sprintf(buf, "Add Measure");
            break;
        case k_UNDO_OP_DELETE_MEASURES:
            sprintf(buf, "Delete Measures");
            break;
        case k_UNDO_OP_CHANGE_VOICES:
            sprintf(buf, "Change Voices");
            break;
        case k_UNDO_OP_ADD_VOICES:
            sprintf(buf, "Add Voices");
            break;
        case k_UNDO_OP_DELETE_VOICES:
            sprintf(buf, "Delete Voices");
            break;
        case k_UNDO_OP_READ_SCORE:
            sprintf(buf, "Read");
            break;
        case k_UNDO_OP_IMPORT_MIDI_SCORE:
            sprintf(buf, "Import MIDI");
            break;
        case k_UNDO_OP_IMPORT_XML_SCORE:
            sprintf(buf, "Import XML");
            break;
        case k_UNDO_OP_READ_ROLL:
            sprintf(buf, "Read");
            break;
        case k_UNDO_OP_IMPORT_MIDI_ROLL:
            sprintf(buf, "Import MIDI");
            break;
        case k_UNDO_OP_READ_UISLOT:
            sprintf(buf, "Read");
            break;
        case k_UNDO_OP_CLEAR_SCORE:
            sprintf(buf, "Clear");
            break;
        case k_UNDO_OP_CLEAR_ROLL:
            sprintf(buf, "Clear");
            break;
        case k_UNDO_OP_CLEAR_UISLOT:
            sprintf(buf, "Clear");
            break;
        case k_UNDO_OP_REBUILD_SCORE:
            sprintf(buf, "Rebuild");
            break;
        case k_UNDO_OP_REBUILD_ROLL:
            sprintf(buf, "Rebuild");
            break;
        case k_UNDO_OP_POP_OUT_TEMPO:
            sprintf(buf, "Pop Tempo Out");
            break;
        case k_UNDO_OP_ADD_TEMPO:
            sprintf(buf, "Add Tempo");
            break;
        case k_UNDO_OP_DELETE_SELECTED_MEASURES:
            sprintf(buf, "Delete Selected Measures");
            break;
        case k_UNDO_OP_DELETE_SELECTION:
            sprintf(buf, "Delete Selection");
            break;
        case k_UNDO_OP_RIPPLE_DELETE_SELECTION:
            sprintf(buf, "Ripple Delete Selection");
            break;
        case k_UNDO_OP_CHANGE_SLOT:
            sprintf(buf, "Change Slot");
            break;
        case k_UNDO_OP_FIX_DYNAMICS:
            sprintf(buf, "Fix Dynamics");
            break;
        case k_UNDO_OP_ASSIGN_DYNAMICS:
            sprintf(buf, "Assign Dynamics");
            break;
        case k_UNDO_OP_ASSIGN_VELOCITIES:
            sprintf(buf, "Assign Velocities");
            break;
        case k_UNDO_OP_CLEAR_MARKERS:
            sprintf(buf, "Clear Markers");
            break;
        case k_UNDO_OP_SNAP_PITCH_TO_GRID_FOR_SELECTION:
            sprintf(buf, "Snap Pitch To Grid");
            break;
        case k_UNDO_OP_SNAP_ONSET_TO_GRID_FOR_SELECTION:
            sprintf(buf, "Snap Onset To Grid");
            break;
        case k_UNDO_OP_SNAP_TAIL_TO_GRID_FOR_SELECTION:
            sprintf(buf, "Snap Tail To Grid");
            break;
        case k_UNDO_OP_RESET_ALL_ENHARMONICITIES:
            sprintf(buf, "Reset All Enharmonicities");
            break;
        case k_UNDO_OP_RESET_ENHARMONICITY_FOR_SELECTION:
            sprintf(buf, "Reset Enharmonicity");
            break;
        case k_UNDO_OP_RESPELL:
            sprintf(buf, "Respell Notes");
            break;
        case k_UNDO_OP_CHANGE_ONSET_FOR_SELECTION:
            sprintf(buf, "Change Onset");
            break;
        case k_UNDO_OP_CHANGE_DURATION_FOR_SELECTION:
            sprintf(buf, "Change Duration");
            break;
        case k_UNDO_OP_CHANGE_TAIL_FOR_SELECTION:
            sprintf(buf, "Change Tail");
            break;
        case k_UNDO_OP_CHANGE_CENTS_FOR_SELECTION:
            sprintf(buf, "Change Cents");
            break;
        case k_UNDO_OP_CHANGE_PITCH_FOR_SELECTION:
            sprintf(buf, "Change Pitch");
            break;
        case k_UNDO_OP_CHANGE_POC_FOR_SELECTION:
            sprintf(buf, "Change Pitch Or Cents");
            break;
        case k_UNDO_OP_CHANGE_MEASUREINFO_FOR_SELECTION:
            sprintf(buf, "Change Measureinfo");
            break;
        case k_UNDO_OP_CHANGE_VOICE_FOR_SELECTION:
            sprintf(buf, "Change Voice");
            break;
        case k_UNDO_OP_CHANGE_VELOCITY_FOR_SELECTION:
            sprintf(buf, "Change Velocity");
            break;
        case k_UNDO_OP_CHANGE_TIE_FOR_SELECTION:
            sprintf(buf, "Change Tie");
            break;
        case k_UNDO_OP_CHANGE_IOI_FOR_SELECTION:
            sprintf(buf, "Change Inter-Onset Interval");
            break;
        case k_UNDO_OP_ADD_BREAKPOINTS_TO_SELECTION:
            sprintf(buf, "Add Pitch Breakpoints");
            break;
        case k_UNDO_OP_ERASE_BREAKPOINTS_FOR_SELECTION:
            sprintf(buf, "Erase Pitch Breakpoints");
            break;
        case k_UNDO_OP_ADD_SLOTS_TO_SELECTION:
            sprintf(buf, "Add Slots");
            break;
        case k_UNDO_OP_ERASE_SLOTS_FOR_SELECTION:
            sprintf(buf, "Erase Slots");
            break;
        case k_UNDO_OP_MOVE_SLOTS_FOR_SELECTION:
            sprintf(buf, "Move Slots");
            break;
        case k_UNDO_OP_COPY_SLOTS_FOR_SELECTION:
            sprintf(buf, "Copy Slots");
            break;
        case k_UNDO_OP_CHANGE_SLOTS_FOR_SELECTION:
            sprintf(buf, "Change Slots");
            break;
        case k_UNDO_OP_ADD_MARKER:
            sprintf(buf, "Add Marker");
            break;
        case k_UNDO_OP_DELETE_MARKER:
            sprintf(buf, "Delete Marker");
            break;
        case k_UNDO_OP_CHANGE_MARKER_NAME:
            sprintf(buf, "Change Marker Name");
            break;
        case k_UNDO_OP_CHANGE_MARKER_ATTACHMENT:
            sprintf(buf, "Change Marker Attachment");
            break;
        case k_UNDO_OP_GLUE_CHORD:
            sprintf(buf, "Glue Chord");
            break;
        case k_UNDO_OP_MERGE:
            sprintf(buf, "Merge");
            break;
        case k_UNDO_OP_OVERTYPE:
            sprintf(buf, "Overtype");
            break;
        case k_UNDO_OP_ALIGN_SELECTION:
            sprintf(buf, "Align");
            break;
        case k_UNDO_OP_EQUALLY_RESPACE_SELECTION:
            sprintf(buf, "Equally Respace");
            break;
        case k_UNDO_OP_LEGATO_FOR_SELECTION:
            sprintf(buf, "Legato");
            break;
        case k_UNDO_OP_GLISSANDO_FOR_SELECTION:
            sprintf(buf, "Glissando");
            break;
        case k_UNDO_OP_FORCE_POLYPHONY_FOR_SELECTION:
            sprintf(buf, "Force Polyphony");
            break;
        case k_UNDO_OP_DELETE_NOTE:
            sprintf(buf, "Delete Note");
            break;
        case k_UNDO_OP_ADD_NOTE:
            sprintf(buf, "Add Note");
            break;
        case k_UNDO_OP_CHANGE_NOTE:
            sprintf(buf, "Change Note");
            break;
        case k_UNDO_OP_DELETE_PITCH_BREAKPOINT:
            sprintf(buf, "Delete Pitch Breakpoint");
            break;
        case k_UNDO_OP_ADD_PITCH_BREAKPOINT:
            sprintf(buf, "Add Pitch Breakpoint");
            break;
        case k_UNDO_OP_CHANGE_PITCH_BREAKPOINT:
            sprintf(buf, "Change Pitch Breakpoint");
            break;
        case k_UNDO_OP_CHANGE_PITCH:
            sprintf(buf, "Change Pitch");
            break;
        case k_UNDO_OP_MOUSEDRAG_CHANGE:
            sprintf(buf, "Mousedrag Change");
            break;
        case k_UNDO_OP_CHANGE_VOICE_NAME:
            sprintf(buf, "Change Voice Name");
            break;
        case k_UNDO_OP_CHANGE_LYRICS:
            sprintf(buf, "Change Lyrics");
            break;
        case k_UNDO_OP_CHANGE_DYNAMICS:
            sprintf(buf, "Change Dynamics");
            break;
        case k_UNDO_OP_TRIM_END:
            sprintf(buf, "Trim End");
            break;
        case k_UNDO_OP_TRIM_START:
            sprintf(buf, "Trim End");
            break;
        case k_UNDO_OP_CHANGE_NAMES:
            sprintf(buf, "Change Names");
            break;
        case k_UNDO_OP_CLEAR_NAMES:
            sprintf(buf, "Clear Names");
            break;
        case k_UNDO_OP_NAMES_FROM_SLOT:
            sprintf(buf, "Assign Names From Slot");
            break;
        case k_UNDO_OP_NAMES_TO_SLOT:
            sprintf(buf, "Export Names To Slot");
            break;
        case k_UNDO_OP_CHANGE_ROLES:
            sprintf(buf, "Change Roles");
            break;
        case k_UNDO_OP_RESET_TAIL_SLOPE:
            sprintf(buf, "Reset Tail Slope");
            break;
        case k_UNDO_OP_DELETE_PITCH_BREAKPOINTS_IN_SELECTION:
            sprintf(buf, "Operation");
            break;
        case k_UNDO_OP_RESET_PITCH_BREAKPOINTS_SLOPE_FOR_SELECTION:
            sprintf(buf, "Reset Pitch Breakpoints Slope");
            break;
        case k_UNDO_OP_SHIFT_PITCH_UP_FOR_SELECTION:
            sprintf(buf, "Shift Pitch Up");
            break;
        case k_UNDO_OP_SHIFT_PITCH_DOWN_FOR_SELECTION:
            sprintf(buf, "Shift Pitch Down");
            break;
        case k_UNDO_OP_LOCK_UNLOCK_SELECTION:
            sprintf(buf, "Lock/Unlock");
            break;
        case k_UNDO_OP_MUTE_UNMUTE_SELECTION:
            sprintf(buf, "Mute/Unmute");
            break;
        case k_UNDO_OP_SOLO_UNSOLO_SELECTION:
            sprintf(buf, "Solo/Unsolo");
            break;
        case k_UNDO_OP_DELETE_GROUP:
            sprintf(buf, "Delete Group");
            break; 
        case k_UNDO_OP_CREATE_GROUP:
            sprintf(buf, "Create Group");
            break;
        case k_UNDO_OP_PASTE_SLOT_CONTENT:
            sprintf(buf, "Paste Slot Content");
            break;
        case k_UNDO_OP_PASTE_DURATION_LINE:
            sprintf(buf, "Paste Duration Line");
            break;
        case k_UNDO_OP_PASTE:
            sprintf(buf, "Paste");
            break;
        case k_UNDO_OP_CUT_SLOT_CONTENT:
            sprintf(buf, "Cut Slot Content");
            break;
        case k_UNDO_OP_CUT_DURATION_LINE:
            sprintf(buf, "Cut Duration Line");
            break;
        case k_UNDO_OP_CUT:
            sprintf(buf, "Cut");
            break;
        case k_UNDO_OP_DELETE_SLOT_CONTENT:
            sprintf(buf, "Delete Slot Content");
            break;
        case k_UNDO_OP_DELETE_ARTICULATIONS_FOR_SELECTION:
            sprintf(buf, "Delete Articulations");
            break;
        case k_UNDO_OP_RESET_LOCAL_SPACING_FOR_SELECTION:
            sprintf(buf, "Reset Local Spacing");
            break;
        case k_UNDO_OP_RESET_LOCAL_SPACING:
            sprintf(buf, "Reset Local Spacing");
            break;
        case k_UNDO_OP_SET_MEASURE_PARAMETERS:
            sprintf(buf, "Set Measure Parameters");
            break;
        case k_UNDO_OP_CEIL_MEASURES:
            sprintf(buf, "Ceil Measures");
            break;
        case k_UNDO_OP_AUTO_RHYTHMIC_TREE_KEEPING_EXISTING_TUPLETS:
            sprintf(buf, "Auto Rhythmic Tree Keeping Existing Tuplets");
            break;
        case k_UNDO_OP_STICK_RHYTHMIC_TREE:
            sprintf(buf, "Stick Rhythmic Tree");
            break;
        case k_UNDO_OP_DESTROY_RHYTHMIC_TREE:
            sprintf(buf, "Destroy Rhythmic Tree");
            break;
        case k_UNDO_OP_ADD_RHYTHMIC_TREE_LEVEL:
            sprintf(buf, "Add Rhythmic Tree Level");
            break;
        case k_UNDO_OP_DESTROY_RHYTHMIC_TREE_LEVEL:
            sprintf(buf, "Destroy Rhythmic Tree Level");
            break;
        case k_UNDO_OP_AUTO_RHYTHMIC_TREE_IGNORING_EXISTING_TUPLETS:
            sprintf(buf, "Auto Rhythmic Tree Ignoring Existing Tuplets");
            break;
        case k_UNDO_OP_TURN_REST_INTO_NOTE:
            sprintf(buf, "Turn Rest Into Note");
            break;
        case k_UNDO_OP_DELETE_ARTICULTATION:
            sprintf(buf, "Delete Articulation");
            break;
        case k_UNDO_OP_DELETE_TEMPO:
            sprintf(buf, "Delete Tempo");
            break;
        case k_UNDO_OP_LINEAR_EDIT_CHANGE_PITCH:
            sprintf(buf, "Change Pitch");
            break;
        case k_UNDO_OP_LINEAR_EDIT_TOGGLE_REST:
            sprintf(buf, "Toggle Rest");
            break;
        case k_UNDO_OP_LINEAR_EDIT_TOGGLE_TIES:
            sprintf(buf, "Toggle Ties");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_SHARP:
            sprintf(buf, "Add Sharp");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_FLAT:
            sprintf(buf, "Add Flat");
            break;
        case k_UNDO_OP_LINEAR_EDIT_TOGGLE_GRACE:
            sprintf(buf, "Toggle Grace");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_NOTE:
            sprintf(buf, "Add Note");
            break;
        case k_UNDO_OP_LINEAR_EDIT_DELETE_NOTE:
            sprintf(buf, "Delete Note");
            break;
        case k_UNDO_OP_LINEAR_EDIT_DELETE_CHORD:
            sprintf(buf, "Delete Chord");
            break;
        case k_UNDO_OP_LINEAR_EDIT_SPLIT_CHORD:
            sprintf(buf, "Split Chord");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_DOT:
            sprintf(buf, "Add Dot");
            break;
        case k_UNDO_OP_LINEAR_EDIT_CHANGE_CHORD_DURATION:
            sprintf(buf, "Change Chord Duration");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_CHORD:
            sprintf(buf, "Add Chord");
            break;
        case k_UNDO_OP_LINEAR_EDIT_ADD_NEW_MEASURE:
            sprintf(buf, "Add New Measure");
            break;
        case k_UNDO_OP_LINEAR_EDIT_CLEAR_MEASURE:
            sprintf(buf, "Clear Measure");
            break;
        case k_UNDO_OP_DELETE_MEASURES_IN_SELECTION:
            sprintf(buf, "Delete Measures");
            break;
        case k_UNDO_OP_CLEAR_MEASURES_IN_SELECTION:
            sprintf(buf, "Clear Measures");
            break;
        case k_UNDO_OP_DUPLICATE_SELECTED_MEASURES:
            sprintf(buf, "Duplicate Measures");
            break;
        case k_UNDO_OP_DELETE_SELECTED_TEMPI:
            sprintf(buf, "Delete Tempi");
            break;
        case k_UNDO_OP_TOGGLE_INTERPOLATION_FOR_SELECTED_TEMPI:
            sprintf(buf, "Toggle Tempi Interpolation");
            break;
        case k_UNDO_OP_DELETE_SLURS_FOR_SELECTION:
            sprintf(buf, "Delete Slurs");
            break;
        case k_UNDO_OP_ADD_ARTICULATION_TO_SELECTION:
            sprintf(buf, "Add Articulation");
            break;
        case k_UNDO_OP_CHANGE_ARTICULATION:
            sprintf(buf, "Change Articulation");
            break;
        case k_UNDO_OP_TURN_SELECTION_INTO_RESTS:
            sprintf(buf, "Turn Into Rests");
            break;
        case k_UNDO_OP_JOIN_SELECTION:
            sprintf(buf, "Join");
            break;
        case k_UNDO_OP_DELETE_GRACE:
            sprintf(buf, "Delete Grace Chords");
            break;
        case k_UNDO_OP_MERGE_GRACE:
            sprintf(buf, "Merge Grace Chords");
            break;
        case k_UNDO_OP_AUTO_BEAM:
            sprintf(buf, "Auto Beam");
            break;
        case k_UNDO_OP_AUTO_RHYTHMIC_TREE_KEEPING_EXISTING_TUPLETS_FOR_SELECTION:
            sprintf(buf, "Auto Rhythmic Tree Keeping Existing Tuplets");
            break;
        case k_UNDO_OP_AUTO_RHYTHMIC_TREE_IGNORING_EXISTING_TUPLETS_FOR_SELECTION:
            sprintf(buf, "Auto Rhythmic Tree Ignoring Existing Tuplets");
            break;
        case k_UNDO_OP_DESTROY_RHYTHMIC_TREE_LEVEL_FOR_SELECTION:
            sprintf(buf, "Destroy Rhythmic Tree Level");
            break;
        case k_UNDO_OP_STICK_RHYTHMIC_TREE_FOR_SELECTION:
            sprintf(buf, "Stick Rhythmic Tree");
            break;
        case k_UNDO_OP_DESTROY_RHYTHMIC_TREE_FOR_SELECTION:
            sprintf(buf, "Destroy Rhythmic Tree");
            break;
        case k_UNDO_OP_ADD_RHYTHMIC_TREE_LEVELS_FROM_SELECTION:
            sprintf(buf, "Add Rhythmic Tree Level");
            break;
        case k_UNDO_OP_LOCK_UNLOCK_RHYTHMIC_TREES_FOR_SELECTION:
            sprintf(buf, "Lock/Unlock Rhythmic Tree");
            break;
        case k_UNDO_OP_TIE_UNTIE_SELECTION:
            sprintf(buf, "Tie/Untie");
            break;
        case k_UNDO_OP_SPLIT_SELECTION:
            sprintf(buf, "Split");
            break;
        case k_UNDO_OP_CUT_MEASURES:
            sprintf(buf, "Cut Measures");
            break;
        case k_UNDO_OP_PASTE_MEASURES:
            sprintf(buf, "Paste Measures");
            break;
        case k_UNDO_OP_FIX_UNFIX_MEASURE_WIDTH_FOR_SELECTION:
            sprintf(buf, "Fix/Unfix Measure Width");
            break;
        case k_UNDO_OP_CHANGE_SLOTS_FROM_MESSAGE:
            sprintf(buf, "Change Slots From Message");
            break;
        case k_UNDO_OP_LOCK_SELECTION:
            sprintf(buf, "Lock");
            break;
        case k_UNDO_OP_UNLOCK_SELECTION:
            sprintf(buf, "Unlock");
            break;
        case k_UNDO_OP_MUTE_SELECTION:
            sprintf(buf, "Mute");
            break;
        case k_UNDO_OP_UNMUTE_SELECTION:
            sprintf(buf, "Unmute");
            break;
        case k_UNDO_OP_SOLO_SELECTION:
            sprintf(buf, "Solo");
            break;
        case k_UNDO_OP_UNSOLO_SELECTION:
            sprintf(buf, "Unsolo");
            break;
        case k_UNDO_OP_NO_SOLOS:
            sprintf(buf, "No Solos");
            break;
        case k_UNDO_OP_NO_MUTES:
            sprintf(buf, "No Mutes");
            break;
        case k_UNDO_OP_ENHARMONICALLY_RESPELL_NOTE:
            sprintf(buf, "Enharmonically Respell Note");
            break;
        case k_UNDO_OP_CHANGE_BARLINE_TYPE:
            sprintf(buf, "Change Barline");
            break;
        case k_UNDO_OP_CHANGE_TIME_SIGNATURE_FOR_SELECTED_MEASURES:
            sprintf(buf, "Change Time Signatures");
            break;
        case k_UNDO_OP_LOCK_RHYTHMIC_TREE_FOR_SELECTION:
            sprintf(buf, "Lock Rhythmic Tree");
            break;
        case k_UNDO_OP_UNLOCK_RHYTHMIC_TREE_FOR_SELECTION:
            sprintf(buf, "Unlock Rhythmic Tree");
            break;
        case k_UNDO_OP_CREATE_VOICE_ENSEMBLE:
            sprintf(buf, "Create Voice Ensemble");
            break;
        case k_UNDO_OP_BREAK_VOICE_ENSEMBLE:
            sprintf(buf, "Break Voice Ensemble");
            break;
        case k_UNDO_OP_CLEAR_ARTICULATIONS:
            sprintf(buf, "Clear Articulations");
            break;
        case k_UNDO_OP_CLEAR_NOTES:
            sprintf(buf, "Clear Notes");
            break;
        case k_UNDO_OP_CLEAR_TEMPI:
            sprintf(buf, "Clear Tempi");
            break;
        case k_UNDO_OP_CLEAR_BREAKPOINTS:
            sprintf(buf, "Clear Pitch Breakpoints");
            break;
        case k_UNDO_OP_CHANGE_BACH_ATTRIBUTE:
            sprintf(buf, "Change Attribute");
            break;
        case k_UNDO_OP_SLICE:
            sprintf(buf, "Slice");
            break;
        case k_UNDO_OP_AUTOSPELL:
            sprintf(buf, "Autospell");
            break;
        case k_UNDO_OP_TAILS_TO_GRACES:
            sprintf(buf, "Convert tails to grace chords");
            break;
        default:
            sprintf(buf, "Generic Operation");
            break;
    }
    return buf;
}




void translate_rhythmic_level_om_to_bach(t_llll *box, t_rational box_duration){
    t_llllelem *elem;
    t_rational sum = long2rat(0);
    
    // getting total level weight
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && elem->l_hatom.h_w.w_llll->l_head && is_hatom_number(&elem->l_hatom.h_w.w_llll->l_head->l_hatom)) {
            sum = rat_rat_sum(sum, rat_abs(hatom_getrational(&elem->l_hatom.h_w.w_llll->l_head->l_hatom)));
        } else if (is_hatom_number(&elem->l_hatom)) {
            sum = rat_rat_sum(sum, rat_abs(hatom_getrational(&elem->l_hatom)));
        }
    }
    
    
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL && elem->l_hatom.h_w.w_llll->l_head && is_hatom_number(&elem->l_hatom.h_w.w_llll->l_head->l_hatom)
            && elem->l_hatom.h_w.w_llll->l_head->l_next && hatom_gettype(&elem->l_hatom.h_w.w_llll->l_head->l_next->l_hatom) == H_LLLL) {
            t_rational weight = hatom_getrational(&elem->l_hatom.h_w.w_llll->l_head->l_hatom);
            t_llll *newllll = elem->l_hatom.h_w.w_llll->l_head->l_next->l_hatom.h_w.w_llll;
            llll_destroyelem(elem->l_hatom.h_w.w_llll->l_head);
            llll_splatter(elem, LLLL_FREETHING_DONT);
            translate_rhythmic_level_om_to_bach(newllll, rat_rat_prod(box_duration, rat_rat_div(weight, sum)));
        } else if (is_hatom_number(&elem->l_hatom)) {
            t_rational weight;
            if (hatom_gettype(&elem->l_hatom) == H_DOUBLE)
                llll_insertsym_before(_llllobj_sym_t, elem, 0, WHITENULL_llll);
            weight = hatom_getrational(&elem->l_hatom);
            hatom_setrational(&elem->l_hatom, rat_rat_prod(box_duration, rat_rat_div(weight, sum)));
        }
    }
}


t_llll *om_rhythmic_tree_to_bach_rhythmic_tree(t_llll *omtree, t_llll **measureinfo){
    t_llll *bach_tree = llll_get();
    *measureinfo = llll_get();
    
    t_llllelem *voice;
    for (voice = omtree->l_head; voice; voice = voice->l_next){
        t_llll *thisvoiceinfo = llll_get();
        t_llll *thisvoice = llll_get();
        if (hatom_gettype(&voice->l_hatom) == H_LLLL){
            t_llllelem *meas = voice->l_hatom.h_w.w_llll->l_tail && hatom_gettype(&voice->l_hatom.h_w.w_llll->l_tail->l_hatom) == H_LLLL ? 
                                    voice->l_hatom.h_w.w_llll->l_tail->l_hatom.h_w.w_llll->l_head : NULL;
            while (meas) {
                if (hatom_gettype(&meas->l_hatom) == H_LLLL) {
                    t_llll *ll = meas->l_hatom.h_w.w_llll;
                    t_rational total_meas_duration = long2rat(0);
                    if (ll && ll->l_head && ll->l_head->l_next && hatom_gettype(&ll->l_head->l_hatom) == H_LLLL && hatom_gettype(&ll->l_head->l_next->l_hatom) == H_LLLL) {
                        t_llll *thisll = llll_clone(ll->l_head->l_hatom.h_w.w_llll);
                        llll_wrap_once(&thisll);
                        if (thisll->l_head){
                            t_rational total_meas_duration1 = hatom_gettype(&thisll->l_head->l_hatom) == H_LLLL ? llll_sum_of_rat_llll(thisll->l_head->l_hatom.h_w.w_llll) : hatom_getrational(&thisll->l_head->l_hatom);
                            t_rational total_meas_duration2 = hatom_gettype(&thisll->l_tail->l_hatom) == H_LLLL ? llll_sum_of_rat_llll(thisll->l_tail->l_hatom.h_w.w_llll) : hatom_getrational(&thisll->l_tail->l_hatom);
                            total_meas_duration = rat_rat_div(total_meas_duration1, total_meas_duration2);
                        }

                        llll_appendllll(thisvoiceinfo, thisll, 0, WHITENULL_llll);

                        if (total_meas_duration.r_num > 0){
                            t_llll *measurebachtree = llll_clone(ll->l_head->l_next->l_hatom.h_w.w_llll);
                            translate_rhythmic_level_om_to_bach(measurebachtree, total_meas_duration);
                            llll_appendllll(thisvoice, measurebachtree, 0, WHITENULL_llll);
                        }
                    }
                }
                meas = meas->l_next;
            }
        }
        llll_appendllll(*measureinfo, thisvoiceinfo, 0, WHITENULL_llll);
        llll_appendllll(bach_tree, thisvoice, 0, WHITENULL_llll);
    }
    return bach_tree;
}



void bach2pwgl_measure_level(t_notation_obj *r_ob, t_llll *box, char *need_set_double){
    t_llll *durs = rhythmic_tree_to_duration_tree(r_ob, box, true, false);
    t_rational gcd = llll_gcd_on_first_level_in_rdurations_rhythmic_tree(durs, false);
    
    t_llllelem *elem;
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
            t_llll *level = hatom_getllll(&elem->l_hatom);
            t_llll *newllll = llll_get();
            t_llll *newinnerllll = llll_get();
            t_rational level_dur = get_level_rduration(r_ob, level, false, true, false, false);
            
            llll_clone_upon(hatom_getllll(&elem->l_hatom), newinnerllll);
            llll_appendlong(newllll, rat_rat_div(level_dur, gcd).r_num, 0, WHITENULL_llll);
            llll_appendllll(newllll, newinnerllll, 0, WHITENULL_llll);
            if (is_level_grace(level)){
                llll_appendsym(newllll, gensym(":class"), 0, WHITENULL_llll);
                llll_appendsym(newllll, gensym(":grace-beat"), 0, WHITENULL_llll);
            }
            if (level->l_thing.w_obj)
                bach_freeptr(level->l_thing.w_obj);
            hatom_change_to_llll_and_free(&elem->l_hatom, newllll);
            bach2pwgl_measure_level(r_ob, newinnerllll, need_set_double);
            
        } else if (hatom_gettype(&elem->l_hatom) == H_OBJ) {
            t_chord *ch = (t_chord *)hatom_getobj(&elem->l_hatom);
            
            if (ch) {
                t_llll *chord_llll = llll_get();
                long tree_director = rat_rat_div(ch->r_sym_duration, gcd).r_num;
                
                if (*need_set_double) {
                    llll_appenddouble(chord_llll, tree_director * 1.0, 0, WHITENULL_llll);
                    *need_set_double = false;
                } else
                    llll_appendlong(chord_llll, tree_director, 0, WHITENULL_llll);
                
                if (ch->r_sym_duration.r_num >= 0) {     
                    t_llll* notes_llll = llll_get();
                    t_note *nt;
                    llll_appendsym(chord_llll, gensym(":notes"), 0, WHITENULL_llll);
                    
                    for (nt = ch->firstnote; nt; nt = nt->next) {
                        t_llll* this_note_llll = llll_get();
                        double mc_as_double = rat2double(note_get_screen_midicents_with_accidental(nt))/100.;
                        if (((double)mc_as_double) == round(mc_as_double))
                            llll_appendlong(this_note_llll, round(mc_as_double), 0, WHITENULL_llll);
                        else
                            llll_appenddouble(this_note_llll, mc_as_double, 0, WHITENULL_llll);
                        if (note_breakpoints_are_nontrivial(r_ob, nt)) 
                            append_note_breakpoints_formatted_for_pwgl(r_ob, this_note_llll, nt);
                        if (notation_item_has_slot_content(r_ob, (t_notation_item *)nt))
                            append_note_slot_formatted_for_pwgl(r_ob, this_note_llll, nt);
                        llll_appendllll(notes_llll, this_note_llll, 0, WHITENULL_llll);    
                    }
                    llll_appendllll(chord_llll, notes_llll, 0, WHITENULL_llll);    
                } else {
                    t_llll* notes_llll = llll_get();
                    llll_appendlong(notes_llll, 60, 0, WHITENULL_llll); // default
                    llll_appendsym(chord_llll, gensym(":notes"), 0, WHITENULL_llll);
                    llll_appendllll(chord_llll, notes_llll, 0, WHITENULL_llll);
                }
                hatom_change_to_llll_and_free(&elem->l_hatom, chord_llll);
                
                if (chord_is_all_tied_to(r_ob, ch, false, NULL))
                    *need_set_double = true;
            }
        }
    }
    
    llll_free_freethings(durs, LLLL_FREETHING_MEM);
}


void bach2om_rhythmic_tree_change_level(t_llll *box, char *need_set_double){
//    t_rational sum = llll_sum_abs_of_rat_llll(box);
    t_rational gcd = llll_gcd_on_first_level(box);
    
    t_llllelem *elem;
    for (elem = box->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
            t_llll *newllll = llll_get();
            t_llll *newinnerllll = llll_clone(hatom_getllll(&elem->l_hatom));
            llll_appendlong(newllll, rat_rat_div(llll_sum_abs_of_rat_llll(hatom_getllll(&elem->l_hatom)), gcd).r_num, 0, WHITENULL_llll);
            llll_appendllll(newllll, newinnerllll, 0, WHITENULL_llll);
            hatom_change_to_llll_and_free(&elem->l_hatom, newllll);
            bach2om_rhythmic_tree_change_level(newinnerllll, need_set_double);
        } else if (is_hatom_number(&elem->l_hatom)) {
            if (*need_set_double) {
                hatom_setdouble(&elem->l_hatom, rat_rat_div(hatom_getrational(&elem->l_hatom), gcd).r_num * 1.);
                *need_set_double = false;
            } else
                hatom_setlong(&elem->l_hatom, rat_rat_div(hatom_getrational(&elem->l_hatom), gcd).r_num);
            if (elem->l_next && hatom_gettype(&elem->l_next->l_hatom) == H_SYM && hatom_getsym(&elem->l_next->l_hatom) == _llllobj_sym_t){
                llll_destroyelem(elem->l_next);
                *need_set_double = true;
            }
        }
    }
}



t_llll *bach_measure_to_pwgl_measure(t_notation_obj *r_ob, t_measure *meas, char *need_set_double){
    t_llll *pwglmeas = llll_get();
    t_llll *tree;
    t_rational tempo_figure = RAT_1OVER4, figure_tempo_value = long2rat(60), tempo_value = long2rat(60);
    char interpolation = 0;
    
    t_llll *metronome_llll = llll_get();
    t_llll *ts_llll = llll_get();
    
    if (meas->firsttempo) {
        tempo_figure = meas->firsttempo->tempo_figure;
        figure_tempo_value = meas->firsttempo->figure_tempo_value;
        tempo_value = meas->firsttempo->tempo_value;
        interpolation = meas->firsttempo->interpolation_type;
    } else
        get_tempo_at_timepoint(r_ob, meas->voiceparent, build_timepoint_with_voice(meas->measure_number, long2rat(0), meas->voiceparent->v_ob.number), &figure_tempo_value, &tempo_figure, &tempo_value, &interpolation);

    llll_appendlong(metronome_llll, long_rat_div(1, tempo_figure).r_num, 0, WHITENULL_llll);
    llll_appendlong(metronome_llll, (long)round(rat2double(figure_tempo_value)), 0, WHITENULL_llll);
    llll_appendlong(ts_llll, meas->timesignature.numerator, 0, WHITENULL_llll);
    llll_appendlong(ts_llll, meas->timesignature.denominator, 0, WHITENULL_llll);
    
    llll_appendsym(pwglmeas, gensym(":metronome"), 0, WHITENULL_llll);
    llll_appendllll(pwglmeas, metronome_llll, 0, WHITENULL_llll);
    llll_appendsym(pwglmeas, gensym(":time-signature"), 0, WHITENULL_llll);
    llll_appendllll(pwglmeas, ts_llll, 0, WHITENULL_llll);
    
    tree = llll_clone_extended(meas->rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
    bach2pwgl_measure_level(r_ob, tree, need_set_double);
    
    llll_free_all_l_things(tree);
    
    // checking the beats
    t_rational div = ts_to_division_for_PWGL(r_ob, &meas->timesignature);
    long num_divs = rat_rat_div(measure_get_sym_duration(meas), div).r_num;
    t_llllelem *elem;
    long routers_sum = 0;
    for (elem = tree->l_head; elem; elem = elem->l_next){
        if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
            t_llll *ll = hatom_getllll(&elem->l_hatom);
            if (ll && ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_LONG)
                routers_sum += labs(hatom_getlong(&ll->l_head->l_hatom));
        }
    }
    
    if (num_divs != routers_sum) {
        t_llll *bigger_outer = llll_get();
        t_llll *inner = llll_clone_extended(tree, WHITENULL_llll, 0, ignore_l_thing_fn);
        llll_appendlong(bigger_outer, num_divs, 0, WHITENULL_llll);
        llll_appendllll(bigger_outer, inner, 0, WHITENULL_llll);
        llll_wrap_once(&bigger_outer);
        llll_free(tree);
        tree = bigger_outer;

    } else {
        
        // deleting initial negative routers
        for (elem = tree->l_head; elem; elem = elem->l_next){
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *ll = hatom_getllll(&elem->l_hatom);
                if (ll && ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_LONG && hatom_getlong(&ll->l_head->l_hatom) < 0) {
                    long rout = hatom_getlong(&ll->l_head->l_hatom);
                    t_llll *substitute_with_this = llll_get();
                    t_llll *inner = llll_clone_extended(ll, WHITENULL_llll, 0, ignore_l_thing_fn);
                    if (inner->l_head && hatom_gettype(&inner->l_head->l_hatom) == H_LONG)
                        hatom_setlong(&inner->l_head->l_hatom, -1);
                    llll_appendlong(substitute_with_this, -rout, 0, WHITENULL_llll);
                    llll_wrap_once(&inner);
                    llll_appendllll(substitute_with_this, inner, 0, WHITENULL_llll);
                    hatom_change_to_llll_and_free(&elem->l_hatom, substitute_with_this);
                }
            }
        }
    }

    llll_chain(pwglmeas, tree);
    
    return pwglmeas;
}


t_llll *bach_rhythmic_tree_to_om_rhythmic_tree(t_llll *durs, t_llll *measureinfo){
    t_llllelem *durs_voice, *minfo_voice, *last_minfo_meas = NULL;
    t_llll *omdurs = llll_get();
    
    for (durs_voice = durs->l_head, minfo_voice = measureinfo->l_head; durs_voice; durs_voice = durs_voice->l_next, minfo_voice = minfo_voice->l_next ? minfo_voice->l_next : NULL){ 
        if (hatom_gettype(&durs_voice->l_hatom) == H_LLLL){
            t_llllelem *durs_meas, *minfo_meas;
            t_llll *omdurs_voice = llll_get();
            t_llll *omdurs_voice_inner = llll_get();
            for (durs_meas = durs_voice->l_hatom.h_w.w_llll->l_head, minfo_meas = hatom_gettype(&minfo_voice->l_hatom) == H_LLLL ? minfo_voice->l_hatom.h_w.w_llll->l_head : NULL; 
                durs_meas; durs_meas = durs_meas->l_next, minfo_meas = minfo_meas->l_next ? minfo_meas->l_next : NULL){
                if (hatom_gettype(&durs_meas->l_hatom) == H_LLLL){
                    t_llll *ommeas = llll_get();
                    t_llll *timesignature = llll_get();
                    long num = 4, den = 4;
                    
                    // find timesignature
                    if (minfo_meas)
                        last_minfo_meas = minfo_meas;
                        
                    if (hatom_gettype(&last_minfo_meas->l_hatom) == H_LLLL &&
                        last_minfo_meas->l_hatom.h_w.w_llll->l_head && hatom_gettype(&last_minfo_meas->l_hatom.h_w.w_llll->l_head->l_hatom)){
                        t_llll *ts = last_minfo_meas->l_hatom.h_w.w_llll->l_head->l_hatom.h_w.w_llll;
                        if (ts->l_head) {
                            if (is_hatom_number(&ts->l_head->l_hatom))
                                num = hatom_getlong(&ts->l_head->l_hatom);
                            else if (hatom_gettype(&ts->l_head->l_hatom) == H_LLLL)
                                num = llll_sum_of_rat_llll(ts->l_head->l_hatom.h_w.w_llll).r_num;
                        }
                        if (ts->l_tail) {
                            if (is_hatom_number(&ts->l_tail->l_hatom))
                                den = hatom_getlong(&ts->l_tail->l_hatom);
                            else if (hatom_gettype(&ts->l_tail->l_hatom) == H_LLLL)
                                den = llll_sum_of_rat_llll(ts->l_tail->l_hatom.h_w.w_llll).r_num;
                        }
                    }
                    
                    llll_appendlong(timesignature, num, 0, WHITENULL_llll);
                    llll_appendlong(timesignature, den, 0, WHITENULL_llll);
                            
                    llll_clone_upon(hatom_getllll(&durs_meas->l_hatom), ommeas);

                    char need_set_double = false;
                    bach2om_rhythmic_tree_change_level(ommeas, &need_set_double);
                    llll_wrap_once(&ommeas);

                    llll_prependllll(ommeas, timesignature, 0, WHITENULL_llll);
                    llll_appendllll(omdurs_voice_inner, ommeas, 0, WHITENULL_llll);
                }
            }
            llll_appendsym(omdurs_voice, _llllobj_sym_questionmark, 0, WHITENULL_llll);
            llll_appendllll(omdurs_voice, omdurs_voice_inner, 0, WHITENULL_llll);
            llll_appendllll(omdurs, omdurs_voice, 0, WHITENULL_llll);
        }
    }
    
    return omdurs;
}

t_llll *get_notation_obj_header_as_llll(t_notation_obj *r_ob, long dump_what, char add_router_symbol, 
                                        char explicitly_get_also_default_stuff, char also_get_fields_saved_in_max_inspector,
                                        e_data_considering_types for_what)
{
    t_llll *out_llll = llll_get();
    
    if (add_router_symbol && (r_ob->obj_type == k_NOTATION_OBJECT_ROLL || r_ob->obj_type == k_NOTATION_OBJECT_SCORE))
        llll_appendsym(out_llll, r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? _llllobj_sym_roll : _llllobj_sym_score, 0, WHITENULL_llll);

    if (dump_what & k_HEADER_SLOTINFO) 
        llll_appendllll(out_llll, get_slotinfo_as_llll(r_ob, explicitly_get_also_default_stuff, also_get_fields_saved_in_max_inspector, for_what == k_CONSIDER_FOR_SAVING_WITH_BW_COMPATIBILITY), 0, WHITENULL_llll); // slotinfo
    
    if (r_ob->obj_type != k_NOTATION_OBJECT_SLOT) {

        if (dump_what & k_HEADER_COMMANDS) 
            llll_appendllll(out_llll, get_commands_values_as_llll(r_ob, for_what == k_CONSIDER_FOR_SAVING_WITH_BW_COMPATIBILITY), 0, WHITENULL_llll); // command
        
        if (dump_what & k_HEADER_CLEFS)
            llll_appendllll(out_llll, get_clefs_as_llll(r_ob, true), 0, WHITENULL_llll);
        
        if (dump_what & k_HEADER_KEYS)
            llll_appendllll(out_llll, get_keys_as_llll(r_ob, true), 0, WHITENULL_llll);
        
        if (dump_what & k_HEADER_VOICENAMES)
            llll_appendllll(out_llll, get_voicenames_as_llll(r_ob, true), 0, WHITENULL_llll);

        if (dump_what & k_HEADER_VOICESPACING)
            llll_appendllll(out_llll, get_voicespacing_as_llll(r_ob, true), 0, WHITENULL_llll);

        if (dump_what & k_HEADER_HIDEVOICES)
            llll_appendllll(out_llll, get_hidevoices_as_llll(r_ob, true), 0, WHITENULL_llll);

        if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
            if (dump_what & k_HEADER_GROUPS) 
                llll_appendllll(out_llll, get_groups_for_dump_as_llll(r_ob, 0, 0, 0), 0, WHITENULL_llll);
        }

        if (dump_what & k_HEADER_MARKERS)
            llll_appendllll(out_llll, get_markers_as_llll(r_ob, 0, 0, 0, false, for_what, 0), 0, WHITENULL_llll);

        if (dump_what & k_HEADER_STAFFLINES)
            llll_appendllll(out_llll, get_stafflines_as_llll(r_ob, true), 0, WHITENULL_llll);

        if (dump_what & k_HEADER_MIDICHANNELS)
            llll_appendllll(out_llll, get_midichannels_as_llll(r_ob, true), 0, WHITENULL_llll);

        if (dump_what & k_HEADER_ARTICULATIONINFO)
            llll_appendllll(out_llll, get_articulationinfo_as_llll(r_ob));

        if (dump_what & k_HEADER_NOTEHEADINFO)
            llll_appendllll(out_llll, get_noteheadinfo_as_llll(r_ob));

        if (dump_what & k_HEADER_NUMPARTS)
            llll_appendllll(out_llll, get_numparts_as_llll(r_ob));

        if (dump_what & k_HEADER_LOOP)
            llll_appendllll(out_llll, get_loop_region_as_llll(r_ob, true), 0, WHITENULL_llll);


    }
    return out_llll;
}


// switch a chord from grace to not grace
void toggle_grace_for_chord(t_notation_obj *r_ob, t_chord *chord, char grace){
    t_chord *orig_chord = chord, *last_chord = chord, *temp;
    if (!grace) {
        t_llllelem *elem = chord->rhythmic_tree_elem;
        t_llll *gr_level = elem->l_parent;
        while (gr_level && gr_level->l_owner && !is_level_grace(gr_level)) 
            gr_level = gr_level->l_owner->l_parent;
        ((t_rhythm_level_properties *)gr_level->l_thing.w_obj)->level_type &= ~k_RHYTHM_LEVEL_GRACE;
        ((t_rhythm_level_properties *)gr_level->l_thing.w_obj)->is_grace = false;
    } else {
        t_llllelem *orig_elem, *last_elem;
        
        while (orig_chord && chord_is_all_tied_from(orig_chord, true))
            orig_chord = orig_chord->prev;
        
        if (orig_chord) {
            orig_elem = orig_chord->rhythmic_tree_elem;
            last_elem = last_chord->rhythmic_tree_elem;
            
            while (orig_elem && last_elem && orig_elem->l_parent != last_elem->l_parent){
                long orig_depth, last_depth, rel_depth;
                t_llll *anc = llllelem_find_first_common_relative(orig_elem, last_elem, &orig_depth, &last_depth, &rel_depth);
                t_llllelem *next_orig_elem, *next_last_elem;
                if (!anc) {
                    orig_chord = last_chord;
                    orig_elem = last_elem;
                    break;
                }
                
                if (orig_depth > last_depth) {
                    next_orig_elem = orig_elem->l_parent->l_owner;
                    next_last_elem = last_elem;
                    llll_splatter(orig_elem, LLLL_FREETHING_MEM);
                } else {
                    next_last_elem = last_elem->l_parent->l_owner;
                    next_orig_elem = orig_elem;
                    llll_splatter(last_elem, LLLL_FREETHING_MEM);
                }
                orig_elem = next_orig_elem;
                last_elem = next_last_elem;
            }
            
            if (orig_elem && last_elem && orig_elem->l_parent == last_elem->l_parent) {
                t_llll *new_ll = llll_wrap_element_range(orig_elem, last_elem);
                set_level_type_flag_for_level(new_ll, k_RHYTHM_LEVEL_GRACE + k_RHYTHM_LEVEL_ORIGINAL);
                for (temp = orig_chord; temp; temp = chord_get_next(temp)) {
                    temp->is_grace_chord = true;
                    if (temp == last_chord)
                        break;
                }
            }
        }
    }
}

char only_tails_are_selected(t_notation_obj *r_ob){
    char there_are_all_tails = true;
    t_notation_item *it;

    if (r_ob->selection_type == k_DURATION_TAIL)
        return true;

    if (r_ob->selection_type != k_PITCH_BREAKPOINT && r_ob->selection_type != k_PITCH_BREAKPOINT_OR_DURATION_TAIL)
        return false;

    for (it = r_ob->firstselecteditem; it; it = it->next_selected){
        if (it->type != k_PITCH_BREAKPOINT || ((t_bpt *)it)->next){
            there_are_all_tails = false;
            break;
        }
    }
    return there_are_all_tails;
}

// param == 0 returns tp1, params == 1 returns tp2
// only works when voices and meas_num are the same
t_timepoint interpolate_timepoints(t_timepoint tp1, t_timepoint tp2, double param){
    if (tp1.voice_num == tp2.voice_num && tp1.measure_num == tp2.measure_num) {
        double d1 = rat2double(tp1.pt_in_measure);
        double d2 = rat2double(tp2.pt_in_measure);
        double res = rescale(param, 0, 1, d1, d2);
        t_rational new_pim = approx_double_with_rat_fixed_den(res, lcm(100, lcm(tp1.pt_in_measure.r_den, tp2.pt_in_measure.r_den)), 0, NULL);
        return build_timepoint_with_voice(tp1.measure_num, new_pim, tp1.voice_num);
    }
    return tp1;
}

long find_first_free_slot(t_notation_obj *r_ob){
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    long min = 0;
    char restart = true;
    while (restart) {
        for (voice = r_ob->firstvoice; voice && !restart; voice = voice_get_next(r_ob, voice)){
            for (chord = r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? ((t_rollvoice *)voice)->firstchord : (((t_scorevoice *)voice)->firstmeasure ? ((t_scorevoice *)voice)->firstmeasure->firstchord : NULL);
                 chord && !restart; chord = chord_get_next(chord)){
                for (note = chord->firstnote; note && !restart; note = note->next){
                    if (note->slot[min].firstitem) {
                        min++;
                        restart = true;
                        break;
                    }
                }
            }
        }
        if (min == CONST_MAX_SLOTS)
            return -1;
    }
    return min;
}

void shift_voicewise_arrays(t_notation_obj *r_ob, long from_idx, long to_idx, long num_elems_to_shift)
{
    sysmem_copyptr(&r_ob->clefs_as_symlist[from_idx], &r_ob->clefs_as_symlist[to_idx], num_elems_to_shift * sizeof(t_symbol *));
    sysmem_copyptr(&r_ob->keys_as_symlist[from_idx], &r_ob->keys_as_symlist[to_idx], num_elems_to_shift * sizeof(t_symbol *));
//    sysmem_copyptr(&r_ob->voicenames_as_atomlist[from_idx], &r_ob->voicenames_as_atomlist[to_idx], num_elems_to_shift * sizeof(t_atom *));
    sysmem_copyptr(&r_ob->hidevoices_as_charlist[from_idx], &r_ob->hidevoices_as_charlist[to_idx], num_elems_to_shift * sizeof(char));
    sysmem_copyptr(&r_ob->voiceuspacing_as_floatlist[from_idx], &r_ob->voiceuspacing_as_floatlist[to_idx], num_elems_to_shift * sizeof(double));
    sysmem_copyptr(&r_ob->show_measure_numbers[from_idx], &r_ob->show_measure_numbers[to_idx], num_elems_to_shift * sizeof(char));
    sysmem_copyptr(&r_ob->midichannels_as_longlist[from_idx], &r_ob->midichannels_as_longlist[to_idx], num_elems_to_shift * sizeof(long));
    sysmem_copyptr(&r_ob->voice_part[from_idx], &r_ob->voice_part[to_idx], num_elems_to_shift * sizeof(long));
}


void swapelem_voicewise_arrays(t_notation_obj *r_ob, long idx1, long idx2){
    t_symbol *temp = r_ob->clefs_as_symlist[idx2];
    r_ob->clefs_as_symlist[idx2] = r_ob->clefs_as_symlist[idx1];
    r_ob->clefs_as_symlist[idx1] = temp;
    
    temp = r_ob->keys_as_symlist[idx2];
    r_ob->keys_as_symlist[idx2] = r_ob->keys_as_symlist[idx1];
    r_ob->keys_as_symlist[idx1] = temp;

    char temp_char = r_ob->hidevoices_as_charlist[idx2];
    r_ob->hidevoices_as_charlist[idx2] = r_ob->hidevoices_as_charlist[idx1];
    r_ob->hidevoices_as_charlist[idx1] = temp_char;

    double temp_float = r_ob->voiceuspacing_as_floatlist[idx2];
    r_ob->voiceuspacing_as_floatlist[idx2] = r_ob->voiceuspacing_as_floatlist[idx1];
    r_ob->voiceuspacing_as_floatlist[idx1] = temp_float;

    temp_char = r_ob->show_measure_numbers[idx2];
    r_ob->show_measure_numbers[idx2] = r_ob->show_measure_numbers[idx1];
    r_ob->show_measure_numbers[idx1] = temp_char;

    long temp_long = r_ob->midichannels_as_longlist[idx2];
    r_ob->midichannels_as_longlist[idx2] = r_ob->midichannels_as_longlist[idx1];
    r_ob->midichannels_as_longlist[idx1] = temp_long;

    temp_long = r_ob->voice_part[idx2];
    r_ob->voice_part[idx2] = r_ob->voice_part[idx1];
    r_ob->voice_part[idx1] = temp_long;
}

void remove_label_families_data_for_notation_item(t_notation_item *it)
{
    if (it && it->label_families && it->label_families->l_size > 0) {
        t_llllelem *elem = it->label_families->l_head, *nextelem = NULL;
        while (elem) {
            nextelem = elem->l_next;
            t_llll *ll = hatom_getllll(&elem->l_hatom);
            if (ll) {
                t_bach_label_family *fam = (t_bach_label_family *)hatom_getobj(&ll->l_head->l_hatom);
                t_llllelem *fam_elem = fam->llelem;
                t_llllelem *llelem_to_delete = (t_llllelem *)hatom_getobj(&ll->l_head->l_next->l_hatom);
                t_llll *ll_family = llelem_to_delete->l_parent;
                llll_destroyelem(llelem_to_delete);
                
                if (ll_family->l_size == 0) {
                    // must delete whole family.
                    free_label_family(fam);
                    llll_destroyelem(fam_elem);
                } else {
                    fam->need_update_contour = true;
                }
            }
            
            llll_destroyelem(elem);
            elem = nextelem;
        }
    }
}



char change_notation_item_names(t_notation_obj *r_ob, t_notation_item *it, t_llll *newnames, char create_undo_tick)
{
    if (!are_names_equal(it->names, newnames)) {
        if (create_undo_tick)
            create_simple_selected_notation_item_undo_tick(r_ob, it, it->type, k_UNDO_MODIFICATION_CHANGE_NAME);
        
        remove_label_families_data_for_notation_item(it);
        
        llll_free(it->names);
        it->names = newnames ? llll_clone(newnames) : llll_get();
        
        add_label_families_data_for_notation_item(r_ob, it);
        
        return 1;
    }
    return 0;
}



char change_selection_name(t_notation_obj *r_ob, t_llll *newnames, t_llll *only_change_this_elems, 
                           char incremental, char append_names, char also_assign_to_progeny_for_chords, char lambda)
{ 
    char res = 0;
    t_notation_item *curr_it;

    curr_it = r_ob->firstselecteditem;

    set_selected_markers_flags(r_ob, k_FLAG_TO_BE_MODIFIED);
    
    
    curr_it = notation_item_get_first_selected_account_for_lambda(r_ob, lambda);

    
    while (curr_it) { // cycle on the selected items
        t_llll *names = NULL;
        if (append_names) {
            names = get_names_as_llll(curr_it, false);
            llll_chain_clone(names, newnames);
        } else 
            names = newnames;
        
        if (((!only_change_this_elems || only_change_this_elems->l_size == 0) && (curr_it->type == k_NOTE || curr_it->type == k_CHORD || curr_it->type == k_MEASURE)) ||
            (only_change_this_elems && ((curr_it->type == k_NOTE && is_symbol_in_llll_first_level(only_change_this_elems, _llllobj_sym_note)) || 
            (curr_it->type == k_CHORD && is_symbol_in_llll_first_level(only_change_this_elems, _llllobj_sym_chord)) ||
            (curr_it->type == k_MEASURE && is_symbol_in_llll_first_level(only_change_this_elems, _llllobj_sym_measure))))) {
            if (!is_editable(r_ob, curr_it->type, k_MODIFICATION_NAME)) continue;
            res |= change_notation_item_names(r_ob, curr_it, names, true);
            if (also_assign_to_progeny_for_chords && curr_it->type == k_CHORD) {
                t_note *nt;
                for (nt = ((t_chord *)curr_it)->firstnote; nt; nt = nt->next)
                    res |= change_notation_item_names(r_ob, (t_notation_item *)nt, names, true);
            }
        } else if (curr_it->type == k_MARKER && ((!only_change_this_elems || only_change_this_elems->l_size == 0) || is_symbol_in_llll_first_level(only_change_this_elems, _llllobj_sym_marker))) {
            if (!is_editable(r_ob, k_MARKER, k_MODIFICATION_NAME)) continue;
            t_llll *newnames_ok = NULL;
            create_header_undo_tick(r_ob, k_HEADER_MARKERS);
//            if (incremental && names->l_head && ((t_marker *)curr_it)->role == k_MARKER_ROLE_NONE)
            if (incremental && names->l_head) // && ((t_marker *)curr_it)->role == k_MARKER_ROLE_NONE)
                newnames_ok = find_unused_marker_names(r_ob, &names->l_head->l_hatom, (t_marker *) curr_it);
            else 
                newnames_ok = llll_clone(names);
            res |= change_marker_names(r_ob, (t_marker *)curr_it, newnames_ok);
            curr_it->flags &= ~k_FLAG_TO_BE_MODIFIED;
            llll_free(newnames_ok);
        } else if (curr_it->type == k_VOICE && ((!only_change_this_elems || only_change_this_elems->l_size == 0) || is_symbol_in_llll_first_level(only_change_this_elems, _llllobj_sym_voice))) {
            if (!is_editable(r_ob, k_VOICE, k_MODIFICATION_NAME)) continue;
            change_single_voicename(r_ob, (t_voice *)curr_it, names, true);
        }
        
        if (append_names)
            llll_free(names);
        
        curr_it = lambda ? NULL : curr_it->next_selected;
    }
    
    unset_selected_markers_flags(r_ob, k_FLAG_TO_BE_MODIFIED);

    
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    return res;
}

/*
void notation_obj_clearnames(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *names = llll_get();
    change_selection_name(r_ob, names, NULL, false, false, false);
    handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_CLEAR_NAMES);
    llll_free(names);
}
*/

void notation_obj_name(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *selectllll = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    char incremental = find_long_arg_attr_key(selectllll, gensym("incremental"), 0, true);
    char progeny = find_long_arg_attr_key(selectllll, gensym("progeny"), 0, true);
    char append = find_long_arg_attr_key(selectllll, gensym("append"), 0, true);
    t_symbol *unique = find_symbol_arg_attr_key(selectllll, gensym("unique"), _llllobj_sym_none, true);
    t_llll *names = get_names_from_llll(r_ob, selectllll);
    if (unique == gensym("sym") || unique == gensym("symbol")) {
        llll_clear(names);
        llll_appendsym(names, symbol_unique());
    } else if (unique == gensym("int") || unique == gensym("integer")) {
        llll_clear(names);
        t_hatom h;
        long u = -1;
        for (long i = 1; i < LONG_MAX; i++) {
            hatom_setlong(&h, i);
            if (!notationobj_name_is_used(r_ob, &h)) {
                u = i;
                break;
            }
        }
        if (u > 0)
            llll_appendlong(names, u);
        else {
            object_error((t_object *)r_ob, "Can't find unique integer name available.");
        }
    }
    change_selection_name(r_ob, names, NULL, incremental, append, progeny, s == _llllobj_sym_lambda);
    handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_CHANGE_NAMES);
    llll_free(selectllll);
    llll_free(names);
}

void notation_obj_nameappend(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *selectllll = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    t_llll *names = get_names_from_llll(r_ob, selectllll);
    change_selection_name(r_ob, names, NULL, false, true, false, s == _llllobj_sym_lambda);
    handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_CHANGE_NAMES);
    llll_free(selectllll);
    llll_free(names);
}


e_nametoslot_chordname_policy symbol_to_nametoslot_chordname_policy(t_symbol *s)
{
    if (s == gensym("ignore"))
        return k_NAMETOSLOT_CHORDNAME_IGNORE;
    if (s == gensym("replace"))
        return k_NAMETOSLOT_CHORDNAME_REPLACE;
    if (s == gensym("replacenull"))
        return k_NAMETOSLOT_CHORDNAME_REPLACEIFNULL;
    if (s == gensym("prepend"))
        return k_NAMETOSLOT_CHORDNAME_PREPEND;
    if (s == gensym("append") || s == gensym("postpend"))
        return k_NAMETOSLOT_CHORDNAME_APPEND;
    if (s == gensym("merge") || s == gensym("mergeprepend"))
        return k_NAMETOSLOT_CHORDNAME_MERGEPREPEND;
    if (s == gensym("mergeappend") || s == gensym("mergepostpend"))
        return k_NAMETOSLOT_CHORDNAME_MERGEAPPEND;

    return k_NAMETOSLOT_CHORDNAME_MERGEPREPEND;
}

void note_nametoslot_do(t_notation_obj *r_ob, t_note *nt, long slotnum, e_nametoslot_chordname_policy policy)
{
    t_notation_item *nt_it = (t_notation_item *)nt;
    t_notation_item *ch_it = (t_notation_item *)((t_note *)nt_it)->parent;
    t_llll *slotll = NULL;
    if ((ch_it->names && ch_it->names->l_size > 0) && (policy == k_NAMETOSLOT_CHORDNAME_REPLACE || (policy == k_NAMETOSLOT_CHORDNAME_REPLACEIFNULL && (nt_it->names && nt_it->names->l_size == 0)))) {
        slotll = llll_clone(ch_it->names);
    } else if ((ch_it->names && ch_it->names->l_size > 0) && policy == k_NAMETOSLOT_CHORDNAME_PREPEND) {
        slotll = llll_clone(ch_it->names);
        llll_chain_clone(slotll, nt_it->names);
    } else if ((ch_it->names && ch_it->names->l_size > 0) && policy == k_NAMETOSLOT_CHORDNAME_APPEND) {
        slotll = llll_clone(nt_it->names);
        llll_chain_clone(slotll, ch_it->names);
    } else if ((ch_it->names && ch_it->names->l_size > 0) && policy == k_NAMETOSLOT_CHORDNAME_MERGEPREPEND) {
        // merge things more wisely...
        slotll = llll_clone(ch_it->names);
        llll_union(slotll, llll_clone(nt_it->names));
    } else if ((ch_it->names && ch_it->names->l_size > 0) && policy == k_NAMETOSLOT_CHORDNAME_MERGEAPPEND) {
        // merge things more wisely...
        slotll = llll_clone(nt_it->names);
        llll_union(slotll, llll_clone(ch_it->names));
    } else { // ignore
        slotll = llll_clone(nt_it->names);
    }
    llll_prependlong(slotll, slotnum + 1);
    llll_wrap_once(&slotll);
    
    if (slotll)
        set_slots_values_to_notationitem_from_llll(r_ob, nt_it, slotll);
    else
        note_clear_slot(r_ob, nt, slotnum);
    llll_free(slotll);
}

long notation_obj_nametoslot_do(t_notation_obj *r_ob, long slotnum, e_nametoslot_chordname_policy policy)
{
    long changed = 0;
    lock_general_mutex(r_ob);
    for (t_notation_item *curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        switch (curr_it->type) {
            case k_NOTE:
                changed = 1;
                create_simple_notation_item_undo_tick(r_ob, curr_it, k_UNDO_MODIFICATION_CHANGE);
                note_nametoslot_do(r_ob, (t_note *)curr_it, slotnum, policy);
                break;
                
            case k_CHORD:
            {
                changed = 1;
                create_simple_notation_item_undo_tick(r_ob, curr_it, k_UNDO_MODIFICATION_CHANGE);
                t_chord *ch = (t_chord *)curr_it;
                if (ch->firstnote) {
                    for (t_note *nt = ch->firstnote; nt; nt = nt->next)
                        note_nametoslot_do(r_ob, nt, slotnum, policy);
                } else {
                    // it's a rest
                    t_llll *slotll = llll_clone(curr_it->names);
                    llll_prependlong(slotll, slotnum + 1);
                    llll_wrap_once(&slotll);
                    set_slots_values_to_notationitem_from_llll(r_ob, curr_it, slotll);
                    llll_free(slotll);
                }
            }
                break;
                
            default:
                break;
        }
    }
    unlock_general_mutex(r_ob);
    return changed;
}


void notation_obj_nametoslot(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *selectllll = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    if (selectllll && selectllll->l_head) {
        e_nametoslot_chordname_policy policy = k_NAMETOSLOT_CHORDNAME_MERGEPREPEND;
        long slotnum = llllelem_to_slotnum(r_ob, selectllll->l_head, true);
        if (selectllll->l_head->l_next && hatom_gettype(&selectllll->l_head->l_next->l_hatom) == H_SYM)
            policy = symbol_to_nametoslot_chordname_policy(hatom_getsym(&selectllll->l_head->l_next->l_hatom));
        notation_obj_nametoslot_do(r_ob, slotnum, policy);
        handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_NAMES_TO_SLOT);
    }
    llll_free(selectllll);
}




void note_slottoname_do(t_notation_obj *r_ob, t_note *nt, long slotnum)
{
    t_notation_item *nt_it = (t_notation_item *)nt;
    t_notation_item *ch_it = (t_notation_item *)nt->parent;
    t_llll *newnames = notation_item_get_single_slot_values_as_llll(r_ob, nt_it, k_CONSIDER_FOR_SLOT_VALUES_ONLY, slotnum, false);
    
    if (ch_it->names && ch_it->names->l_size > 0) {
        t_llll *empty_ll = llll_get();
        change_notation_item_names(r_ob, ch_it, empty_ll, true);
        llll_free(empty_ll);
    }
    
    change_notation_item_names(r_ob, nt_it, newnames, true);
    
    llll_free(newnames);
}

long notation_obj_slottoname_do(t_notation_obj *r_ob, long slotnum)
{
    char changed = 0;

    lock_general_mutex(r_ob);

    for (t_notation_item *curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) {
        
        switch (curr_it->type) {
            case k_NOTE:
                changed = 1;
                note_slottoname_do(r_ob, (t_note *)curr_it, slotnum);
                break;

            case k_CHORD:
                changed = 1;
                if (((t_chord *)curr_it)->firstnote) {
                    for (t_note *nt = ((t_chord *)curr_it)->firstnote; nt; nt = nt->next)
                        note_slottoname_do(r_ob, nt, slotnum);
                } else {
                    // it's a rest
                    t_llll *newnames = notation_item_get_single_slot_values_as_llll(r_ob, curr_it, k_CONSIDER_FOR_SLOT_VALUES_ONLY, slotnum, false);
                    change_notation_item_names(r_ob, curr_it, newnames, true);
                    llll_free(newnames);
                }
                break;

            default:
                break;
        }
    }
    
    unlock_general_mutex(r_ob);
    
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    return changed;
}

void notation_obj_slottoname(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *selectllll = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    if (selectllll && selectllll->l_head) {
        long slotnum = llllelem_to_slotnum(r_ob, selectllll->l_head, true);
        notation_obj_slottoname_do(r_ob, slotnum);
        handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_NAMES_FROM_SLOT);
    }
    llll_free(selectllll);
}




void notation_obj_clear_names(t_notation_obj *r_ob, long voices, long measures, long chords, long notes, long markers) 
{
    (r_ob->whole_obj_undo_tick_function)(r_ob);
    
    t_voice *voice;
    t_measure *measure;
    t_chord *chord; 
    t_note *note;
    t_llll *empty_ll = llll_get();
    
    if (voices || measures || chords || notes) {
        for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
            
            if (voices) {
                if (!is_editable(r_ob, k_VOICE, k_MODIFICATION_NAME)) continue;
                change_single_voicename(r_ob, voice, empty_ll, false);
            }
            
            if (measures && r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
                if (!is_editable(r_ob, k_MEASURE, k_MODIFICATION_NAME)) continue;
                for (measure = ((t_scorevoice *)voice)->firstmeasure; measure; measure = measure->next)
                    change_notation_item_names(r_ob, (t_notation_item *)measure, empty_ll, false);
            }
            
            if (chords || notes) {
                for (chord = (r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? ((t_rollvoice *)voice)->firstchord :
                              (((t_scorevoice *)voice)->firstmeasure ? ((t_scorevoice *)voice)->firstmeasure->firstchord : NULL)); 
                     chord; chord = chord_get_next(chord)) {
                    
                    if (chords) {
                        if (is_editable(r_ob, k_CHORD, k_MODIFICATION_NAME))
                            change_notation_item_names(r_ob, (t_notation_item *)chord, empty_ll, false);
                    }
                    
                    if (notes) {
                        if (is_editable(r_ob, k_NOTE, k_MODIFICATION_NAME))
                            for (note = chord->firstnote; note; note = note->next)
                                change_notation_item_names(r_ob, (t_notation_item *)note, empty_ll, false);
                    }
                }
            }
        }
    }
    
    if (markers) {
        t_marker *marker;
        if (is_editable(r_ob, k_MARKER, k_MODIFICATION_NAME)) {
            for (marker = r_ob->firstmarker; marker; marker = marker->next)
                change_marker_names(r_ob, marker, empty_ll);
        }
    }
    
    llll_free(empty_ll);
    
    handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_CHANGE_NAMES);
}





char change_selection_role(t_notation_obj *r_ob, t_symbol *new_role, t_llll *new_value, char lambda)
{
    char res = 0;
    t_notation_item *curr_it;
    
    curr_it = r_ob->firstselecteditem;
    
    curr_it = notation_item_get_first_selected_account_for_lambda(r_ob, lambda);
    
    e_marker_roles role_ok = sym_to_marker_role(new_role);
    
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_MARKER) {
            if (!is_editable(r_ob, k_MARKER, k_MODIFICATION_GENERIC)) continue;
            change_marker_role(r_ob, ((t_marker *)curr_it), role_ok, new_value);
        }
        
        curr_it = lambda ? NULL : curr_it->next_selected;
    }
    
    notationobj_invalidate_notation_static_layer_and_redraw(r_ob);
    return res;
}



void notation_obj_role(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv)
{
    t_llll *args = llllobj_parse_llll((t_object *) r_ob, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_CLONE);
    if (args && args->l_head && hatom_gettype(&args->l_head->l_hatom) == H_SYM) {
        t_llll *rolevalue = NULL;
        if (args->l_head->l_next && hatom_gettype(&args->l_head->l_next->l_hatom) == H_LLLL)
            rolevalue = hatom_getllll(&args->l_head->l_next->l_hatom);
        create_header_undo_tick(r_ob, k_HEADER_MARKERS);
        change_selection_role(r_ob, hatom_getsym(&args->l_head->l_hatom), rolevalue, s == _llllobj_sym_lambda);
        handle_change_if_there_are_free_undo_ticks(r_ob, k_CHANGED_STANDARD_UNDO_MARKER, k_UNDO_OP_CHANGE_ROLES);
    }
    llll_free(args);
}






// THIS IS AN EXPERIMENTAL FUNCTION, NOT VERY USED UP TO NOW.
// iterate the function fn on the (globally) selected notes of the notation object <r_ob>.
// changes must be NON-destructive?
char iterate_notewise_changes_on_selection(t_notation_obj *r_ob, notation_obj_note_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem, char also_apply_on_notetails)
{
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items

        if (curr_it->type == k_NOTE) { // it is a note
            t_note *nt = (t_note *) curr_it;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                fn(r_ob, nt, data);
                changed = 1;
            }
        } else if (curr_it->type == k_CHORD) {
            t_note *temp_nt = ((t_chord *)curr_it)->firstnote;
            while (temp_nt) {
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, curr_it, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                    fn(r_ob, temp_nt, data);
                    changed = 1;
                }
                temp_nt = temp_nt->next;
            }
        } else if (curr_it->type == k_MEASURE) {
            t_chord *temp_ch = ((t_measure *)curr_it)->firstchord;
            while (temp_ch) {
                t_note *temp_nt = temp_ch->firstnote;
                while (temp_nt) {
                    if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)temp_nt)) {
                        create_simple_selected_notation_item_undo_tick(r_ob, curr_it, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                        fn(r_ob, temp_nt, data);
                        changed = 1;
                    }
                    temp_nt = temp_nt->next;
                }
                temp_ch = temp_ch->next;
            }
        } else if (curr_it->type == k_PITCH_BREAKPOINT && !((t_bpt *) curr_it)->next) {
            t_note *nt = ((t_bpt *) curr_it)->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)nt)) {
                create_simple_selected_notation_item_undo_tick(r_ob, curr_it, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                fn(r_ob, nt, data);
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}


// set (if val != 0) or unset (if val = 0) a given flag for all selected notation items of a certain type
void set_unset_flag_to_selected_chords(t_notation_obj *r_ob, long flag, char val, char also_apply_if_single_note_selected)
{
    t_notation_item *curr_it;
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) { // cycle on the selected items
        if (curr_it->type == k_NOTE && also_apply_if_single_note_selected) {
            t_chord *ch = ((t_note *) curr_it)->parent;
            if (val)
                ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | flag);
            else
                ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags & ~flag);
        } else if (curr_it->type == k_CHORD) { 
            t_chord *ch = (t_chord *) curr_it;
            if (val)
                ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | flag);
            else
                ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags & ~flag);
        } else if (curr_it->type == k_MEASURE) {
            t_chord *ch;
            for (ch = ((t_measure *)curr_it)->firstchord; ch; ch = ch->next) {
                if (val)
                    ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | flag);
                else
                    ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags & ~flag);
            }
        }
    }
}

char iterate_chordwise_changes_on_selection(t_notation_obj *r_ob, notation_obj_chord_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem, char also_apply_if_single_note_selected){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);
    
    
    /*
    for (curr_it = r_ob->firstselecteditem; curr_it; curr_it = curr_it->next_selected) { // cycle on the selected items
        if (curr_it->type == k_NOTE && also_apply_if_single_note_selected) {
            t_chord *ch = ((t_note *) curr_it)->parent;
            ch->r_it.flags &= ~k_FLAG_MODIFIED;
        } else if (curr_it->type == k_CHORD) { 
            t_chord *ch = (t_chord *) curr_it;
            ch->r_it.flags &= ~k_FLAG_MODIFIED;
        } else if (curr_it->type == k_MEASURE) {
            t_chord *ch = ((t_measure *)curr_it)->firstchord;
            while (ch) {
                ch->r_it.flags &= ~k_FLAG_MODIFIED;
                ch = ch->next;
            }
        }
    }
    */
    
    set_unset_flag_to_selected_chords(r_ob, k_FLAG_MODIFIED, 0, also_apply_if_single_note_selected);
    
    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items

        if (curr_it->type == k_NOTE && also_apply_if_single_note_selected) { 
            t_chord *ch = ((t_note *) curr_it)->parent;
            if (!(ch->r_it.flags & k_FLAG_MODIFIED)){ 
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)ch)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                    fn(r_ob, ch, data);
                    ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | k_FLAG_MODIFIED);
                    changed = 1;
                }
            }
        } else if (curr_it->type == k_CHORD) {
            t_chord *ch = (t_chord *)curr_it;
            if (!(ch->r_it.flags & k_FLAG_MODIFIED)) {
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)ch)) {
                    create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                    fn(r_ob, ch, data);
                    ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | k_FLAG_MODIFIED);
                    changed = 1;
                }
            }
        } else if (curr_it->type == k_MEASURE) {
            t_chord *ch = ((t_measure *)curr_it)->firstchord;
            while (ch) {
                if (!(ch->r_it.flags & k_FLAG_MODIFIED)) {
                    if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)ch)) {
                        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
                        fn(r_ob, ch, data);
                        ch->r_it.flags = (e_bach_internal_notation_flags) (ch->r_it.flags | k_FLAG_MODIFIED);
                        changed = 1;
                    }
                }
                ch = ch->next;
            }
        }
        curr_it = curr_it->next_selected;
    }
    
    
    set_unset_flag_to_selected_chords(r_ob, k_FLAG_MODIFIED, 0, also_apply_if_single_note_selected);
    
    unlock_general_mutex(r_ob);    
    return changed;
}



// THIS IS AN EXPERIMENTAL FUNCTION, NOT VERY USED UP TO NOW.
char iterate_changes_on_selection(t_notation_obj *r_ob, notation_obj_notation_item_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem){ 
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    lock_general_mutex(r_ob);    
    while (curr_it) { // cycle on the selected items
        if (!notation_item_is_globally_locked(r_ob, curr_it)) {
            create_simple_selected_notation_item_undo_tick(r_ob, curr_it, smallest_undoable_elem, k_UNDO_MODIFICATION_CHANGE);
            fn(r_ob, curr_it, data);
            changed = 1;
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);    
    return changed;
}

void set_all_prevent_edit_to_value(t_prevent_edit *pe, long val)
{
    pe->chord_onset = val;
    pe->note_duration = val;
    pe->note_pitch = val;
    pe->note_velocity = val;
    pe->note_creation = val;
    pe->chord_deletion = val;
    pe->chord_creation = val;
    pe->note_deletion = val;
    pe->note_modification = val;
    pe->slot = val;
    pe->breakpoints_onset = val;
    pe->breakpoints_pitch = val;
    pe->breakpoints_velocity = val;
    pe->breakpoints_creation = val;
    pe->breakpoints_deletion = val;
    pe->measure_creation = val;
    pe->measure_deletion = val;
    pe->measure_rhythmic_tree = val;
    pe->measure_modification = val;
    pe->voice_creation = val;
    pe->voice_deletion = val;
    pe->voice_position = val;
    pe->voice_name = val;
    pe->voice_clef = val;
    pe->voice_key = val;
    pe->voice_modification = val;
    pe->timesignature_modification = val;
    pe->tempo_creation = val;
    pe->tempo_deletion = val;
    pe->tempo_modification = val;
    pe->marker_onset = val;
    pe->marker_name = val;
    pe->marker_creation = val;
    pe->marker_deletion = val;
    pe->marker_modification = val;
    pe->articulation_creation = val;
    pe->articulation_deletion = val;
    pe->selection_single = val;
    pe->selection_multiple = val;
    pe->zooming = val;
    pe->dilation_rect = val;
    pe->grouping = val;
    pe->inspector = val;
    pe->popup_menu = val;
    pe->slotinfo = val;
    pe->lyrics = val;
    pe->dynamics = val;
    pe->cursor = val;
    pe->loop_region = val;
    pe->scrollbar = val;
    pe->drop = val;
}

void clear_prevent_edit(t_prevent_edit *pe)
{
    set_all_prevent_edit_to_value(pe, 0);
}

char is_editable(t_notation_obj *r_ob, e_element_types element_type, e_element_actions action)
{
    switch (element_type) {
        case k_NOTE:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.note_creation;
                case k_DELETION: return !r_ob->prevent_edit.note_deletion;
                case k_MODIFICATION_ONSET: return !r_ob->prevent_edit.chord_onset;
                case k_MODIFICATION_DURATION: return !r_ob->prevent_edit.note_duration;
                case k_MODIFICATION_PITCH: return !r_ob->prevent_edit.note_pitch;
                case k_MODIFICATION_VELOCITY: return !r_ob->prevent_edit.note_velocity;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.note_modification;
                default: return 1;
            }
        }
            break;
        case k_CHORD: case k_NOTE_OR_CHORD:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.chord_creation;
                case k_DELETION: return !r_ob->prevent_edit.chord_deletion;
                case k_MODIFICATION_ONSET: return !r_ob->prevent_edit.chord_onset;
                case k_MODIFICATION_DURATION: return !r_ob->prevent_edit.note_duration;
                case k_MODIFICATION_PITCH: return !r_ob->prevent_edit.note_pitch;
                case k_MODIFICATION_VELOCITY: return !r_ob->prevent_edit.note_velocity;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.note_modification;
                default: return 1;
            }
        }
            break;
        case k_PITCH_BREAKPOINT:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.breakpoints_creation;
                case k_DELETION: return !r_ob->prevent_edit.breakpoints_deletion;
                case k_MODIFICATION_ONSET: return !r_ob->prevent_edit.breakpoints_onset;
                case k_MODIFICATION_PITCH: return !r_ob->prevent_edit.breakpoints_pitch;
                case k_MODIFICATION_VELOCITY: return !r_ob->prevent_edit.breakpoints_velocity;
                default: return 1;
            }
        }
            break;
        case k_MEASURE:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.measure_creation;
                case k_DELETION: return !r_ob->prevent_edit.measure_deletion;
                case k_MODIFICATION_RHYTHMIC_TREE: return !r_ob->prevent_edit.measure_rhythmic_tree;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.measure_modification;
                default: return 1;
            }
        }
            break;
        case k_VOICE:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.voice_creation;
                case k_DELETION: return !r_ob->prevent_edit.voice_deletion;
                case k_MODIFICATION_NAME: return !r_ob->prevent_edit.voice_name;
                case k_MODIFICATION_CLEF: return !r_ob->prevent_edit.voice_clef;
                case k_MODIFICATION_KEY: return !r_ob->prevent_edit.voice_key;
                case k_MODIFICATION_POSITION: return !r_ob->prevent_edit.voice_position;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.voice_modification;
                default: return 1;
            }
        }
            break;
        case k_TEMPO:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.tempo_creation;
                case k_DELETION: return !r_ob->prevent_edit.tempo_deletion;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.tempo_modification;
                default: return 1;
            }
        }
            break;
        case k_MARKER:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.marker_creation;
                case k_DELETION: return !r_ob->prevent_edit.marker_deletion;
                case k_MODIFICATION_ONSET: return !r_ob->prevent_edit.marker_onset;
                case k_MODIFICATION_NAME: return !r_ob->prevent_edit.marker_name;
                case k_MODIFICATION_GENERIC: return !r_ob->prevent_edit.marker_modification;
                default: return 1;
            }
        }
            break;
        case k_ARTICULATION:
        {
            switch (action) {
                case k_CREATION: return !r_ob->prevent_edit.articulation_creation;
                case k_DELETION: return !r_ob->prevent_edit.articulation_deletion;
                default: return 1;
            }
        }
            break;
        case k_SLOT:
            return !r_ob->prevent_edit.slot;
        case k_SLOTINFO:
            return !r_ob->prevent_edit.slotinfo;
        case k_TIME_SIGNATURE:
            return !r_ob->prevent_edit.timesignature_modification;
        case k_SELECTION:
        {
            switch (action) {
                case k_SINGLE_SELECTION: return !r_ob->prevent_edit.selection_single;
                case k_MULTIPLE_SELECTION: return !r_ob->prevent_edit.selection_multiple;
                default: return !(r_ob->prevent_edit.selection_single || r_ob->prevent_edit.selection_multiple);
            }
        }
        case k_ZOOMING_REGION:
            return !r_ob->prevent_edit.zooming;
        case k_DILATION_RECTANGLE:
            return !r_ob->prevent_edit.dilation_rect;
        case k_GROUP:
            return !r_ob->prevent_edit.grouping;
        case k_BACH_INSPECTOR:
            return !r_ob->prevent_edit.inspector;
        case k_POPUP_MENU:
            return !r_ob->prevent_edit.popup_menu;
        case k_LYRICS:
            return !r_ob->prevent_edit.lyrics;
        case k_DYNAMICS:
            return !r_ob->prevent_edit.dynamics;
        case k_PLAYCURSOR:
            return !r_ob->prevent_edit.cursor;
        case k_LOOP_REGION:
            return !r_ob->prevent_edit.loop_region;
        case k_SCROLLBAR:
            return !r_ob->prevent_edit.scrollbar;
        case k_DROP:
            return !r_ob->prevent_edit.drop;
        default: return 1;
    }
    return 1;
}

// convert the name of an element as a symbol (like gensym("note")) into the corresponding id as a #e_element_types;
long elementtypesym2elementtypeid(t_symbol *sym)
{
    if (sym == _llllobj_sym_note || sym == _llllobj_sym_notes)
        return k_NOTE;
    else if (sym == _llllobj_sym_breakpoint || sym == _llllobj_sym_breakpoints)
        return k_PITCH_BREAKPOINT;
    else if (sym == _llllobj_sym_tail || sym == _llllobj_sym_tails)
        return k_DURATION_TAIL;
    else if (sym == _llllobj_sym_chord || sym == _llllobj_sym_chords)
        return k_CHORD;
    else if (sym == _llllobj_sym_selection)
        return k_SELECTION;
    else if (sym == _llllobj_sym_scrollbar || sym == _llllobj_sym_scrollbars)
        return k_SCROLLBAR;
    else if (sym == _llllobj_sym_voice || sym == _llllobj_sym_voices)
        return k_VOICE;
    else if (sym == _llllobj_sym_measure || sym == _llllobj_sym_measures)
        return k_MEASURE;
    else if (sym == _llllobj_sym_tempo || sym == _llllobj_sym_tempi)
        return k_TEMPO;
    else if (sym == _llllobj_sym_cursor)
        return k_PLAYCURSOR;
    else if (sym == _llllobj_sym_loop)
        return k_LOOP_REGION;
    else if (sym == _llllobj_sym_slot || sym == _llllobj_sym_slots)
        return k_SLOT;
    else if (sym == _llllobj_sym_articulation || sym == _llllobj_sym_articulations)
        return k_ARTICULATION;
    else if (sym == _llllobj_sym_slur || sym == _llllobj_sym_slurs)
        return k_SLUR;
    else if (sym == _llllobj_sym_marker || sym == _llllobj_sym_markers)
        return k_MARKER;
    else if (sym == _llllobj_sym_zoom)
        return k_ZOOMING_REGION;
    else if (sym == _llllobj_sym_dilationrectangle)
        return k_DILATION_RECTANGLE;
    else if (sym == _llllobj_sym_barline || sym == _llllobj_sym_barlines)
        return k_MEASURE_END_BARLINE;
    else if (sym == _llllobj_sym_lyrics)
        return k_LYRICS;
    else if (sym == _llllobj_sym_dynamics)
        return k_DYNAMICS;
    else if (sym == _llllobj_sym_timesig || sym == _llllobj_sym_timesignature || sym == _llllobj_sym_timesignatures)
        return k_TIME_SIGNATURE;
    else if (sym == _llllobj_sym_slotinfo)
        return k_SLOTINFO;
    else if (sym == _llllobj_sym_inspector)
        return k_BACH_INSPECTOR;
    else if (sym == _llllobj_sym_popup)
        return k_POPUP_MENU;
    else if (sym == _llllobj_sym_group || sym == _llllobj_sym_groups)
        return k_GROUP;
    else if (sym == gensym("drop"))
        return k_DROP;
    return k_NONE;
}

long actiontypesym2actiontypeid(t_symbol *sym)
{
    if (sym == _llllobj_sym_create)
        return k_CREATION;
    else if (sym == _llllobj_sym_delete)
        return k_DELETION;
    else if (sym == _llllobj_sym_onset || sym == _llllobj_sym_onsets)
        return k_MODIFICATION_ONSET;
    else if (sym == _llllobj_sym_pitch || sym == _llllobj_sym_cents || sym == _llllobj_sym_cent)
        return k_MODIFICATION_PITCH;
    else if (sym == _llllobj_sym_velocity || sym == _llllobj_sym_velocities)
        return k_MODIFICATION_VELOCITY;
    else if (sym == _llllobj_sym_duration || sym == _llllobj_sym_duration)
        return k_MODIFICATION_DURATION;
    else if (sym == _llllobj_sym_position)
        return k_MODIFICATION_POSITION;
    else if (sym == _llllobj_sym_clef || sym == _llllobj_sym_clefs)
        return k_MODIFICATION_CLEF;
    else if (sym == _llllobj_sym_key || sym == _llllobj_sym_keys)
        return k_MODIFICATION_KEY;
    else if (sym == _llllobj_sym_name || sym == _llllobj_sym_names)
        return k_MODIFICATION_NAME;
    else if (sym == _llllobj_sym_rhythmictree)
        return k_MODIFICATION_RHYTHMIC_TREE;
    else if (sym == _llllobj_sym_modify)
        return k_MODIFICATION_GENERIC;
    else if (sym == gensym("multiple"))
        return k_MULTIPLE_SELECTION;
    else if (sym == gensym("single"))
        return k_SINGLE_SELECTION;
    return k_ELEMENT_ACTIONS_NONE; //was: -1
}


t_symbol *clef_llllelem_to_symbol(t_llllelem *el)
{
    t_symbol *clef_sym = NULL;
    if (hatom_gettype(&el->l_hatom) == H_SYM) {
        clef_sym = hatom_getsym(&el->l_hatom);
        
        // fixing syntax, if needed
        long j, len = strlen(clef_sym->s_name);
        char string[2048];
        
        if (len > 5 || (len <= 5 && len > 0 && clef_sym->s_name[0] != 'g' && clef_sym->s_name[0] != 'f' && clef_sym->s_name[0] != 'G' && clef_sym->s_name[0] != 'F')) {
            // symbolic clefs (Alto, Tenor...)
            string[0] = (clef_sym->s_name[0] >= 97 && clef_sym->s_name[0] <= 122) ? clef_sym->s_name[0] - 32 : clef_sym->s_name[0];
            for (j = 1; j < 2048 && j < len; j++)
                string[j] = (clef_sym->s_name[j] >= 65 && clef_sym->s_name[j] <= 90) ? clef_sym->s_name[j] + 32 : clef_sym->s_name[j];
        } else {
            // GF clefs and clef combinations
            for (j = 0; j < 2048 && j < len; j++)
                string[j] = (clef_sym->s_name[j] == 'f' || clef_sym->s_name[j] == 'g') ? clef_sym->s_name[j] - 32 : clef_sym->s_name[j];
        }
        string[len] = 0;
        
        clef_sym = gensym(string);
        
        if (clef_sym == _llllobj_sym_GF)
            clef_sym = _llllobj_sym_FG;
        else if (clef_sym == _llllobj_sym_GGF)
            clef_sym = _llllobj_sym_FGG;
        else if (clef_sym == _llllobj_sym_GFF)
            clef_sym = _llllobj_sym_FFG;
        else if (clef_sym == _llllobj_sym_GGFF)
            clef_sym = _llllobj_sym_FFGG;
        
    } else if (hatom_gettype(&el->l_hatom) == H_PITCH) { // we need to separately address the clefs F8vb and G8vb (and for bw compatibility F8 and G8)
        t_pitch p = hatom_getpitch(&el->l_hatom);
        if (p == t_pitch(3, genrat(-5, 8), 8)) // F8vb
            clef_sym = _llllobj_sym_F8vb;
        else if (p == t_pitch(4, genrat(-5, 8), 8)) // G8vb
            clef_sym = _llllobj_sym_G8vb;
        else if (p == t_pitch(3, long2rat(0), 8)) // F8
            clef_sym = _llllobj_sym_F8vb;
        else if (p == t_pitch(4, long2rat(0), 8)) // G8
            clef_sym = _llllobj_sym_G8va;
    }
    return clef_sym;
}

// pitches is an llll (not necessarily plain) with the midicents of all pitches (left untouched, function is NOT destructive)
// data falling farther than <cutoff_threshold> * stdev(pitches) are deleted, then
// the data range is compared with the staff ranges
long infer_most_appropriate_clef(t_notation_obj *r_ob, t_llll *pitches, double cutoff_threshold, t_llll *allowed_clefs)
{
    t_llllelem *elem;
    t_hatom h_sum, *h_min = NULL, *h_max = NULL;
    double sum = 0, average = 0;
    double min, max;
    
    if (pitches->l_size == 0)
        return k_CLEF_G;
    
    t_llll *minaddress = llll_get(), *maxaddress = llll_get();
    t_llll *pitches_wk = llll_clone(pitches);
    llll_flatten(pitches_wk, 0, 0);
    llll_minmax(pitches_wk, &h_min, &h_max, minaddress, maxaddress, 0, 0);
    llll_sum(pitches_wk, &h_sum, 0, -1);
    min = hatom_getdouble(h_min);
    max = hatom_getdouble(h_max);
    sum = hatom_getdouble(&h_sum);
    average = sum / pitches_wk->l_size;
    
    double variance = 0;
    for (elem = pitches_wk->l_head; elem; elem = elem->l_next)
        variance += (hatom_getdouble(&elem->l_hatom) - average) * (hatom_getdouble(&elem->l_hatom) - average);
    variance /= pitches_wk->l_size;
    
    double stdev = sqrt(variance);
    
    elem = pitches_wk->l_head;
    while (elem) {
        t_llllelem *nextelem = elem->l_next;
        double this_val = hatom_getdouble(&elem->l_hatom);
        if (fabs(this_val - average) >  cutoff_threshold * stdev)
            llll_destroyelem(elem);
        elem = nextelem;
    }
    
    llll_clear(minaddress);
    llll_clear(maxaddress);
    
    // retreving new maximum and minimum
    llll_minmax(pitches_wk, &h_min, &h_max, minaddress, maxaddress, 0, 0);
    min = hatom_getdouble(h_min);
    max = hatom_getdouble(h_max);
    
    // searching for fitting key
    long num_allowed_clefs = 12;
    long clefs_to_test[1024];
    long backup_clef = k_CLEF_FFGG;
    long found = -1, i;
    double best_diff = DBL_MAX;
    
    if (allowed_clefs) {
        i = 0;
        for (t_llllelem *el = allowed_clefs->l_head; el && i < 1024; el = el->l_next) {
            long c = hatom_getlong(&el->l_hatom);
            if (i == 0)
                backup_clef = c;
            clefs_to_test[i++] = c;
        }
        num_allowed_clefs = i;
    } else {
        num_allowed_clefs = 12;
        clefs_to_test[0] = k_CLEF_G;
        clefs_to_test[1] = k_CLEF_F;
        clefs_to_test[2] = k_CLEF_G8va;
        clefs_to_test[3] = k_CLEF_G15ma;
        clefs_to_test[4] = k_CLEF_F8vb;
        clefs_to_test[5] = k_CLEF_F15mb;
        clefs_to_test[6] = k_CLEF_FG;
        clefs_to_test[7] = k_CLEF_GG;
        clefs_to_test[8] = k_CLEF_FF;
        clefs_to_test[9] = k_CLEF_FGG;
        clefs_to_test[10] = k_CLEF_FFG;
        clefs_to_test[11] = k_CLEF_FFGG;
    }

    for (i = 0; i < num_allowed_clefs; i++) {
        long clefmin, clefmax;
        double this_diff;
        get_staff_range_mc(clefs_to_test[i], &clefmin, &clefmax);
        clefmin -= 600;
        clefmax += 600;
        if ((clefmin <= min || clefmin == 1900-600) && (max <= clefmax || clefmax == 10100+600) ) { // found!
            found = i;
            break;
        } else if (clefmin <= min && clefmax <= max) {
            this_diff = max - clefmax;
            if (this_diff < best_diff) {
                best_diff = this_diff;
                found = i;
            }
        } else if (min <= clefmin && max <= clefmax) {
            this_diff = clefmin - min;
            if (this_diff < best_diff) {
                best_diff = this_diff;
                found = i;
            }
        } else if (min <= clefmin && clefmax <= max) {
            this_diff = (clefmin - min) + (max - clefmax);
            if (this_diff < best_diff) {
                best_diff = this_diff;
                found = i;
            }
        }
    }
    
    llll_free(minaddress);
    llll_free(maxaddress);
    llll_free(pitches_wk);
    
    return found >= 0 ? clefs_to_test[found] : backup_clef; // if no key was found, we use backup_clef
}


long infer_most_appropriate_clef_for_voice(t_notation_obj *r_ob, t_voice *voice, double cutoff_threshold, t_llll *allowed_clefs)
{
    t_chord *chord = NULL;
    t_note *note = NULL;
    long res = get_voice_clef(r_ob, voice);
    
    if (!voice)
        return res;
    
    t_llll *ll = llll_get();
    for (chord = r_ob->obj_type == k_NOTATION_OBJECT_ROLL ? ((t_rollvoice *)voice)->firstchord :
         (((t_scorevoice *)voice)->firstmeasure ? ((t_scorevoice *)voice)->firstmeasure->firstchord : NULL);
         chord; chord = chord_get_next(chord))
        for (note = chord->firstnote; note; note = note->next)
            llll_appenddouble(ll, note->midicents, 0, WHITENULL_llll);
    
    if (ll->l_size > 0)
        res = infer_most_appropriate_clef(r_ob, ll, cutoff_threshold, allowed_clefs);
    else if (allowed_clefs && allowed_clefs->l_head)
        res = hatom_getlong(&allowed_clefs->l_head->l_hatom);

    llll_free(ll);
    
    return res;
}


double tempo_and_sym_duration_to_duration_ms(double figure_tempo_value, t_rational tempo_figure, t_rational sym_duration)
{
    // dur_sec = dur_sym * 4 / tempo_al_quarto = dur_sym / (tempo_al_quarto * 1/4) = dur_sym / ((tempo_value * (tempo_figure/(1/4)) * 1/4) = ->
    return 1000 * rat2double(sym_duration) / ((figure_tempo_value / 60.) * rat2double(tempo_figure));
}


void preselect_markers_in_region(t_notation_obj *r_ob, double ms_min, double ms_max)
{
    t_marker *mk;
    for (mk = r_ob->firstmarker; mk; mk = mk->next){
        if (mk->position_ms >= ms_min && mk->position_ms <= ms_max) {
            notation_item_add_to_preselection(r_ob, (t_notation_item *)mk);
        } else if (mk->position_ms > ms_max)
            break;
    }
}



void preselect_notes_in_region(t_notation_obj *r_ob, double ms_min, double ms_max, double mc_min, double mc_max, long voice_min, long voice_max, char also_preselect_tails, char also_preselect_breakpoints)
{
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    t_bpt *bpt;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        if (voice->number < voice_min) continue;
        if (voice->number > voice_max) break;
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord)) {
            double chord_onset = chord_get_onset_ms(chord);
            if (chord_onset >= ms_min && chord_onset <= ms_max) {
                for (note = chord->firstnote; note; note = note->next) {
                    if (note->midicents >= mc_min && note->midicents <= mc_max)
                        notation_item_add_to_preselection(r_ob, (t_notation_item *)note);
                    else if (note->midicents > mc_max)
                        break;
                }
            } else if (also_preselect_tails && chord_onset < ms_min) { // maybe the duration tail is selected...
                for (note = chord->firstnote; note; note = note->next) {
                    if ((chord_onset+note->duration >= ms_min && chord_onset+note->duration <= ms_max) &&
                        (note->midicents + note->lastbreakpoint->delta_mc >= mc_min && note->midicents + note->lastbreakpoint->delta_mc <= mc_max))
                            notation_item_add_to_preselection(r_ob, (t_notation_item *)note->lastbreakpoint);
                }
            } else if (chord_onset > ms_max)
                break;
            
            if (also_preselect_breakpoints && (!notation_item_is_preselected(r_ob, (t_notation_item *)chord))) { // looking for breakpoint-selection
                for (note = chord->firstnote; note; note = note->next) {
                    // we only select breakpoints IF the whole note has NOT been selected in the region, otherwise the whole note is selected, that's all
                    if (!notation_item_is_preselected(r_ob, (t_notation_item *)note)) {
                        for (bpt = note->firstbreakpoint->next; bpt; bpt = bpt->next) {
                            if (bpt != note->lastbreakpoint){
                                if ((chord_onset + bpt->rel_x_pos * note->duration >= ms_min && chord_onset + bpt->rel_x_pos * note->duration <= ms_max) &&
                                    (note->midicents + bpt->delta_mc >= mc_min && note->midicents + bpt->delta_mc <= mc_max))
                                        notation_item_add_to_preselection(r_ob, (t_notation_item *)bpt);
                            }
                        }
                    }
                }
            }
        }
    }
}


//// *****************************************
//// **** SEPARATE-TO-GATHERED CONVERSION ****
//// *****************************************

long trans_mode2_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0){
        llll_trans_inplace(hatom_getllll(a), 2);
    }
    return 0;
}


long prepend_extras_sym_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0){
        t_llll *ll = hatom_getllll(a);
        if (ll->l_size > 0)
            llll_prependhatom_clone(ll, (t_hatom *)data, 0, WHITENULL_llll);
    }

    return 0;
}

long preprocess_extras_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0){
        t_llll *ll = llll_clone(hatom_getllll(a));
        t_llll *right_slice = llll_slice(ll, 1);
        char this_extra_is_articulations = (ll && ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_SYM && 
                                    hatom_getsym(&ll->l_head->l_hatom) == _llllobj_sym_articulations) ? true : false;
        if (ll && ll->l_head) {
            if (this_extra_is_articulations)
                llll_funall(right_slice, (fun_fn) prepend_extras_sym_fn, &ll->l_head->l_hatom, 1, -2, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
            else
                llll_funall(right_slice, (fun_fn) prepend_extras_sym_fn, &ll->l_head->l_hatom, 1, 4, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
        }
        llll_free(ll);
        if (right_slice)
            hatom_change_to_llll_and_free(a, right_slice);
    }
    return 0;
}

long put_chords_properly2_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llllelem *elem;
        t_llll *right_slice, *ll = llll_clone(hatom_getllll(a));
        right_slice = llll_slice(ll, 3);
        elem = right_slice->l_head; 
        while (elem) {
            t_llllelem *nextelem = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL && hatom_getllll(&elem->l_hatom)->l_size == 0)
                llll_destroyelem(elem);
            elem = nextelem;
        }
        llll_chain(ll, right_slice);
        hatom_change_to_llll_and_free(a, ll);
    }
    return 0;
}


long put_chords_properly1_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *ll = llll_clone(hatom_getllll(a));
        t_llll *right_slice = llll_slice(ll, 1);
        if (right_slice) {
            llll_trans_inplace(right_slice, 2);
            llll_funall(right_slice, (fun_fn) put_chords_properly2_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
        }
        llll_chain(ll, right_slice);
        hatom_change_to_llll_and_free(a, ll);
    }
    return 0;
}

long put_chords_properly_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *ll = llll_clone(hatom_getllll(a));
        t_llll *right_slice = llll_slice(ll, 1);
        if (right_slice) {
            llll_trans_inplace(right_slice, 2);
            llll_funall(right_slice, (fun_fn) put_chords_properly1_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
        }
        llll_chain(ll, right_slice);
        hatom_change_to_llll_and_free(a, ll);
    }
    return 0;
}

long put_grace_chords_into_grace_levels_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *sll;
        t_llllelem *elem, *start = NULL, *end = NULL;

        t_llll *ll = llll_clone(hatom_getllll(a));

        elem = ll->l_head;
        while (elem) {
            if (hatom_gettype(&elem->l_hatom) == H_LLLL && (sll = hatom_getllll(&elem->l_hatom))->l_head &&
                hatom_gettype(&sll->l_head->l_hatom) == H_LONG && hatom_getlong(&sll->l_head->l_hatom) == 0) {
                hatom_change_to_rat(&sll->l_head->l_hatom, RAT_1OVER8);
                if (!start)
                    start = end = elem;
                else
                    end = elem;
            } else {
                if (start && end) {
                    t_llll *nl = llll_wrap_element_range(start, end);
                    llll_prependsym(nl, _llllobj_sym_g, 0, WHITENULL_llll);
                    start = end = NULL;
                }
            }
            elem = elem->l_next;
        }
        if (start && end) {
            t_llll *nl = llll_wrap_element_range(start, end);
            llll_prependsym(nl, _llllobj_sym_g, 0, WHITENULL_llll);
        }
        
        hatom_change_to_llll_and_free(a, ll);
    }
    return 0;
}


// convert a score separate synatx into its gathered syntax (returned)
t_llll *score_separate2gathered_syntax(t_llll *measureinfo, t_llll *cents, t_llll *durations, t_llll *velocities, t_llll *ties, t_llll *extras)
{
    t_llll *out = llll_get();
    t_llll *cloned_extras = llll_clone(extras);
    
    // Here we might possibly add a preprocessing, to be sure that all lists have the right depths! (and e.g. that user didn't put a single 
    // value for all notes of a chord)
    // This should be a thing to do if ever this function will become an external, up to now, we're sure that we'll give the properly syntaxed data.

//    llll_print(cloned_extras, NULL, 0, 2, NULL);
    llll_funall(cloned_extras, (fun_fn) preprocess_extras_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
//    llll_print(cloned_extras, NULL, 0, 2, NULL);

    llll_appendllll_clone(out, measureinfo, 0, WHITENULL_llll, NULL);
    llll_appendllll_clone(out, durations, 0, WHITENULL_llll, NULL);
    llll_appendllll_clone(out, cents, 0, WHITENULL_llll, NULL);
    llll_appendllll_clone(out, velocities, 0, WHITENULL_llll, NULL);
    llll_appendllll_clone(out, ties, 0, WHITENULL_llll, NULL);
    llll_chain(out, cloned_extras);
    
    llll_trans_inplace(out, 2); // trans on voices
    llll_funall(out, (fun_fn) trans_mode2_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    llll_funall(out, (fun_fn) put_chords_properly_fn, NULL, 1, 2, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);

    llll_funall(out, (fun_fn) put_grace_chords_into_grace_levels_fn, NULL, 1, 2, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    
    return out;
}

long set_whitenull_l_thing_to_grace_duration_llllelems_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *this_level = hatom_getllll(a);
        if (this_level->l_head) {
            if (this_level->l_head && is_hatom_number(&this_level->l_head->l_hatom)) {
                this_level->l_head->l_thing.w_obj = WHITENULL;
                return 1;
            }
        }        
    }
    return 0;
}

long parse_gathered_measure_step1_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL && address->l_size > 0) {
        t_llll *measure_durs = (t_llll *)((void **)data)[0];
        t_llll *measure_notes = (t_llll *)((void **)data)[1];
        char put_all_grace_notes_to_zero_duration = *((char *)((void **)data)[2]);
        t_llll *this_level = hatom_getllll(a);
        
        if (address->l_size == 1 && hatom_getlong(&address->l_head->l_hatom) == 1)
            return 1; // we don't enter into the first element of <measure_gathered>, because it is the MeasureInfo 
        
        if (this_level->l_head) {
            if (this_level->l_head && is_hatom_number(&this_level->l_head->l_hatom)) {
                t_llll *notes_ll = llll_get();
                if (this_level->l_head->l_thing.w_obj == WHITENULL_llll) {
                    if (put_all_grace_notes_to_zero_duration) {
                        llll_appendlong(measure_durs, 0, 0, WHITENULL_llll);
                    } else {
                        t_llll *g_ll = llll_get();
                        llll_appendsym(g_ll, _llllobj_sym_g, 0, WHITENULL_llll);
                        llll_appendhatom_clone(g_ll, &this_level->l_head->l_hatom, 0, WHITENULL_llll);
                        llll_appendllll(measure_durs, g_ll, 0, WHITENULL_llll);
                    }
                } else
                    llll_appendhatom_clone(measure_durs, &this_level->l_head->l_hatom, 0, WHITENULL_llll);
                llll_clone_upon(this_level, notes_ll);
                llll_behead(notes_ll);
                if (notes_ll->l_tail && hatom_gettype(&notes_ll->l_tail->l_hatom) == H_LONG)
                    llll_betail(notes_ll);
                llll_appendllll(measure_notes, notes_ll, 0, WHITENULL_llll);
                return 1;
            } else if (this_level->l_head && hatom_gettype(&this_level->l_head->l_hatom) == H_SYM && 
                        hatom_getsym(&this_level->l_head->l_hatom) == _llllobj_sym_g) {
                llll_funall(this_level, (fun_fn) set_whitenull_l_thing_to_grace_duration_llllelems_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
            }
        }
    }
    return 0;
}

long remove_level_types_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *this_level = hatom_getllll(a);
        if (this_level->l_head && hatom_gettype(&this_level->l_head->l_hatom) == H_LLLL) {
            t_llll *subll = hatom_getllll(&this_level->l_head->l_hatom);
            if (subll && subll->l_head && hatom_gettype(&subll->l_head->l_hatom) == H_SYM && hatom_getsym(&subll->l_head->l_hatom) == _llllobj_sym_leveltype)
                llll_destroyelem(this_level->l_head);
        }        
    }
    return 0;
}

long only_keep_lists_starting_with_sym_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_symbol *this_sym = (t_symbol *)data; 
        t_llll *this_level = hatom_getllll(a);
        
        t_llllelem *elem = this_level->l_head;
        while (elem) {
            t_llllelem *next = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) != H_LLLL)
                llll_destroyelem(elem);
            else {
                t_llll *ll = hatom_getllll(&elem->l_hatom);
                if (!ll->l_head || hatom_gettype(&ll->l_head->l_hatom) != H_SYM ||
                    hatom_getsym(&ll->l_head->l_hatom) != this_sym)
                    llll_destroyelem(elem);
                else if (ll->l_head) {
                    llll_behead(ll);
                    llll_splatter(ll->l_owner, LLLL_FREETHING_DONT);
                }
            }
            elem = next;
        }
    }
    return 0;
}


long keep_three_numbers_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *this_level = hatom_getllll(a);
        t_llllelem *elem = this_level->l_head;
        long count = 0;
        while (elem) {
            t_llllelem *next = elem->l_next;
            count++;
            if (hatom_gettype(&elem->l_hatom) == H_LLLL || count > 3)
                llll_destroyelem(elem);
            elem = next;
        }
        while (count < 3) {
            llll_appendllll(this_level, llll_get(), 0, WHITENULL_llll);
            count++;
        }
    }
    return 0;
}

long only_keep_non_attrsymbolic_sublllls_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *this_level = hatom_getllll(a);
        t_llllelem *elem = this_level->l_head;
        while (elem) {
            t_llllelem *next = elem->l_next;
            if (hatom_gettype(&elem->l_hatom) != H_LLLL || 
                (hatom_getllll(&elem->l_hatom)->l_head && hatom_gettype(&hatom_getllll(&elem->l_hatom)->l_head->l_hatom) == H_SYM))
                llll_destroyelem(elem);
            elem = next;
        }
    }
    return 0;
}


long fill_nils_with_three_nils_fn(void *data, t_hatom *a, const t_llll *address){
    if (hatom_gettype(a) == H_LLLL) {
        t_llll *this_level = hatom_getllll(a);
        if (this_level->l_size == 0) {
            llll_appendllll(this_level, llll_get(), 0, WHITENULL_llll);
            llll_appendllll(this_level, llll_get(), 0, WHITENULL_llll);
            llll_appendllll(this_level, llll_get(), 0, WHITENULL_llll);
        }
    }
    return 0;
}
// convert a score gathered synatx into its separate syntax (all the t_llll** are allocated and filled)
void score_gathered2separate_syntax(t_llll *gathered, t_llll **measureinfo, t_llll **cents, t_llll **durations, t_llll **velocities, t_llll **ties, t_llll **extras,
                                    char put_all_grace_notes_to_zero_duration)
{
    t_llllelem *voice, *measure;
    t_llll *gathered_cloned = get_body(gathered); // we get a copy of the list with sliced header 
    t_llll *aux = llll_get(); // auxiliary llll which will contain for each measure (MEASUREINFO (RAT DURS) ((NOTE1) (NOTE2) ...))
    
    t_llll *symbols_to_map, *notes;
    t_llllelem *elem;

    // remove leveltypes:
    llll_funall(gathered_cloned, (fun_fn)remove_level_types_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);

    for (voice = gathered_cloned->l_head; voice; voice = voice->l_next) {
        if (hatom_gettype(&voice->l_hatom) == H_LLLL) {
            t_llll *voice_aux = llll_get();
            for (measure = hatom_getllll(&voice->l_hatom)->l_head; measure; measure = measure->l_next) {
                if (hatom_gettype(&measure->l_hatom) == H_LLLL) { // filtering voice flag
                    t_llll *measure_gathered = hatom_getllll(&measure->l_hatom);
                    if (measure_gathered->l_head) {
                        t_llll *measure_aux = llll_get();
                        t_llll *measure_durs = llll_get();
                        t_llll *measure_notes = llll_get();
                        void *data[3];
                        char temp = put_all_grace_notes_to_zero_duration;
                        data[0] = measure_durs;
                        data[1] = measure_notes;
                        data[2] = &temp;

                        llll_appendhatom_clone(measure_aux, &measure_gathered->l_head->l_hatom, 0, WHITENULL_llll); // append MEASUREINFO
                        llll_funall(measure_gathered, (fun_fn)parse_gathered_measure_step1_fn, data, 1, -1, FUNALL_SKIP_ATOMS);
                        llll_appendllll(measure_aux, measure_durs, 0, WHITENULL_llll);
                        llll_appendllll(measure_aux, measure_notes, 0, WHITENULL_llll);
                        llll_appendllll(voice_aux, measure_aux, 0, WHITENULL_llll);
                    }
                }
            }
            llll_appendllll(aux, voice_aux, 0, WHITENULL_llll);
        }
    }
    
    llll_funall(aux, (fun_fn) trans_mode2_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    llll_trans_inplace(aux, 2);
    
    // now in aux we have (MEASUREINFO (RAT DURS) ((NOTE1) (NOTE2) ...))
    

    *measureinfo = llll_get();
    *durations = llll_get();
    notes = llll_get(); 
    
    if (aux->l_size >= 1 && hatom_gettype(&aux->l_head->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&aux->l_head->l_hatom), *measureinfo);
    if (aux->l_size >= 2 && hatom_gettype(&aux->l_head->l_next->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&aux->l_head->l_next->l_hatom), *durations);
    if (aux->l_size >= 3 && hatom_gettype(&aux->l_head->l_next->l_next->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&aux->l_head->l_next->l_next->l_hatom), notes);


    // first we obtain the extras
    symbols_to_map = llll_get();
    llll_appendsym(symbols_to_map, _llllobj_sym_graphic, 0, WHITENULL_llll);
    llll_appendsym(symbols_to_map, _llllobj_sym_breakpoints, 0, WHITENULL_llll);
    llll_appendsym(symbols_to_map, _llllobj_sym_slots, 0, WHITENULL_llll);
    
//    llll_post_named(notes, 0, 2, 2, gensym("Notes"), NULL);

    *extras = llll_get();
    for (elem = symbols_to_map->l_head; elem; elem = elem->l_next) {
        t_symbol *this_sym = hatom_getsym(&elem->l_hatom);
        t_llll *this_sym_ll = llll_clone(notes);
        llll_funall(this_sym_ll, (fun_fn) only_keep_non_attrsymbolic_sublllls_fn, NULL, 3, 3, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // removing "chord-attributes" such as (name ...)
        llll_funall(this_sym_ll, (fun_fn) only_keep_lists_starting_with_sym_fn, this_sym, 4, 4, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
        llll_prependsym(this_sym_ll, this_sym, 0, WHITENULL_llll);
        llll_appendllll(*extras, this_sym_ll, 0, WHITENULL_llll);
    }
    
    llll_funall(notes, (fun_fn) only_keep_non_attrsymbolic_sublllls_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // removing "voice-attributes" such as (name ...)
    llll_funall(notes, (fun_fn) only_keep_non_attrsymbolic_sublllls_fn, NULL, 2, 2, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // removing "measure-attributes" such as (name ...)
    llll_funall(notes, (fun_fn) only_keep_non_attrsymbolic_sublllls_fn, NULL, 3, 3, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // removing "chord-attributes" such as (name ...)
    llll_funall(notes, (fun_fn) keep_three_numbers_fn, NULL, 4, 4, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // removing "note-attributes" and slots and extras...

    llll_funall(notes, (fun_fn) trans_mode2_fn, NULL, 1, 3, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    llll_funall(notes, (fun_fn) fill_nils_with_three_nils_fn, NULL, 1, 3, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH); // each rest-chord () is filled with (() () ()) 
    llll_funall(notes, (fun_fn) trans_mode2_fn, NULL, 1, 2, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    llll_funall(notes, (fun_fn) trans_mode2_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    llll_trans_inplace(notes, 2);

    *cents = llll_get();
    *velocities = llll_get();
    *ties = llll_get();
    if (notes->l_size >= 1 && hatom_gettype(&notes->l_head->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&notes->l_head->l_hatom), *cents);
    if (notes->l_size >= 2 && hatom_gettype(&notes->l_head->l_next->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&notes->l_head->l_next->l_hatom), *velocities);
    if (notes->l_size >= 3 && hatom_gettype(&notes->l_head->l_next->l_next->l_hatom) == H_LLLL)
        llll_clone_upon(hatom_getllll(&notes->l_head->l_next->l_next->l_hatom), *ties);

/*    llll_post_named(*measureinfo, 0, 2, 2, gensym("MeasureInfo"), NULL);
    llll_post_named(*cents, 0, 2, 2, gensym("Cents"), NULL);
    llll_post_named(*durations, 0, 2, 2, gensym("Durations"), NULL);
    llll_post_named(*velocities, 0, 2, 2, gensym("Velocities"), NULL);
    llll_post_named(*ties, 0, 2, 2, gensym("Ties"), NULL);
    llll_post_named(*extras, 0, 2, 2, gensym("Extras"), NULL);
*/    
    
    llll_free(gathered_cloned);
    llll_free(aux);
    llll_free(notes);
    llll_free(symbols_to_map);
}


double get_midicents_from_double_elem_or_notename(t_notation_obj *r_ob, t_llllelem *elem)
{
    if (hatom_gettype(&elem->l_hatom) == H_SYM)
        return notename2midicents(r_ob->middleC_octave, &r_ob->last_used_octave, hatom_getsym(&elem->l_hatom)->s_name, NULL, NULL);
    else if (is_hatom_number(&elem->l_hatom))
        return hatom_getdouble(&elem->l_hatom);
    else
        return 0;
}

// voicenum is 0-based
void constraint_midicents_depending_on_editing_ranges(t_notation_obj *r_ob, double *midicents, long voicenum)
{
    if (!r_ob->constraint_pitches_when_editing || r_ob->constraint_pitches_when_editing->l_depth < 2)
        return; // nothing to do
    
    t_llllelem *voice_el = llll_getindex(r_ob->constraint_pitches_when_editing, voicenum + 1, I_STANDARD);
    if (!voice_el)
        voice_el = r_ob->constraint_pitches_when_editing->l_tail;
    
    if (voice_el && hatom_gettype(&voice_el->l_hatom) == H_LLLL) {
        t_llll *ll = hatom_getllll(&voice_el->l_hatom);
        if (ll->l_depth == 1) {  
            t_llll *values = llll_get();
            t_llllelem *subelem;
            for (subelem = ll->l_head; subelem; subelem = subelem->l_next)
                llll_appenddouble(values, get_midicents_from_double_elem_or_notename(r_ob, subelem), 0, WHITENULL_llll);
            ysnap_double(midicents, values, 0);
            llll_free(values);
        } else if (ll->l_depth == 2 && ll->l_size == 1) {
            if (ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_LLLL) {
                t_llll *subll = hatom_getllll(&ll->l_head->l_hatom);
                if (subll && subll->l_head) { // subll must be flat, since ll->l_depth = 2.
                    double min = get_midicents_from_double_elem_or_notename(r_ob, subll->l_head);
                    double max = get_midicents_from_double_elem_or_notename(r_ob, subll->l_tail);
                    clip_double(midicents, min, max);
                }
            }
        } else {
            t_llllelem *elem;
            char mc_already_correct = false;
            t_llll *extremes = llll_get();
            for (elem = ll->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *subll = hatom_getllll(&elem->l_hatom);
                    if (subll && subll->l_depth == 1 && subll->l_head) { 
                        double min = get_midicents_from_double_elem_or_notename(r_ob, subll->l_head);
                        double max = get_midicents_from_double_elem_or_notename(r_ob, subll->l_tail);
                        if (*midicents >= min && *midicents <= max) {
                            mc_already_correct = true;
                            break;
                        }
                        llll_appenddouble(extremes, min, 0, WHITENULL_llll);
                        llll_appenddouble(extremes, max, 0, WHITENULL_llll);
                    }
                } else if (is_hatom_number(&elem->l_hatom)) {
                    double this_val = get_midicents_from_double_elem_or_notename(r_ob, elem);
                    if (this_val == *midicents) {
                        mc_already_correct = true;
                        break;
                    }
                    llll_appenddouble(extremes, this_val, 0, WHITENULL_llll);
                }
            }
            if (!mc_already_correct) 
                ysnap_double(midicents, extremes, 0);
            llll_free(extremes);
        }
    }
}

t_llllelem *ysnap_double_to_editing_range(double *val, t_llll *editing_range, char *inside_range, char *range_hit)
{
    t_llllelem *elem, *res = NULL;
    // editing range is an llll which can be either flat, e.g. 6000 6100 6450 8700, or it can contain range-syntax such as 6000 (6400 6900) 7000
    // first we check if the value lies inside a (...) range
    if (editing_range->l_depth > 1) {
        for (elem = editing_range->l_head; elem; elem = elem->l_next) {
            if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                t_llll *ll = hatom_getllll(&elem->l_hatom);
                if (ll->l_depth == 1 && ll->l_size >= 2 && is_hatom_number(&ll->l_head->l_hatom) && is_hatom_number(&ll->l_head->l_next->l_hatom)) {
                    double first = hatom_getdouble(&ll->l_head->l_hatom);
                    double last = hatom_getdouble(&ll->l_head->l_next->l_hatom);
                    if (*val >= first && *val <= last) {
                        res = elem;
                        if (inside_range)
                            *inside_range = true;
                        if (range_hit) {
                            if (*val == first)
                                *range_hit = -1;
                            if (*val == last)
                                *range_hit = 1;
                        }
                        return res;
                    }
                }
            }
        }
    }
    
    if (range_hit)
        *range_hit = 0;
    if (inside_range)
        *inside_range = false;
    return ysnap_double(val, editing_range, 0);
}

double get_next_step_depending_on_editing_ranges(t_notation_obj *r_ob, double midicents, long voicenum, long delta_steps)
{
    if (!r_ob->constraint_pitches_when_editing || r_ob->constraint_pitches_when_editing->l_depth < 2) {
        return midicents + (delta_steps * (200. / r_ob->tone_division));
    }
        
    t_llllelem *voice_el = llll_getindex(r_ob->constraint_pitches_when_editing, voicenum + 1, I_STANDARD);
    if (!voice_el)
        voice_el = r_ob->constraint_pitches_when_editing->l_tail;
    
    if (voice_el && hatom_gettype(&voice_el->l_hatom) == H_LLLL) {
        t_llll *ll = hatom_getllll(&voice_el->l_hatom), *temp;
        double midicents_temp = midicents;
        char inside_range = 0, range_hit = 0;
        t_llllelem *snap_el = ysnap_double_to_editing_range(&midicents_temp, ll, &inside_range, &range_hit);
        char direction = (delta_steps > 0 ? 1 : -1);

        long count = labs(delta_steps);
        while (count > 0 && snap_el)  {
            if (hatom_gettype(&snap_el->l_hatom) == H_LLLL && (temp = hatom_getllll(&snap_el->l_hatom)) && temp->l_size >= 2 &&
                is_hatom_number(&temp->l_head->l_hatom) && is_hatom_number(&temp->l_head->l_next->l_hatom)) {
                // subrange
                if (delta_steps > 0 && range_hit == 1) {
                    snap_el = snap_el->l_next;
                    count--;
                } else if (delta_steps < 0 && range_hit == -1) {
                    snap_el = snap_el->l_prev;
                    count--;
                } else {
                    double start = hatom_getdouble(&temp->l_head->l_hatom);
                    double end = hatom_getdouble(&temp->l_head->l_next->l_hatom);
                    double curr_mc = midicents_temp;
                    
                    double test_res = curr_mc + (count * direction * (200. / r_ob->tone_division));
                    if (delta_steps > 0 && test_res <= end) 
                        return snap_to_microtonal_grid(r_ob, test_res);
                    if (delta_steps < 0 && test_res >= start) 
                        return snap_to_microtonal_grid(r_ob, test_res);
                    while (count > 0 && (delta_steps > 0 ? (curr_mc <= end) : (curr_mc >= start)) &&
                           ((delta_steps > 0 && curr_mc <= end) || (delta_steps < 0 && curr_mc >= start))) {
                        curr_mc = curr_mc + (direction * (200. / r_ob->tone_division));
                        count--;
                    }
                    if (count == 0)
                        return test_res <= start ? start : (test_res >= end ? end :  snap_to_microtonal_grid(r_ob, test_res));
                    snap_el = delta_steps > 0 ? snap_el->l_next : snap_el->l_prev;
                }
            } else {
                snap_el = delta_steps > 0 ? snap_el->l_next : snap_el->l_prev;
                count--;
            }
        }
        
        if (snap_el) {
            if (is_hatom_number(&snap_el->l_hatom))
                return hatom_getdouble(&snap_el->l_hatom);
            else if (hatom_gettype(&snap_el->l_hatom) == H_LLLL && (temp = hatom_getllll(&snap_el->l_hatom)) && temp->l_size >= 2 &&
                     is_hatom_number(&temp->l_head->l_hatom) && is_hatom_number(&temp->l_head->l_next->l_hatom)) {
                double start = hatom_getdouble(&temp->l_head->l_hatom);
                double end = hatom_getdouble(&temp->l_head->l_next->l_hatom);
                return (delta_steps > 0 ? start : end);
            }
        }
    }
    
    return midicents + (delta_steps * (200. / r_ob->tone_division));
}



void trim_note_slots(t_notation_obj *r_ob, t_note *nt, double delta_ms, char trim_absolute_slots_only)
{
    double new_duration = nt->duration + delta_ms;

    // handling temporal slots
    for (long i = 0; i < CONST_MAX_SLOTS; i++) {
        
        if (trim_absolute_slots_only && !slot_is_temporal_absolute(r_ob, i))
            continue;
        
        char can_extend_beyond_note_tail = slot_can_extend_beyond_note_tail(r_ob, i);
        double domain_min = slot_get_domain_min(r_ob, i);
        double domain_max = slot_get_domain_max_force_default_duration(r_ob, i, new_duration);
        if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_FUNCTION && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal function
            t_slotitem *thisitem = nt->slot[i].firstitem;
            while (thisitem){
                t_slotitem *next = thisitem->next;
                t_pts *pts = (t_pts *) thisitem->item;
                
                double pts_absolute_onset = 0, new_x = 0;
                if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                    pts_absolute_onset = pts->x * nt->duration;
                    new_x = pts_absolute_onset/new_duration;
                } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                    pts_absolute_onset = pts->x;
                    new_x = pts_absolute_onset;
                }
                
                if (new_x < domain_min || (new_x > domain_max && !can_extend_beyond_note_tail)) {
                    if (thisitem->prev && ((t_pts *)thisitem->prev->item)->x == domain_max)
                        slotitem_delete(r_ob, i, thisitem);
                    else if (!thisitem->prev)
                        new_x = domain_max;
                    else {
                        pts->x = domain_max;
                        // beware: ((t_pts *)thisitem->prev->item)->x has already been updated at the previous step
                        pts->y = rescale_with_slope(domain_max, ((t_pts *)thisitem->prev->item)->x, new_x, ((t_pts *)thisitem->prev->item)->y, pts->y, pts->slope);
                    }
                } else
                    pts->x = new_x;
                thisitem = next;
            }
        } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_3DFUNCTION && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal function
            t_slotitem *thisitem = nt->slot[i].firstitem;
            while (thisitem){
                t_slotitem *next = thisitem->next;
                t_pts3d *pts = (t_pts3d *) thisitem->item;
                
                double pts_absolute_onset = 0, new_x = 0;
                if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                    pts_absolute_onset = pts->x * nt->duration;
                    new_x = pts_absolute_onset/new_duration;
                } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                    pts_absolute_onset = pts->x;
                    new_x = pts_absolute_onset;
                }
                
                if (new_x < domain_min || (new_x > domain_max && !can_extend_beyond_note_tail)) {
                    if (thisitem->prev && ((t_pts3d *)thisitem->prev->item)->x == domain_max)
                        slotitem_delete(r_ob, i, thisitem);
                    else if (!thisitem->prev)
                        new_x = domain_max;
                    else {
                        pts->x = domain_max;
                        // beware: ((t_pts *)thisitem->prev->item)->x has already been updated at the previous step
                        pts->y = rescale_with_slope(domain_max, ((t_pts3d *)thisitem->prev->item)->x, new_x, ((t_pts3d *)thisitem->prev->item)->y, pts->y, pts->slope);
                        pts->z = rescale_with_slope(domain_max, ((t_pts3d *)thisitem->prev->item)->x, new_x, ((t_pts3d *)thisitem->prev->item)->z, pts->z, pts->slope);
                    }
                } else
                    pts->x = new_x;
                thisitem = next;
            }
        } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_SPAT && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal spatfunction
            t_slotitem *thisitem = nt->slot[i].firstitem;
            while (thisitem){
                t_slotitem *next = thisitem->next;
                t_spatpt *spatp = (t_spatpt *) thisitem->item;
                
                double pts_absolute_onset = 0, new_x = 0;
                if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                    pts_absolute_onset = spatp->t * nt->duration;
                    new_x = pts_absolute_onset/new_duration;
                } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                    pts_absolute_onset = spatp->t;
                    new_x = pts_absolute_onset;
                }
                
                if (new_x < domain_min || (new_x > domain_max && !can_extend_beyond_note_tail)) {
                    if (thisitem->prev && ((t_spatpt *)thisitem->prev->item)->t == domain_max)
                        slotitem_delete(r_ob, i, thisitem);
                    else if (!thisitem->prev) 
                        new_x = domain_max;
                    else {
                        spatp->t = domain_max;
                        // beware: ((t_spatpt *)thisitem->prev->item)->t has already been updated at the previous step
                        spatp->radius = rescale(domain_max, ((t_spatpt *)thisitem->prev->item)->t, new_x, ((t_spatpt *)thisitem->prev->item)->radius, spatp->radius);
                        spatp->angle = rescale(domain_max, ((t_spatpt *)thisitem->prev->item)->t, new_x, ((t_spatpt *)thisitem->prev->item)->angle, spatp->angle);
                    }
                } else
                    spatp->t = new_x;
                thisitem = next;
            }
        }
    }
}


// ONLY FOR ROLL
void trim_note_end(t_notation_obj *r_ob, t_note *nt, double delta_ms)
{
    double new_duration = nt->duration + delta_ms; 
    t_bpt *bpt;

    if (!(nt->parent->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)nt->parent, k_CHORD, k_UNDO_MODIFICATION_CHANGE);

    if (new_duration < 0) 
        new_duration = 0;

    // handling breakpoints
    bpt = nt->firstbreakpoint;
    while (bpt){
        t_bpt *next = bpt->next;
        if (bpt != nt->firstbreakpoint && bpt != nt->lastbreakpoint) {
            double bpt_absolute_onset = bpt->rel_x_pos * nt->duration;
            double new_rel_x_pos = CLAMP(bpt_absolute_onset/new_duration, 0., 1.);
            if (new_rel_x_pos >= 1 || new_rel_x_pos <= 0)
                delete_breakpoint(r_ob, bpt);
            else
                bpt->rel_x_pos = new_rel_x_pos;
        }
        bpt = next;
    }
    
    trim_note_slots(r_ob, nt, delta_ms, false);
    
    nt->duration = new_duration;
}

long llll_add_fn(void *data, t_hatom *a, const t_llll *address)
{
    double how_much = *((double *)data);
    switch (hatom_gettype(a)) {
        case H_LONG:
            hatom_setdouble(a, hatom_getlong(a) + how_much);
            break;

        case H_DOUBLE:
            hatom_setdouble(a, hatom_getdouble(a) + how_much);
            break;

        case H_RAT:
            hatom_setdouble(a, hatom_getdouble(a) + how_much);
            break;

        default:
            break;
    }
    return 0;
}


void add_amount_to_trimlinked_slot(t_notation_obj *r_ob, long slot_num, t_slot *s, double howmuch)
{
    long i = slot_num;
    if (r_ob->slotinfo[i].trim_with_notehead) {
        t_slotitem *item;
        double slot_max = r_ob->slotinfo[i].slot_range[1], slot_min = r_ob->slotinfo[i].slot_range[0];
        switch (r_ob->slotinfo[i].slot_type) {
            case k_SLOT_TYPE_FLOAT:
            case k_SLOT_TYPE_FLOATLIST:
                for (item = s->firstitem; item; item = item->next) {
                    *((double *)item->item) = CLAMP(*((double *)item->item) + howmuch, slot_min, slot_max);
                }
                break;
            case k_SLOT_TYPE_INT:
            case k_SLOT_TYPE_INTLIST:
                for (item = s->firstitem; item; item = item->next) {
                    *((long *)item->item) = CLAMP(*((long *)item->item) + howmuch, slot_min, slot_max);
                }
                break;
            case k_SLOT_TYPE_LLLL:
            case k_SLOT_TYPE_INTMATRIX:
            case k_SLOT_TYPE_FLOATMATRIX:
            case k_SLOT_TYPE_TOGGLEMATRIX:
            {
                t_slotitem *sl_item = s->firstitem;
                if (sl_item->item)
                    llll_funall((t_llll *) sl_item->item, (fun_fn)llll_add_fn, &howmuch, 1, -1);
                break;
            }
        }
    }
}



void add_amount_to_all_trimlinked_slots(t_notation_obj *r_ob, t_notation_item *nitem, double howmuch)
{
    long i;
    if (!nitem)
        return;
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        if (r_ob->slotinfo[i].trim_with_notehead)
            add_amount_to_trimlinked_slot(r_ob, i, notation_item_get_slot(r_ob, nitem, i), howmuch);
    }
}



long llll_check_trimlink_fn(void *data, t_hatom *a, const t_llll *address)
{
    double *amount_ms = (double *) ((void **)data)[0];
    double slot_min = *((double *) ((void **)data)[1]);
    double slot_max = *((double *) ((void **)data)[2]);

    double this_val = hatom_getdouble(a);
    if (*amount_ms + this_val < slot_min)
        *amount_ms = slot_min - this_val;
    else if (*amount_ms + this_val > slot_max)
        *amount_ms = slot_max - this_val;
    return 0;
}


void correct_trimlink_amount(t_notation_obj *r_ob, t_notation_item *nitem, double *amount_ms)
{
    long i;
    if (!nitem)
        return;
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        if (r_ob->slotinfo[i].trim_with_notehead) {
            t_slot *s = notation_item_get_slot(r_ob, nitem, i);
            if (s) {
                t_slotitem *item;
                double slot_max = r_ob->slotinfo[i].slot_range[1], slot_min = r_ob->slotinfo[i].slot_range[0];
                switch (r_ob->slotinfo[i].slot_type) {
                    case k_SLOT_TYPE_FLOAT:
                    case k_SLOT_TYPE_FLOATLIST:
                        for (item = s->firstitem; item; item = item->next) {
                            double this_val = *((double *)item->item);
                            if (*amount_ms + this_val < slot_min)
                                *amount_ms = slot_min - this_val;
                            else if (*amount_ms + this_val > slot_max)
                                *amount_ms = slot_max - this_val;
                        }
                        break;
                    case k_SLOT_TYPE_INT:
                    case k_SLOT_TYPE_INTLIST:
                        for (item = s->firstitem; item; item = item->next) {
                            double this_val = *((long *)item->item);
                            if (*amount_ms + this_val < slot_min)
                                *amount_ms = slot_min - this_val;
                            else if (*amount_ms + this_val > slot_max)
                                *amount_ms = slot_max - this_val;
                        }
                        break;
                        break;
                    case k_SLOT_TYPE_LLLL:
                    case k_SLOT_TYPE_INTMATRIX:
                    case k_SLOT_TYPE_FLOATMATRIX:
                    case k_SLOT_TYPE_TOGGLEMATRIX:
                    {
                        t_slotitem *sl_item = s->firstitem;
                        void *data[3];
                        data[0] = &amount_ms;
                        data[1] = &slot_min;
                        data[2] = &slot_max;
                        
                        if (sl_item->item)
                            llll_funall((t_llll *) sl_item->item, (fun_fn)llll_check_trimlink_fn, amount_ms, 1, -1);
                        break;
                    }
                }
            }
        }
    }
}

void trim_chord_start(t_notation_obj *r_ob, t_chord *ch, double delta_ms)
{
    t_note *nt;

    // 1. checking if the new onset is ok with all chord notes
    if (delta_ms > 0) {
        for (nt = ch->firstnote; nt; nt = nt->next)
            delta_ms = MIN(delta_ms, nt->duration);
    }
    if (delta_ms < 0)
        delta_ms = MAX(delta_ms, -ch->onset);

    double new_onset = ch->onset + delta_ms;
    t_bpt *bpt; long i;

    if (!(ch->r_it.flags & k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER))
        create_simple_selected_notation_item_undo_tick(r_ob, (t_notation_item *)ch, k_CHORD, k_UNDO_MODIFICATION_CHANGE);
    
    // handling breakpoints
    for (nt = ch->firstnote; nt; nt = nt->next) {
        double new_duration = nt->duration - delta_ms;
        bpt = nt->firstbreakpoint;
        while (bpt){
            t_bpt *next = bpt->next;
            if (bpt != nt->firstbreakpoint && bpt != nt->lastbreakpoint) {
                double bpt_absolute_onset = notation_item_get_onset_ms(r_ob, (t_notation_item *)bpt);
                double new_rel_x_pos = CLAMP((bpt_absolute_onset - new_onset) /new_duration, 0., 1.);
                if (new_rel_x_pos >= 1 || new_rel_x_pos <= 0)
                    delete_breakpoint(r_ob, bpt);
                else
                    bpt->rel_x_pos = new_rel_x_pos;
            }
            bpt = next;
        }
    }

    // handling slots whose values should be changed according to the trimming
    for (nt = ch->firstnote; nt; nt = nt->next)
        add_amount_to_all_trimlinked_slots(r_ob, (t_notation_item *)nt, delta_ms);
    

    // handling temporal slots
    for (nt = ch->firstnote; nt; nt = nt->next) {
        double new_duration = nt->duration - delta_ms;
        for (i = 0; i < CONST_MAX_SLOTS; i++) {
            char slot_can_extend_beyond_tail = slot_can_extend_beyond_note_tail(r_ob, i);
            double domain_min = slot_get_domain_min(r_ob, i);
            double domain_max = slot_get_domain_max_force_default_duration(r_ob, i, new_duration);
            if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_FUNCTION && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal function
                t_slotitem *thisitem = nt->slot[i].firstitem;
                while (thisitem){
                    t_slotitem *next = thisitem->next;
                    t_pts *pts = (t_pts *) thisitem->item;
                    // TO DO: implement for a generic domain; everywhere
                    // should be: rescale(pts->x, r_ob->slotinfo[i].slot_domain[0], r_ob->slotinfo[i].slot_domain[1], 0, 1)

                    double pts_absolute_onset = 0, new_x = 0;
                    if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                        pts_absolute_onset = ch->onset + pts->x * nt->duration;
                        new_x = (pts_absolute_onset - new_onset)/new_duration;
                    } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                        pts_absolute_onset = ch->onset + pts->x;
                        new_x = pts_absolute_onset - new_onset;
                    }
                    
                    if (new_x < domain_min || (new_x > domain_max && !slot_can_extend_beyond_tail)) {
                        double next_pts_absolute_onset = 0;
                        if (thisitem->next) {
                            if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE)
                                next_pts_absolute_onset = ch->onset + ((t_pts *)thisitem->next->item)->x * nt->duration;
                            else
                                next_pts_absolute_onset = ch->onset + ((t_pts *)thisitem->next->item)->x;
                        }
                        if (thisitem->next && ((t_pts *)thisitem->next->item)->x == 0)
                            slotitem_delete(r_ob, i, thisitem);
                        else if (thisitem->next && next_pts_absolute_onset <= new_onset)
                            slotitem_delete(r_ob, i, thisitem);
                        else if (!thisitem->next)
                            new_x = domain_min;
                        else {
                            pts->x = domain_min;
                            // TO DO
                            // beware: ((t_pts *)thisitem->prev->item)->x has already been updated at the previous step
                            pts->y = rescale_with_slope(new_onset, pts_absolute_onset, next_pts_absolute_onset, pts->y, ((t_pts *)thisitem->next->item)->y, ((t_pts *)thisitem->next->item)->slope);
                        }
                    } else
                        pts->x = new_x;
                    thisitem = next;
                }
            } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_3DFUNCTION && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal function
                t_slotitem *thisitem = nt->slot[i].firstitem;
                while (thisitem){
                    t_slotitem *next = thisitem->next;
                    t_pts3d *pts = (t_pts3d *) thisitem->item;
                    
                    double pts_absolute_onset = 0, new_x = 0;
                    if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                        pts_absolute_onset = ch->onset + pts->x * nt->duration;
                        new_x = (pts_absolute_onset - new_onset)/new_duration;
                    } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                        pts_absolute_onset = ch->onset + pts->x;
                        new_x = (pts_absolute_onset - new_onset);
                    }
                    
                    if (new_x < domain_min || (new_x > domain_max && !slot_can_extend_beyond_tail)) {
                        if (thisitem->prev && ((t_pts3d *)thisitem->prev->item)->x == domain_max)
                            slotitem_delete(r_ob, i, thisitem);
                        else if (!thisitem->prev)
                            new_x = domain_max;
                        else {
                            pts->x = domain_max;
                            // beware: ((t_pts *)thisitem->prev->item)->x has already been updated at the previous step
                            pts->y = rescale_with_slope(domain_max, ((t_pts3d *)thisitem->prev->item)->x, new_x, ((t_pts3d *)thisitem->prev->item)->y, pts->y, pts->slope);
                            pts->z = rescale_with_slope(domain_max, ((t_pts3d *)thisitem->prev->item)->x, new_x, ((t_pts3d *)thisitem->prev->item)->z, pts->z, pts->slope);
                        }
                    } else
                        pts->x = new_x;
                    thisitem = next;
                }
            } else if (r_ob->slotinfo[i].slot_type == k_SLOT_TYPE_SPAT && nt->slot[i].firstitem && slot_is_temporal(r_ob, i)){ // temporal spatfunction
                t_slotitem *thisitem = nt->slot[i].firstitem;
                while (thisitem){
                    t_slotitem *next = thisitem->next;
                    t_spatpt *spatp = (t_spatpt *) thisitem->item;
                    
                    double pts_absolute_onset = 0, new_x = 0;
                    if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_RELATIVE) {
                        pts_absolute_onset = ch->onset + spatp->t * nt->duration;
                        new_x = (pts_absolute_onset - new_onset)/new_duration;
                    } else if (r_ob->slotinfo[i].slot_temporalmode == k_SLOT_TEMPORALMODE_MILLISECONDS) {
                        pts_absolute_onset = ch->onset + spatp->t;
                        new_x = (pts_absolute_onset - new_onset);
                    }

                    if (new_x < domain_min || (new_x > domain_max && !slot_can_extend_beyond_tail)) {
                        if (thisitem->prev && ((t_spatpt *)thisitem->prev->item)->t == domain_max)
                            slotitem_delete(r_ob, i, thisitem);
                        else if (!thisitem->prev)
                            new_x = domain_max;
                        else {
                            spatp->t = domain_max;
                            // beware: ((t_spatpt *)thisitem->prev->item)->t has already been updated at the previous step
                            spatp->radius = rescale(domain_max, ((t_spatpt *)thisitem->prev->item)->t, new_x, ((t_spatpt *)thisitem->prev->item)->radius, spatp->radius);
                            spatp->angle = rescale(domain_max, ((t_spatpt *)thisitem->prev->item)->t, new_x, ((t_spatpt *)thisitem->prev->item)->angle, spatp->angle);
                        }
                    } else
                        spatp->t = new_x;
                    thisitem = next;
                }
            }
        }
    }
    
    for (nt = ch->firstnote; nt; nt = nt->next) {
        double new_duration = nt->duration - delta_ms;
        nt->duration = new_duration;
    }
    ch->onset = new_onset;
}






void eliminate_spaces_before_open_bracket_symbol(char *buf)
{
    long i, len = strlen(buf);
    for (i = 0; i < len - 1; i++) {
        if (buf[i] == ' ' && buf[i+1] == LLLL_PUSH_CHAR) {
            strcpy(&buf[i], &buf[i+1]);
            len--;
        }
    }
}


char trim_selection_end(t_notation_obj *r_ob, double delta_ms)
{
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;
    
    lock_general_mutex(r_ob);
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE || (curr_it->type == k_PITCH_BREAKPOINT && !((t_bpt *)curr_it)->next)) {
            t_note *note = curr_it->type == k_NOTE ? (t_note *)curr_it : ((t_bpt *)curr_it)->owner;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)note)) {
                trim_note_end(r_ob, note, delta_ms);
                changed = 1;
            }
        } else if (curr_it->type == k_CHORD) {
            t_note *curr_nt = ((t_chord *)curr_it)->firstnote;
            while (curr_nt) { // cycle on the notes
                if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)curr_nt))
                    trim_note_end(r_ob, curr_nt, delta_ms);
                curr_nt = curr_nt->next;
            }
            changed = 1;
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);
    
    if (changed)
        recompute_total_length(r_ob);

    return changed;
}


char trim_selection_start(t_notation_obj *r_ob, double delta_ms)
{
    t_notation_item *curr_it = r_ob->firstselecteditem;
    char changed = 0;

    // correct trimming, possibly
    lock_general_mutex(r_ob);
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE || curr_it->type == k_CHORD) {
            t_chord *chord = curr_it->type == k_NOTE ? ((t_note *)curr_it)->parent : (t_chord *)curr_it;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)chord)) {
                if (curr_it->type == k_NOTE)
                    correct_trimlink_amount(r_ob, curr_it, &delta_ms);
                else {
                    for (t_note *nt = chord->firstnote; nt; nt = nt->next)
                        correct_trimlink_amount(r_ob, (t_notation_item *)nt, &delta_ms);
                }
            }
        }
        curr_it = curr_it->next_selected;
    }

    curr_it = r_ob->firstselecteditem;
    while (curr_it) { // cycle on the selected items
        if (curr_it->type == k_NOTE || curr_it->type == k_CHORD) {
            t_chord *chord = curr_it->type == k_NOTE ? ((t_note *)curr_it)->parent : (t_chord *)curr_it;
            if (!notation_item_is_globally_locked(r_ob, (t_notation_item *)chord)) {
                trim_chord_start(r_ob, chord, delta_ms);
                changed = 1;
            }
        }
        curr_it = curr_it->next_selected;
    }
    unlock_general_mutex(r_ob);
    
    if (changed)
        recompute_total_length(r_ob);
    
    return changed;
}


// mainly used by bach.slot
void send_changed_open_slot_notification(t_notation_obj *r_ob, long outlet_num)
{
    t_llll *ll = llll_get();
    llll_appendsym(ll, _llllobj_sym_openslot, 0, WHITENULL_llll);
    llll_appendlong(ll, r_ob->active_slot_num + 1, 0, WHITENULL_llll);
    llllobj_outlet_llll((t_object *) r_ob, LLLL_OBJ_UI, outlet_num, ll);
    llll_free(ll);
}


t_voice *voice_get_first_visible(t_notation_obj *r_ob)
{
    t_voice *voice;
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice))
        if (!voice->hidden && voice->part_index == 0)
            return voice;
    return NULL;
}

t_voice *voice_get_last_visible(t_notation_obj *r_ob)
{
    t_voice *voice;
    for (voice = nth_voice(r_ob, r_ob->num_voices - 1); voice && voice->number >= 0; voice = voice_get_prev(r_ob, voice))
        if (!voice->hidden && voice->part_index == 0)
            return voice;
    return NULL;
}


// IMPORTANT: doesn't work for bach.slot
void notation_obj_openslotwin(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv){
    long slot_num = 0; // 1-based
    
    if (r_ob->firstselecteditem == r_ob->lastselecteditem) {
        if (r_ob->firstselecteditem && argc && argv) {
            slot_num = atom_to_slotnum(r_ob, argv, true);
            
            if (slot_num >= 0 && slot_num < CONST_MAX_SLOTS)
                open_slot_window(r_ob, slot_num, notation_item_to_notation_item_for_slot_win_opening(r_ob, r_ob->firstselecteditem));
        }
    }
}


void lock_deparse_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_lock(r_ob->c_deparse_mutex);
}

void unlock_deparse_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_unlock(r_ob->c_deparse_mutex);
}

void lock_general_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_lock(r_ob->c_general_mutex);
}

long trylock_general_mutex(t_notation_obj *r_ob)
{
    return systhread_mutex_trylock(r_ob->c_general_mutex);
}

void unlock_general_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_unlock(r_ob->c_general_mutex);
}

void lock_markers_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_lock(r_ob->c_markers_mutex);
}

void unlock_markers_mutex(t_notation_obj *r_ob)
{
    systhread_mutex_unlock(r_ob->c_markers_mutex);
}

void notation_obj_reset_slotinfo(t_notation_obj *r_ob)
{
    long i;
    initialize_slots(r_ob, true);
    for (i = 0; i < CONST_MAX_SLOTS; i++) {
        slot_check_range(r_ob, i); 
        slot_check_zrange(r_ob, i);
        slot_check_domain(r_ob, i);
    }
    r_ob->num_background_slots = 0;
    r_ob->num_popup_menu_slots = 0;
    object_attr_setlong(r_ob, gensym("linkdynamicstoslot"), BACH_DEFAULT_SLOT_DYNAMICS);
    object_attr_setlong(r_ob, gensym("linklyricstoslot"), BACH_DEFAULT_SLOT_LYRICS);
    object_attr_setlong(r_ob, gensym("linkarticulationstoslot"), BACH_DEFAULT_SLOT_ARTICULATIONS);
    object_attr_setlong(r_ob, gensym("linknoteheadstoslot"),BACH_DEFAULT_SLOT_NOTEHEADS);
}

void notation_obj_reset_noteheadinfo(t_notation_obj *r_ob)
{
    r_ob->noteheads_typo_preferences.num_noteheads = k_NUM_STANDARD_NOTEHEADS;
}

void notation_obj_reset_articulationinfo(t_notation_obj *r_ob)
{
    r_ob->articulations_typo_preferences.num_articulations = k_NUM_STANDARD_ARTICULATIONS;
}

void modify_cents_if_nan_or_inf_and_warn(t_notation_obj *r_ob, double *cents)
{
    if (cents) {
        if (isnan(*cents)){
            object_warn((t_object *)r_ob, "Warning: NaN pitch changed to default one.");
            *cents = CONST_DEFAULT_NEW_NOTE_CENTS;
        } else if (isinf(*cents)) {
            object_warn((t_object *)r_ob, "Warning: infinite pitch changed to default one.");
            *cents = CONST_DEFAULT_NEW_NOTE_CENTS;
        }
    }
}


long notationobj_throw_issue(t_notation_obj *r_ob)
{
    bach_breakpoint(0);
    return 1;
}

long check_note(t_notation_obj *r_ob, t_note *nt)
{
#ifdef CONFIGURATION_Development
    if (!nt->parent)
        notationobj_throw_issue(r_ob);
    
    t_note *temp;
    char found = false;
    for (temp = nt->parent->firstnote; temp; temp = temp->next) {
        if (temp == nt) {
            found = true;
            break;
        }
    }
    
    if (!found)
        notationobj_throw_issue(r_ob);
#endif    
    return 0;
}

long check_chord(t_notation_obj *r_ob, t_chord *ch)
{
#ifdef CONFIGURATION_Development
    if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL) {
        
        if (ch->is_score_chord || ch->r_it.ID == BACH_MAGIC_BAD)
            notationobj_throw_issue(r_ob);

        if (!ch->voiceparent)
            notationobj_throw_issue(r_ob);
        
        t_chord *temp;
        char found = false;
        for (temp = ch->voiceparent->firstchord; temp; temp = temp->next) {
            if (temp == ch) {
                found = true;
                break;
            }
        }
        if (!found)
            notationobj_throw_issue(r_ob);
        
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        
        if (!ch->is_score_chord || ch->r_it.ID == BACH_MAGIC_BAD)
            notationobj_throw_issue(r_ob);

        if (!ch->parent)
            notationobj_throw_issue(r_ob);
        
        t_chord *temp;
        char found = false;
        for (temp = ch->parent->firstchord; temp; temp = temp->next) {
            if (temp == ch) {
                found = true;
                break;
            }
        }
        
        long real_num_notes = 0;
        t_note *nt;
        for (nt = ch->firstnote; nt; nt = nt->next)
            real_num_notes++;
        
        if (real_num_notes != ch->num_notes)
            notationobj_throw_issue(r_ob);
        
        if (!found)
            notationobj_throw_issue(r_ob);
    }
    
    t_note *nt_temp;
    for (nt_temp = ch->firstnote; nt_temp; nt_temp = nt_temp->next) 
        check_note(r_ob, nt_temp);
    
#endif    
    return 0;
}


char change_pitch_must_actually_snap_to_grid(t_notation_obj *r_ob, char mode, char snap_pitch_to_grid)
{
    if (r_ob->snap_pitch_to_grid_when_editing && snap_pitch_to_grid &&    
        (mode != 0 || !r_ob->constraint_pitches_when_editing || r_ob->constraint_pitches_when_editing->l_depth < 2))
        return 1;
    return 0;
}

t_chord *chord_get_first(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (((t_scorevoice *)voice)->firstmeasure)
            return ((t_scorevoice *)voice)->firstmeasure->firstchord;
        else
            return NULL;
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return ((t_rollvoice *)voice)->firstchord;
    return NULL;
}

t_chord *chord_get_last(t_notation_obj *r_ob, t_voice *voice)
{
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        if (((t_scorevoice *)voice)->lastmeasure)
            return ((t_scorevoice *)voice)->lastmeasure->lastchord;
        else
            return NULL;
    } else if (r_ob->obj_type == k_NOTATION_OBJECT_ROLL)
        return ((t_rollvoice *)voice)->lastchord;
    return NULL;
}


t_llll *notationobj_get_interp_timesig(t_notation_obj *r_ob, t_timepoint tp)
{
    t_voice *voice;
    t_llll *out = llll_get();
    
    lock_general_mutex(r_ob);
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        t_timesignature timesig;
        get_timesig_at_timepoint(r_ob, (t_scorevoice *)voice, tp, &timesig);
        llll_appendllll(out, get_timesignature_as_llll(&timesig));
    }
    unlock_general_mutex(r_ob);
    
    return out;
}

t_llll *notationobj_get_interp_tempo(t_notation_obj *r_ob, t_timepoint tp)
{
    t_voice *voice;
    t_llll *out = llll_get();
    
    lock_general_mutex(r_ob);
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        t_llll *voice_ll = llll_get();
        
        t_tempo tempo;
        tempo.tempo_figure = RAT_1OVER4;
        tempo.figure_tempo_value = long2rat(60);
        tempo.interpolation_type = 0;
        tempo.tempo_value = long2rat(60);
        get_tempo_at_timepoint(r_ob, (t_scorevoice *)voice, tp, &tempo.figure_tempo_value, &tempo.tempo_figure, &tempo.tempo_value, &tempo.interpolation_type);
        
        llll_appenddouble(voice_ll, rat2double(tempo.tempo_value)); // instantaneous quartertempo value
        {
            t_llll *sub_ll = llll_get();
            llll_appendrat(sub_ll, tempo.tempo_figure);
            llll_appenddouble(sub_ll, rat2double(tempo.figure_tempo_value));
            llll_appendlong(sub_ll, tempo.interpolation_type);
            llll_appendllll(voice_ll, sub_ll);
        }
        
        llll_appendllll(out, voice_ll);
    }
    unlock_general_mutex(r_ob);
    
    return out;
}

t_llll *notationobj_get_interp(t_notation_obj *r_ob, double ms)
{
    t_voice *voice;
    t_chord *chord;
    t_note *note;
    t_llll *out = llll_get();
    
    lock_general_mutex(r_ob);
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        t_llll *voice_ll = llll_get();
        
        for (chord = chord_get_first(r_ob, voice); chord; chord = chord_get_next(chord)) {
            long dur = chord_get_max_duration(r_ob, chord);
            if (chord->onset <= ms && chord->onset + dur > ms) {
                // a chord has something at #ms milliseconds; notice that if the chord ENDS exactly at ms, we don't consider it.
                // which is a fairly reasonable choice, to have legato figures only being sampled with one note at a time in all cases.
                t_llll *chord_ll = llll_get();
                
                for (note = chord->firstnote; note; note = note->next) {
                    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE || chord->onset + note->duration > ms) {
                        // the note has something at #ms milliseconds
                        t_llll *note_ll = NULL;
                        
                        r_ob->curr_sampling_ms = ms;
                        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
                            note_ll = get_scorenote_values_as_llll(r_ob, note, k_CONSIDER_FOR_SAMPLING);
                        else
                            note_ll = get_rollnote_values_as_llll(r_ob, note, k_CONSIDER_FOR_SAMPLING);
                        llll_appendllll(chord_ll, note_ll, 0, WHITENULL_llll);
                    }
                }
                
                llll_appendllll(voice_ll, chord_ll, 0, WHITENULL_llll);
            }
        }
        
        llll_appendllll(out, voice_ll, 0, WHITENULL_llll);
    }
    unlock_general_mutex(r_ob);
    
    return out;
}

t_llll *notationobj_get_sampling(t_notation_obj *r_ob, long num_points)
{
    t_llll *out = llll_get();
    t_llll *out1 = llll_get();
    t_llll *out2 = llll_get();

    if (num_points > 1) {
        long count = 0;
        double ms, step = r_ob->length_ms_till_last_note / num_points;
        for (ms = 0, count = 0; count < num_points; count++, ms += step) {
            llll_appenddouble(out1, ms, 0, WHITENULL_llll);
            llll_appendllll(out2, notationobj_get_interp(r_ob, ms), 0, WHITENULL_llll);
        }
    }
    
    llll_appendllll(out, out1, 0, WHITENULL_llll);
    llll_appendllll(out, out2, 0, WHITENULL_llll);
    
    return out;
}


t_llll *notationobj_get_sampling_ms(t_notation_obj *r_ob, double delta_ms)
{
    t_llll *out = llll_get();
    t_llll *out1 = llll_get();
    t_llll *out2 = llll_get();
    
    if (delta_ms > 0) {
        double ms;
        for (ms = 0; ms < r_ob->length_ms_till_last_note; ms += delta_ms) {
            llll_appenddouble(out1, ms, 0, WHITENULL_llll);
            llll_appendllll(out2, notationobj_get_interp(r_ob, ms), 0, WHITENULL_llll);
        }
    }
    
    llll_appendllll(out, out1, 0, WHITENULL_llll);
    llll_appendllll(out, out2, 0, WHITENULL_llll);
    
    return out;
}






void notationobj_pixel_to_element(t_notation_obj *r_ob, t_pt pix, void **clicked_elem_ptr, long *clicked_elem_type)
{
    double this_x = pix.x, this_y = pix.y;
    *clicked_elem_ptr = NULL;
    *clicked_elem_type = k_NONE;
    
    // clicked hscrollbar?
    if (r_ob->need_hscrollbar && r_ob->show_hscrollbar) {
        char res = is_in_scrollbar_shape(r_ob, this_x, this_y);
        if (res == 1) {
            *clicked_elem_ptr = WHITENULL; //doesn't really matter, but NON 0...
            *clicked_elem_type = k_SCROLLBAR;
            return;
        } else if (res == -1) {
            *clicked_elem_ptr = WHITENULL;
            *clicked_elem_type = k_SCROLLBAR_LEFT_AREA;
            return;
        } else if (res == -2) {
            *clicked_elem_ptr = WHITENULL;
            *clicked_elem_type = k_SCROLLBAR_RIGHT_AREA;
            return;
        }
    }
    
    // clicked vscrollbar?
    if (r_ob->need_vscrollbar && r_ob->show_vscrollbar) {
        char res= is_in_vscrollbar_shape(r_ob, this_x, this_y);
        if (res == 1) {
            *clicked_elem_ptr = WHITENULL; //doesn't really matter, but NON 0...
            *clicked_elem_type = k_VSCROLLBAR;
            return;
        } else if (res == -1) {
            *clicked_elem_ptr = WHITENULL;
            *clicked_elem_type = k_SCROLLBAR_TOP_AREA;
            return;
        } else if (res == -2) {
            *clicked_elem_ptr = WHITENULL;
            *clicked_elem_type = k_SCROLLBAR_BOTTOM_AREA;
            return;
        }
    }
    
    t_voice *voice;
    t_chord *curr_ch;
    t_note *curr_nt;

    // clefs == voices?
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        if (voice->hidden) continue;
        if (is_in_clef_shape(r_ob, this_x, this_y, voice)) {
            *clicked_elem_ptr = voice;
            *clicked_elem_type = k_VOICE;
            return;
        }
    }
    
    // Noteheads are far too important, we handle them with a loop BEFORE all other elements, except for clefs
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        for (curr_ch = chord_get_first(r_ob, voice); curr_ch; curr_ch = chord_get_next(curr_ch)){
            double align_x = chord_get_alignment_x(r_ob, curr_ch);
            
            if (align_x > this_x + 200) // safe threshold to break
                break;
            if (align_x < this_x - 200)
                continue;
            
            for (curr_nt = curr_ch->firstnote; curr_nt; curr_nt = curr_nt->next){
                // note heads?
                if (is_in_note_shape(r_ob,curr_nt,this_x,this_y)) {
                    *clicked_elem_ptr = curr_nt;
                    *clicked_elem_type = k_NOTE;
                    return;
                }
            }
        }
    }
    
    for (voice = r_ob->firstvoice; voice && voice->number < r_ob->num_voices; voice = voice_get_next(r_ob, voice)) {
        for (curr_ch = chord_get_first(r_ob, voice); curr_ch; curr_ch = chord_get_next(curr_ch)){
            double align_x = chord_get_alignment_x(r_ob, curr_ch);
            t_note *longestnote = chord_get_longest_note(r_ob, curr_ch);
            double tail_x = longestnote ? get_tail_alignment_x(r_ob, longestnote) : align_x;
            
            if (align_x > this_x + 200) // safe threshold to break
                break;
            if (tail_x < this_x - 200)
                continue;

            for (curr_nt = curr_ch->firstnote; curr_nt; curr_nt = curr_nt->next){
                // tail?
                if (r_ob->show_durations && is_in_tail_shape(r_ob,curr_nt,this_x,this_y)) {
                    *clicked_elem_ptr = curr_nt->lastbreakpoint;
                    *clicked_elem_type = k_PITCH_BREAKPOINT;
                    return;
                }
                
                // breakpoint?
                if (r_ob->show_durations && r_ob->allow_glissandi && curr_nt->num_breakpoints > 2) {
                    t_bpt *curr_bpt;
                    for (curr_bpt =  curr_nt->firstbreakpoint->next; curr_bpt; curr_bpt = curr_bpt->next) {
                        if (is_in_breakpoint_shape(r_ob, curr_bpt, this_x, this_y)) {
                            *clicked_elem_ptr = curr_bpt;
                            *clicked_elem_type = k_PITCH_BREAKPOINT;
                            return;
                        }
                    }
                }

                // duration line?
                if (r_ob->show_durations && is_in_durationline_shape(r_ob,curr_nt,this_x,this_y)) {
                    *clicked_elem_ptr = curr_nt->durationline;
                    *clicked_elem_type = k_DURATION_LINE;
                    return;
                }
                
            }
            
            // rests?
            if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE && !curr_ch->firstnote && is_in_rest_shape(r_ob, curr_ch, this_x, this_y)) {
                *clicked_elem_ptr = curr_ch;
                *clicked_elem_type = k_CHORD;
                return;
            }
            
            // lyrics?
            if (r_ob->link_lyrics_to_slot > 0 && r_ob->show_lyrics) {
                if (is_in_chord_lyrics_shape(r_ob, curr_ch, this_x, this_y)){
                    *clicked_elem_ptr = curr_ch->lyrics;
                    *clicked_elem_type = k_LYRICS;
                    return;
                }
            }

            // dynamics?
            if (r_ob->link_dynamics_to_slot > 0 && r_ob->show_dynamics) {
                t_dynamics *dyn = chord_get_dynamics(curr_ch);
                if (dyn && is_in_dynamics_shape(r_ob, dyn, this_x, this_y)){
                    *clicked_elem_ptr = dyn;
                    *clicked_elem_type = k_DYNAMICS;
                    return;
                }
            }
        }
    }
    
    
    // marker?
    if (r_ob->show_markers) {
        t_marker *marker;
        for (marker = r_ob->firstmarker; marker; marker = marker->next) {
            if (is_in_marker_shape(r_ob, marker, this_x, this_y) ||
                is_in_markername_shape(r_ob, marker, this_x, this_y)) {
                *clicked_elem_ptr = marker;
                *clicked_elem_type = k_MARKER;
                return;
            }
        }
    }
    
    // measures
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
        long voicenum = yposition_to_voicenumber(r_ob, this_y, -1, k_VOICEENSEMBLE_INTERFACE_FIRST);
        t_voice *voice = nth_voice(r_ob, voicenum);
        char instaff = false, between_staff_and_next = false;
        
        
//        if (is_y_within_voice_staff(r_ob, this_y, voice)) {

        if ((instaff = is_y_within_voice_staff(r_ob, this_y, (t_voice *)voice)) ||
            (r_ob->draw_barlines_across_staves && (between_staff_and_next = is_y_between_this_staff_and_the_next_or_prev(r_ob, this_y, (t_voice *)voice)))) {
            
            double ux = xposition_to_unscaled_xposition(r_ob, this_x);
            if (ux >= r_ob->screen_ux_start) {
                char barline_clicked = 0;
                
                t_measure *meas = ux_to_measure(r_ob, ux, voice, &barline_clicked);
                if (barline_clicked == -1) { // left barline clicked? we'll switch to right barline of previous measure
                    if (meas->prev) {
                        barline_clicked = 1;
                        meas = meas->prev;
                    } else {
                        barline_clicked = 0;
                        meas = NULL;
                    }
                }
                
                if (meas) {
                    if (!barline_clicked && instaff) {
                        *clicked_elem_ptr = meas;
                        *clicked_elem_type = k_MEASURE;
                        return;
                    } else if (barline_clicked) {
                        *clicked_elem_ptr = meas;
                        *clicked_elem_type = k_MEASURE_END_BARLINE;
                        return;
                    }
                }
            }
        }
    }
    
}


void notationobj_setnotationcolors(t_notation_obj *r_ob, t_llll *ll)
{
    if (ll->l_size >= 3) {
        double r = hatom_getdouble(&ll->l_head->l_hatom);
        double g = hatom_getdouble(&ll->l_head->l_next->l_hatom);
        double b = hatom_getdouble(&ll->l_head->l_next->l_next->l_hatom);
        double a = ll->l_size >= 4 ? hatom_getdouble(&ll->l_head->l_next->l_next->l_next->l_hatom) : 1.;
        t_jrgba color = build_jrgba(r, g, b, a);
        object_attr_setjrgba(r_ob, gensym("accidentalcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("annotationcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("articulationcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("clefcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("keysigcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("lyricscolor"), &color);
        object_attr_setjrgba(r_ob, gensym("mainstavescolor"), &color);
        object_attr_setjrgba(r_ob, gensym("auxiliarystavescolor"), &color);
        object_attr_setjrgba(r_ob, gensym("notecolor"), &color);
        object_attr_setjrgba(r_ob, gensym("stemcolor"), &color);
        object_attr_setjrgba(r_ob, gensym("dynamicscolor"), &color);
        if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE) {
            object_attr_setjrgba(r_ob, gensym("beamcolor"), &color);
            object_attr_setjrgba(r_ob, gensym("flagcolor"), &color);
            object_attr_setjrgba(r_ob, gensym("restcolor"), &color);
            object_attr_setjrgba(r_ob, gensym("tupletcolor"), &color);
            object_attr_setjrgba(r_ob, gensym("tempocolor"), &color);
        }
    }
}


void notationobj_toggle_realtime_mode(t_notation_obj *r_ob, char realtime)
{
    if (r_ob->curr_realtime_mode != realtime) {
        if (realtime) {
            // TURN ON
            r_ob->curr_realtime_attrs.legend = r_ob->legend;
            r_ob->curr_realtime_attrs.highlight_played_notes = r_ob->highlight_played_notes;
            r_ob->curr_realtime_attrs.max_undo_steps = r_ob->max_undo_steps;
            t_atom a;
            atom_setlong(&a, 0);
            object_attr_setchar(r_ob, gensym("legend"), 0);
            object_attr_setchar(r_ob, gensym("highlightplay"), 0);
            object_attr_setvalueof(r_ob, gensym("maxundosteps"), 1, &a);
        } else {
            // TURN OFF
            object_attr_setchar(r_ob, gensym("legend"), r_ob->curr_realtime_attrs.legend);
            object_attr_setchar(r_ob, gensym("highlightplay"), r_ob->curr_realtime_attrs.highlight_played_notes);
            object_attr_setvalueof(r_ob, gensym("maxundosteps"), 1, &r_ob->curr_realtime_attrs.max_undo_steps);
        }
        r_ob->curr_realtime_mode = realtime;
    }
}

t_chord *chord_get_first_strictly_before_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset)
{
    t_chord *ch;
    for (ch = meas->firstchord; ch; ch = ch->next) {
        if (ch->r_sym_onset >= r_sym_onset)
            return ch->prev;
    }
    return meas->lastchord;
}


t_chord *chord_get_first_strictly_after_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset)
{
    t_chord *ch;
    for (ch = meas->lastchord; ch; ch = ch->prev) {
        if (ch->r_sym_onset <= r_sym_onset)
            return ch->next;
    }
    return meas->firstchord;
}


t_chord *chord_get_first_before_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset)
{
    t_chord *ch;
    for (ch = meas->firstchord; ch; ch = ch->next) {
        if (ch->r_sym_onset > r_sym_onset)
            return ch->prev;
    }
    return meas->lastchord;
}


t_chord *chord_get_first_after_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset)
{
    t_chord *ch;
    for (ch = meas->lastchord; ch; ch = ch->prev) {
        if (ch->r_sym_onset < r_sym_onset)
            return ch->next;
    }
    return meas->firstchord;
}



t_chord *chord_get_first_before_ms(t_notation_obj *r_ob, t_voice *voice, double ms)
{
    t_chord *ch;
    for (ch = chord_get_first(r_ob, voice); ch; ch = chord_get_next(ch)) {
        if (chord_get_onset_ms(ch) > ms)
            return ch->prev;
    }
    return chord_get_last(r_ob, voice);
}

t_chord *chord_get_first_after_ms(t_notation_obj *r_ob, t_voice *voice, double ms)
{
    t_chord *ch;
    for (ch = chord_get_last(r_ob, voice); ch; ch = chord_get_prev(ch)) {
        if (chord_get_onset_ms(ch) < ms)
            return ch->next;
    }
    return chord_get_first(r_ob, voice);
}



void move_linear_edit_cursor_depending_on_edit_ranges(t_notation_obj *r_ob, char num_steps, long modifiers)
{
    long direction = (num_steps > 0 ? 1 : (num_steps < 0 ? -1 : 0));
    
    r_ob->notation_cursor.step += num_steps;
    
    if ((r_ob->obj_type == k_NOTATION_OBJECT_SCORE && !r_ob->notation_cursor.measure) || (r_ob->obj_type == k_NOTATION_OBJECT_ROLL && !r_ob->notation_cursor.voice))
        return;
        
    if (!r_ob->constraint_pitches_when_editing || r_ob->constraint_pitches_when_editing->l_depth < 2)
        return; // easy case: no forced editing ranges
    
    long voicenum = 0;
    if (r_ob->obj_type == k_NOTATION_OBJECT_SCORE)
        voicenum = r_ob->notation_cursor.measure ? r_ob->notation_cursor.measure->voiceparent->v_ob.number : (r_ob->notation_cursor.voice ? r_ob->notation_cursor.voice->number : 0);
    else
        voicenum = r_ob->notation_cursor.chord ? r_ob->notation_cursor.chord->voiceparent->v_ob.number : (r_ob->notation_cursor.voice ? r_ob->notation_cursor.voice->number : 0);
    t_llllelem *voice_el = llll_getindex(r_ob->constraint_pitches_when_editing, voicenum + 1, I_STANDARD);
    double this_midicents = scaleposition_to_midicents(r_ob->notation_cursor.step);
    char failed = false;
    
    if (!voice_el)
        voice_el = r_ob->constraint_pitches_when_editing->l_tail;
    
    if (voice_el && hatom_gettype(&voice_el->l_hatom) == H_LLLL) {
        t_llll *ll = hatom_getllll(&voice_el->l_hatom);
        if (ll->l_depth == 1) {
            t_llll *values = llll_get();
            t_llllelem *subelem;
            for (subelem = ll->l_head; subelem; subelem = subelem->l_next)
                llll_appenddouble(values, get_midicents_from_double_elem_or_notename(r_ob, subelem), 0, WHITENULL_llll);
            if (!ysnap_double(&this_midicents, values, direction))
                failed = true;
            llll_free(values);
        } else if (ll->l_depth == 2 && ll->l_size == 1) {
            if (ll->l_head && hatom_gettype(&ll->l_head->l_hatom) == H_LLLL) {
                t_llll *subll = hatom_getllll(&ll->l_head->l_hatom);
                if (subll && subll->l_head) { // subll must be flat, since ll->l_depth = 2.
                    double min = get_midicents_from_double_elem_or_notename(r_ob, subll->l_head);
                    double max = get_midicents_from_double_elem_or_notename(r_ob, subll->l_tail);
                    clip_double(&this_midicents, min, max);
                }
            }
        } else {
            t_llllelem *elem;
            char mc_already_correct = false;
            t_llll *extremes = llll_get();
            for (elem = ll->l_head; elem; elem = elem->l_next) {
                if (hatom_gettype(&elem->l_hatom) == H_LLLL) {
                    t_llll *subll = hatom_getllll(&elem->l_hatom);
                    if (subll && subll->l_depth == 1 && subll->l_head) {
                        double min = get_midicents_from_double_elem_or_notename(r_ob, subll->l_head);
                        double max = get_midicents_from_double_elem_or_notename(r_ob, subll->l_tail);
                        if (this_midicents >= min && this_midicents <= max) {
                            mc_already_correct = true;
                            break;
                        }
                        llll_appenddouble(extremes, min, 0, WHITENULL_llll);
                        llll_appenddouble(extremes, max, 0, WHITENULL_llll);
                    }
                } else if (is_hatom_number(&elem->l_hatom)) {
                    double this_val = get_midicents_from_double_elem_or_notename(r_ob, elem);
                    if (this_val == this_midicents) {
                        mc_already_correct = true;
                        break;
                    }
                    llll_appenddouble(extremes, this_val, 0, WHITENULL_llll);
                }
            }
            if (!mc_already_correct) 
                if (!ysnap_double(&this_midicents, extremes, direction))
                    failed = true;
            llll_free(extremes);
        }
    }
    
    if (failed) {
        r_ob->notation_cursor.step -= num_steps; // revert to original step!
    } else {
        t_rational screen_acc;
        long screen_midicents = (long)this_midicents;
        mc_to_screen_approximations(r_ob, this_midicents, &screen_midicents, &screen_acc, NULL, NULL);
        r_ob->notation_cursor.step = midicents_to_diatsteps_from_middleC(r_ob, screen_midicents);
    }
}


void markers_check_update_name_uwidth(t_notation_obj *r_ob)
{
    t_marker *marker;
    if (r_ob->need_update_markers_uwidth) {
        for (marker = r_ob->firstmarker; marker; marker = marker->next)
            if (marker->need_update_name_uwidth) {
                recalculate_marker_name_uwidth(r_ob, marker);
                marker->need_update_name_uwidth = false;
            }
        r_ob->need_update_markers_uwidth = false;
    }
}





t_measure *tuttipoint_get_first_measure(t_notation_obj *r_ob, t_tuttipoint *tpt)
{
    long i;
    for (i = 0; i < r_ob->num_voices; i++) // cycle on the voices
        if (tpt->measure[i])
            return tpt->measure[i];
    
    return NULL;
}


double slot_item_get_temporal_x(t_notation_obj *r_ob, long slot_num, t_slotitem *it, char normalize_to_01)
{
    if (!it || !it->item)
        return 0;
    
    double val = 0;
    switch (r_ob->slotinfo[slot_num].slot_type) {
        case k_SLOT_TYPE_FUNCTION:
            val = ((t_pts *)it->item)->x;
            break;
        case k_SLOT_TYPE_3DFUNCTION:
            val =  ((t_pts3d *)it->item)->x;
            break;
        case k_SLOT_TYPE_SPAT:
            val = ((t_spatpt *)it->item)->t;
            break;
        case k_SLOT_TYPE_DYNFILTER:
            val = ((t_biquad *)it->item)->t;
            break;
        default:
            val = 0;
    }
    
    if (normalize_to_01) {
        return (val - r_ob->slotinfo[slot_num].slot_domain[0])/(r_ob->slotinfo[slot_num].slot_domain[1] - r_ob->slotinfo[slot_num].slot_domain[0]);
    } else {
        return val;
    }
}


void slot_item_set_temporal_x(t_notation_obj *r_ob, long slot_num, t_slotitem *it, double value, char from_01_normalized_range)
{
    if (!it || !it->item)
        return;
    
    if (from_01_normalized_range) {
        value = (value * (r_ob->slotinfo[slot_num].slot_domain[1] - r_ob->slotinfo[slot_num].slot_domain[0])) + r_ob->slotinfo[slot_num].slot_domain[0];
    }
    
    switch (r_ob->slotinfo[slot_num].slot_type) {
        case k_SLOT_TYPE_FUNCTION:
            ((t_pts *)it->item)->x = value;
            break;
            
        case k_SLOT_TYPE_3DFUNCTION:
            ((t_pts3d *)it->item)->x = value;
            break;
            
        case k_SLOT_TYPE_SPAT:
            ((t_spatpt *)it->item)->t = value;
            break;
            
        case k_SLOT_TYPE_DYNFILTER:
            ((t_biquad *)it->item)->t = value;
            break;
            
        default:
            break;
    }
}


void note_stretch_portion_of_duration_line_and_temporal_slots(t_notation_obj *r_ob, t_note *nt, double from_rel_pos, double to_rel_pos, double stretch_factor, char direction, double old_note_duration, double new_note_duration)
{
    double ratio = old_note_duration / new_note_duration;
    for (t_bpt *bpt = nt->firstbreakpoint; bpt; bpt = bpt->next) {
        if (bpt->prev && bpt->next) {
            double rel_pos = bpt->rel_x_pos;
            if (rel_pos > from_rel_pos && rel_pos < to_rel_pos) {
                if (direction <= 0) { // keep from_rel_pos as pivot
                    bpt->rel_x_pos = (from_rel_pos + (rel_pos - from_rel_pos) * stretch_factor) * ratio;
                } else if (direction > 0) {
                    bpt->rel_x_pos = 1. - (to_rel_pos + (to_rel_pos - rel_pos) * stretch_factor) * ratio;
                }
                bpt->rel_x_pos = CLAMP(bpt->rel_x_pos, 0., 1.);
            } else if (rel_pos >= to_rel_pos && direction == 0) {
                // "shift"
                bpt->rel_x_pos = (from_rel_pos + (to_rel_pos - from_rel_pos) * stretch_factor + (rel_pos - to_rel_pos)) * ratio;
                bpt->rel_x_pos = CLAMP(bpt->rel_x_pos, 0., 1.);
            } else if (rel_pos <= from_rel_pos) {
                // "keep them"
                bpt->rel_x_pos = rel_pos * ratio;
                bpt->rel_x_pos = CLAMP(bpt->rel_x_pos, 0., 1.);
            }
        }
    }
    
    for (long i = 0; i < CONST_MAX_SLOTS; i++) {
        if (slot_is_temporal(r_ob, i)) {
            for (t_slotitem *it = notation_item_get_slot_firstitem(r_ob, (t_notation_item *)nt, i); it; it = it->next) {
                double rel_pos = slot_item_get_temporal_x(r_ob, i, it, true);
                double new_pos = rel_pos;
                if (rel_pos > from_rel_pos && rel_pos < to_rel_pos) {
                    if (direction < 0) { // keep from_rel_pos as pivot
                        new_pos = (from_rel_pos + (rel_pos - from_rel_pos) * stretch_factor) * ratio;
                    } else if (direction > 0) {
                        new_pos =  1. - (to_rel_pos + (to_rel_pos - rel_pos) * stretch_factor) * ratio;
                    }
                    new_pos = CLAMP(new_pos, 0., 1.);
                    slot_item_set_temporal_x(r_ob, i, it, new_pos, true);
                } else if (rel_pos >= to_rel_pos && direction == 0) {
                    // "shift"
                    new_pos = (from_rel_pos + (to_rel_pos - from_rel_pos) * stretch_factor + (rel_pos - to_rel_pos)) * ratio;
                    new_pos = CLAMP(new_pos, 0., 1.);
                    slot_item_set_temporal_x(r_ob, i, it, new_pos, true);
                } else if (rel_pos <= from_rel_pos) {
                    // "keep them"
                    new_pos = rel_pos * ratio;
                    new_pos = CLAMP(new_pos, 0., 1.);
                    slot_item_set_temporal_x(r_ob, i, it, new_pos, true);
                }
            }
        }
    }
}

