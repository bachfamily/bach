/*
 *  notation.h
 *
 * Copyright (C) 2010-2022 Andrea Agostini and Daniele Ghisi
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License
 * as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 *
 */

/**
    @file    notation.h
    @brief    Common notation tools.
*/

#ifndef _NOTATION_H_
#define _NOTATION_H_

#include "foundation/bach.h"

#ifdef BACH_MAX
#include "ext.h"
#include "ext_obex.h"
#include "jpatcher_api.h"
#include "ext_systhread.h"
#include "ext_strings.h"
#include "ext_charset.h"
#include "ext_atomic.h"
#include "ext_common.h"
#include "foundation/llll_files.h" // llllobj.h is included here
#include "math/lexpr.h"
#endif

#ifdef BACH_JUCE
#include "bach_jucewrapper.h"
#include "foundation/llll_commons.h"
#endif

#include <stdio.h>
#include <locale.h>
#include <time.h> 
#include "math/llll_math.h"
#include <stdarg.h>
#include "graphics/bach_graphics.h"
#include "math/bach_math_utilities.h"
#include "graphics/bach_cursors.h"
#include "foundation/llll_commons_ext.h"
#include "parsers/alterparser/alterparser.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS

    #define rhythmic_tree_debug_post(...) ((void) 0)
    #define verbose_post_rhythmic_tree(...) ((void) 0)
    
    #define USE_NEW_UNDO_SYSTEM                            true    ///< Use the new undo system? Should be always true, we kept it only to be sure that we can always revert to previous way
    #define PLAY_REDRAWS_AT_NOTES_END                    true    ///< Do the play method redraws the static layer at each note end?
    #define    USE_BITMAPS_FOR_STANDARD_QUARTERNOTEHEADS    false    ///< Use bitmaps for standard noteheads â€“ instead than glyphs
    #define BACH_NOTES_HAVE_ID                        ///< Do notes have IDs as well? Should always be defined, except for weird debug purposes
    #define BACH_MARKERS_HAVE_ID                    ///< Do markers have IDs as well? Should always be defined, except for weird debug purposes
//    #define BACH_OUTPUT_SYMBOLIC_FLAGS              ///< Are notation item flags to be output as symbols, instead of integers?
//    #define BACH_OUTPUT_SYMBOLIC_LEVELTYPES         ///< Are leveltypes to be output as symbols, instead of integers?

    #define BACH_CHORDS_HAVE_SLOTS
//    #define BACH_MARKERS_HAVE_SLOTS   ///< Not yet ready for this!

    // #define BACH_SUPPORT_SLURS       ///< Not yet ready for this!

    // THESE THREE SHOULD NOT BE DEFINED; they increase the size of the t_note without actually gaining that much in CPU speed.
    //#define BACH_SLOTS_HAVE_LASTITEM              ///< Last item is saved inside slot structure
    //#define BACH_SLOTS_HAVE_ACTIVEITEM            ///< Active item is saved inside slot structure
    //#define BACH_SLOTS_HAVE_OWNER                 ///< Slot owner is saved inside slot structure


//    #define BACH_PATTR_SUPPORT    ///< Pattr support? Really unadvisable. Should NOT be defined, too many weird things with PATTR.


    #define BACH_NEW_LLLLSLOT_SYNTAX            ///< This one might or might not be advisable. Removes the outer ( ) in the llll and matrix slot syntax 


    #ifdef CONFIGURATION_Development

        // Handy flags for debugging:
        //#define BACH_RHYTHMIC_TREE_DEBUG                ///< Print verbosely rhythmic trees at each step, and do additional checking. Only works on Mac
        //#define BACH_POST_IDS_IN_RHYTHMIC_TREE_DEBUG    ///< Also post IDs in rhythmic tree debug
        //#define BACH_PLAY_DEBUG                        ///< Debug the playing task with messages about next scheduled chords
        //#define BACH_QUANTIZE_DEBUG                    ///< Debug the quantize task
        //#define BACH_SPACING_DEBUG                    ///< Debug the spacing task (and display alignment points)
        //#define BACH_PAINT_IDS                        ///< Paint the IDs for all elements having one
        //#define BACH_UNDO_DEBUG                        ///< Debug the undo task
        //#define BACH_ARTICULATION_POSITION_DEBUG      ///< Debug for articulation position
        //#define BACH_CHECK_NOTATION_ITEMS               ///< Debug for notation items

        #ifdef BACH_RHYTHMIC_TREE_DEBUG
            #undef rhythmic_tree_debug_post
            #undef verbose_post_rhythmic_tree
            #define rhythmic_tree_debug_post(...) object_post(__VA_ARGS__)
            #define verbose_post_rhythmic_tree(...) post_rhythmic_tree(__VA_ARGS__)
        #endif
    
    #endif
#endif



// DEFINING CONSTANTS

/** \addtogroup notation
 *  @{
 */
// Standard durations (we don't need to use genrat() for them, just genrat_noreduce())
#define RAT_1OVER2 (genrat_noreduce(1,2))       ///< 1/2
#define RAT_1OVER4 (genrat_noreduce(1,4))       ///< 1/4
#define RAT_1OVER8 (genrat_noreduce(1,8))       ///< 1/8
#define RAT_1OVER16 (genrat_noreduce(1,16))     ///< 1/16
#define RAT_1OVER32 (genrat_noreduce(1,32))     ///< 1/32
#define RAT_1OVER64 (genrat_noreduce(1,64))     ///< 1/64
#define RAT_1OVER128 (genrat_noreduce(1,128))   ///< 1/128


// Default slot numbers for specific types
#define BACH_DEFAULT_SLOT_DYNAMICS 20
#define BACH_DEFAULT_SLOT_LYRICS 21
#define BACH_DEFAULT_SLOT_ARTICULATIONS 22
#define BACH_DEFAULT_SLOT_NOTEHEADS 23
#define BACH_DEFAULT_SLOT_ANNOTATIONS 24


// maximum/minimum constants
#define CONST_MAX_ACCIDENTALS 16                            ///< Maximum allowed number of accidentals per note
#define CONST_MIN_VELOCITY 1                                ///< Minimum velocity (0 being considered for note-offs)  
#define CONST_MAX_VELOCITY 127                                ///< Maximum velocity  
#define CONST_MAX_TEMPO 1000                                ///< A safety upper bound for each tempo value  
#define CONST_MAX_VOICES 250                                ///< Maximum number of admitted voices (was 35 until bach 0.6.x)
#define CONST_MAX_VOICES_PLUS_ONE 251
#define CONST_MAX_VOICE_NAME_CHARS 200                        ///< Maximum number of characters for a voice name
#define CONST_MAX_TURN_ANGLE 100.                            ///< Maximum absolute value of an angle (in radiants) for a #t_spatpt in a #k_SLOT_TYPE_SPAT slot
#define CONST_MAX_LEDGER_LINES 20                            ///< Maximum number of ledger lines per note
#define CONST_MAX_UNDO_STEPS 30                                ///< (OBSOLETE) Old maximum number of undo steps allowed (until bach 0.6.x)
#define CONST_MAX_BEAMS 10                                    ///< Maximum number of nested beams admitted (e.g. 4 would be up to the 1/64th, 5 would be up to 1/128th)
#define CONST_MAX_ARTICULATIONS 100                         ///< Maximum number of articulations, including the standard ones (see #e_articulations) and the custom-defined ones.
#define CONST_MAX_NOTEHEADS 100                             ///< Maximum number of noteheads, including the standard ones (see #e_noteheads) and the custom-defined ones.
#define CONST_MAX_COMMANDS 5                                ///< Maximum number of used definable commands (should be upgraded to 30 at some point in the future)
#define CONST_MAX_COMMAND_CHAR 30                            ///< Maximum number of characters for a command label
#define CONST_MAX_ARTICULATIONS_PER_NOTE 4                  ///< (OBSOLETE, UNUSED) Maximum number of articulations per note and per chord (used to be 10 up to bach 0.7.1)
#define CONST_MAX_SLURS_PER_NOTE 1                            ///< Maximum number of slurs starting or ending on a note (still not supported: used to be 20 up to bach 0.7.1)
#define CONST_MAX_STAFF_LINES 50                            ///< Maximum number of staff lines per staff
#define    CONST_MAX_TRANCHES 1000                                ///< (UNUSED) Maximum number of tuttipoint tranches per tuttipoint region (this is unused, and actually one can have any number of tranches per tuttipoint region.
#define CONST_MAX_ENHARMONICITY_OPTIONS 3                    ///< Maximum number of enharmonicity options appearing in the contextual menu when right-clicking on a note
#define CONST_MIN_OCTAVE -4                                    ///< Minimum possible octave number (used by notename2midicents conversions)
#define CONST_MAX_OCTAVE 12                                    ///< Maximum possible octave number (used by notename2midicents conversions)
#define CONST_MAX_SLOTS 30                                    ///< Maximum number of allowed slots
#define CONST_MAX_TS_NUMERATOR_ELEMENTS 20                    ///< Maximum number of separate elements at the numerator of a time signature, e.g. ((3 4 3 4 5 4 3) 8) for 3+4+3+4+5+4+3/8...
#define CONST_MIN_ZOOM 1                                    ///< Minimum horizontal zoom factor
#define CONST_MAX_ZOOM 100000                                ///< Maximum horizontal zoom factor
#define CONST_FILTER_MIN_Q 0.00001                            ///< Minimum Q for filters in slots of type #k_SLOT_TYPE_FILTER
#define CONST_MAX_TUPLET_CHARS 100                            ///< Maximum number of characters in a tuplet number over or under a chord
#define    CONST_MAX_NESTED_TUPLETS_FOR_SPEEDY 1                ///< Maximum nested tuplet insertion while speedy editing
#define CONST_MAX_CENTS 100000                                ///< Loose upper bound for the midicents of a note, only when setting them via the bach inspector 
#define CONST_MIN_SYM_DURATION_FOR_CHORD (genrat(1,8192))    ///< Minimum symbolic duration for a chord (this is due to the fact that going under this duration may cause problems with beaming tree algorithms, and so on...) 

/** @}*/


#define    CONST_MAX_XML_NESTED_TUPLETS 10                        ///< Maximum nested tuplet insertion while speedy editing @ingroup import_export
#define CONST_MAX_NOTATION_ITEM_NAMES 10                    ///< Maximum number of names a notation item may have (was 10 until bach 0.7.1) @ingroup names

/** \addtogroup attributes 
 *  @{
 */
#define CONST_MAX_BACH_ELEMENT_TYPES 100                    ///< Maximum number of bach element types (must be greater than the number of #e_element_types)
#define CONST_MAX_BACH_ELEMENT_TYPES_PLUS_TEN 110

#define CONST_MAX_BACH_ATTR 50                                ///< Maximum number of bach attributes per element
#define CONST_MAX_BACH_ATTR_ENUMINDEX_ITEMS 50                ///< Maximum number of items in the enumindex dropdown menu for an attribute 
#define CONST_BACH_INSPECTOR_ITEM_UY_STEP 16                ///< Unscaled vertical step between an attribute and the next one in the inspector
#define CONST_BACH_INSPECTOR_ITEM_LINE_UHEIGHT 13            ///< Unscaled vertical height of a line in the inspector (corresponding, e.g., to the unscaled vertical height of the checkboxes if an attribute had the on/off toggle display).
#define CONST_BACH_INSPECTOR_ITEM_UY_START_PAD 50            ///< Unscaled vertical shift of the first attribute in the inspector
#define CONST_BACH_INSPECTOR_ITEM_UX_COLUMN0 5                ///< Unscaled horizontal start in pixels of the first column in the bach inspector
#define CONST_BACH_INSPECTOR_ITEM_UX_COLUMN1 150            ///< Unscaled horizontal start in pixels of the second column in the bach inspector
#define CONST_BACH_INSPECTOR_ITEM_UX_COLUMN2 245            ///< Unscaled horizontal start in pixels of the third column in the bach inspector
#define CONST_BACH_INSPECTOR_ITEM_UX_COLUMN2b 315            ///< Unscaled horizontal start in pixels of the third+ column in the bach inspector (for the enumindex umenus triangles)
#define CONST_BACH_INSPECTOR_ITEM_COLUMN1_MAX_REL_POS 0.3    ///< Maximum relative position of the second column start in the bach inspector
#define CONST_BACH_INSPECTOR_ITEM_COLUMN2_MAX_REL_POS 0.54    ///< Maximum relative position of the third column start in the bach inspector
#define CONST_BACH_INSPECTOR_ITEM_COLUMN2b_MAX_REL_POS 0.8    ///< Maximum relative position of the third+ column start in the bach inspector (for the enumindex umenus triangles)
#define CONST_BACH_INSPECTOR_TEXT_FONT_SIZE 11                ///< Unscaled font size inside the bach inspector
#define CONST_BACH_INSPECTOR_TEXT_COLOR (get_grey(0.1))        ///< Default text color inside the bach inspector
#define CONST_BACH_INSPECTOR_INACTIVE_COLOR (get_grey(0.5))    ///< Default text color inside the bach inspector for the inactive attributes
#define    CONST_BACH_INSPECTOR_VSCROLLBAR_WIDTH 10            ///< Unscaled width of the vertical scrollbar in the bach inspector
#define    CONST_BACH_INSPECTOR_VSCROLLBAR_RIGHT_PAD 3            ///< Unscaled distance of the vertical scrollbar in the bach inspector from the right edge
#define    CONST_BACH_INSPECTOR_VSCROLLBAR_MIN_UHEIGHT 10        ///< Minimum unscaled height of the vertical scrollbar in the bach inspector
#define CONST_BACH_INSPECTOR_ENUMINDEX_UY_STEP 10            ///< Unscaled vertical step of each element in the enumindex umenu in the bach inspector
#define CONST_BACH_INSPECTOR_MAX_HEADER_NUM_CHARS 300        ///< Maximum number of characters for the title in the inspector
#define CONST_BACH_INSPECTOR_DEFAULT_ZOOM 1.3                ///< Zoom factor used for painting external bach inspector
/** @}*/


/** \addtogroup notation_graphics
 *  @{
 */
// common graphic constants    
#define CONST_MIDDLEC_UY 112                                    ///< Unscaled pixel y position of the middle C for a single voice having staff #k_CLEF_FFGG, 
#define CONST_STEP_UY 3                                            ///< Unscaled height of a step (see #e_clefs to know more about steps), i.e. HALF of the unscaled distance between two staff lines
#define CONST_X_SCALING 0.1                                        ///< Multiplicative factor to fix a default x-axis time-pixel relationship (relationship which will be affected by <zoom_x> and <zoom_y> also)  
                                                                ///< At <zoom_x> = <zoom_y> = 1, Î”pixels = CONST_X_SCALING * Î”time. Only used by [bach.roll]
#define CONST_X_SCALING_SCORE 1                                    ///< (Private, never change) Multiplicative factor to respace horizontaly elements in [bach.score] (leave it to 1; change <zoom_x>, instead)  
#define CONST_UX_KEYSIGNATURE_START 22.                            ///< Unscaled x position corresponding to the beginning of the keysignature, after the clefs
#define CONST_ROLL_UX_LEFT_START 34.                            ///< Unscaled x position corresponding to the beginning of the screen window. Only used by [bach.roll].
                                                                ///< When there's no scrollbar, and for <zoom_x> = <zoom_y> = 1, it is the x position for the point having onset = 0 ms
#define CONST_SCORE_UX_LEFT_START 24                            ///< Unscaled x position corresponding to the beginning of the screen window, only used by [bach.score].
                                                                ///< When there's no scrollbar, and for <zoom_x> = <zoom_y> = 1, it is the x position for the first time signature write box.
#define CONST_KEYSIGNATURE_USPACE_BETWEEN_ACC 0.1                ///< Unscaled horizontal blank space between two accidentals for the keysignature
#define CONST_USPACE_AFTER_KEY_SIGNATURE 4                        ///< Unscaled horizontal blank space after the key signature (if there's a key signature)
#define CONST_USPACE_BEFORE_VOICENAMES 2                        ///< Unscaled horizontal blank space before the voicenames (if there are voicenames)
#define CONST_USPACE_AFTER_VOICENAMES 8                            ///< Unscaled horizontal blank space after the voicenames (if there are voicenames)
#define CONST_LEDGER_LINES_HALF_UWIDTH 6.0                        ///< Unscaled HALF width of the ledger lines, for unresized noteheads (otherwise, they resize accordingly)
#define CONST_STEM_WIDTH 1.15                                   ///< Width of the stem line (set to 0.85 for better look when zoomed)
#define CONST_AUX_STEM_WIDTH 1.                                    ///< Width of the auxiliary stems line (auxiliary stems are the one which rely to the stem the notes not directly attached to the main stem)
#define CONST_SCORE_USPACE_BETWEEN_NOTE_AND_BARLINE 2            ///< Unscaled additional horizontal blank spacing (in pixels) before any barline
#define CONST_SCORE_TIE_OUTER_UHEIGHT 5                            ///< Unscaled maximum height (in pixels) of a tie at its middle point 
#define CONST_SCORE_TIE_INNER_UHEIGHT 3                            ///< Unscaled minimum height (in pixels) of a tie at its middle point
#define CONST_SCORE_BEAMING_TREE_STEP_UHEIGHT 6                    ///< Unscaled height (in pixels) of each level skip when painting a rhythmic tree (which happens only in [bach.score] and only if the <show_rhythmic_tree> field of the notation object is set)
#define    CONST_TUPLET_TICK_UHEIGHT 4                                ///< Unscaled height (in pixels) of the tick at the beginning and of at the end of a tuplet bracket
#define    CONST_TUPLET_USPACE_FROM_CHORDS 4 //5.5                        ///< Unscaled additional vertical distance (in pixels) of the tuplet from the relative chords
#define    CONST_TUPLET_USPACE_FROM_FURTHER_STUFF 4 //2            ///< Unscaled additional vertical distance (in pixels) of the tuplet from other superposed stuff (like another superposed tuplet)
#define CONST_MIN_TOPSTAFF_STEMTIP_UPOSITION 3 * CONST_STEP_UY    ///< Minimum unscaled vertical distance between the topmost staff line and the ending tip of a stem (only for [bach.score])

#define CONST_SCORE_SLUR_UWIDTH 2                            ///< Unscaled maximum width of a slur (in pixels)
#define CONST_SLUR_MIN_UHEIGHT 4.2                            ///< Unscaled minimum overall height of a slur (precisely: minimum unscaled height of the bounding trapece)
#define CONST_SLUR_MAX_UHEIGHT 21                            ///< Unscaled maximum overall height of a slur (precisely: maximum unscaled height of the bounding trapece)

#define CONST_SLUR_AVOID_OBJECTS_PAD 2
#define CONST_SLUR_AVOID_LAST_ACCIDENTALS_PAD 0

#define CONST_LABEL_FAMILY_NOTE_STARTING_URADIUS 6.
#define CONST_LABEL_FAMILY_NOTE_SEPARATION_URADIUS 4.
#define CONST_LABEL_FAMILY_LINE_WIDTH 1.5


// grace chords
#define    CONST_GRACE_CHORD_SIZE 0.7                        ///< Relative size of a grace chord with respect to a standard chord (0.7 = 70%)
#define CONST_SCORE_USPACE_BEFORE_GRACE_CHORD 2            ///< Unscaled space before a grace chord
#define CONST_GRACE_CHORD_VERTICALUSPACE_FROM_BEAM 3    ///< Additional unscaled space between a grace chord and a beam under or over which the chord lies 
#define CONST_SCORE_ADD_GRACE_USPACE_FOR_STEMS 2        ///< Additional unscaled space between a chord and its last grace note, if the stems collide
#define CONST_SCORE_MIN_USPACE_BETWEEN_GRACE_CHORDS 6.  ///< Minimum unscaled space between two contiguous grace chords

#define CONST_XSCROLLBAR_UHEIGHT 8.                    ///< Unscaled height (in pixels) of the horizontal scrollbar
#define CONST_YSCROLLBAR_UWIDTH 8.                    ///< Unscaled width (in pixels) of the vertical scrollbar
#define CONST_XSCROLLBAR_WHITE_UPAD_UPON 2.            ///< Unscaled amount (in pixels) of white pad above the horizontal scrollbar
#define CONST_YSCROLLBAR_WHITE_UPAD_LEFT 2.            ///< Unscaled amount (in pixels) of white pad at the left of the vertical scrollbar
#define CONST_XSCROLLBAR_Y_SHIFT -2.                ///< Small vertical shift (towards the top) of the horizontal scrollbar (in pixels)
#define CONST_YSCROLLBAR_X_SHIFT -2.                ///< Small horizontal shift (towards the left) of the vertical scrollbar (in pixels)
#define CONST_XSCROLLBAR_MIN_UWIDTH 20                ///< Unscaled minimum width of the horizontal scrollbar (can't be smaller than this!) 
#define CONST_YSCROLLBAR_MIN_UHEIGHT 20                ///< Unscaled minimum height of the vertical scrollbar (can't be smaller than this!)
#define CONST_YSCROLLBAR_INNER_PAD 6                ///< White vertical pad (in pixels) at the beginning and at the end of the vertical scrollbar 

#define CONST_X_LEFT_START_FADE_MS 200                ///< (Obsolete) For <zoom_x> = 1, difference in milliseconds from the start point of the current screen window, so that from the point situated at left 
                                                    ///< of the latter by #CONST_X_LEFT_START_FADE_MS/<zoom_x> ms there's an alpha-fading starting (notation become blurred)
#define CONST_X_LEFT_START_DELETE_MS 100            ///< (Obsolete) For <zoom_x> = 1, point where the previous alpha-fading ends, and notes are no more visible (only staff lines and clefs).
                                                    ///< This point is also defined by this difference in milliseconds with the starting point of the current screen window
#define CONST_X_LEFT_START_FADE_NUM_STEPS 15        ///< Granularity of the alpha fade (number of rectangles painted between #CONST_X_LEFT_START_FADE_MS and #CONST_X_LEFT_START_DELETE_MS
#define CONST_X_LEFT_START_FADE_UX_ROLL 20                ///< For <zoom_x> = 1, difference in unscaled x pixels from the start point of the current screen window, in order to start a window fading (for [bach.roll]).
#define CONST_X_LEFT_START_DELETE_UX_ROLL 10                ///< For <zoom_x> = 1, point where the previous alpha-fading ends, and notes are no more visible (only staff lines and clefs) (for [bach.roll]).
#define CONST_X_LEFT_START_FADE_UX_SCORE 10                ///< For <zoom_x> = 1, difference in unscaled x pixels from the start point of the current screen window, in order to start a window fading (for [bach.score])
#define CONST_X_LEFT_START_DELETE_UX_SCORE 0                ///< For <zoom_x> = 1, point where the previous alpha-fading ends, and notes are no more visible (only staff lines and clefs) (for [bach.score].
#define CONST_DILATION_RECTANGLE_SQUARES_USIDE 6    ///< Unscaled side (in pixels) of the small squares at the corners and in the middle of the sides of the dilation rectangle (if visible)

#define CONST_DEFAULT_ROLLVOICES_SPACING_UY 17        ///< Default vertical distance between two voices in [bach.roll]
#define CONST_DEFAULT_SCOREVOICES_SPACING_UY 26        ///< Default vertical distance between two voices in [bach.score]

// #define CONST_BPT_UHEIGHT 3.                        ///< Unscaled height of a pitch breakpoint rhomboid 
#define CONST_NOTETAIL_UWIDTH 2.                    ///< Unscaled width of a note tail

#define CONST_USHIFT_TEMPI_LEFT 9                    ///< Unscaled additional left shift (in pixels) of the tempo writing box.
#define CONST_MEASURE_NUMBER_STAFF_USEPARATION 2    ///< Unscaled vertical separation (in pixels) of the measure numbers from the topmost staff line 
#define CONST_BARLINE_LOCK_UY_SHIFT -9                ///< Unscaled vertical shift of the barline locks with respect to the topmost position (either topmost staff line, or measure number top)
#define CONST_BARLINE_TREE_LOCK_UY_SHIFT -1            ///< Unscaled vertical shift of the barline rhythmic tree locks with respect to the topmost position (either topmost staff line, or measure number top, or lock)

#define CONST_SAFETY_USEPARATION_TAIL_NEXT_OBJ 1    ///< Unscaled small shortening of the duration line (only used in [bach.score]). 
                                                    ///< This is due to the fact that we don't want the tail to superpose with the next chord. 
                                                    ///< This means that in the chord structure the <duration_ux> will NOT fit perfectly with the <duration_ms>, but
                                                    ///< will 'happen' in general a little bit before.
#define CONST_STEP_BEZIER_POINT_IDENTIFICATION 5    ///< Finesse parameter to identify a bezier curve.
#define CONST_CLICK_BEZIER_TOLLERATION_FACTOR 4        ///< Toleration factor for clicking on bezier curves.
#define CONST_FUNCTION_SLOT_LABEL_TO_LABEL_COLLISION_SAFETY    4 ///< Safety pad (in pixels) to separate point labels from point labels inside slot window displaying function slots 
#define CONST_FUNCTION_SLOT_LABEL_TO_LINE_COLLISION_SAFETY    1 ///< Safety pad (in pixels) to separate point labels from lines inside slot window displaying function slots 

/** @}*/

/** \addtogroup slot_graphic
 *  @{
 */
// slot graphical parameters
#define CONST_SLOT_LONG_FLOAT_BAR_UWIDTH 2.3            ///< Unscaled width (in pixels) of the handle in the slot window for slots of type #k_SLOT_TYPE_INT, #k_SLOT_TYPE_FLOAT, #k_SLOT_TYPE_INTLIST, #k_SLOT_TYPE_FLOATLIST
#define CONST_SLOT_WINDOW_INSET_X 4                        ///< Horizontal inset (in pixels) of the slot window, both at the left and at right (<slot_window_active_x1> = <slot_window_x1> + CONST_SLOT_WINDOW_INSET_X)
#define CONST_SLOT_WINDOW_INSET_Y 2                        ///< Vertical inset (in pixels) of the slot window, both at the top and at the bottom (<slot_window_active_y1> = <slot_window_y1> + CONST_SLOT_WINDOW_INSET_Y)
                                                        ///< The "inner slot window" is the slot window reduced ignoring this two insets.
#define CONST_SLOT_TEXT_UY_START 12.                    ///< Unscaled vertical offset (in pixels) at the top of the slot window for #k_SLOT_TYPE_TEXT or #k_SLOT_TYPE_LLLL  
#define CONST_SLOT_FILE_UY_START 8.                        ///< Unscaled vertical offset (in pixels) at the top of the slot window for #k_SLOT_TYPE_FILELIST  
#define CONST_SLOT_FILE_UY_STEP 10.                        ///< Unscaled vertical distance (in pixels) between a file and the next one in the slot window of the #k_SLOT_TYPE_FILELIST
#define CONST_SLOT_FUNCTION_UY_INSET_TOP 12.            ///< Unscaled vertical offset (in pixels) at the top of the inner slot window for #k_SLOT_TYPE_FUNCTION, #k_SLOT_TYPE_3DFUNCTION, #k_SLOT_TYPE_SPAT, #k_SLOT_TYPE_FILTER and #k_SLOT_TYPE_DYNFILTER
#define CONST_SLOT_FUNCTION_UY_INSET_BOTTOM 2.            ///< Unscaled vertical offset (in pixels) at the bottom of the inner slot window for #k_SLOT_TYPE_FUNCTION, #k_SLOT_TYPE_3DFUNCTION, #k_SLOT_TYPE_SPAT, k_SLOT_TYPE_FILTER and #k_SLOT_TYPE_DYNFILTER
#define CONST_SLOT_COLOR_UY_INSET_TOP 12.                ///< Unscaled vertical offset (in pixels) at the top of the inner slot window for #k_SLOT_TYPE_COLOR
#define CONST_SLOT_COLOR_UY_INSET_BOTTOM 2.                ///< Unscaled vertical offset (in pixels) at the bottom of the inner slot window for #k_SLOT_TYPE_COLOR
#define CONST_SLOT_FUNCTION_POINT_URADIUS 1.6            ///< Unscaled radius (in pixels) of a point in the slot window of a #k_SLOT_TYPE_FUNCTION, and base radius for #k_SLOT_TYPE_3DFUNCTION points
#define CONST_SLOT_SPAT_CIRCLE_URADIUS 5.5                ///< Unscaled radius (in pixels) of a spatpoint in the slot window of a #k_SLOT_TYPE_SPAT
#define CONST_SLOT_FUNCTION_LINE_WIDTH 1.                ///< Width (in pixels) of the line which displays the funcions in slots #k_SLOT_TYPE_FUNCTION, #k_SLOT_TYPE_SPAT and #k_SLOT_TYPE_FILTER
#define CONST_SLOT_NUMBER_UY_START 11.                    ///< Unscaled vertical offset (in pixels) at the top of the inner slot window for #k_SLOT_TYPE_INTLIST and #k_SLOT_TYPE_FLOATLIST
#define CONST_SLOT_NUMBERLIST_UY_START 16.                ///< Unscaled vertical offset (in pixels) at the top of the inner slot window for #k_SLOT_TYPE_INTLIST and #k_SLOT_TYPE_FLOATLIST
#define CONST_SLOT_NUMBERLIST_UY_STEP 10.                ///< Unscaled vertical distance (in pixels) between a number bar and the next one in the slot window of the #k_SLOT_TYPE_INTLIST and #k_SLOT_TYPE_FLOATLIST
#define CONST_SLOT_NUMBERMATRIX_UY_START 6.                ///< Unscaled vertical offset (in pixels) at the top of the inner slot window for #k_SLOT_TYPE_TOGGLEMATRIX, #k_SLOT_TYPE_INTMATRIX and #k_SLOT_TYPE_FLOATMATRIX
#define CONST_SLOT_NUMBERMATRIX_UY_PAD 10.                ///< Additional unscaled vertical pad (in pixels) before the top of the matrix, if the columns have names (for #k_SLOT_TYPE_TOGGLEMATRIX, #k_SLOT_TYPE_INTMATRIX and #k_SLOT_TYPE_FLOATMATRIX)
#define CONST_SLOT_NUMBERMATRIX_UX_PAD 15.                ///< Additional unscaled horizontal pad (in pixels) before the top of the matrix, if the rows have names (for #k_SLOT_TYPE_TOGGLEMATRIX, #k_SLOT_TYPE_INTMATRIX and #k_SLOT_TYPE_FLOATMATRIX)
#define CONST_SLOT_FUNCTION_UY_LINE_SELECTION_WIDTH 6    ///< Unscaled width (in pixels) of the function line selection space. It should be greater than #CONST_SLOT_FUNCTION_LINE_WIDTH, to help selecting it

#define CONST_SLOT_LONG_FLOAT_DEFAULT_UWIDTH 100        ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_INT, #k_SLOT_TYPE_FLOAT, #k_SLOT_TYPE_INTLIST, #k_SLOT_TYPE_FLOATLIST 
#define CONST_SLOT_TEXT_DEFAULT_UWIDTH 100                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_TEXT, #k_SLOT_TYPE_LLLL
#define CONST_SLOT_ARTICULATIONS_DEFAULT_UWIDTH 110                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_ARTICULATIONS
#define CONST_SLOT_NOTEHEAD_DEFAULT_UWIDTH 110                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_NOTEHEAD
#define CONST_SLOT_DYNAMICS_DEFAULT_UWIDTH 110                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_DYNAMICS
#define CONST_SLOT_FUNCTION_DEFAULT_UWIDTH 110                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_FUNCTION (when static)
#define CONST_SLOT_FILELIST_DEFAULT_UWIDTH 150            ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_FILELIST
#define CONST_SLOT_MATRIX_DEFAULT_UWIDTH 150            ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_TOGGLEMATRIX, #k_SLOT_TYPE_INTMATRIX, #k_SLOT_TYPE_FLOATMATRIX
#define CONST_SLOT_FILTER_DEFAULT_UWIDTH 200            ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_FILTER 
#define CONST_SLOT_NONE_DEFAULT_UWIDTH 100                ///< Unscaled default width (in pixels) of the slot window for slots of type #k_SLOT_TYPE_NONE
#define CONST_SLOT_FILTER_NUM_PIXELS_PER_STEP 3            ///< Number of pixels per step in the frequency response representation of a biquad filter in a slot of type #k_SLOT_TYPE_FILTER. The higher this value, the quicker the redraw
#define CONST_SLOT_DYNFILTER_NUM_V_PIXELS_PER_STEP 1.5    ///< Number of pixels per vertical step in the frequency response representation of a dynamic biquad filter in a slot of type #k_SLOT_TYPE_DYNFILTER. The higher this value, the quicker the redraw
#define CONST_SLOT_DYNFILTER_NUM_H_PIXELS_PER_STEP 6    ///< Number of pixels per horizontal step in the frequency response representation of a dynamic biquad filter in a slot of type #k_SLOT_TYPE_DYNFILTER. The higher this value, the quicker the redraw
#define CONST_SLOT_COLOR_NUM_V_PIXELS_PER_STEP 1        ///< Number of pixels per vertical step in the color spectrum painting in a slot of type #k_COLOR. The higher this value, the quicker the redraw
#define CONST_SLOT_COLOR_NUM_H_PIXELS_PER_STEP 1        ///< Number of pixels per horizontal step in the color spectrum painting in a slot of type #k_COLOR. The higher this value, the quicker the redraw

#define CONST_SLOT_NAME_COLOR_DARK (get_grey(0.9))        ///< Color used in the dark slot windows to paint the slot name
#define CONST_SLOT_NAME_COLOR_CLEAR (get_grey(0.25))    ///< Color used in the clear slot windows to paint the slot name
#define CONST_SLOT_NAME_COLOR_DARK_CLEAR_THRESHOLD 0.4    ///< Color lightness threshold under which a background slot window color is considered to be "dark" 
#define CONST_SLOT_TEXTCOLOR (get_grey(0.25))            ///< Color used in the slot windows to paint text in slots
#define CONST_SLOT_NUMBERS_LINECOLOR (get_grey(0.2))    ///< Color used for lines and number handles in the slot windows
#define CONST_SLOT_TEXT_TEXTCOLOR (get_grey(0.1))        ///< Color used in the #k_SLOT_TYPE_TEXT and #k_SLOT_TYPE_LLLL slot windows to show the text or the llll

#define CONST_SLOT_3DFUNCTION_ZDIM_USIZE 50                        ///< Unscaled size of the z-dimension "coming out" from the screen in the #k_SLOT_TYPE_3DFUNCTION slots
#define CONST_SLOT_3DFUNCTION_ZDIM_ANGLE (PIOVERTWO * 0.75)        ///< Angle (in radians) to which the z-dimension is represented in the 2d projection (for #k_SLOT_TYPE_3DFUNCTION slots)
/** @}*/

/** \addtogroup slot_interface
 *  @{
 */
// slots interface
#define CONST_SLOT_FUNCTION_POINT_ADD_RADIUS_FOR_SELECTION 2.    ///< Additional radius (in pixels), in addition to the point radius, to better select a point in the slot window of a #k_SLOT_TYPE_FUNCTION
#define CONST_SLOT_DYNFILTER_BIQUAD_ADD_WIDTH_FOR_SELECTION 2.    ///< Additional width (in pixels), in addition to the biquad marker rectangle, to better select a single biquad in the slot window of a #k_SLOT_DYNFUNCTION

#define CONST_FILTER_SLOT_Q_DRAG_UCHANGE 60.            ///< Constant that handle the speed of the change for the Q of a filter inside a #k_SLOT_TYPE_FILTER, according to the equation new_Q = old_Q * (1 + delta_y_pixels/(CONST_FILTER_SLOT_Q_DRAG_UCHANGE * <zoom_y>)
#define CONST_FILTER_SLOT_GAIN_DRAG_UCHANGE 5            ///< Constant that handle the speed of the change for the gain of a filter inside a #k_SLOT_TYPE_FILTER
#define    CONST_DYNFILTER_SLOT_MIN_GAIN -30                ///< Minimum gain for filters in a #k_SLOT_TYPE_DYNFILTER slot
#define CONST_DYNFILTER_SLOT_MAX_GAIN 30                ///< Maximum gain for filters in a #k_SLOT_TYPE_DYNFILTER slot
#define    CONST_FILTER_SLOT_DEFAULT_MIN_GAIN -24            ///< Default minimum gain for slots of type #k_SLOT_TYPE_FILTER
#define CONST_FILTER_SLOT_DEFAULT_MAX_GAIN 24            ///< Default maximum gain for slots of type #k_SLOT_TYPE_FILTER
/** @}*/


/** \addtogroup notation_graphics
 *  @{
 */
// beaming graphic constants
#define CONST_BEAMINGS_UDISTANCE 4.5                    ///< Unscaled distance between one beam and the following one (e.g. between the 1/8 and 1/16 beams)
#define CONST_BEAMING_UWIDTH 3                            ///< Unscaled width of the beaming line. Usually it coincides with #CONST_STEP_UY
#define CONST_BEAMINGS_TICK_DEFAULT_UEXTENSION 5.        ///< Default unscaled horizontal length of any the beaming tick. This is affected by <zoom_y>, but UNAFFECTED by <zoom_x> 
#define CONST_SECOND_BEAM_UY_SHIFT 6                    ///< Unscaled vertical shift of the beamings, towards the noteheads technical, only if the beams are at least 2. 
                                                        ///< (This is used to avoid the case where beamings get too "tall" even just for a sequence of 1/16 notes)
#define CONST_VERTICAL_USEPARATION_RESTS_FROM_BEAM 5.    ///< Unscaled vertical additional separation between a rest and a beam inside which the rest lies
#define CONST_FLOAT_STEP_PART_SHIFT 4                   ///< Shift in steps of rests due to different parts in the same voice ensemble. Must be EVEN otherwise we
                                                        ///< mess up with 4/4 and 2/4 rests vertical positioning

// score spacing constants
#define CONST_SCORE_USPACE_AFTER_START_BARLINE_WITH_NO_TS 6        ///< Unscaled horizontal blank space (in pixels) after a measure barline, when no time signature in the measure is needed
#define CONST_SCORE_USPACE_AFTER_START_BARLINE_WITH_TS 5        ///< Unscaled horizontal blank space (in pixels) after a measure barline, before the time signature (if there's a time signature
#define CONST_SCORE_USPACE_AFTER_TS 14                            ///< Unscaled horizontal blank space (in pixels) after a time signature, before drawing the measure chords 
#define CONST_REST_DOT_USEPARATION 2.                            ///< Unscaled separation (in pixels) between a rest and its first dot
#define CONST_CHORD_DOT_USEPARATION 2.                            ///< Unscaled separation (in pixels) between a note and its first dot
#define CONST_DOT_DOT_USEPARATION 4.                            ///< Unscaled separation (in pixels) between a dot, and the next one
#define CONST_DOT_UWIDTH 4                                        ///< Reserved width, during spacing calculation, for one dot
#define CONST_UX_ACC_SEPARATION_FROM_ACC 0.8                    ///< Unscaled separation (in pixels) between two accidentals
#define CONST_UX_ACC_SEPARATION_FROM_NOTE 3.0                    ///< Unscaled separation (in pixels) between a note and its accidental (if there's no other accidental horizontally in between)  
#define CONST_SCORE_TIE_ADDITIONAL_USPACING 6                    ///< Unscaled horizontal additional spacing if note has a tie which starts on it

#define CONST_TEMPI_FIGURE_PT 0.7                                ///< Rescaling factor of the small figures in the tempi equations (e.g. 'q = 120') with respect to the ordinary figures
#define CONST_FIGURE_IN_TUPLET_LEGEND_RATIO 0.55                ///< Rescaling factor of the small note in the tuplet ratio specification, as 'aq:b'

#define CONST_TEXT_FRACTIONS_PT 7.5                                ///< For <zoom_y> = 1, size (in pt) of the font used to write the fractions-like and cents-like accidentals (as '-1/5' or '+34c')
#define CONST_WIDTH_ADD_FRACTIONS 2                                ///< Additional pad (in pixels) in fractions-like and cents-like accidentals, to better show the + and - signs
#define CONST_TUPLET_BASE_PT 10                                    ///< For <zoom_y> = 1, size (in pt) of the font used to write the numbers for the tuplets

// 8va and 15ma clefs graphic constants
#define CONST_G_CLEF_OCTAVE_NUMBER_UX_SHIFT_ABOVE 10        ///< Unscaled horizontal shift (in pixels) from the beginning of the staff of the middle textbox position to write the small octave number over the G clef
#define CONST_G_CLEF_OCTAVE_NUMBER_UX_SHIFT_BELOW 10        ///< Unscaled horizontal shift (in pixels) from the beginning of the staff of the middle textbox position to write the small octave number under the G clef
#define CONST_F_CLEF_OCTAVE_NUMBER_UX_SHIFT_ABOVE 8        ///< Unscaled horizontal shift (in pixels) from the beginning of the staff of the middle textbox position to write the small octave number over the F clef
#define CONST_F_CLEF_OCTAVE_NUMBER_UX_SHIFT_BELOW 8        ///< Unscaled horizontal shift (in pixels) from the beginning of the staff of the middle textbox position to write the small octave number under the F clef
#define CONST_G_CLEF_OCTAVE_NUMBER_UY_SHIFT_ABOVE 0.3        ///< Unscaled vertical shift (in pixels), with respect to the G clef textbox, of the top textbox boundary to write the small octave number over the G clef
#define CONST_G_CLEF_OCTAVE_NUMBER_UY_SHIFT_BELOW 15.8    ///< Unscaled vertical shift (in pixels), with respect to the G clef textbox, of the top textbox boundary to write the small octave number under the G clef
#define CONST_F_CLEF_OCTAVE_NUMBER_UY_SHIFT_ABOVE 15        ///< Unscaled vertical shift (in pixels), with respect to the F clef textbox, of the top textbox boundary to write the small octave number over the F clef
#define CONST_F_CLEF_OCTAVE_NUMBER_UY_SHIFT_BELOW 23    ///< Unscaled vertical shift (in pixels), with respect to the F clef textbox, of the top textbox boundary to write the small octave number under the F clef
#define CONST_CLEF_OCTAVE_NUMBER_BASE_PT 9        ///< Dimension in pt (for <zoom_y> = 1) of the small "15" number under the F clef
/** @}*/


/** \addtogroup interface
 *  @{
 */
// basic interface constants
#define CONST_NOTE_CLICK_URADIUS_PAD 0.7                ///< Additional unscaled radius (in addition to the half notehead width) to the allowed clicking region for a note. 
                                                        ///< So that if we click within the circle having radius <notehead_uwidth> + #CONST_NOTE_CLICK_URADIUS_PAD, the note will be selected 
#define CONST_VELOCITY_DRAG_UCHANGE 1.                    ///< Multiplicative constant that handle the speed of the velocity change upon mouse dragging. 
                                                        ///< At <zoom_y> = 1, dragging #CONST_VELOCITY_DRAG_UCHANGE pixels upward changes the velocity of 1 unit.
#define CONST_TEMPO_DRAG_UCHANGE 1.                        ///< Multiplicative constant that handle the speed of the tempo change upon mouse dragging. 
                                                        ///< At <zoom_y> = 1, dragging #CONST_TEMPO_DRAG_UCHANGE pixels upward changes the tempo of 1 bpm.
#define CONST_SLOPE_DRAG_UCHANGE 60.                    ///< Multiplicative constant that handle how fast the slope of the breakpoint and function segments change while dragging.
                                                        ///< At <zoom_y> = 1, dragging #CONST_SLOPE_DRAG_UCHANGE pixels upward changes the slope of 1 unit.
#define CONST_DYNAMICS_DRAG_UCHANGE 6.                    ///< Multiplicative constant that handle how fast the dynamics change while dragging
#define CONST_ANGLE_DRAG_UCHANGE 30.                    ///< Multiplicative constant that handle how fast the angle of spatpoints changes while dragging.
                                                        ///< At <zoom_y> = 1, dragging #CONST_ANGLE_DRAG_UCHANGE pixels upward changes the angle of 1 radiant.
#define CONST_ALPHA_DRAG_UCHANGE 200.                    ///< Multiplicative constant that handle how fast the alpha value changes while dragging inside a slot window of a #k_SLOT_TYPE_COLOR slot, or the color palette inside the bach inspector.
                                                        ///< At <zoom_y> = 1, dragging #CONST_ALPHA_DRAG_UCHANGE pixels upward adds 1 to the alpha value.
#define CONST_BACH_INSPECTOR_ATTR_DRAG_UCHANGE 40.        ///< Multiplicative constant that handle the speed of the change of the values in the bach inspector upon mouse dragging. 
                                                        ///< At <zoom_y> = 1, dragging #CONST_VELOCITY_DRAG_UCHANGE pixels upward changes the velocity of 1 unit.
#define CONST_ONSET_SHIFT_FROM_KEYBOARD 20                ///< Shift in milliseconds for <zoom_x> = 1 of a chord when it is selected and keyboard arrows are pressed (only for [bach.roll]). 
                                                        ///< If <zoom_x> != 1, the final shift in milliseconds will be #CONST_ONSET_SHIFT_FROM_KEYBOARD/<zoom_x> 
#define CONST_DURATION_SHIFT_FROM_KEYBOARD 20            ///< Increase/decrease amount in milliseconds (for <zoom_x> = 1) for the durations, when handled via keyboard arrows (only for [bach.roll]).
                                                        ///< If <zoom_x> != 1, the final amount in milliseconds will be #CONST_DURATION_SHIFT_FROM_KEYBOARD/<zoom_x>
#define CONST_FASTER_FROM_KEYBOARD 5                    ///< Multiplier for shifts and increasing/decreasing amounts when the Shift key is kept pressed ("it goes #CONST_FASTER_FROM_KEYBOARD times faster") 
#define CONST_FINER_FROM_KEYBOARD 0.04                    ///< Multiplier for finer adjustments: when Shift+Cmd (mac) or Shift+Ctrl (win) is pressed, deplacement are slowed down (by this factor)
#define CONST_UX_SCROLLBAR_SHIFT_FROM_KEYBOARD 10        ///< Unscaled shift in pixel of the scrollbar when Cmd+keyboard arrows (mac) or Ctrl+keyboard arrows (win) are pressed.

#define CONST_X_MOUSEWHEEL_FACTOR 15                    ///< Factor for horizontal scrolling while using the mousewheel
#define CONST_Y_MOUSEWHEEL_FACTOR 15                    ///< Factor for vertical scrolling while using the mousewheel

#define CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE 2.5    ///< Unscaled tolerance (in pixels) around a barline, such that if one clicks at left or at right of the measure barline 
                                                        ///< by at most #CONST_BARLINE_WIDTH_SELECTION_UTOLERANCE, the barline is still selected

// articulations
#define CONST_ARTICULATION_SELECTION_HORIZONTAL_UTOLERANCE 1    ///< Unscaled horizontal tolerance (in pixels) around an articulation. 
                                                                ///< If one clicks at left or at right of the bounding rectangle by at most #CONST_ARTICULATION_SELECTION_HORIZONTAL_UTOLERANCE, the articulation is still selected
#define CONST_ARTICULATION_SELECTION_VERTICAL_UTOLERANCE 3        ///< Unscaled vertical tolerance (in pixels) around an articulation. 
                                                                ///< If one clicks above or below the bounding rectangle by at most #CONST_ARTICULATION_SELECTION_HORIZONTAL_UTOLERANCE, the articulation is still selected
#define CONST_ARTICULATION_EXTENSION_END_UTRIM 10                ///< Unscaled left nudge of the right limit of the textbox containing an articulation extension. 
                                                                ///< This applies for instance at teh '~~~~~~~' line for the trill, so that the articulation extension does not overflow on the next chord


// slurs
#define CONST_SLUR_START_END_POINT_SEL_WIDTH 4            ///< (UNSUPPORTED) Width and height of the rectangle (in pixels) around the slur starting or ending point, allowing to select those points
#define CONST_SLUR_USEPARATION_FROM_STEM 1                ///< (UNSUPPORTED) Minimum unscaled separation of a slur start or end point from the stem of a chord

// ruler & grid
#define CONST_RULER_MAIN_TICKS_UHEIGHT 10                            ///< Unscaled height (in pixels) of the main ticks of the ruler/grid
#define CONST_RULER_SECONDARY_TICKS_UHEIGHT 5                        ///< Unscaled height (in pixels) of the secondary ticks of the ruler/grid
#define CONST_RULER_MINIMUM_DELTA_PIXEL_FOR_SUBDIVISIONS_TICKS 2.5    ///< Minimum distance in pixels between two secondary ticks, which allows them to be painted. Otherwise only main ticks
                                                                    ///< are painted (this does NOT apply to the intelligent ruler/grid mode, but only to the fixed ruler/grid mode)
#define CONST_OPTIMAL_PIXEL_DELTA_FOR_RULER_BIG_TICKS 150            ///< Expected distance in pixels between two main ticks of the ruler/grid, when using the intelligent ruler/grid mode


// lyrics
#define CONST_NUM_DASH_PER_UX 0.05                ///< Number of dash characters '-' per horizontal unscaled pixel, when two lyrics syllabes are joined by '- - - - - - - -'.
#define CONST_UX_MINIMUM_SPACE_FOR_DASH 3.5        ///< Minimum unscaled horizontal width between syllables in order to be able to paint a " - - - " line. 
                                                ///< If the separation is narrower, no dash is painted
#define CONST_WORD_EXTENSIONS_UY_SHIFT 12        ///< Unscaled vertical shift of the word extensions, with respect to the top of the writing box for the lyrics. 
                                                ///< Extensions are the "_____" situated after a syllable e.g. to account for a melisma: "be______" 

// page view
#define CONST_SYSTEM_JUMP_USHIFT 20        ///< Default unscaled additional shift between systems, in addition to the needed vertical height of each system
#define CONST_RIGHT_UPAD 20                ///< Unscaled right pad in pixels, for the page view, between the end of the milliseconds on a system and the end of the staff lines


// score spacing thresholds
#define CONST_SCORE_USPACE_BETWEEN_THINGS 1        ///< Unscaled horizontal space (in pixels) between any element and any other subsequential element, for the minimal spacing computation
#define CONST_THRESHOLD_FOR_SMART_SPACING 5        ///< (Private) Additive threshold to add to minimal spacing to admit a smart spacing (see \theta in function documentation)
#define CONST_SPACING_DECAY_ALPHA 3                ///< (Private) Spacing alpha constant in function documentation
#define CONST_SPACING_DECAY_BETA 0.5            ///< (Private) Spacing beta constant in function documentation
#define CONST_SPACING_DECAY_ALPHA_PRIME 0.3        ///< (Private) Spacing alpha' constant in function documentation
#define CONST_SPACING_DECAY_BETA_PRIME 18        ///< (Private) Sapcing beta' constant in function documentation
#define CONST_THRESHOLD_FOR_APPROX_TPT_EQ 0.001    ///< (Private) Threshold in seconds under which approximated barlines will be considered to lie in the same place (in order to calculate the tuttipoints)
                                                ///< Beware: this is only used when approximations in the computation needed to be done (because rationals were too high); otherwise all comparisons are precise!
/** @}*/


/** \addtogroup settings
 *  @{
 */
// settings
#define CONST_TOTAL_ULENGTH_ADD 100                    ///< Additional ending pad (in ms, for <zoom_y> = 1) after the end of the last NOTE in a [bach.roll].
                                                    ///< This is ignored by the <length_ms_till_last_note> field of the notation object (which keeps the REAL length of the [bach.roll)
                                                    ///< but is kept into account in the <length_ms> field, which thus in general has an additional pad of #CONST_TOTAL_ULENGTH_ADD * <zoom_y> ms
#define CONST_TOTAL_ULENGTH_MARKER_ADD 500            ///< Additional ending pad (in ms, for <zoom_y> = 1) after the end of the last MARKER in a [bach.roll].
                                                    ///< As before, this is ignored by <length_ms_till_last_note>, but kept into account by <length_ms>
#define CONST_SCORE_ADDITIONALS_UX_AT_THE_END 6        ///< Additional number of unscaled pixels at the end of a [bach.score], in order to leave a pad for displaying

#define CONST_VOICE_THRESHOLD 14                    ///< (Private) Threshold to handle the anchorage of events to one voice or to the next one, e.g. while dragging notes across voices.
#define CONST_EPSILON_SELECT 0.01                    ///< (Private) General small threshold variely used (as milliseconds, midicents, ux) in the select functions

#define CONST_DEFAULT_DURATION 10                    ///< The default duration of a newly placed note will be 1/#CONST_DEFAULT_DURATION of the current domain (only for [bach.roll]
#define CONST_DEFAULT_NEW_NOTE_DURATION 500            ///< Default duration for new notes (when set by message)
#define CONST_DEFAULT_NEW_NOTE_ONSET 1000            ///< Default onset for new notes (when set by message)
#define CONST_DEFAULT_NEW_NOTE_CENTS 6000            ///< Default cents for new notes (when set by message)
#define CONST_DEFAULT_NEW_NOTE_VELOCITY 100            ///< Default velocity for new notes (both by message and by interface)

#define CONST_DEFAULT_GLUECHORD_THRESHOLD_MS 1        ///< Default threshold in milliseconds for the "gluechord" command to glue notes together.  
                                                    ///< If there was a previous note, and the new inserted note (the one to be glued) starts less than #CONST_DEFAULT_GLUECHORD_THRESHOLD_MS later, if the pitch is ok, the 
                                                    ///< note will be glued. This threshold can be changed, as a parameter in the message. (Only used by [bach.roll])
#define CONST_DEFAULT_GLUECHORD_THRESHOLD_CENTS 1    ///< Default threshold in midicents for the "gluechord" command to glue notes together. 
                                                    ///< If temporally they can be glued, if their pitches are no more than #CONST_DEFAULT_GLUECHORD_THRESHOLD_CENTS midicents apart, 
                                                    ///< notes will be glued. This threshold can be changed, as a parameter in the message. (Only used by [bach.roll])

#define BACH_MAX_TEMPO_DIGITS   6                   ///< Maximum tempo digits
#define BACH_MAX_LAST_ANNOTATION_TEXT_CHARS 2048    ///< Maximum annotation text characters (only used for comparing with last annotation!)

#ifdef C74_X64
#define CONST_RAT_APPROX_TEMPI_DEN 100                ///< Denominator used for tempi approximation. 
                                                    ///< Tempo indeed is a #t_rational internally (see function documentation), even if the
                                                    ///< user can handle them as floating point numbers - they are immediately converted inside in a fraction having this denominator 
                                                    ///< or a divisor.
#else
#define CONST_RAT_APPROX_TEMPI_DEN 10
#endif 

#define CONST_RAT_MAX_DEN_SAFETY 32768                 ///< (Private) Maximum denominator in some trapece integration, if we need to "go safe" // WAS: 8000
#define CONST_RAT_MAX_NUM_SAFETY 32768                ///< (Private) Maximum numerator in some trapece integration, if we need to "go safe"   // WAS: 8000
#define CONST_RAT_SINGLE_DEN 20160                    ///< Denominator for the fraction to which each duration is approximated in the quantize function. 
                                                    ///< The choice is 20160 = 64 * 9 * 5 * 7 so we have quite a lot of values and reducing denominator 
#define CONST_MAX_TEMPO_SAFETY    100000                ///< Maximum allowed tempo (for safety)
#define CONST_MAX_DEPTH_DURATION_DRAWABLE 4            ///< Number of maximum recursive depth when automatically re-parsing the durations in [bach.score] to obtain a representable list of figures

#define BACH_CLEF_AUTODETECT_CUTOFF_THRESHOLD 1.5    ///< Threshold used by automatic clef inference, corresponding to the cutoff threshold of infer_most_appropriate_clef() and infer_most_appropriate_clef_for_voice()
/** @}*/


#define CONST_NUM_PART_COLORS 4         ///< Number of part colors (which will be looped as candycane)

#define CONST_GRAPHICS_COLOR_SATURATION_FACTOR   0.5  ///< Saturation factor for double to color conversions

#define CONST_MARKERS_ON_FIRST_MEASURE_CHORDS false             ///< Markers at the beginning of the measure are placed on barlines instead that on starting chords?

/** \addtogroup dynamics
 *  @{
 */
#define CONST_MAX_NUM_DYNAMICS_PER_CHORD 64                 ///< Max number of dynamics for a chord (used in sequence)
#define CONST_MAX_NUM_DYNAMICS_CHARS 64                     ///< Max number of character per dynamics
#define CONST_USPACE_BETWEEN_DYNAMICS_MARK_WORDS 2          ///< Space between words inside the same dynamics mark
#define CONST_MIN_UWIDTH_BETWEEN_DYNAMICS 10
#define CONST_UX_NUDGE_LEFT_FOR_FIRST_ROMAN_WORD 4           ///< Small left nudge for first roman word inside a dynamic mark
                                                             ///< Roman words are left-aligned when at the beginning of a note (differently from
                                                             ///< standard dynamics. A small compensation is however needed for better visualization

#define CONST_DEFAULT_DYNAMICS_TO_VELOCITY_EXPONENT 0.8             ///< Exponent for dynamics2velocities conversions
#define CONST_DEFAULT_DYNAMICS_SPECTRUM_WIDTH 5                     ///< Default dynamics spectrum width for conversions (i.e. from "pppp" to "ffff")
#define CONST_DEFAULT_VELOCITIES_TO_DYNAMICS_HAIRPIN_THRESH 1.      ///< Default hairpin detection threshold
/** @}*/


// ---------------  enum structures  ------------------

/** Elements used in the code. These are used both for graphic rendering and for interface handling, so sometimes some actions are also included.
    @ingroup    notation
    @remark        Usually this enum is used in the code, whenever there's an "object type" which has to be specified.
                Notice that this is NOT a list of notation items (see #t_notation_item).
 */
typedef enum _element_types {
    k_ELEMENT_TYPES_UNDEFINED = -1,
     k_NONE = 0,                                    ///< No element
    k_NOTE = 1,                                    ///< Note
    k_DURATION_LINE = 2,                        ///< (DEPRECATED) Duration line: black line representing the duration of the note
    k_DURATION_TAIL = 3,                        ///< (DEPRECATED) Duration tail: the end of the duration line
    k_PITCH_BREAKPOINT = 4,                        ///< Pitch breakpoint: diamond within the duration line representing a point within a glissando
    k_CHORD = 5,                                ///< Chord (essentially a set of notes)
    k_REGION = 6,                                ///< Region: a selection rectangle drawn across the UI object
    k_SCROLLBAR = 7,                            ///< The horizontal scroll bar handle
    k_PITCH_BREAKPOINT_OR_DURATION_TAIL = 8,    ///< Either a pitch breakpoint or a duration tail. Gathering them in this element might  be useful since the duration tail is nothing but a particular pitch breakpoint. 
    k_SLOT_INT_FLOAT_BAR = 9,                    ///< The rectangular bar shown in the slot window for int(-list) or float(-list) slots  
    k_SLOT_FUNCTION_POINT = 10,                    ///< The function breakpoint inside the slot window for function slots
    k_SLOT_SPAT_POINT = 11,                        ///< The spat-point inside the slot window for spat slots: the spat-point is a big circle including a small line determining an angle inside the circle
    k_VOICE = 12,                                ///< Voice (in [bach.roll] it'll be essentially a set of chords, in [bach.score] it'll be essentially a set of measures)
    k_MEASURE = 13,                                ///< Measure (essentially a set of chords)
    k_TEMPO = 14,                                ///< Tempo indication
    k_PLAYCURSOR = 15,                            ///< The play cursor
    k_MIXED = 16,                                ///< Multiple selection of various elements
    k_DRAG = 17,                                ///< "Hand-grasp" obtained when the user wants to scroll the object 
    k_SLOT = 18,                                ///< Generic slot
    k_ARTICULATION = 19,                        ///< Articulation (staccato, portato...)
    k_SLUR = 20,                                ///< Slur
    k_SLUR_START_POINT = 21,                    ///< The starting point of a slur  
    k_SLUR_END_POINT = 22,                        ///< The ending point of a slur
    k_SLOT_MATRIX_CELL = 23,                    ///< One of the matrix cells inside the slot window for (toggle-/int-/float-)matrix slots 
    k_MARKER = 24,                                ///< Marker
    k_SCROLLBAR_LEFT_AREA = 25,                    ///< The area at the left of the horizontal scrollbar handle
    k_SCROLLBAR_RIGHT_AREA = 26,                ///< The area at the right of the horizontal scrollbar handle
    k_ZOOMING_REGION = 27,                        ///< "Zooming-rectangle" obtained when the user wants to zoom inside this rectangle
    k_VOICENAME = 28,                            ///< Voicename, at the beginning of the staff
    k_TEXT_IN_SLOT = 29,                        ///< Some text shown inside a slot window for a text slot
    k_LLLL_IN_SLOT = 30,                        ///< An llll shown inside a slot window for an llll-slot
    k_MARKERNAME = 31,                            ///< The name of a marker (shown next to the marker line)
    k_SELECTION_CONTENT = 32,                    ///< The content of a generic selection (used for copy/pasting)
    k_MEASURE_END_BARLINE = 33,                    ///< The barline at the end of a measure
    k_LYRICS = 34,                                ///< Lyrics, shown below a given chord
    k_SCROLLBAR_TOP_AREA = 35,                    ///< The area at the top of the vertical scrollbar handle
    k_SCROLLBAR_BOTTOM_AREA = 36,                ///< The area at the bottom of the vertical scrollbar handle
    k_VSCROLLBAR = 37,                            ///< The vertical scroll bar handle
    k_SLOT_DYNFILTER_BIQUAD = 38,                ///< The single biquad filter inside the slot window for #k_SLOT_TYPE_DYNFILTER slots
    k_SLOT_COLOR_PALETTE = 39,                    ///< The color palette of a #k_SLOT_TYPE_COLOR slot
    k_SLOT_COLOR_SPECTRUM = 40,                    ///< The spectrum as a right column in a #k_SLOT_TYPE_COLOR slot 
    k_DILATION_RECTANGLE_TOPLEFT_SQ = 41,        ///< Dilation square situated at the top left corner of the dilation rectangle
    k_DILATION_RECTANGLE_TOPRIGHT_SQ = 42,        ///< Dilation square situated at the top right corner of the dilation rectangle
    k_DILATION_RECTANGLE_BOTTOMLEFT_SQ = 43,    ///< Dilation square situated at the bottom left corner of the dilation rectangle
    k_DILATION_RECTANGLE_BOTTOMRIGHT_SQ = 44,    ///< Dilation square situated at the bottom right corner of the dilation rectangle
    k_DILATION_RECTANGLE_TOPMIDDLE_SQ = 45,        ///< Dilation square situated at the top-middle point of the dilation rectangle
    k_DILATION_RECTANGLE_BOTTOMMIDDLE_SQ = 46,    ///< Dilation square situated at the bottom-middle point of the dilation rectangle
    k_DILATION_RECTANGLE_MIDDLELEFT_SQ = 47,    ///< Dilation square situated at the middle-left point of the dilation rectangle
    k_DILATION_RECTANGLE_MIDDLERIGHT_SQ = 48,    ///< Dilation square situated at the middle-right point of the dilation rectangle
    k_DILATION_RECTANGLE_BODY = 49,                ///< The inner part of the dilation rectangle
    k_TIME_SIGNATURE = 50,                        ///< A time signature
    k_WHOLE_NOTATION_OBJECT = 51,                ///< The whole notation object, no matter which one (used chiefly for undoing)
    k_HEADER_DATA = 52,                            ///< Any of the data contained in the header element (see #e_header_elems)
    k_SLOTINFO = 53,                            ///< Generic slot information
    k_BACH_INSPECTOR_ITEM = 54,                    ///< Generic item in the bach inspector
    k_BACH_INSPECTOR_VSCROLLBAR = 55,            ///< The vertical scrollbar handle of the bach inspector
    k_BACH_INSPECTOR_COLOR_PALETTE = 56,        ///< The color palette in the bach inspector
    k_BACH_INSPECTOR_COLOR_SPECTRUM = 57,        ///< The color spectrum in the bach inspector
    k_SLOT_3DFUNCTION_POINT = 58,                ///< The function breakpoint inside the slot window for #k_SLOT_TYPE_3DFUNCTION slots
    k_BACH_INSPECTOR = 59,                        ///< The bach inspector itself
    k_GROUP    = 60,                                ///< A set of grouped elements
    k_SELECTION = 66,                            ///< A generic selection task
    k_NOTE_OR_CHORD = 67,                        ///< A common identification for notes and chords
    k_POPUP_MENU = 68,                            ///< The right-click popup menu
    k_DILATION_RECTANGLE = 69,                    ///< The selection dilation rectangle
    k_LOOP_REGION = 70,                            ///< A loop region
    k_LOOP_START = 71,                            ///< Starting point of a loop region
    k_LOOP_END = 72,                            ///< Ending point of a loop region
    k_SLOT_FUNCTION_SEGMENT = 73,                ///< A segment between two #k_SLOT_FUNCTION_POINT elements, representing a segment (or curve) inside a #k_SLOT_FUNCTIOn slot
    k_SLOT_REGION = 74,                            ///< Slot region: a selection rectangle drawn across the open slot window
    k_SLOT_SELECTION = 75,                        ///< Selected content in a slot
    k_NUMBER_IN_SLOT = 76,                        ///< Numbers shown inside a slot window for a int/float slot
    k_DROP = 77,                                ///< File dropping on score
    k_DYNAMICS_IN_SLOT = 78,                    ///< Some text shown inside a slot window for a dynamics slot
    k_DYNAMICS = 79,                            ///< Dynamics, shown below a given chord
    k_GATHERED_SYNTAX = 80,                     ///< Gathered syntax
    k_NUM_ELEMENT_TYPES,
} e_element_types;


/** Types of actions associated with elements.
    @ingroup    interface
 */
typedef enum _element_actions {
    k_ELEMENT_ACTIONS_NONE = 0,
    k_CREATION = 1,                    ///< Create an element
    k_DELETION,                        ///< Delete an element
    k_MODIFICATION_ONSET,            ///< Modify element's onset
    k_MODIFICATION_PITCH,            ///< Modify element's pitch
    k_MODIFICATION_VELOCITY,        ///< Modify element's velocity
    k_MODIFICATION_DURATION,        ///< Modify element's duration
    k_MODIFICATION_NAME,            ///< Modify element's name
    k_MODIFICATION_POSITION,        ///< Modify element's position
    k_MODIFICATION_CLEF,            ///< Modify element's clef
    k_MODIFICATION_RHYTHMIC_TREE,    ///< Modify element's rhythmic tree
    k_MODIFICATION_KEY,                ///< Modify element's key
    k_MODIFICATION_GENERIC,            ///< Generically modify an element
    k_SINGLE_SELECTION,                ///< Select single elements
    k_MULTIPLE_SELECTION,            ///< Select multiple elements
    k_ALL_ACTIONS,                    ///< All possible actions
} e_element_actions;


/** Constitutive elements for roll and score gathered syntax, i.e.: header elements + body.
    @ingroup    notation
    @remark        The "HEADER" name is an abuse, since #k_HEADER_BODY is in here and the body is not a part of the header.
 */
typedef enum _header_elems {
    k_HEADER_NONE = 0,                ///< None of the #e_header_elems
    k_HEADER_BODY = 1,                ///< Body of the object (content of voices, measures, chords, notes...) 
    k_HEADER_CLEFS = 2,                ///< Clef information
    k_HEADER_KEYS = 4,                ///< Key signatures information
    k_HEADER_MARKERS = 8,            ///< Information about markers
    k_HEADER_SLOTINFO = 16,            ///< Slotinfo information (information about the nature of each single slot)
    k_HEADER_COMMANDS = 32,            ///< Commands information (information about the nature of each single command)
    k_HEADER_MIDICHANNELS = 64,        ///< Midichannels information
    k_HEADER_VOICENAMES = 128,        ///< Voicenames information
    k_HEADER_GROUPS = 256,            ///< Groups information
    k_HEADER_STAFFLINES = 512,        ///< Staff lines information
    k_HEADER_ARTICULATIONINFO = 1024,    ///< Custom articulations information
    k_HEADER_NOTEHEADINFO = 2048,    ///< Custom noteheads information
    k_HEADER_NUMPARTS = 4096,        ///< Voice to part assignment information
    k_HEADER_LOOP = 8192,          ///< Loop position
    k_HEADER_VOICESPACING = 16384,        ///< Voice spacing information
    k_HEADER_HIDEVOICES = 32768,        ///< Voice hiding information
    k_HEADER_ALL = 0xFFFFFFFF,        ///< All the other #e_header_elems together
} e_header_elems;



typedef enum _merge_when {
    k_MERGE_WHEN_NEVER = 0,         ///< Never merge
    k_MERGE_WHEN_DRAWABLE = 1,      ///< Merge all-tied sequences (or all-rests sequence) only when the resulting sum is drawable
    k_MERGE_WHEN_ALWAYS = 2         ///< Always merge all-tied sequences
} e_merge_when;



typedef enum _scheduling_type {
    k_SCHEDULING_STANDARD = 0,       ///< Online play (default)
    k_SCHEDULING_OFFLINE = 1,      ///< Off-line play (no scheduling)
    k_SCHEDULING_PRESCHEDULE = 2      ///< Accurate online scheduling (but won't respond to modifications in the score, and loops and lambda won't work)
} e_scheduling_type;



typedef enum _nametoslot_chordname_policy {
    k_NAMETOSLOT_CHORDNAME_IGNORE = 0,
    k_NAMETOSLOT_CHORDNAME_REPLACE = 1,
    k_NAMETOSLOT_CHORDNAME_REPLACEIFNULL = 2,
    k_NAMETOSLOT_CHORDNAME_PREPEND = 3,
    k_NAMETOSLOT_CHORDNAME_APPEND = 4,
    k_NAMETOSLOT_CHORDNAME_MERGEPREPEND = 5,
    k_NAMETOSLOT_CHORDNAME_MERGEAPPEND = 6,
} e_nametoslot_chordname_policy;


typedef enum _voiceensemble_interface_policy {
    k_VOICEENSEMBLE_INTERFACE_NONE = 0,
    k_VOICEENSEMBLE_INTERFACE_FIRST = 1,
    k_VOICEENSEMBLE_INTERFACE_LAST = 2,
    k_VOICEENSEMBLE_INTERFACE_ACTIVE = 3,
    k_VOICEENSEMBLE_INTERFACE_ANY = 4
} e_voiceensemble_interface_policy;


typedef enum _chord_position_in_screen {
    k_CHORDPOSITIONINSCREEN_ENDS_BEFORE_DOMAIN = -3,
    k_CHORDPOSITIONINSCREEN_ENDS_INSIDE_PREDOMAIN = -2,
    k_CHORDPOSITIONINSCREEN_ENDS_INSIDE_DOMAIN = -1,
    k_CHORDPOSITIONINSCREEN_STARTS_INSIDE_DOMAIN = 0,
    k_CHORDPOSITIONINSCREEN_STARTS_AFTER_DOMAIN = 1,
    k_CHORDPOSITIONINSCREEN_OVERSPANS_DOMAIN = 2,
} e_chord_position_in_screen;


typedef enum _play_offline_key {
    k_PLAYOFFLINE_KEY_NONE = 0,
    k_PLAYOFFLINE_KEY_LEFTCLICK = 1,
    k_PLAYOFFLINE_KEY_RIGHTCLICK = 2,
    k_PLAYOFFLINE_KEY_DOUBLECLICK = 3,
} e_play_offline_key;



/** Function setting the whole information for the notation object, starting from a ll. 
    Each notation object implement one of these.
    @ingroup interface
 */
typedef long (*rebuild_fn)(void *notation_obj, t_llll *ll, char also_lock_general_mutex);


/** Void function involving a notation object and a notation item.
    @ingroup notation
 */
typedef void (*notation_obj_notation_item_fn)(void *notation_obj, void *item, void *data);


/** Void function involving a notation object and a note.
    @ingroup notation
 */
typedef void (*notation_obj_note_fn)(void *notation_obj, void *note, void *data);


/** Void function involving a notation object and a chord.
    @ingroup notation
 */
typedef void (*notation_obj_chord_fn)(void *notation_obj, void *chord, void *data);


/** Void function involving a notation object only.
    Chiefly used for undo (whole object undo) and bach inspector.
    @ingroup notation
 */
typedef void (*notation_obj_fn)(void *notation_obj);


/** Setter for a given bach attribute (works like Max setters). 
    Sets the proper fields in the notation structures starting from the ac-av signature.
    @ingroup attributes
 */
typedef void (*bach_setter_fn)(void *inspector_manager, void *elem, void *attr, long ac, t_atom *av);


/** Getter for a given bach attribute (works like Max getters).
    Fills the ac-av signature starting from the current state of the attribute and of the notation structures.
    @ingroup attributes
 */
typedef void (*bach_getter_fn)(void *inspector_manager, void *elem, void *attr, long *ac, t_atom **av);


/** Function which will be called before or after an attribute has changed.
    @ingroup attributes
 */
typedef void (*bach_attr_process_fn)(void *inspector_manager, void *elem, void *attr);


/** Function which tells if an attribute for an element should or should not be active.
    Returns 1 if it is inactive, 0 otherwise.
    @ingroup attributes
 */
typedef long (*bach_inactive_fn)(void *inspector_manager, void *elem, void *attr);


/** Function returning the miniature rectangle on the layer named gensym("static_layer_1").
    Also fills the #show_line pointer with a combination of the #e_inspector_miniature_lines values, telling
    if a vertical or horizontal thin line (or both) in the middle of the miniature should be painted.
    @ingroup attributes
 */
typedef t_rect (*bach_inspector_miniature_fn)(void *notation_obj, void *elem, long elem_type, char *show_line);


/** Function returning the text for the header of the inspector. The text must be filled in the #txt variable.
    @remark The array #txt has to be sized at least #CONST_BACH_INSPECTOR_MAX_HEADER_NUM_CHARS, and
            whatever you do in this function has to take this into account. So use snprintf_zero(txt, CONST_BACH_INSPECTOR_MAX_HEADER_NUM_CHARS, ...) 
            instead of simple sprintf() functions.
    @ingroup attributes
 */
typedef void (*bach_inspector_header_fn)(void *notation_obj, void *inspector_manager, void *elem, long elem_type, char *txt);


/** Function returning the image for the header of the inspector.
 @ingroup attributes
 */
typedef t_jsurface *(*bach_inspector_image_fn)(void *notation_obj, void *inspector_manager, void *elem, long elem_type);


/** Function returning the color of the inspector background.
    @ingroup attributes
 */
typedef t_jrgba (*bach_inspector_color_fn)(void *notation_obj, void *elem, long elem_type);


/** Function to delete a given notation item
    @ingroup notation
 */
typedef char (*delete_item_fn)(void *notation_obj, void *notation_item, char *need_check_scheduling);


/** Function to be wrapped by the object's paint function
    @ingroup display
 */
typedef void (*bach_paint_ext_fn)(t_object *x, t_object *view, t_jgraphics *g, t_rect rect);


//TBD
typedef char (*notation_obj_inscreenmeas_fn)(t_object *x, void *measure_from, void *measure_to, char also_send_domain);



/** Structure for a bach attribute. A bach attribute is some field of some specific element which we want to bring in the foreground,
    in order for the user to be able to set/get it via the bach integrated inspector.
    @ingroup attributes
 */
typedef struct _bach_attribute
{
    long        idx;                    ///< Index of the attribute
    
    t_symbol    *name;                    ///< Attribute name. If the attribute is not a basic one (pitch, velocity, duration...), this must correspond to the router symbol in the llll specifying the attribute (e.g. "ysnap")
    const char      *displayed_label;        ///< Displayed label for the attribute. This can be more verbose than the attribute name (e.g. "Snap Range Values");
    
    long        owner_type;                ///< Owner type (one of the #e_element_types)
    long        field_position;            ///< Offset of the attribute field inside the owner structure;
    long        attr_type;                ///< Type of the variable of #field, one of the #e_bach_attr_types
    long        attr_size;                ///< For array-typed attributes, size of the array
    long        field_position_for_var_attr_size;        ///< Offset, inside the owner structure, of a long field keeping track of the length of the attribute if it is of variable size;

    long                flags;          ///< Attribute flags. Unused in bach, used in dada

    // display
    char        display_type;            ///< One of the #e_bach_attr_display_types
    long        num_enum_index_elems;    ///< Number of items in the enumindex dropdown menu (only meaningful if #display_type = #k_BACH_ATTR_DISPLAY_ENUMINDEX)
    t_symbol    *enum_index[CONST_MAX_BACH_ATTR_ENUMINDEX_ITEMS];    ///< Array containing one symbol for each item in the dropdown menu

    const char    *default_val;           ///< Default value as character sequence. Unused in bach, used in dada
    
    // functions
    bach_setter_fn        setter;            ///< Setter method (NULL uses bach default one)
    bach_getter_fn        getter;            ///< Getter method (NULL uses bach default one)
    bach_attr_process_fn    preprocess;        ///< Preprocess method (NULL uses bach default one)
    bach_attr_process_fn postprocess;    ///< Postprocess method (NULL uses bach default one)
    bach_inactive_fn    inactive;        ///< Inactive method, returning 1 if the attribute is inactive, 0 otherwise (NULL if the attribute is always active)
    long                preprocess_flags;    ///< Still unused
    long                postprocess_flags;    ///< Still unused
    
    // utilities
    char                still_not_dragged;        ///< Utility which is set to 1 at mousedown, so that it is 1 at the first mousedrag event of the cursor on the inspector item, and then 0, until the new mousedown
    double                float_dragging_value;    ///< Float value of the item while dragging.
} t_bach_attribute;




/** Accidental display preferences.
    @ingroup    notation
 */
typedef enum _show_accidentals_preferences {
    k_SHOW_ACC_CLASSICAL = 0,                   ///< Classical accidental display; in [bach.score] this is the measure-wise standard accidental display;
                                                ///  in [bach.roll] this is equivalent to #k_SHOW_ACC_ALLALTERED_NONATURALS
    k_SHOW_ACC_ALL = 1,                         ///< Show accidentals for all altered and natural notes
    k_SHOW_ACC_ALLALTERED = 2,                  ///< Show accidentals for all altered notes; also display naturals to cancel them
    k_SHOW_ACC_ALLALTERED_NOREPETITION = 3,     ///< Show accidentals for all altered notes, except for direct repetitions; also display naturals to cancel them
    k_SHOW_ACC_ALLALTERED_NONATURALS = 4,       ///< Show accidentals for all altered notes, don't show naturals for natural notes
    k_SHOW_ACC_NONE = 5,                        ///< Show accidentals for no note
} e_show_accidentals_preferences;


/** Accidental and ties display preferences.
    @ingroup    notation
 */
typedef enum _show_accidentals_tie_preferences {
    k_SHOW_ACC_TIES_NEVER = 0,                   ///< Never show accidentals on notes where a tie ends
    k_SHOW_ACC_TIES_MEASURE_BEGINNING = 1,       ///< Show accidentals only for notes where a tie ends if they are at the beginning of a measure
    k_SHOW_ACC_TIES_ALWAYS = 2,                  ///< Show accidentals for all notes where a tie ends
} e_show_accidentals_tie_preferences;


/** Rests display preferences.
    @ingroup    notation
 */
typedef enum _show_rests_preferences {
    k_SHOW_RESTS_NEVER = 0,                   ///< Never show rests
    k_SHOW_RESTS_NOT_IN_EMPTY_MEASURES = 1,   ///< Always show rests except for empty measures
    k_SHOW_RESTS_ALWAYS = 2,                  ///< Always show rests
} e_show_rests_preferences;

/** Stems display preferences.
    @ingroup    notation
 */
typedef enum _show_stems_preferences {
    k_SHOW_STEMS_DONT = 0,                  ///< Never show stems
    k_SHOW_STEMS_MAIN = 1,                  ///< Always show main chord stem
    k_SHOW_STEMS_MAIN_AND_AUXILIARY = 2,    ///< Always show main and auxiliary stems
} e_show_stems_preferences;




/** Accidental definition for a given note. Note might have automatic-defined accidentals (which means: the algorithms will
    choose the default accidental, given the key signature and the accidental preferences), or a manually-defined one
    (inserted by the user, either as a (graphic...) extra or via the interface, by right clicking and choosing enharmonicity.
    @ingroup    notation
 */
typedef enum _accidentals_type {
    k_ACCIDENTALS_AUTO = 0, ///< Automatically assigned accidental
    k_ACCIDENTALS_USER        ///< User-assigned accidental
} e_accidentals_type;


/** Accidental display type. Accidentals can be displayed in various ways: classically, as fractions and as cents differences.
    The two latter cases work with no matter which microtonal division; the classical view only works for semitone, quartertone and eighttone division,
    and only if the chosen accidental fonts have the proper symbols (e.g. Boulez does NOT allow quartertones). If the classical view is chosen when the 
    microtonal division is not supported, some 'bogus' accidentals are shown instead.
    @ingroup    notation
    @see        #e_accidentals_preferences
 */
typedef enum _accidentals_display_type {
    k_ACCIDENTALS_NO_DISPLAY = 0,            ///< Don't ever display accidentals
    k_ACCIDENTALS_CLASSICAL = 1,            ///< Display accidentals classically (with the selected font, and with the loaded #e_accidentals_preferences)
    k_ACCIDENTALS_FRACTION = 2,                ///< Display accidentals as fractions (+1/2, -1/4...)
    k_ACCIDENTALS_UNREDUCED_FRACTION = 3,    ///< Display accidentals as fractions, but never reduce the fractions (e.g. leave -3/6 when working with 6-th tones)
    k_ACCIDENTALS_CENTS = 4                    ///< Display accidentals only as cents differences (+25c, -74c...)
} e_accidentals_display_type;


/** Alignment positions (only supported in bach.roll)
    @remark        bach.score only supports #k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_CENTER.
    @ingroup    notation
 */
typedef enum _chord_align_mode {
    k_CHORD_ALIGN_WITH_STEMS = 0,                        ///< Align chords based on their stems
    k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_CENTER = 1,    ///< Align chords based on the center of the principal notehead (default in bach.roll).
                                                        ///  The principal notehead is the directly on the left of the stem when the stem is upward,  
                                                        ///  or directly on the right of the stem when the stem is downward
    k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_END = 2,        ///< Align chords based on the right end of the principal notehead (see #k_CHORD_ALIGN_WITH_PRINCIPAL_NOTEHEAD_CENTER).
} e_chord_align_mode;



/** Clefs. 
    @remark        A standard single clef is represented by the step-position of its middle C, with respect to the bottommost staff line. 
                For instance, the G clef is represented as -2, since the middle C is 2 steps below the bottommost staff line (1 space+1 line below = 2 steps). 
                Analogously, the F clef is represented as 10, since che middle C is 10 steps up with respecto to the bottommost staff line. 
                On the other hand, nonstandard clefs have values v such that |v| >= 100. They represent particular clefs (such as percussion clefs)
                or clef combinations, which show multiple staves for the same voices (e.g. the piano F and G clefs).
    @ingroup    notation
 */
typedef enum _clefs {
    k_CLEF_G = -2,                ///< G clef
    k_CLEF_F = 10,                ///< F clef
    k_CLEF_G8va = -9,            ///< G clef, 1 octave higher
    k_CLEF_G8vb = 5,            ///< G clef, 1 octave lower
    k_CLEF_G15ma = -16,            ///< G clef, 2 octaves higher
    k_CLEF_G15mb = 12,            ///< G clef, 2 octaves lower
    k_CLEF_F8va = 3,            ///< F clef, 1 octave higher
    k_CLEF_F8vb = 17,            ///< F clef, 1 octave lower
    k_CLEF_F15ma = -4,            ///< F clef, 2 octaves higher
    k_CLEF_F15mb = 24,            ///< F clef, 2 octaves lower

    k_CLEF_SOPRANO = 0,            ///< Soprano clef
    k_CLEF_MEZZO = 2,            ///< Mezzosoprano clef
    k_CLEF_ALTO = 4,            ///< Alto clef
    k_CLEF_TENOR = 6,            ///< Tenor clef
    k_CLEF_BARYTONE = 8,        ///< Barytone clef

    k_CLEF_PERCUSSION = -126,    ///< Percussion clef
    k_CLEF_NONE = -127,            ///< No clef
    
    k_CLEF_FFGG = 100,            ///< Combination of F(15mb), F, G and G(15ma) clefs
    k_CLEF_FFG = 101,            ///< Combination of F(15mb), F and G clefs
    k_CLEF_FGG = 102,            ///< Combination of F, G and G(15ma) clefs
    k_CLEF_FF = 103,            ///< Combination of F(15mb) and F clefs
    k_CLEF_FG = 104,            ///< Combination of F and G clefs (standard piano staff)
    k_CLEF_GG = 105,            ///< Combination of G and G(15ma) clefs

    k_CLEF_AUTO = -124,         ///< Auto clef (to be assigned)
    k_CLEF_WRONG = -125,        ///< Wrong clef (or not yet assigned)
} e_clefs;


/** Modes.
    @ingroup    notation
 */
typedef enum _modes {
    k_MODE_MAJOR = 1,            ///< Major mode
    k_MODE_MINOR = -1,            ///< Minor mode
    k_MODE_NONSTANDARD = 0        ///< Any other nonstandard mode
} e_modes;


/** Flags for notation elements that need to be saved in the gathered syntax dump
    @ingroup    notation
 */
typedef enum _bach_element_flags {
    k_FLAG_ELEMENT_LOCKED = 1,                ///< The element is locked
    k_FLAG_ELEMENT_MUTED = 2,                ///< The element is muted
    k_FLAG_ELEMENT_SOLO = 4,                ///< The element is solo
    k_FLAG_ELEMENT_BEAMING_TREE_LOCKED = 8,    ///< The element (measure) has a locked rhythmic tree
} e_notation_item_flags;


/** Internal flags, typically assigned to the #t_notation_item <flag> field.
    @ingroup    notation
 */
typedef enum _bach_internal_notation_flags {
    k_FLAG_PLAYED = 1 << 0,                            ///< (OBSOLETE) Element is being played (now see e.g. the t_chord#played field of the structures)
    k_FLAG_BEAM = 1 << 1,                            ///< (OBSOLETE) Element's beams have been computed
    k_FLAG_COUNT = 1 << 2,                            ///< Element has been counted
    k_FLAG_MODIFIED = 1 << 3,                        ///< Element has been modified
    k_FLAG_DEFINES_LOCAL_SPACING_WIDTH = 1 << 4,    ///< Element has to define a local spacing multiplier
    k_FLAG_DEFINES_FIXED_WIDTH = 1 << 5,            ///< Element has to define a fixed width
    k_FLAG_REMOVES_FIXED_WIDTH = 1 << 6,            ///< Element has to remove a fixed width
    k_FLAG_SHIFT = 1 << 7,                            ///< Element has been shifted
    k_FLAG_SPLIT = 1 << 8,                            ///< Element has been split
    k_FLAG_MERGE = 1 << 9,                            ///< Element has been merged
    k_FLAG_DONETUPLETS = 1 << 10,                    ///< We're done calculating tuplets on element
    k_FLAG_VALIDATEACCIDENTALS = 1 << 11,            ///< Element's accidentals have been validated
    k_FLAG_DUPLICATE = 1 << 12,                        ///< Element has been duplicated
    k_FLAG_COLLAPSE = 1 << 13,                        ///< Element has been collapsed
    k_FLAG_MODIF_UNDO = 1 << 14,                    ///< We have stored element's undo information in the currently free ticks at the beginning of the undo llll; if the undo operation is performed, no chord order checking will be required.
    k_FLAG_MODIF_FLAG_UNDO = 1 << 15,                ///< We have stored element's flag undo information in the currently free ticks at the beginning of the undo llll
    k_FLAG_MODIF_CHECK_ORDER_UNDO = 1 << 16,        ///< We have stored element's undo information in the currently free ticks at the beginning of the undo llll, and also this will require to check the chords order when the undo operation will be performed
    k_FLAG_MODIF_NAME_UNDO = 1 << 17,                ///< We have stored element's name undo information in the currently free ticks at the beginning of the undo llll
    k_FLAG_TO_BE_MODIFIED = 1 << 18,                ///< Element needs to be modified
    k_FLAG_TO_BE_DELETED = 1 << 19,                    ///< Element needs to be deleted
    k_FLAG_OVERFLOW_TO_NEXT = 1 << 20,                ///< Content exceeding duration must overflow to next measure
    k_FLAG_TO_BE_SNAPPED = 1 << 21,                 ///< Element needs to be snapped later on
    k_FLAG_TO_BE_KEPT = 1 << 22,                    ///< Element needs to be kept
} e_bach_internal_notation_flags;

#define k_FLAG_MODIF_UNDO_WITH_OR_WO_CHECK_ORDER (k_FLAG_MODIF_UNDO | k_FLAG_MODIF_CHECK_ORDER_UNDO)    ///< We have stored element's undo information in the currently free ticks at the beginning of the undo llll (with or without the need to check chords' order) @ingroup notation


/** Velocity handling. How do we want to represent the velocity of each note on the score? 
    @ingroup    notation
 */
typedef enum _velocity_handling {
    k_VELOCITY_HANDLING_NONE = 0,                ///< Don't represent velocity
    k_VELOCITY_HANDLING_COLORSCALE = 1,            ///< Represent velocity by changing luminosity of the note color (from almost white, softest, to the attribute-defined note color, loudest)
    k_VELOCITY_HANDLING_COLORSPECTRUM = 2,        ///< Represent velocity with a colorspectrum (red being the softest, blue being the loudest)
    k_VELOCITY_HANDLING_ALPHACHANNEL = 3,        ///< Represent velocity by changing the alpha-channel of the note color (from almost 0., softest, to 1., loudest)
    k_VELOCITY_HANDLING_DURATIONLINEWIDTH = 4,    ///< Represent velocity by increasing or decreasing the width of the duration line (from almost 0., softest, to the attribute-defined width, loudest)
    k_VELOCITY_HANDLING_NOTEHEADSIZE = 5        ///< Represent velocity by increasing or decreasing the notehead size (from almost 0., softest, to the default size, loudest)
} e_velocity_handling;


/** Show label families types
    @ingroup    names
 */
typedef enum _show_label_families_type {
    k_SHOW_LABEL_FAMILIES_NONE = 0,                    ///< Don't represent label families
    k_SHOW_LABEL_FAMILIES_SINGLETONS = 1,            ///< Enclose chords, notes, measures into colored shapes to represent label families
    k_SHOW_LABEL_FAMILIES_BOUNDINGBOX = 2,            ///< Rectangles as bounding box, collecting all elements in label families
    k_SHOW_LABEL_FAMILIES_VENN = 3,                    ///< "Venn" diagram collecting all elements in label families
} e_show_label_families_type;

/** Barline modifiers. 
    @ingroup    notation
 */
typedef enum _barline_modifier {
    k_BARLINE_AUTOMATIC = 'a',     ///< Automatic barline (normal barline when the measure is NOT final, final barline when the measure is final)
    k_BARLINE_NORMAL = 'n',        ///< Normal barline
    k_BARLINE_DASHED = 'd',        ///< Dashed barline
    k_BARLINE_POINTS = 'p',        ///< Pointed barline
    k_BARLINE_DOUBLE = 't',        ///< Double barline
    k_BARLINE_FINAL = 'f',         ///< Final barline (a thin and a thick one in sequence)
    k_BARLINE_HIDDEN = 'h',        ///< Hidden barline
    k_BARLINE_SOLID = 's',         ///< Solid barline (thicker than the normal one)
    k_BARLINE_TICK = 'k',          ///< Tick
    k_BARLINE_INTERVOICES = 'i'    ///< Intervoice barline only
} e_barline_modifier;


/** Note name conventions.
    @ingroup    notation
 */
typedef enum _note_names_conventions {
    k_NOTE_NAMES_LATIN = 0,        ///< Use latin naming (do, re, mi...)
    k_NOTE_NAMES_ANGLOSAXON = 1        ///< Use anglosaxon naming (C, D, E...)
} e_note_names_styles;


/** Ways of show tuplets number.
    @ingroup    notation
 */
typedef enum _tuplet_ratio_display_types {
    k_TUPLET_DISPLAY_NO_NUMBER = 0,                    ///< Show nothing
    k_TUPLET_DISPLAY_SHOW_AUTO = 1,                    ///< Automatically choose one of the following display types
    k_TUPLET_DISPLAY_SHOW_SINGLE_NUMBER = 2,        ///< Show single number (e.g. 3)
    k_TUPLET_DISPLAY_SHOW_RATIO = 3,                ///< Show ratio (e.g. 3:2)
    k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES = 4,    ///< Show ratio and figure (e.g. 3q:2q)
    k_TUPLET_DISPLAY_SHOW_FRACTION = 5                ///< Display the fraction (e.g. 2/3)
} e_tuplet_ratio_display_types;


/** Tuplet shapes
    @ingroup    notation
 */
typedef enum _tuplet_shapes {
    k_TUPLET_SHAPE_NONE = 0,        ///< Don't use any shape for tuplets
    k_TUPLET_SHAPE_BRACKET = 1,        ///< Gather tuplets under a bracket
    k_TUPLET_SHAPE_SLUR = 2,        ///< Gather tuplets under a slur
} e_tuplet_shapes;


/** Score views.
    @ingroup    notation
    @remark        At the end of November 2011, the only implemented view is the scroll view.
                Users can, though, fake a page view by using multiple UI objects and the "inscreenpos" and "inscreenmeas" messages.
 */
typedef enum _views {
    k_VIEW_SCROLL = 0,    ///< Scroll view (score indefinitely scrolls horizontally)
    k_VIEW_PAPYRUS = 1,    ///< Papyrus view (score indefinitely scrolls vertically)
    k_VIEW_PAGE = 2        ///< Page view (score does not scroll indefinitely, but user can turn pages).
} e_views;


/** Spacing algorithms for [bach.score].
    @ingroup    notation
 */
typedef enum _spacing_types {
    k_SPACING_SMART = 0,            ///< Smart spacing: just like Note/TS spacing, but it chooses automatically the proportion within each tuttipoint region (which in most cases correspond to a global measure)
    k_SPACING_NOTE_TS = 1,            ///< Depending on the spacingproportionality attribute (0 to 1), the spacing varies from purely note-spacing (items are placed with respect to the spacing needed to draw them) and purely time-signature spacing (items are placed at the correct position with respect to the event timing within each measure or tuttipoint tranche).
    k_SPACING_PROPORTIONAL = 2,        ///< Spacing is purely proportional: as for [bach.roll], items are placed at the correct position in the timeline, only depending on their onset in milliseconds. Consider that most likely this will produce overlapping things.
    k_SPACING_SPRING = 3,            ///< Spring spacing: chords are kept together via imaginari springs, and their placement is a result of a equilibrium configuration of the pseudo-physical system. 
} e_spacing_types;


/** Notation objects.
    @ingroup    notation
 */
typedef enum _notation_objects {
    k_NOTATION_OBJECT_ANY = 0,        ///< Any notation object
    k_NOTATION_OBJECT_ROLL,            ///< A [bach.roll] object
    k_NOTATION_OBJECT_SCORE,        ///< A [bach.score] object
    k_NOTATION_OBJECT_SLOT,            ///< A [bach.slot] object
    k_NOTATION_OBJECT_CUSTOM,        ///< A custom notation object
} e_notation_objects;



/** Articulations.
    @ingroup    articulations
 */
typedef enum _articulations {
    k_ARTICULATION_NONE = 0,                ///< No articulation
    k_ARTICULATION_STACCATO,                ///< Staccato
    k_ARTICULATION_ACCENT,                  ///< Accent
    k_ARTICULATION_PORTATO,                 ///< Portato
    k_ARTICULATION_TRILL,                   ///< Trill
    k_ARTICULATION_TRILL_NATURAL,           ///< Trill with the natural sign
    k_ARTICULATION_TRILL_FLAT,              ///< Trill with the flat sign
    k_ARTICULATION_TRILL_SHARP,             ///< Trill with the sharp sign
    k_ARTICULATION_TRILL_DOUBLE_FLAT,        ///< Trill with the flat sign
    k_ARTICULATION_TRILL_DOUBLE_SHARP,        ///< Trill with the sharp sign
    k_ARTICULATION_FERMATA,                    ///< Fermata (corona)
    k_ARTICULATION_ACCENT_STACCATO,            ///< Accent+staccato
    k_ARTICULATION_ACCENT_PORTATO,            ///< Accent+portato
    k_ARTICULATION_PORTATO_STACCATO,        ///< Portato+staccato
    k_ARTICULATION_STACCATISSIMO,            ///< Staccatissimo (similar to a reversed "V" sign)
    k_ARTICULATION_MARTELLATO,                ///< Martellato (the "^" sign)
    k_ARTICULATION_MARTELLATO_STACCATO,     ///< Martellato+staccato
    k_ARTICULATION_MORDENT_UP,                ///< Single upward mordent
    k_ARTICULATION_MORDENT_DOWN,            ///< Single reversed mordent
    k_ARTICULATION_DOUBLE_MORDENT,            ///< Double upward mordent
    k_ARTICULATION_GRUPPETTO,                ///< Gruppetto
    k_ARTICULATION_HARMONIC,                ///< Circle for the harmonic ("Â°" sign)
    k_ARTICULATION_LEFT_HAND_PIZZICATO,     ///< Left hand pizzicato ("+" sign)
    k_ARTICULATION_BOWING_UP,                ///< Upward bowing
    k_ARTICULATION_BOWING_DOWN,             ///< Downward bowing
    k_ARTICULATION_TREMOLO3,                ///< Tremolo with 3 lines
    k_ARTICULATION_TREMOLO2,                ///< Tremolo with 2 lines
    k_ARTICULATION_TREMOLO1,                ///< Tremolo with 1 line
    k_NUM_STANDARD_ARTICULATIONS,
} e_articulations;


/** Articulation positioning.
    @ingroup    articulations
 */
typedef enum _articulation_positioning {
    k_ARTICULATION_POSITIONING_MANUAL = 0,                ///< Manual positioning
    k_ARTICULATION_POSITIONING_NOTE_SIDE,                ///< On the note side
    k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_NOTEHEAD,    ///< On the stem side, but anchored to the the notehead (as the stem increase)
    k_ARTICULATION_POSITIONING_STEM_SIDE_NEAR_FLAG,        ///< On the stem side, but anchored to the flag (as the stem increase)
    k_ARTICULATION_POSITIONING_ABOVE_NOTE,                ///< Always above the note
    k_ARTICULATION_POSITIONING_BELOW_NOTE                ///< Always below the note
} e_articulation_positioning;


/** Flags for articulation options.
    @ingroup    articulations
 */
typedef enum _articulation_options {
    k_ARTICULATION_OPTION_AVOID_STAFF_LINES = 0x01,     ///< Avoid the staff lines
    k_ARTICULATION_OPTION_OUTSIDE_STAFF = 0x02,         ///< Place outside the staff
    k_ARTICULATION_OPTION_CENTER_OVER_NOTE = 0x04,      ///< Center horizontally with respect to the notehead
    k_ARTICULATION_OPTION_CENTER_OVER_STEM = 0x08,      ///< Center horizontally with respect to the stem
    k_ARTICULATION_OPTION_SPAN_TIES = 0x10,             ///< Articulation extension (if any) spans ties
    k_ARTICULATION_OPTION_SPAN_REST_SEQUENCES = 0x20,   ///< Articulation extension (if any) spans ties
    k_ARTICULATION_OPTION_SHIFT_WITH_BEAMS = 0x40,      ///< Shift vertically depending on the number of beams (for bach.score only)
    k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_SAME_CHORD = 0x80, ///< Articulation can be copied when a note is cloned inside the SAME chord
    k_ARTICULATION_OPTION_COPY_WHEN_CLONED_TO_NEW_CHORD = 0x100,  ///< Articulation can be copied when a note is cloned to a new chord
    k_ARTICULATION_OPTION_COPY_WHEN_SPLIT = 0x200,               ///< During processes which might entail note splitting (such as quantization),
                                                                 ///< when a note having such articulation
                                                                 ///< is split, the articulation is assigned to all notes (if more than one),
                                                                 ///< and not just to the first one
                                                                 ///< For instance, to a whole tied sequence of notes quantizing the single original one
} e_articulation_options;



/** Noteheads.
    @ingroup    noteheads
 */
typedef enum _noteheads {
    k_NOTEHEAD_DEFAULT = 0,         ///< Default notehead: will be reconducted to one of the four following ones
    k_NOTEHEAD_DOUBLE_WHOLE_NOTE,   ///< Double 2/1 notehead
    k_NOTEHEAD_WHOLE_NOTE,          ///< Full 1/1 notehead
    k_NOTEHEAD_WHITE_NOTE,          ///< White 1/2 notehead
    k_NOTEHEAD_BLACK_NOTE,          ///< Black 1/4 notehead
    k_NOTEHEAD_CROSS,               ///< X notehead
    k_NOTEHEAD_DIAMOND,             ///< Diamond-shaped "harmonic" notehead
    k_NOTEHEAD_NONE,                ///< No notehead
    k_NOTEHEAD_ACCENT,              ///< Accent-shaped "slap" notehead
    k_NOTEHEAD_PLUS,                ///< Plus-sign notehead
    k_NOTEHEAD_BLACK_SQUARE,        ///< Black square
    k_NOTEHEAD_WHITE_SQUARE,        ///< White square
    k_NOTEHEAD_SQUARE,              ///< Square (white or black, it'll depend on the chord symbolic duration, in bach.score)
    k_NOTEHEAD_BLACK_RHOMBUS,       ///< Black rhombus
    k_NOTEHEAD_WHITE_RHOMBUS,       ///< White rhombus
    k_NOTEHEAD_RHOMBUS,             ///< Rhombus (white or black, it'll depend on the chord symbolic duration, in bach.score)
    k_NOTEHEAD_BLACK_TRIANGLE,      ///< Black triangle
    k_NOTEHEAD_WHITE_TRIANGLE,      ///< White triangle
    k_NOTEHEAD_TRIANGLE,            ///< Triangle (white or black, it'll depend on the chord symbolic duration, in bach.score)
    
    k_NUM_STANDARD_NOTEHEADS,
} e_noteheads;



/** Flag to decide to show properties on an element depending if the element is selected or not.
    @ingroup    notation
    @remark        This is mostly used in code for mute/lock/solo colors, which can be shown when an element is selected, or when it is not selected.
                Use k_SHOW_WHEN_SELECTED + k_SHOW_WHEN_NOT_SELECTED to always show the property.
 */
typedef enum _show_when {
    k_SHOW_WHEN_NEVER = 0,            ///< Never show the property
    k_SHOW_WHEN_SELECTED = 1,        ///< Show the property when the element is selected
    k_SHOW_WHEN_NOT_SELECTED = 2,    ///< Show the property when the element is NOT selected
} e_show_when;


/** Selection modes; more precisely: way of merging the preselection llll with the selection llll.
    @ingroup    notation
    @remark    
 */
typedef enum _selection_modes {
    k_SELECTION_MODE_INVOLUTIVE = 0,        ///< If a preselected item is reselected, it'll be unselected (default, used almost everywhere in the interface)
    k_SELECTION_MODE_FORCE_SELECT = 1,        ///< If a preselected item is reselected, it just stays selected (all objects in the preselection are FORCED to be selected)
    k_SELECTION_MODE_FORCE_UNSELECT = -1,    ///< If a NON-preselected item is selected, it'll just stays UNselected (all objects in the preselection are FORCED to be unselected)
    k_SELECTION_MODE_INTERSECT_WITH_SELECTION = 2,    ///< Only select items if already previously selected.
} e_selection_modes;


/** Lyrics alignments.
    @ingroup    notation
 */
typedef enum e_lyrics_alignments {
    k_LYRICS_ALIGNMENT_AUTO = 0,        ///< Automatic alignment (currently equal to the #k_LYRICS_ALIGNMENT_CENTER alignment, but will be improved)
    k_LYRICS_ALIGNMENT_LEFT = 1,        ///< Syllabes are left-aligned
    k_LYRICS_ALIGNMENT_CENTER = 2,        ///< Syllabes are center-aligned
    k_LYRICS_ALIGNMENT_RIGHT = 3        ///< Syllabes are right-aligned
} e_lyrics_alignments;


/** Lambda spacing modes for [bach.roll]
    @ingroup    notation
 */
typedef enum _custom_spacing_mode
{
    k_CUSTOMSPACING_NONE = 0,    ///< No custom spacing: default spacing is used
    k_CUSTOMSPACING_PIXELINWINDOW = 1,    ///< Pixels refer to the proper pixel position inside the window
    k_CUSTOMSPACING_PIXELFROMSTART = 2,    ///< Pixels are asked and retrieved "from the beginning of the score"
} e_custom_spacing_mode;



/** Window type for spectral rhythm analysis (used by [bach.rhythmogram])
    @ingroup    spectral
 */
typedef enum _win_types 
{
    k_WIN_RECTANGULAR = 0,    ///< Rectangular window
    k_WIN_TRIANGULAR = 1,    ///< Triangular window
    k_WIN_HAMMING = 2,        ///< Hamming window
    k_WIN_HANNING = 3,        ///< Hann or Hanning window
    k_WIN_COSINE = 4        ///< Cosine window
} e_win_types;


/** Shapes for the element contributions (e.g. a single amplitude is spread over more bins, according to one of these shapes)
    @ingroup    spectral
 */
typedef enum _shape_types 
{
    k_SHAPE_TRIANGULAR = 0,    ///< Triangular shape
    k_SHAPE_COSINE = 1,        ///< Cosine shape
    k_SHAPE_GAUSSIAN = 2,    ///< Gaussian shape
    k_SHAPE_HANNING = 3,    ///< Hanning shape
    k_SHAPE_PUNCTUAL = 4,    ///< Punctual shape (just the nearest bin is used, no spread)
} e_shape_types;


/** Slot types. 
    The <item> field of each slotitem (which is a void *) will need to be casted to different values depending on the slot type, in order to
    retrieve the correct slot item data. Those casting are explained here in the comments.
    @ingroup    slots
 */
typedef enum _slot_types {
    k_SLOT_TYPE_NONE = 0,        ///< Dummy empty slot.
    k_SLOT_TYPE_INT,            ///< Integer slot: containing a long number (name "int" is for compatibility with Max). Slot item content is of type (long *).
    k_SLOT_TYPE_FLOAT,            ///< Float slot: containing a double number (name "float" is for compatibility with Max). Slot item content is of type (double *).
    k_SLOT_TYPE_FUNCTION,        ///< Function slot: the content is a breakpoint function, whose segment have a slope as well. Slot item content is of type (t_pts *).
    k_SLOT_TYPE_INTLIST,        ///< Intlist slot: a list of long numbers. Slot item content is of type (long *).
    k_SLOT_TYPE_FLOATLIST,        ///< Floatlist slot: a list of double numbers. Slot item content is of type (double *).
    k_SLOT_TYPE_TEXT,            ///< Text slot. Slot item content is of type (char *).
    k_SLOT_TYPE_LLLL,            ///< llll slot: the content is a generic llll. Slot item content is of type (t_llll *).
    k_SLOT_TYPE_FILELIST,        ///< Filelist slot: a list of existing files (existing! For incorrect file path, the algorithm will look in the searchspace for a match, if no match is found, the item is kept but marked as absent). Slot item content is of type (t_file *). 
    k_SLOT_TYPE_SPAT,            ///< Spat slot: the content is a path between some spat-points, representing a point at a certain distance and angle from the listener. Slot item content is of type (t_spatpt *).
    k_SLOT_TYPE_TOGGLEMATRIX,    ///< Togglematrix slot:    the content is a matrix whose cells are just toggles (0/1 values). Slot item content is of type (t_llll *).
    k_SLOT_TYPE_INTMATRIX,        ///< Intmatrix slot: the content is a matrix whose cell values are integer. (Actually, a matrix is just a particular llll, but the matrix-type slots offer a handy interface for the slot window). Slot item content is of type (t_llll *).
    k_SLOT_TYPE_FLOATMATRIX,    ///< Floatmatrix slot: the content is a matrix whose cell values are double. Slot item content is of type (t_llll *).
    k_SLOT_TYPE_FILTER,            ///< Filter slot: the content is a biquad filter, handled via a filtergraph-like mechanism. Slot item content is of type (t_biquad *).
    k_SLOT_TYPE_DYNFILTER,        ///< Dynamic filter slot: the content is a series of biquad filters, which will be interpolated. Slot item content is of type (t_biquad *).
    k_SLOT_TYPE_COLOR,            ///< Slot containing a color as a #t_jrgba structure. Slot item content is of type (t_jrgba *).
    k_SLOT_TYPE_3DFUNCTION,        ///< Slot containing a breakpoint function assuming values in a 2d space (thus the graphic is a 3d graphic). Segments have a slope as well. Slot item content is of type (t_pts3d *).
    k_SLOT_TYPE_ARTICULATIONS,    ///< Articulation slot, containing a (t_articulation *) structure, in turns containing an ID of the #e_articulations
    k_SLOT_TYPE_NOTEHEAD,       ///< Notehead slot, containing (t_symbol *) value as one of the #e_notehead
    k_SLOT_TYPE_DYNAMICS,       ///< Dynamics slot, containing a (t_dynamics *) value
    k_NUM_SLOT_TYPES            ///< Number of slot types (NONE-type included).

} e_slot_types;


/** Slot temporal modes.
    @ingroup    slots
 */

typedef enum _slot_temporalmodes
{
    k_SLOT_TEMPORALMODE_NONE = 0,               ///< The slot is static (not temporal)
    k_SLOT_TEMPORALMODE_RELATIVE = 1,           ///< The slot is temporal, and the temporal position is a relative value between the domain start (= note beginning) and the domain end (note end)
    k_SLOT_TEMPORALMODE_MILLISECONDS = 2,       ///< The slot is temporal, and the temporal position is a ms position (0 being the note start)
    k_SLOT_TEMPORALMODE_TIMEPOINTS = 3,         ///< The slot is temporal, and the temporal position is a timepoint (not yet supported)
    k_NUM_SLOT_TEMPORALMODES                    ///< Number of slot temporal modes (NONE-type included).
} e_slot_temporalmodes;


/** Things to which a slot can be linked with.
    @ingroup    slots
 */
typedef enum _slot_linkages {
    k_SLOT_LINKAGE_NONE = 0,            ///< Slot isn't linked to any element
    k_SLOT_LINKAGE_LYRICS,                ///< Slot is linked to lyrics content
    k_SLOT_LINKAGE_NOTE_COLOR,            ///< Slot is linked to the note color
    k_SLOT_LINKAGE_NOTEHEAD_ADJUST,     ///< Slot is linked to the notehead adjustments
    k_SLOT_LINKAGE_NOTEHEAD_FONT,        ///< Slot is linked to the notehead font
    k_SLOT_LINKAGE_NOTEHEAD,        ///< Slot is linked to the notehead character, which might also include other specification
                                        ///< if the slot is of type "notehead".
                                        ///< This is the preferred way of defining noteheads.
    k_SLOT_LINKAGE_NOTE_SIZE,            ///< Slot is linked to the note resizing percentage
    k_SLOT_LINKAGE_ARTICULATIONS,        ///< Slot is linked to the articulation(s)
    k_SLOT_LINKAGE_ANNOTATION,          ///< Slot is linked to textual annotation
    k_SLOT_LINKAGE_DYNAMICS,            ///< Slot is linked to dynamics
    k_SLOT_LINKAGE_DURATIONLINE_COLOR,  ///< Slot is linked to the color of the duration line
    k_NUM_SLOT_LINKAGES                 ///< Number of slot linkages (NONE-type included).
} e_slot_linkages;



/** Spat-points interpolation. The interpolation between two spat points can be either circular or linear,
    corresponding to sound travelling circularly around listener, or linearly from one point to another
    @ingroup    slot   
 */
typedef enum _spat_interpolation {
    k_SPAT_INTERPOLATION_ARC = 0,            ///< Circular interpolation
    k_SPAT_INTERPOLATION_SEGMENT = 1,        ///< Linear interpolation
} e_spat_interpolation;


/** Filter types (for slots of type #k_SLOT_TYPE_FILTER)
    @ingroup    filters
 */
typedef enum _filter_types
{
    k_FILTER_NONE = -1,        ///< No filter defined yet
    k_FILTER_DISPLAY = 0,    ///< Just display the content (not interactive)
    k_FILTER_LOWPASS = 1,    ///< Low-pass filter
    k_FILTER_HIGHPASS = 2,    ///< High-pass filter
    k_FILTER_BANDPASS = 3,    ///< Band-pass filter
    k_FILTER_BANDSTOP = 4,    ///< Band-stop filter
    k_FILTER_PEAKNOTCH = 5,    ///< Peak-notch filter
    k_FILTER_LOWSHELF = 6,    ///< Low-shelf filter
    k_FILTER_HIGHSHELF = 7,    ///< High-shelf filter
    k_FILTER_RESONANT = 8,    ///< Resonant filter
    k_FILTER_ALLPASS = 9    ///< All-pass filter
} e_filter_types;


/** Things to which the markers can be attached. This only makes sense in [bach.score], since in [bach.roll]
    markers can only be attached to milliseconds position.
    @ingroup    markers
 */
typedef enum _marker_attach {
    k_MARKER_ATTACH_TO_MS = 0,    ///< Attach the marker to the position in milliseconds 
    k_MARKER_ATTACH_TO_MEASURE,    ///< Attach the marker to a given measure
} e_marker_attach;


/** Role of markers: roles the marker can have in [bach.roll], representing additional tempo or time signature information.
    To understand the tempo or time signature content of the marker, one always has to parse it name.
    @ingroup    markers
 */
typedef enum _marker_roles
{
    k_MARKER_ROLE_NONE = 0,                ///< Marker has no particular additional meaning (default)
    k_MARKER_ROLE_TEMPO = 1,            ///< Marker contains tempo information
    k_MARKER_ROLE_TIME_SIGNATURE = 2,    ///< Marker contains time signature information
    k_MARKER_ROLE_MEASURE_BARLINE = 3,    ///< Marker represents a barline
    k_MARKER_ROLE_MEASURE_DIVISION = 4,    ///< Marker represents a division point inside a measure
    k_MARKER_ROLE_MEASURE_SUBDIVISION = 5,    ///< Marker represents a subdivision point inside a measure
} e_marker_roles;



/** Rhythmic trees handling mode: what do we do when the user defines a rhythmic tree? 
    @ingroup    rhythmic_trees
 */
typedef enum _rhythmic_tree_modes
{
    k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED = 0,                ///< Take the given tree for granted, don't touch it.
    k_RHYTHMIC_TREE_HANDLING_REFINE_ONLY_GRAPHICALLY = 1,        ///< As the followind #k_RHYTHMIC_TREE_HANDLING_REFINE, but the created lists are only used graphically, and the tree content remains untouched
    k_RHYTHMIC_TREE_HANDLING_REFINE = 2,                        ///< Use the given tree as a starting point, and refine it, but only in depth.
                                                                ///< This means that any level added is created by putting (...) around SIMPLE ELEMENTS,
                                                                ///< and there has to be NO llll in the added brackets. For instance, from (a b (c d) e) we can
                                                                ///< obtain ((a b) (c d) e) but NOT (a (b (c d) e)).
    k_RHYTHMIC_TREE_HANDLING_PROCESS = 3,                        ///< Use the given tree as a starting point, and modify also the existing levels, if a better solution can be found.
    k_RHYTHMIC_TREE_HANDLING_IGNORE = 4,                        ///< Completely ignore the given tree, and rebuild it automatically, starting from the time signature.
} e_rhythmic_tree_modes;


/** Types of levels in the rhythmic tree. This is supposed to be private.
    @ingroup    rhythmic_trees
 */
typedef enum _rhythm_level_types
{
    k_RHYTHM_LEVEL_ORIGINAL = 1,        ///< Rhythmic level was user defined.
    k_RHYTHM_LEVEL_ADDED = 2,            ///< Rhythmic level has been added after refinement.
    k_RHYTHM_LEVEL_DISPLAY_ONLY = 4,    ///< Rhythmic level has been added, but will only be graphical (not taken into account in the beaming tree).
    k_RHYTHM_LEVEL_TS_BOX = 8,            ///< Rhythmic level is directly linked with the time signature standard boxing (e.g. in 4/4 boxes of (1/4 1/4 1/4 1/4)).
    k_RHYTHM_LEVEL_TUPLET = 16,            ///< Rhythmic level is a tuplet level.
    k_RHYTHM_LEVEL_GRACE = 32,            ///< Rhythmic level is for a grace figuration (as a grace chord or a grace chord sequence).
    k_RHYTHM_LEVEL_IGNORE = 64,            ///< Rhythmic level need to be reverted to an automatic tree (this happens when one chooses to automatically rebuild a part of the tree).
    k_RHYTHM_LEVEL_KEEP = 128,            ///< Rhythmic level need to be kept, even if it is son (or grand-son) of a level of type #k_RHYTHM_LEVEL_IGNORE.
                                        ///< Levels #k_RHYTHM_LEVEL_IGNORE and #k_RHYTHM_LEVEL_KEEP are used to handle the re-construction of beamings when asked by the user
    k_RHYTHM_LEVEL_FORCE_TUPLET = 256    ///< Rhythmic level tuplet ratio need to be preserved. Tuplet level is NOT ONLY kept (as #k_RHYTHM_LEVEL_KEEP does)
                                        ///< but its tuplet ratio is also taken for granted. This is used while speedy editing, for tuplet insertion, and removed when speedy
                                        ///< editing has ended. Be sure to have the correctly filled <tupletinfo> fields in the #t_beaming_properties structure!
} e_rhythm_level_types;


/** Behavior of rests with respect to beaming lines
    @ingroup    rhythmic_trees
 */
typedef enum _rests_within_beam_handling
{
    k_REST_IN_BEAM_NEVER = 0,                    ///< Never allow rests inside a beaming (force unbeam)
    k_REST_IN_BEAM_IF_INTERNAL = 1,                ///< Allow rests inside a beaming if they're not at the beginning or at the end of the main beaming
    k_REST_IN_BEAM_ALWAYS = 2,                    ///< Always allow rests inside a beaming, even if they're at the beginning or at the end
} e_rests_within_beam_handling;


/** Extend beams over rests modes. (If one doesn't want to extend beams over rests, one should use #k_REST_IN_BEAM_NEVER)
    @ingroup    rhythmic_trees
 */
typedef enum _beams_over_rests
{
    k_EXTEND_BEAMS_OVER_RESTS_FIRST_BEAM_ONLY = 0,        ///< Extend over rests only one beaming (the first one, the 1/8 beaming)
    k_EXTEND_BEAMS_OVER_RESTS_TILL_REST_BEAM_VALUE = 1,    ///< Extend over rests only up to the beaming used if the rests were a note. 
                                                        ///< Thus for a 1/32 rest, we can extend up to 3 beamings, for a 1/16 rest up to 2, and so on
    k_EXTEND_BEAMS_OVER_RESTS_ALWAYS = 2,                ///< Extend over rests all the beamings that you can!
} e_beams_over_rests;


/** Way of correspondence between the rhythmic tree and the beams
    @ingroup    notation
 */
typedef enum _tree_to_beams_correspondences
{
    k_TREE2BEAM_BREAK_BEAMS_AROUND_LEVELS = 0,    ///< Different levels have different beamings, and that's all. Which means, that if you have a lot of levels (or tuplets)
                                                ///< you might quickly end up with having a lot of unbeamed stuff. For instance ((1/12 1/12 1/12) 1/8) won't be globally beamed
                                                ///< since the inner beaming is of depth 1, which forces the outer beaming to have depth 0.
    k_TREE2BEAM_BREAK_BEAMS_AROUND_TUPLETS = 1,    ///< Different levels have different beamings, but only for Tuplet levels. 
                                                ///< For instance something like ((1/12 1/12 1/12) 1/8) can NOT be beamed with a single beam:
                                                ///< but anything like ((1/8 1/8) 1/8) will be still beamed on a single beam
    k_TREE2BEAM_LEVELS_CAN_SHARE_BEAMS = 2,        ///< Different levels can share beams (also tuplets). For instance something like ((1/12 1/12 1/12) 1/8) can be beamed with a single beam:
                                                ///< even if the inner beaming is of depth 1, the outer beaming can have the same beam depth.
} e_tree_to_beams_correspondences;


/** Parameters to force the process_rhythmic_tree() function to avoid some steps of the calculations.
    Please consider that these steps will be performed only if the notation object tree handling fields will admit them. This is, indeed, an additional
    mechanism to prevent the function recomputing some things in some particular occasions.
    @ingroup    rhythmic_trees
 */
typedef enum _beaming_calculation_flags
{
    k_BEAMING_CALCULATION_DO = 0,            ///< Performs the function completely, taking everything into account @ingroup rhythmic_trees
    k_BEAMING_CALCULATION_DONT_DELETE_LEVELS = 1,    ///< Forces the function to leave all levels untouched
    k_BEAMING_CALCULATION_DONT_ADD_LEVELS = 2,        ///< Forces the function to leave all levels untouched
    k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS = 4,    ///< Forces the function to leave all chords untouched (but can add levels)
    k_BEAMING_CALCULATION_DONT_CHANGE_TIES = 8,        ///< Forces the function not to retranscribe all-tied sequences or sequences of consecutive rests
    k_BEAMING_CALCULATION_DONT_AUTOCOMPLETE = 16,    ///< Forces the function never to autocomplete measures
    k_BEAMING_CALCULATION_DO_AND_OVERFLOW_TO_NEXT = 32,    ///< Forces the autocompletion check to flow notes to next measures if needed
    k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS = k_BEAMING_CALCULATION_DONT_ADD_LEVELS + k_BEAMING_CALCULATION_DONT_DELETE_LEVELS,    ///< Forces the function not to create any other level and not to delete any existing level. Also forces to assume that level is tuplet if and only if it's marked as tuplet level.
    k_BEAMING_CALCULATION_DONT_CHANGE_ANYTHING    = k_BEAMING_CALCULATION_DONT_CHANGE_LEVELS + k_BEAMING_CALCULATION_DONT_CHANGE_CHORDS + k_BEAMING_CALCULATION_DONT_CHANGE_TIES + k_BEAMING_CALCULATION_DONT_AUTOCOMPLETE,    ///< Forces the function to leave everything untouched @ingroup rhythmic_trees
} e_beaming_calculation_flags;



/** Way of calculating the spacing for a tuttipoint region
    @ingroup    notation
 */
typedef enum _spacing_calculation_types
{
    k_SPACING_DONT_RECALCULATE = 0,    ///< Don't calculate the spacing
    k_SPACING_REFINE_ONLY = 1,        ///< Calculate the spacing, but only by refining the existing one (new notes will find their place in the interpolation of the existing ones
    k_SPACING_RECALCULATE = 2,        ///< Completely recalculate the spacing
} e_spacing_calculation_types;


/** Different ways to handle the different needed information to be consider while dealing with data.
    These are various answers to the question: what are we considering these data for?
    @ingroup    notation
 */
typedef enum _data_considering_types
{
    k_CONSIDER_ALL_NOTES = -1,                                    ///< The retrieved llll will contain all the notes in gathered syntax
    k_CONSIDER_FOR_DUMPING = 0,                                    ///< The retrieved llll is needed for information dumping (gathered or separate syntax). 
                                                                ///< (Actually we've used in the code k_CONSIDER_FOR_DUMPING and k_CONSIDER_ALL_NOTES alternatively,
                                                                ///< They MIGHT be equivalent, but we are NOT sure AT ALL, so you better check the one you need).
    k_CONSIDER_FOR_PLAYING = 1,                                    ///< The retrieved llll will contain only the non-muted notes (used for playing)
    k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE = 2,                    ///< The retrieved llll will contain only a partial content of a non-muted note.
                                                                ///< This means that all the note parameters are output
                                                                ///< correctly trimmed, depending on the position of the playhead start line: if a note
                                                                ///< has this line at the middle of its duration line, only the right part will be output 
                                                                ///< (a partial note, indeed, used to handle partial note play) 
    k_CONSIDER_FOR_SELECTION_COPYING = 3,                ///< The retrieved llll wil contain only the non-muted notes, but only if they are selected.
                                                                ///< (This is used by playselection() function)
    k_CONSIDER_FOR_COLLAPSING_AS_NOTE_BEGINNING = -4,            ///< The note has been collapsed (only for [bach.score]), and this is the note beginning part
    k_CONSIDER_FOR_COLLAPSING_AS_NOTE_MIDDLE = -5,                ///< The note has been collapsed (only for [bach.score]), and this is the note middle part
    k_CONSIDER_FOR_COLLAPSING_AS_NOTE_END = -6,                    ///< The note has been collapsed (only for [bach.score]), and this is the note ending part
    k_CONSIDER_FOR_SAVING = 5,                                    ///< The retrieved llll will be saved somewhere or written.
    k_CONSIDER_FOR_UNDO = 6,                                    ///< The retrieved llll will contain undo data, then all IDs have to be saved.
    k_CONSIDER_FOR_EVALUATION = 7,                                ///< The retrieved llll is needed because some notation item has been evaluated (selecteed and pressed "V")
    k_CONSIDER_FOR_EXPORT_OM = 8,                                ///< The retrieved llll will be exported to OpenMusic (equivalent to #k_CONSIDER_FOR_SAVING, except that it has no voice flag specification, for backward compatibility with OM 6.5) 
    k_CONSIDER_FOR_EXPORT_PWGL = 9,                                ///< The retrieved llll will be exported to PWGL
    k_CONSIDER_FOR_SCORE2ROLL = 10,                                ///< The retrieved llll will contain data which comes from a bach.score and goes into a bach.roll.
    k_CONSIDER_FOR_PLAYING_AND_ALLOW_PARTIAL_LOOPED_NOTES = 11,    ///< The retrieved llll will contain only the non-muted notes, and notes can be dumped partially due
                                                                ///< to the fact that they might be partially overlapping on the loop region boundaries
    k_CONSIDER_FOR_SUBDUMPING = 12,                                ///< The retrieved llll is needed for information dumping (gathered or separate syntax), but only of a 
                                                                ///< portion of the current score (as in roll's "subroll" message or score "subscore" message).
    k_CONSIDER_FOR_SAMPLING = 13,                                ///< The retrieved llll will contain data about a given sampled position in the score.
    k_CONSIDER_FOR_DUMPING_ONLY_TIE_SPANNING = 14,                ///< As #k_CONSIDER_FOR_DUMPING, but only the slots whose attribute "singleslotfortiednotes" is set to 1 are output.
    k_CONSIDER_FOR_SAVING_WITH_BW_COMPATIBILITY = 15,            ///< ALMOST PRIVATE: this will be used in rare occasions where bugs in the loading
                                                                ///< mechanisms were spotted, rendering impossible to open new patches with old versions of bach.
    k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE_VERBOSE = 16,        ///< Verbosely output the partial note
    k_CONSIDER_FOR_SLOT_VALUES_ONLY = 17,                       ///< Only dump slot values and not slot names (only for single slot dump)
    k_CONSIDER_FOR_SLOT_LLLL_EDITOR = 18,                       ///< The retrieved llll will be displayed in a slot textual editor
} e_data_considering_types;


/** Different ways to handle the purpose for which a notation item (usually a note or a chord) is cloned.
    @ingroup    notation
 */
typedef enum _clone_for_types
{
    k_CLONE_FOR_ORIGINAL = 0,   ///< Clone item, but only to replace the original one with it
    k_CLONE_FOR_NEW,            ///< Clone item, to create an independent new item
    k_CLONE_FOR_SAME_CHORD,     ///< Clone item, to create a new note in the same chord
    k_CLONE_FOR_SPLIT,          ///< Clone item, as the non-first split element of a split elements series
} e_clone_for_types;



/** Actions to perform when something has changed, given as argument for handle_change() or handle_change_if_there_are_free_undo_ticks().
    See also the convenience combinations #k_CHANGED_DO_NOTHING, #k_CHANGED_STANDARD_SEND_BANG, #k_CHANGED_STANDARD_UNDO_MARKER and #k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG.
    @ingroup    interface
 */
typedef enum _actions_upon_change
{
    k_CHANGED_DO_NOTHING = 0,                        ///< Don't do anything
    k_CHANGED_CREATE_UNDO_STEP = 1,                    ///< (OBSOLETE!) Create old-style an undo step. 
                                                    ///< This is no more supported for [bach.roll] & [bach.score], since bach 0.7 there's a new undo system. See the Undo module for more information.
    k_CHANGED_SEND_BANG = 2,                        ///< Send a bang through the "changed" outlet
    k_CHANGED_REDRAW_STATIC_LAYER = 4,                ///< Redraw the static layer
    k_CHANGED_CHECK_CORRECT_SCHEDULING = 8,            ///< Check the correct play scheduling
    k_CHANGED_SEND_AUTOMESSAGE = 16,                ///< Send the object's automessage if any
    k_CHANGED_CREATE_UNDO_STEP_MARKER = 32,            ///< Create a new marker for an undo step, with the label which is passed as argument.
                                                    ///< An undo step markers ends a sequence of undo ticks, which have been placed previously by all the interface actions.
    k_CHANGED_PERFORM_ANALYSIS_AND_CHANGE = 64,        ///< Only used by score: means that score also have to call the #perform_analysis_and_change() routine explicitely

    // convenience combinations
    k_CHANGED_STANDARD = k_CHANGED_REDRAW_STATIC_LAYER + k_CHANGED_CHECK_CORRECT_SCHEDULING + k_CHANGED_SEND_AUTOMESSAGE, // Redraw static layer, check correct play scheduling and send the automessage
    k_CHANGED_STANDARD_SEND_BANG = k_CHANGED_REDRAW_STATIC_LAYER + k_CHANGED_CHECK_CORRECT_SCHEDULING + k_CHANGED_SEND_AUTOMESSAGE + k_CHANGED_SEND_BANG,    ///< Redraw static layer, check correct play scheduling, send the automessage and the changed bang
    k_CHANGED_STANDARD_UNDO_MARKER = k_CHANGED_REDRAW_STATIC_LAYER + k_CHANGED_CREATE_UNDO_STEP_MARKER + k_CHANGED_CHECK_CORRECT_SCHEDULING + k_CHANGED_SEND_AUTOMESSAGE,        ///< Redraw static layer, create undo marker step, check correct play scheduling and send the automessage 
    k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG = k_CHANGED_REDRAW_STATIC_LAYER + k_CHANGED_CREATE_UNDO_STEP_MARKER + k_CHANGED_CHECK_CORRECT_SCHEDULING + k_CHANGED_SEND_AUTOMESSAGE + k_CHANGED_SEND_BANG,        ///< Redraw static layer, create undo marker step, check correct play scheduling, send the automessage and send the bang
} e_actions_upon_change;



/** Operations that can be undone (the names are self-explainatory).
    @ingroup    undo
 */
typedef enum _undo_operations
{
    k_UNDO_OP_UNKNOWN = 0,        
    k_UNDO_OP_CHANGE_SCORE,
    k_UNDO_OP_CHANGE_ROLL,
    k_UNDO_OP_CHANGE_CHORD,
    k_UNDO_OP_ADD_CHORD,
    k_UNDO_OP_DELETE_CHORD,
    k_UNDO_OP_CHANGE_MEASURE,
    k_UNDO_OP_ADD_MEASURE,
    k_UNDO_OP_APPEND_MEASURE,
    k_UNDO_OP_APPEND_MEASURES,
    k_UNDO_OP_INSERT_MEASURE,
    k_UNDO_OP_INSERT_MEASURES,
    k_UNDO_OP_DELETE_MEASURE,
    k_UNDO_OP_CHANGE_VOICE,
    k_UNDO_OP_ADD_VOICE,
    k_UNDO_OP_DELETE_VOICE,
    k_UNDO_OP_INSERT_VOICE,
    k_UNDO_OP_MOVE_VOICE,
    k_UNDO_OP_CHANGE_HEADER,
    k_UNDO_OP_CHANGE_CLEFS,
    k_UNDO_OP_CHANGE_KEYS,
    k_UNDO_OP_CHANGE_MARKERS,
    k_UNDO_OP_CHANGE_SLOTINFO,
    k_UNDO_OP_CHANGE_COMMANDS,
    k_UNDO_OP_CHANGE_MIDICHANNELS,
    k_UNDO_OP_CHANGE_VOICENAMES,
    k_UNDO_OP_CHANGE_GROUPS,
    k_UNDO_OP_CHANGE_STAFFLINES,
    k_UNDO_OP_CHANGE_CUSTOM_ARTICULATIONS_DEFINITION,
    k_UNDO_OP_CHANGE_CUSTOM_NOTEHEADS_DEFINITION,
    k_UNDO_OP_CHANGE_PARTS,
    k_UNDO_OP_CHANGE_LOOP,
    k_UNDO_OP_MULTIPLE_CHANGES,
    k_UNDO_OP_CHANGE_CHORDS,
    k_UNDO_OP_ADD_CHORDS,
    k_UNDO_OP_DELETE_CHORDS,
    k_UNDO_OP_CHANGE_MEASURES,
    k_UNDO_OP_ADD_MEASURES,
    k_UNDO_OP_DELETE_MEASURES,
    k_UNDO_OP_CHANGE_VOICES,
    k_UNDO_OP_ADD_VOICES,
    k_UNDO_OP_DELETE_VOICES,
    k_UNDO_OP_READ_SCORE,
    k_UNDO_OP_IMPORT_MIDI_SCORE,
    k_UNDO_OP_IMPORT_XML_SCORE,
    k_UNDO_OP_READ_ROLL,
    k_UNDO_OP_IMPORT_MIDI_ROLL,
    k_UNDO_OP_READ_UISLOT,
    k_UNDO_OP_CLEAR_SCORE,
    k_UNDO_OP_CLEAR_ROLL,
    k_UNDO_OP_CLEAR_UISLOT,
    k_UNDO_OP_REBUILD_SCORE,
    k_UNDO_OP_REBUILD_ROLL,
    k_UNDO_OP_POP_OUT_TEMPO,
    k_UNDO_OP_ADD_TEMPO,
    k_UNDO_OP_DELETE_SELECTION,
    k_UNDO_OP_DELETE_SELECTED_MEASURES,
    k_UNDO_OP_RIPPLE_DELETE_SELECTION,
    k_UNDO_OP_CHANGE_SLOT,
    k_UNDO_OP_FIX_DYNAMICS,
    k_UNDO_OP_ASSIGN_DYNAMICS,
    k_UNDO_OP_ASSIGN_VELOCITIES,
    k_UNDO_OP_CLEAR_MARKERS,
    k_UNDO_OP_SNAP_PITCH_TO_GRID_FOR_SELECTION,
    k_UNDO_OP_SNAP_ONSET_TO_GRID_FOR_SELECTION,
    k_UNDO_OP_SNAP_TAIL_TO_GRID_FOR_SELECTION,
    k_UNDO_OP_RESET_ALL_ENHARMONICITIES,
    k_UNDO_OP_RESET_ENHARMONICITY_FOR_SELECTION,
    k_UNDO_OP_RESPELL,
    k_UNDO_OP_CHANGE_ONSET_FOR_SELECTION,
    k_UNDO_OP_CHANGE_DURATION_FOR_SELECTION,
    k_UNDO_OP_CHANGE_TAIL_FOR_SELECTION,
    k_UNDO_OP_CHANGE_CENTS_FOR_SELECTION,
    k_UNDO_OP_CHANGE_PITCH_FOR_SELECTION,
    k_UNDO_OP_CHANGE_POC_FOR_SELECTION,
    k_UNDO_OP_CHANGE_MEASUREINFO_FOR_SELECTION,
    k_UNDO_OP_CHANGE_VOICE_FOR_SELECTION,
    k_UNDO_OP_CHANGE_VELOCITY_FOR_SELECTION,
    k_UNDO_OP_CHANGE_TIE_FOR_SELECTION,
    k_UNDO_OP_CHANGE_IOI_FOR_SELECTION,
    k_UNDO_OP_ADD_BREAKPOINTS_TO_SELECTION,
    k_UNDO_OP_ERASE_BREAKPOINTS_FOR_SELECTION,
    k_UNDO_OP_SET_SLOTS_TO_SELECTION,
    k_UNDO_OP_ERASE_SLOTS_FOR_SELECTION,
    k_UNDO_OP_MOVE_SLOTS_FOR_SELECTION,
    k_UNDO_OP_COPY_SLOTS_FOR_SELECTION,
    k_UNDO_OP_CHANGE_SLOTS_FOR_SELECTION,
    k_UNDO_OP_REDUCE_FUNCTION,
    k_UNDO_OP_ADD_MARKER,
    k_UNDO_OP_DELETE_MARKER,
    k_UNDO_OP_CHANGE_MARKER_NAME,
    k_UNDO_OP_CHANGE_MARKER_ATTACHMENT,
    k_UNDO_OP_GLUE_CHORD,
    k_UNDO_OP_MERGE,
    k_UNDO_OP_OVERTYPE,
    k_UNDO_OP_ALIGN_SELECTION,
    k_UNDO_OP_EQUALLY_RESPACE_SELECTION,
    k_UNDO_OP_LEGATO_FOR_SELECTION,
    k_UNDO_OP_GLISSANDO_FOR_SELECTION,
    k_UNDO_OP_FORCE_POLYPHONY_FOR_SELECTION,
    k_UNDO_OP_DELETE_NOTE,
    k_UNDO_OP_ADD_NOTE,
    k_UNDO_OP_CHANGE_NOTE,
    k_UNDO_OP_DELETE_PITCH_BREAKPOINT,
    k_UNDO_OP_ADD_PITCH_BREAKPOINT,
    k_UNDO_OP_CHANGE_PITCH_BREAKPOINT,
    k_UNDO_OP_CHANGE_PITCH,
    k_UNDO_OP_MOUSEDRAG_CHANGE,
    k_UNDO_OP_CHANGE_VOICE_NAME,
    k_UNDO_OP_CHANGE_LYRICS,
    k_UNDO_OP_CHANGE_DYNAMICS,
    k_UNDO_OP_TRIM_END,
    k_UNDO_OP_TRIM_START,
    k_UNDO_OP_CHANGE_NAMES,
    k_UNDO_OP_CLEAR_NAMES,
    k_UNDO_OP_NAMES_FROM_SLOT,
    k_UNDO_OP_NAMES_TO_SLOT,
    k_UNDO_OP_DURATION_LINE_TO_SLOT,
    k_UNDO_OP_SLOT_TO_DURATION_LINE,
    k_UNDO_OP_CHANGE_ROLES,
    k_UNDO_OP_RESET_TAIL_SLOPE,
    k_UNDO_OP_DELETE_PITCH_BREAKPOINTS_IN_SELECTION,
    k_UNDO_OP_RESET_PITCH_BREAKPOINTS_SLOPE_FOR_SELECTION,
    k_UNDO_OP_CHANGE_DURATION_LINES_FOR_SELECTION,
    k_UNDO_OP_SHIFT_PITCH_UP_FOR_SELECTION,
    k_UNDO_OP_SHIFT_PITCH_DOWN_FOR_SELECTION,
    k_UNDO_OP_LOCK_UNLOCK_SELECTION,
    k_UNDO_OP_MUTE_UNMUTE_SELECTION,
    k_UNDO_OP_SOLO_UNSOLO_SELECTION,
    k_UNDO_OP_DELETE_GROUP, 
    k_UNDO_OP_CREATE_GROUP,
    k_UNDO_OP_PASTE_SLOT_CONTENT,
    k_UNDO_OP_PASTE_DURATION_LINE,
    k_UNDO_OP_PASTE,
    k_UNDO_OP_CUT_SLOT_CONTENT,
    k_UNDO_OP_CUT_DURATION_LINE,
    k_UNDO_OP_CUT,
    k_UNDO_OP_DELETE_SLOT_CONTENT,
    k_UNDO_OP_DELETE_ARTICULATIONS_FOR_SELECTION,
    k_UNDO_OP_RESET_LOCAL_SPACING_FOR_SELECTION,
    k_UNDO_OP_RESET_LOCAL_SPACING,
    k_UNDO_OP_SET_MEASURE_PARAMETERS,
    k_UNDO_OP_CEIL_MEASURES,
    k_UNDO_OP_AUTO_RHYTHMIC_TREE_KEEPING_EXISTING_TUPLETS,
    k_UNDO_OP_STICK_RHYTHMIC_TREE,
    k_UNDO_OP_DESTROY_RHYTHMIC_TREE,
    k_UNDO_OP_ADD_RHYTHMIC_TREE_LEVEL,
    k_UNDO_OP_DESTROY_RHYTHMIC_TREE_LEVEL,
    k_UNDO_OP_AUTO_RHYTHMIC_TREE_IGNORING_EXISTING_TUPLETS,
    k_UNDO_OP_TURN_REST_INTO_NOTE,
    k_UNDO_OP_DELETE_ARTICULTATION,
    k_UNDO_OP_DELETE_TEMPO,
    k_UNDO_OP_LINEAR_EDIT_CHANGE_PITCH,
    k_UNDO_OP_LINEAR_EDIT_TOGGLE_REST,
    k_UNDO_OP_LINEAR_EDIT_TOGGLE_TIES,
    k_UNDO_OP_LINEAR_EDIT_ADD_SHARP,
    k_UNDO_OP_LINEAR_EDIT_ADD_FLAT,
    k_UNDO_OP_LINEAR_EDIT_TOGGLE_GRACE,
    k_UNDO_OP_LINEAR_EDIT_ADD_NOTE,
    k_UNDO_OP_LINEAR_EDIT_DELETE_NOTE,
    k_UNDO_OP_LINEAR_EDIT_DELETE_CHORD,
    k_UNDO_OP_LINEAR_EDIT_SPLIT_CHORD,
    k_UNDO_OP_LINEAR_EDIT_ADD_DOT,
    k_UNDO_OP_LINEAR_EDIT_CHANGE_CHORD_DURATION,
    k_UNDO_OP_LINEAR_EDIT_ADD_CHORD,
    k_UNDO_OP_LINEAR_EDIT_ADD_NEW_MEASURE,
    k_UNDO_OP_LINEAR_EDIT_CLEAR_MEASURE,
    k_UNDO_OP_DELETE_MEASURES_IN_SELECTION,
    k_UNDO_OP_CLEAR_MEASURES_IN_SELECTION,
    k_UNDO_OP_DUPLICATE_SELECTED_MEASURES,
    k_UNDO_OP_DELETE_SELECTED_TEMPI,
    k_UNDO_OP_TOGGLE_INTERPOLATION_FOR_SELECTED_TEMPI,
    k_UNDO_OP_DELETE_SLURS_FOR_SELECTION,
    k_UNDO_OP_ADD_ARTICULATION_TO_SELECTION,
    k_UNDO_OP_CHANGE_ARTICULATION,
    k_UNDO_OP_TURN_SELECTION_INTO_RESTS,
    k_UNDO_OP_JOIN_SELECTION,
    k_UNDO_OP_DELETE_GRACE,
    k_UNDO_OP_MERGE_GRACE,
    k_UNDO_OP_AUTO_BEAM,
    k_UNDO_OP_AUTO_RHYTHMIC_TREE_KEEPING_EXISTING_TUPLETS_FOR_SELECTION,
    k_UNDO_OP_AUTO_RHYTHMIC_TREE_IGNORING_EXISTING_TUPLETS_FOR_SELECTION,
    k_UNDO_OP_DESTROY_RHYTHMIC_TREE_LEVEL_FOR_SELECTION,
    k_UNDO_OP_STICK_RHYTHMIC_TREE_FOR_SELECTION,
    k_UNDO_OP_DESTROY_RHYTHMIC_TREE_FOR_SELECTION,
    k_UNDO_OP_ADD_RHYTHMIC_TREE_LEVELS_FROM_SELECTION,
    k_UNDO_OP_LOCK_UNLOCK_RHYTHMIC_TREES_FOR_SELECTION,
    k_UNDO_OP_TIE_UNTIE_SELECTION,
    k_UNDO_OP_SPLIT_SELECTION,
    k_UNDO_OP_PASTE_MEASURES,
    k_UNDO_OP_CUT_MEASURES,
    k_UNDO_OP_FIX_UNFIX_MEASURE_WIDTH_FOR_SELECTION,
    k_UNDO_OP_CHANGE_SLOTS_FROM_MESSAGE,
    
    k_UNDO_OP_LOCK_SELECTION,
    k_UNDO_OP_UNLOCK_SELECTION,
    k_UNDO_OP_MUTE_SELECTION,
    k_UNDO_OP_UNMUTE_SELECTION,
    k_UNDO_OP_SOLO_SELECTION,
    k_UNDO_OP_UNSOLO_SELECTION,
    k_UNDO_OP_NO_SOLOS,
    k_UNDO_OP_NO_MUTES,
    k_UNDO_OP_ENHARMONICALLY_RESPELL_NOTE,
    k_UNDO_OP_CHANGE_BARLINE_TYPE,
    k_UNDO_OP_CHANGE_TIME_SIGNATURE_FOR_SELECTED_MEASURES,
    k_UNDO_OP_LOCK_RHYTHMIC_TREE_FOR_SELECTION,
    k_UNDO_OP_UNLOCK_RHYTHMIC_TREE_FOR_SELECTION,

    k_UNDO_OP_CREATE_VOICE_ENSEMBLE,
    k_UNDO_OP_BREAK_VOICE_ENSEMBLE,

    k_UNDO_OP_CLEAR_ARTICULATIONS,
    k_UNDO_OP_CLEAR_NOTES,
    k_UNDO_OP_CLEAR_TEMPI,
    k_UNDO_OP_CLEAR_BREAKPOINTS,
    k_UNDO_OP_CHANGE_BACH_ATTRIBUTE,
    k_UNDO_OP_SLICE,
    k_UNDO_OP_AUTOSPELL,
    k_UNDO_OP_TAILS_TO_GRACES
} e_undo_operations;


/** Undo or redo operations.
    @ingroup undo
*/
typedef enum _undo_redo
{
    k_UNDO = -1,        ///< Undo operation
    k_REDO = 1            ///< Redo operation
} e_undo_redo;


/** Types of score modifications (used for undoing).
    @ingroup    undo
 */
typedef enum _undo_modification_types
{
    k_UNDO_MODIFICATION_NONE = 0,                    ///< No modification (thus nothing to undo)
    k_UNDO_MODIFICATION_CHANGE = 1,                    ///< Change the parameters of the notation item
    k_UNDO_MODIFICATION_DELETE = 2,                    ///< Erase the notation item
    k_UNDO_MODIFICATION_ADD = 3,                    ///< Add the notation item
    k_UNDO_MODIFICATION_CHANGE_FLAG = 4,            ///< Only change the notation item's solo/lock/mute flags
    k_UNDO_MODIFICATION_CHANGE_CHECK_ORDER = 5,        ///< Change the parameters of the notation item, and also check the order of the notation item within its parent
    k_UNDO_MODIFICATION_CHANGE_NAME = 6,            ///< Only change the element's name
} e_undo_modification_types;


/** Types of slot access type.
    @ingroup    slots
 */
typedef enum _slot_access_types
{
    k_SLOT_ACCESS_READANDWRITE = 0,    ///< Slot content can also be modified
    k_SLOT_ACCESS_READONLY = 1,        ///< Slot content can only be seen in slot window, can't be modified from the interface
    k_SLOT_ACCESS_CANT = 2,         ///< Slot window and slot content are not accessible
} e_slot_access_types;


/** Used by notation_item_change_slotitem()
    @ingroup    slots
 */
typedef enum _slot_changeslotitem_modes
{
    k_CHANGESLOTITEM_MODE_MODIFY_ONE = 0,    ///< Modify a single item
    k_CHANGESLOTITEM_MODE_MODIFY_ALL = 1,    ///< Modify all items
    k_CHANGESLOTITEM_MODE_INSERT = 2,       ///< Insert an item at a given position
    k_CHANGESLOTITEM_MODE_INSERT_AUTO = 3,       ///< Insert an item and automatically find the right position if needed (e.g. for function points)
    k_CHANGESLOTITEM_MODE_APPEND = 4,       ///< Append an item
    k_CHANGESLOTITEM_MODE_PREPEND = 5,      ///< Prepend an item
    k_CHANGESLOTITEM_MODE_DELETE_ONE = 6,       ///< Delete an item
    k_CHANGESLOTITEM_MODE_DELETE_ALL = 7,    ///< Delete all items
} e_slot_changeslotitem_modes;


/** Play modes.
    @ingroup    sequencing
 */
typedef enum _play_modes
{
    k_PLAYMODE_CHORDWISE = 0,    ///< Play chord-wise
    k_PLAYMODE_NOTEWISE = 1,    ///< Play note-wise
} e_play_modes;




/** MusicXML beam and tuplet tags.
    @ingroup    import_export
 */
typedef enum _xml_tags
{
    k_XML_START = -1,            ///< The element (tuplet, beam) starts
    k_XML_CONTINUE = 0,            ///< The element (tuplet, beam) continues
    k_XML_STOP = 1,                ///< The element (tuplet, beam) stops
    k_XML_HOOK_LEFT = -2,        ///< The element (beam) is a hook (tick) at left
    k_XML_HOOK_RIGHT = -3,        ///< The element (beam) is a hook (tick) at right
} e_xml_tags;


/** Types of bach-specific attributes
    @ingroup    attributes
 */
typedef enum _bach_attr_types
{
    k_BACH_ATTR_CHAR,
    k_BACH_ATTR_LONG,
    k_BACH_ATTR_DOUBLE,
    k_BACH_ATTR_RAT,
    k_BACH_ATTR_LONG_ARRAY,
    k_BACH_ATTR_DOUBLE_ARRAY,
    k_BACH_ATTR_RAT_ARRAY,
    k_BACH_ATTR_LLLL,
    k_BACH_ATTR_SYM,
    k_BACH_ATTR_COLOR,
    k_BACH_ATTR_OBJ,
    k_BACH_ATTR_ATOM,
    k_BACH_ATTR_ATOM_ARRAY,
    k_BACH_ATTR_ATOM_ARRAY_VARSIZE,
    k_BACH_ATTR_BIT,                ///< Bit in a long bitfield, unused in bach
} e_bach_attr_types;


/** Ways of displaying bach-specific attributes
    @ingroup    attributes
 */
typedef enum _bach_attr_display_types
{
    k_BACH_ATTR_DISPLAY_ONOFF,
    k_BACH_ATTR_DISPLAY_TEXT,
    k_BACH_ATTR_DISPLAY_ENUMINDEX,
    k_BACH_ATTR_DISPLAY_CHAR,
    k_BACH_ATTR_DISPLAY_COLOR,
} e_bach_attr_display_types;


/** Ways of displaying middle vertical and horizontal lines in the miniature in the bach inspector.
    @ingroup    attributes
 */
typedef enum _inspector_miniature_lines
{
    k_INSPECTOR_MINIATURE_NO_LINE = 0,            ///< Don't show any line on the miniature
    k_INSPECTOR_MINIATURE_SHOW_VERTICAL_LINE = 1,    ///< Show vertical line in the middle of the miniature
    k_INSPECTOR_MINIATURE_SHOW_HORIZONTAL_LINE = 2,    ///< Show horizontal line in the middle of the miniature
} e_inspector_miniature_lines;




/** Conversion modes from milliseconds to bach.score timepoints.
    @ingroup    conversions
 */
typedef enum _ms_to_tp_modes {
    k_MS_TO_TP_RETURN_LEFT_CHORD,       ///< Snap result to leftmost chord
    k_MS_TO_TP_RETURN_RIGHT_CHORD,      ///< Snap result rightmost chord
    k_MS_TO_TP_RETURN_INTERPOLATION,    ///< Interpolate
    k_MS_TO_TP_RETURN_NEAREST,          ///< Snap result to nearest chord
} e_ms_to_tp_modes;





/** Pitch output modes
    @ingroup    attributes
 */
typedef enum _output_pitches {
    k_OUTPUT_PITCHES_DEFAULT = -1,       ///< Always output MIDIcents
    k_OUTPUT_PITCHES_NEVER = 0,       ///< Always output MIDIcents
    k_OUTPUT_PITCHES_WHEN_USER_DEFINED,      ///< Output pitches only when they are user-defined
    k_OUTPUT_PITCHES_ALWAYS,    ///< Force output pitches
} e_output_pitches;




/** Annotation filtering duplicates modes
 @ingroup    attributes
 */
typedef enum _annotations_filterdup_mode {
    k_ANNOTATIONS_FILTERDUP_DONT = 0,           ///< Don't filter duplicates (default)
    k_ANNOTATIONS_FILTERDUP_DO = 1,             ///< Don't show duplicates of annotations
    k_ANNOTATIONS_FILTERDUP_DO_WITHCLEARINGSYM = 2,    ///< Don't show annotation duplicates and use a clearing sym to clear the annotation
    k_ANNOTATIONS_FILTERDUP_DO_WITHLINE = 3,           ///< Show annotation duplicates with lines
} e_annotations_filterdup_modes;




#define k_INSPECTOR_MINIATURE_SHOW_BOTH_LINES (k_INSPECTOR_MINIATURE_SHOW_VERTICAL_LINE + k_INSPECTOR_MINIATURE_SHOW_HORIZONTAL_LINE)  ///< Show both lines in the inspector miniature @ingroup attributes 



// ------------------- DATA STRUCTURES -------------------



/** A structure representing a generic notation item. This is a common set of fields needed to handle all notation items (for instance: they can all be selected).
    @ingroup    notation
 */
typedef struct _notation_item
{
    e_element_types    type;        ///< Type of the notation item, it can be one of the following: #k_NOTE, #k_CHORD, #k_DURATION_LINE, #k_PITCH_BREAKPOINT, 
                                ///  #k_LYRICS, #k_DYNAMICS, #k_MEASURE, #k_VOICE, #k_TEMPO, #k_MARKER. In any of these cases, the pointer to this notation item will also
                                ///  be the pointer respectively to a #t_note, #t_chord, #t_duration_line, #t_bpt, #t_lyrics, #t_dynamics, #t_measure, #t_voice, #t_tempo, #t_marker.
    unsigned long    ID;            ///< ID (> 0) of the notation item, or 0 if none. Not all items have ID, only the ones whose tracking is meaningful for undo purposes.
                                ///< Beware that, for instance, if #type = #k_MEASURE, this ID is by no means the measure number, just a variously assigned ID.

    t_llll            *names;                ///< llll containing the name or names of the notation item. Names can be also organized in sublist, such as <b>[foo 1] [fee 2 bar] [bar 3]</b>
    t_llll            *label_families;    ///< Name-labeling families to which the item belongs, in the form of (<pointer_to_family> <pointer_to_llllelem_corresponding_to_notation_item>) (<family> <lllelem>)... 
                                        ///< where the pointer to the family is a H_OBJ pointing to the correct t_bach_family structure.
    
    long                    flags;            ///< Generic flags, internal, a combination of #e_bach_internal_notation_flags for private use
    
    char                    selected;            ///< Is the notation element selected?
    struct _notation_item    *next_selected;        ///< Pointer to the next selected notation item
    struct _notation_item    *prev_selected;        ///< Pointer to the previous selected notation item
    
    char                    preselected;        ///< Is the notation element preselected?
    struct _notation_item    *next_preselected;    ///< Pointer to the next preselected notation item
    struct _notation_item    *prev_preselected;    ///< Pointer to the previous preselected notation item
    
    struct _group            *group;                ///< Group to which the element belongs
    struct _notation_item    *next_group_item;    ///< Pointer to the next item in the same group
    struct _notation_item    *prev_group_item;    ///< Pointer to the next item in the same group
} t_notation_item;


/** The data structure for a slot item. A slot item is just abstractly an element inside a slot. Slotitems build up a double-linked list,
    so you access the following or previous one by using the fields next and prev. 
    @ingroup    slots
 */
typedef struct _slotitem
{
    void                *item;        ///< Pointer to the actual item. Depending on the slot type, this might contain a long, a double, a #t_file, a #t_pts, a #t_spatpt, some text (char *) or a #t_llll, or other stuff.
                                    ///< See #e_slot_types to have more clues on which slot types need which casting.
    struct _slot        *parent;    ///< Pointer to the slot which is the parent for the slotitems 
    char                selected;
    char                active;     ///< Is active?

    // double linked list
    struct _slotitem    *next;        ///< Pointer to the next slot item
    struct _slotitem    *prev;        ///< Pointer to the previous slot item
} t_slotitem;


/** The data structure for a slot. A slot is a portion of memory associated to a note, possibly containing some #t_slotitem.
    Each note in its slot[] field has already space for #CONST_MAX_SLOTS slots, which are by default empty (firstitem = lastitem = NULL).
    More pratically, slots contain various kind of data associated to a note, for instance envelopes, numbers, text, lllls, files and so on,
    depending on the slot type. The slot type for each one of the #CONST_MAX_SLOTS slots is globally defined (and NOT defined note-wisely), and
    it is stored into the slot_type[] field of the #t_notation_obj.
    @remark        Slot having type text, llll and (toggle-/int-/float/-)matrix should always contain only one item (firstitem = lastitem).
    @ingroup    slots
 */
typedef struct _slot
{
    t_slotitem        *firstitem;        ///< Pointer to the first #t_slotitem in the linked list
    
#ifdef BACH_SLOTS_HAVE_LASTITEM
    t_slotitem        *lastitem;        ///< Pointer to the last #t_slotitem in the linked list
#endif

    long            length;            ///< Length of the slot: it is normally the number of slotitems elements; yet for text-type slot, it contains the length of the text

#ifdef BACH_SLOTS_HAVE_ACTIVEITEM
    t_slotitem        *activeitem;    ///< Pointer to an "active" item: for some types of slot, we need to mark one item out of the whole collection of slotitems as          "active"; for instance in #k_SLOT_TYPE_FILELIST type of slots it is used to point to an active file. It always has to be one of the slotitems in the linklist (between firstitem and lastitem).
#endif
    
#ifdef BACH_SLOTS_HAVE_OWNER
    struct _note    *owner;            ///< Pointer to the note who owns the slot
#endif
} t_slot;


/** The data structure representing a file. This is used inside the #k_SLOT_TYPE_FILELIST type of slot.
    @ingroup    slots
 */
typedef struct _file // a file info
{
    char    filename[MAX_PATH_CHARS];    ///< The filename
    short    pathID;                        ///< The pathID, as in the MaxAPI documentation
    long    filename_length;            ///< The length of the filename
    char    exists;                        ///< 1 if the file could be located by locatefile_extended(), 0 otherwise
} t_file;


/** The data structure representing a point with slope. This is used inside the #k_SLOT_TYPE_FUNCTION type of slot.
    The slope is a double value -1 to 1, which correspond to the one used by Max in [curve~] object (although the formula is not *exactly* the same).
    0 correspond to a linear segment, positive values to an increasing "exponent"-like behaviour, and negative ones to an increasing "logarithm"-like behaviour.
    @remark        The slope always refers to the curvature of the segment BEFORE the point.
    @ingroup    slots
 */
typedef struct _pts
{
    double    x;        ///< The x of the point
    double    y;        ///< The y of the point
    double    slope;    ///< The slope value (-1. to 1., 0. being linear) 
} t_pts;


/** The data structure representing a point in the 3-dimensional space.
    @ingroup    math
 */
typedef struct _3dpt
{
    double    x;        ///< The x of the point
    double    y;        ///< The y of the point
    double    z;        ///< The z of the point
} t_pt3d;


/** The data structure representing a point in the 3-dimensional space, with slope linking segments. This is used inside the #k_SLOT_TYPE_3DFUNCTION type of slot.
    The slope is a double value -1 to 1, which correspond to the one used by Max in [curve~] object (although the formula is not *exactly* the same).
    0 correspond to a linear segment, positive values to an increasing "exponent"-like behaviour, and negative ones to an increasing "logarithm"-like behaviour.
    We consider the x as independent variable, so this is a point of a curve of the type (y, z) = f(x).
    @remark        The slope always refers to the curvature of the segment BEFORE the point.
    @ingroup    slots
 */
typedef struct _3dpts
{
    double    x;        ///< The x of the point
    double    y;        ///< The y of the point
    double    z;        ///< The z of the point
    double    slope;    ///< The slope value (-1. to 1., 0. being linear) 
} t_pts3d;


/** The data structure representing a spatialization point, which is used inside the #k_SLOT_TYPE_SPAT type of slot.
    The #t_spatpt represents a point, at a given moment, having a certain distance (radius) to the listener and a certain angle with respect to the
    straight listener view direction. The spat point is used in spat slot to modelize and handle movements of a sound in the space.
    @remark        Even if the user input angles in degrees, it is converted so that inside the structure the angle is expressed in *radiants*.
                There's no need for the angle to be < 2*PI; indeed, if you want to modelize a sound turning more than once, you'll surely have to increase the 
                end point angle to some value > 2*PI.
    @ingroup    slots
 */
typedef struct _spatpt
{
    double    t;            ///< The time point. By convention, it ranges from 0. (beginning of the note) to 1. (end of the note) 
    double    radius;        ///< Distance of the point from the listener
    double    angle;        ///< Angle (in radiants) with respect to the listener view direction (straight before him).
    char    interp;        ///< Interpolation type. Can be one of the #e_spat_interpolation types: either #k_SPAT_INTERPOLATION_ARC (which means: sound travels circularly around listener) or #k_SPAT_INTERPOLATION_SEGMENT (which means: sound travels linearly from one point to another)
} t_spatpt;



/** The data structure representing a given biquad filter. This is contained in a #k_SLOT_TYPE_FILTER type of slot.
    @remark        Please refer to http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt for more information, considering that we take the case \f$a_0 = 1\f$.
                The transfer function for a biquad filter is
                \f[ H(z) = \displaytype\frac{b_0 + b_1z^{-1} + b_2z^{-2}}{a_0 + a_1z^{-1}+a_2z^{-2}}\f]
                Please notice that the a and b roles are REVERSED with respect to the max [biquad~] and [filtergraph] objects.
    @ingroup    slots
 */
typedef struct _biquad
{
    // explicit coefficients for the biquad filter (see previous remarks)
    double    b0;        ///< \f$b_0\f$ coefficient in the biquad formula.
    double    b1;        ///< \f$b_1\f$ coefficient in the biquad formula.
    double    b2;        ///< \f$b_2\f$ coefficient in the biquad formula.
    double    a0;        ///< \f$a_0\f$ coefficient in the biquad formula.
                    ///< This must always be normalized to 1, by convention! (divide everything else by a0) 
    double    a1;        ///< \f$a_1\f$ coefficient in the biquad formula.
    double    a2;        ///< \f$a_2\f$ coefficient in the biquad formula.
    
    // implicit parameters:
    e_filter_types    filter_type;    ///< The filter type
    double    gain_dB;        ///< The global gain of the filter, in decibels
    double    cutoff_freq;    ///< The frequency at which the filter acts the cutoff or has the peak (depending on the filter type)
    double    Q;                ///< The Q factor. This might affect bandwidth and shelfslope, if filters are of the proper type.
                            ///< Relations linking Q and bandwidth BW are:
                            ///<
                            ///<  \f$\frac{1}{Q} = 2 \cdot sinh(\frac{ln(2)}{2} \cdot BW \cdot \frac{w_0}{sin(w_0)})\f$ (digital filter w BLT)
                            ///<  or   \f$\frac{1}{Q} = 2 \cdot sinh(\frac{ln(2)}{2} \cdot BW)\f$ (analog filter prototype) - UNUSED
                            ///<
                            ///< where \f$w_0 = 2\pi \frac{CF}{SF}\f$, where \f$CF\f$ is the cutoff frequency and \f$SF\f$ is the sampling frequency;
                            ///< The relationship between shelf slope \f$S\f$ and \f$Q\f$ is
                            ///<  \f$\frac{1}{Q} = \sqrt{\left(A + \frac{1}{A}\right)\left(\frac{1}{S} - 1\right) + 2}\f$
                            ///< where \f$A = \sqrt{10^{gain/20}}\f$ is the linear amplitude.
    double    bandwidth;        ///< Bandwidth in octaves between -3 dB frequencies (for band pass filters and notch filters).
                            ///< Bandwidth in absolute frequencies will be
                            ///< \f$CF \cdot 2^{-BW}, CF \cdot 2^{BW})\f$ where \f$CF\f$ is the cutoff frequency and \f$BW\f$ is the bandwidth. 
    double    shelfslope;        ///< Shelf slope. When S = 1, the shelf slope is as steep as it can be and remain monotonically
                            ///< increasing or decreasing gain with frequency.  The shelf slope, in
                            ///< dB/octave, remains proportional to S for all other values for a fixed ratio #cutoff_freq / t_notation_obj#sampling_freq and #gain_dB.
    
    // graphic parameters
    double    bandwidth_x1;    ///< Horizontal pixel where the bandwidth start
    double    bandwidth_x2;    ///< Horizontal pixel where the bandwidth end
    
    // only used by dynamic filters:
    double t;                ///< Temporal position of the biquad (usually between 0 and 1; 0 being the beginning of the note, 1 being the end, as for function points) 
} t_biquad;


/** The data structure representing a "breakpoint". A breakpoint is a middle point inside the duration line (between the beginning of a note, and the note tail).
    Indeed, the beginning of the note and the note tail are breakpoint themselves, so each note always has at least these two (trivial) breakpoints.
    Breakpoints are used to achieve complex glissando-like effects on the note duration lines.
    Glissando also may have a slope (-1 to 1, 0 = linear), see #t_pts to have more information (it is handled in the same way).
    For the implementation, breakpoints form a double linked list.
    @remark        The slope always refer to the portion of duration line BEFORE the breakpoint (thus the first slope is ignored). 
    @ingroup    notation
    @see        #t_pts
 */
typedef struct _bpt{
    t_notation_item        r_it;        ///< Notation item, containing common stuff for all notation items.

    double    delta_mc;                ///< The difference of midicents with respect to the parent note midicents
    double    rel_x_pos;                ///< The x relative position within the note duration line, ranging from 0. = beginning to 1. = end
    double    slope;                    ///< The slope of the portion of segment before the breakpoint (from -1. to 1.; 0 = linear)

    long    velocity;                ///< The velocity of the breakpoint (from #CONST_MIN_VELOCITY to #CONST_MAX_VELOCITY), which is used only if the <breakpoints_have_velocity> field 
                                    ///<  of the #t_notation_obj is set to 1 (otherwise it is ignored)
    double    draggingvelocity;        ///< privete field, for internal use

    struct _note *owner;            ///< Pointer to the note who owns the breakpoint

    // TWO DUMMY FIELDS, ONLY USED TO LINK BACH ATTRIBUTES:
    double    dummy_absolute_onset;            ///< DUMMY FIELD, used to reference the attribute, but not updated: NEVER USE IT, please compute explicitely chord->onset + note->duration * bpt->rel_x_position
    double    dummy_absolute_mc;            ///< DUMMY FIELD, used to reference the attribute, but not updated: NEVER USE IT, please compute explicitely note->midicents + bpt->delta_mc

    // double linked list
    struct _bpt *next;                ///< Pointer to the next breakpoint
    struct _bpt *prev;                ///< Pointer to the previous breakpoint
} t_bpt;



/** The data structure representing the clipboard content, which is filled when one presses Cmd+C (mac) or Ctrl+C (win).
    @ingroup    interface
 */
typedef struct _clipboard
{
    e_element_types type;                    ///< Type of the clipboard content. Can be either #k_SLOT or #k_MEASURE or #k_SELECTION_CONTENT or #k_SLOT_SELECTION
    e_notation_objects object;    ///< The object whose content is copied; must be one of the #e_notation_objects (as #k_NOTATION_OBJECT_SCORE or #k_NOTATION_OBJECT_ROLL)
    t_llll *gathered_syntax;        ///< Real clipboard content (gathered syntax of score, or slot...) in the form of an llll
    t_llll *markers;                ///< Copied markers, if any, in llll form
    
    double onset;    ///< Onset of the copied content, if any (e.g. for [bach.roll], if copying a bunch of notes, this onset is the onset of the first copied note).
} t_clipboard;



// private
typedef struct _scheduled_event
{
    void            *clock;
    t_llll          *content;
    double          time;
    char            is_notewise;
    char            is_end;
} t_scheduled_event;




/** The data structure representing an articulation. 
    In the old days, just like the #t_slot structure, each note already has a certain number of prepared space
    to host its articulations (which can be up to #CONST_MAX_ARTICULATIONS_PER_NOTE). 
    But differently from the slots, also chords have some prepared space for articulations,
    so articulations may be attached either to chords or to notes.
    All of this is old. Now the documented way to define articulations is via slots of type #k_SLOT_TYPE_ARTICULATIONS, which contain as 
    slotitems pointers to these (t_articulations *) structures
    @ingroup    notation
 */
typedef struct _articulation
{
    t_notation_item    r_it;                        ///< Notation item

    t_symbol        *original_name;             ///< Name with which the user has instantiated this articulation.
                                                ///< this is the ONLY information that will be saved, and it is essential that the name be saved,
                                                ///< and NOT the IDs or structure, in order to be able to open things properly without losing data
                                                ///< even when custom articulations are note defined
    
    long            number;                        ///< (OBSOLETE, OLD-WAY) 0-based index of the articulation in the sequence of notes or chords' articulations (0 = 1st articulation, 1 = 2nd articulation and so on)
    long            articulation_ID;            ///< ID of the articulation, as in #e_articulations enum. For compatibility, please use only the enum symbols such as k_ARTICULATION_STACCATO, k_ARTICULATION_PORTATO and so on, an never the integer itself.

    // painting parameters
    unicodeChar        character;                    ///< Character for the articulation. Will be filled according to the values in the fields articulations_typo_preferences of the #t_notation_obj, thus depending on the chosen font.
    char            flipped;                    ///< Is flipped 
    double            x_pos;                        ///< Pixel x value of the "writing-box" for the articulation, centered on the chord stem (thus it is 0 if the x value is exactly at the chord stem).
    double            y_pos;                        ///< Pixel y value of the "writing-box" for the articulation, relative to the corresponding voice middle C position
    double            middle_x_pos;                ///< Pixel x value of the middle position of the bounding rectangle for the articulation (it is absolute, in pixel)
    double            middle_y_pos;                ///< Pixel y value of the middle position of the bounding rectangle for the articulation
    double            width;                        ///< Width in pixel of the bounding rectangle 
    double            height;                        ///< Height in pixel of the bounding rectangle

    char            need_recompute_position;    ///< Flag telling if the painting parameters need to be recomputed. If this is 0 the painting parameters are up-to-date, otherwise they are recomputed in the paint cycle.

    // owner
    t_notation_item    *owner;                        ///< Pointer to the owner of the articulation
    t_slotitem      *parent;                    ///< Slotitem parent (if any, NULL if none)
} t_articulation;




/** (CURRENTLY UNSUPPORTED) The data structure representing a slur. Just like the #t_slot structure, each note already has a certain number of prepared space
    to host its articulation (which can be up to #CONST_MAX_SLURS_PER_NOTE).
    The slur is a bezier curve with two internal control points.
    @ingroup    notation
 */
typedef struct _slur
{
    t_notation_item    r_it;                        ///< Notation item

    struct _note    *start_note;                ///< Pointer to the note where the starting of the slur is attached
    struct _note    *end_note;                    ///< Pointer to the note where the ending of the slur is attached

    char            direction;                    ///< Direction of the slur (1 = up, -1 = down)
    char            end_is_before_start;        ///< Internal flag, telling if is the horizontal direction reversed (because the end note is before the start one)

    // painting parameters
    double            start_x;                    ///< x of the pixel of the slur starting point 
    double            start_y;                    ///< y of the pixel of the slur starting point
    double            cp1_rel_x;                    ///< relative x of the pixel of the slur first control point. This is a relative value, between 0. and 1., where 0. = start_x and 1. = end_x.
    double            cp1_y;                        ///< y of the pixel of the slur first control point
    double            cp2_rel_x;                    ///< relative x of the pixel of the slur second control point. This is a relative value, between 0. and 1., where 0. = start_x and 1. = end_x.
    double            cp2_y;                        ///< y of the pixel of the slur second control point
    double            end_x;                        ///< x of the pixel of the slur end point    
    double            end_y;                        ///< y of the pixel of the slur end point
    
    char            need_recompute_position;    ///< Flag telling if the painting parameters need to be recomputed. If this is 0 the painting parameters are up-to-date, otherwise they are recomputed in the paint cycle.
} t_slur;


/** The data structure representing a note. Notes, inside a chord, form a double linked list.
    @remark        VERY IMPORTANT - A general remark throughout all bach notationAPI:
                Some pixel values are marked as "unscaled" and have an "u" in their name.
                Every unscaled value is not the ACTUAL graphic value, but is the graphic value computed for a base zoom: zoom_y = 1, zoom_x = 1. 
                It needs to be change proportionally to the zoom_y (and, if needed, also to zoom_x), to be used in the actual graphic surface.
    @ingroup    notation
 */
typedef struct _note
{
    t_notation_item    r_it;                ///< Notation item, containing common stuff for all notation items.
                                    
    double            midicents;            ///< Midicents of the note (6000 = middle C, each 100 is a semitone)
    t_pitch         pitch_original;     ///< Original introduced pitch. This can also be a "NotAPitch" (t_pitch::NaP), if the user has only introduced midicents, i.e. if the enharmonicity is automatic and not user-defined
    t_pitch         pitch_displayed;    ///< Displayed pitch, possibly quantized to the microtonal grid.
    
    long            velocity;            ///< MIDIVelocity of the note, from #CONST_MIN_VELOCITY to #CONST_MAX_VELOCITY
    double            duration;            ///< Duration of the note in milliseconds. Please notice that this is only used in [bach.roll]; 
                                        ///< if you need to retrieve the duration in ms of a [bach.score] note, it is saved in the duration_ms field of the parent chord.
    
    // ties
    struct _note    *tie_to;            ///< Pointer to the next tied note. If the note has no tie starting from it, this is NULL. This can also beo WHITENULL if the
                                        ///< tie to next chord is set, but hasn't be validated yet via the check_measure_ties() function. When this function is called, the
                                        ///< WHITENULL is changed to the proper note pointer.
    struct _note    *tie_from;            ///< Pointer to the previous tied note. If the note has no tie ending on it, this is NULL
    char            tie_direction;        ///< Direction of the *starting* tie, if any. 1 = tie is over, -1 = ties is under, 0 = tie direction is undefined (or not yet defined)
    
    char            show_accidental;                    ///< Flag saying if we show the accidental or not, depending on the key signature, on previous score content, on cautionary accidentals handling, and so on.
    ///< For instance, a natural accidental is obtained by setting #screen_accidental to 0, and #show_accidental to 1.
    
    
    struct _chord    *parent;            ///< Pointer to the parent chord
    
    // resize
    double            notehead_resize;            ///< Factor (1. = 100%) for resizing the notehead
    double            accidentals_resize;            ///< Factor (1. = 100%) for resizing the accidental
    
    // private
    double            draggingvelocity;            ///< Private, for internal use (keeps track, only during mousedrag, of the velocity as a double precision floating number)

    // pitch breakpoints
    long                    num_breakpoints;    ///< Number of pitch breakpoints within the duration line (it is always at least 2, given that the note start and the note tail are breakpoints)
    t_bpt                    *firstbreakpoint;    ///< Pointer to the first pitch breakpoint (since there are always at least 2 breakpoints, it should never be NULL)
    t_bpt                    *lastbreakpoint;    ///< Pointer to the last pitch breakpoint (never NULL, again).
    struct _duration_line    *durationline;        ///< Pointer to the duration line structure for the note. This structure comes handy when used for selection and interface changes.
    
    // slots
    t_slot        slot[CONST_MAX_SLOTS];    ///< The array containing the slot content for the note (for each slot)

    // lock/mute/play/solo
    char        locked;                    ///< Flag telling if the note is locked
    char        muted;                    ///< Flag telling if the note is muted
    char        played;                    ///< Flag telling if the note is being played
    char        solo;                    ///< Flag telling if the note is soloed

    // articulations, ***only for backward compatibility***
    long                num_articulations;        ///< Number of articulations really attached to the note
    t_articulation        *articulation;            ///< The array containing the articulations for the note (#num_articulations elements are allocated, NULL if none).

#ifdef BACH_SUPPORT_SLURS
    // slurs, only ***for future compatibility***
    long            num_slurs_to;                            ///< Number of slurs starting on the note
    long            num_slurs_from;                            ///< Number of slurs ending on the note 
    t_slur            *slur_to[CONST_MAX_SLURS_PER_NOTE];        ///< The array containing the pointer to the slurs starting on the note (only num_slurs_to elements are meaningful)
    t_slur            *slur_from[CONST_MAX_SLURS_PER_NOTE];    ///< The array containing the pointer to the slurs ending on the note (only num_slurs_from elements are meaningful)
#endif
    
    // Fixed painting parameters (calculated at some point, and not recalculated if not needed)
//    long            scaleposition;                                ///< Number of steps of vertical graphical distance between the note and the middle C (see #e_clefs for more info about steps)
                                                                ///< E.g. for the F# above the middle C, this is 3 (C->D->E->F). For the B just below the middle C, this is -1.
    char            num_accidentals;                            ///< Number of accidentals needed to display the screen_accidental of the note. E.g. for a Ebb, this is 2.
    char            need_auxiliary_stem;                        ///< Flag telling if the notehead is attached to the stem (0) or not (1, and thus needs the auxiliary stem)
    unicodeChar        accidental_text[CONST_MAX_ACCIDENTALS + 1]; ///< Unicode chararcters for the text of the accidental
    double            notecenter_stem_delta_ux;                    ///< Unscaled horizontal deplacement of the x of the notehead center pixel, with respect to the stem position

    
    // nonstandard noteheads
    long            notehead_ID;                                ///< Notehead type, one of the #e_noteheads
    double            notehead_uwidth;                            ///< Unscaled width of the notehead
    
    double            accidental_stem_delta_ux;                    ///< Unscaled horizontal deplacement of the RIGHT boundary of the accidental text field, with respect to the stem position. Should be always negative.
//    double            accidental_uwidth;                          ///< Unscaled width of the accidental (or 0 if none).
//    double            accidental_top_uextension;                    ///< Unscaled vertical extension of the accidental, from its align vertical center to its topmost point.
                                                                ///< The align vertical center is the vertical y position of the center of the notehead to which it is referred. 
                                                                ///< Notice that the align vertical center of the accidental usually does not coincide with the center of the accidental bounding rectangle. 
                                                                ///< For instance, for a flat, the align vertical center is much lower than the center of the bounding rectangle.
//    double            accidental_bottom_uextension;                ///< Unscaled vertical extension of the accidental, from its align center to its bottommost point.
                                                                ///< See #accidental_top_uextension for more information.

    // Windowed painting parameters (in real pixels, and only calculated when the note is inside the window and painted)
    t_pt            center;                                        ///< Center of the note (it is in real pixels, and not an unscaled ones)
    double            center_stafftop_uy;                            ///< Unscaled distance of the y of the notehead center from the topmost staff point
//    t_pt            notehead_textbox_left_corner;                ///< Left corner of the notehead textbox
    
    // double linked list
    struct _note    *next;                ///< Pointer to the next note
    struct _note    *prev;                ///< Pointer to the previous note
} t_note; 


/** The data structure representing a duration line for a note.
    @remark        Notice that breakpoints don't belong to the notation line, but rather to the note structure itself.
    @ingroup    notation
 */
typedef struct _duration_line
{
    t_notation_item        r_it;        ///< Notation item
    struct _note        *owner;        ///< Note owning the line
} t_duration_line;


/** The data structure representing group of notation elements.
    @ingroup notation
 */
typedef struct _group
{
    long                    ID;                    ///< An ID for the group
    
    struct _notation_item        *firstelem;        ///< Pointer to the first element of the group
    struct _notation_item        *lastelem;        ///< Pointer to the last element of the group
    long                        num_elements;    ///< Number of elements in the group

    // for beamings, calculated and used at paint time
    char                        imposed_direction;      ///< Direction of beaming (if any)
    double                      beam_y;                ///< Beam y
    
    struct _group                *prev;        ///< Pointer to the previous group
    struct _group                *next;        ///< Pointer to the next group
} t_group;



/** The data structure representing a piece of lyrics (associated with a chord). 
    @ingroup    lyrics
 */
typedef struct _lyrics
{
    t_notation_item        r_it;                    ///< Notation item, containing common stuff for all notation items.
    
    struct _chord        *owner;                    ///< The chord owning the piece of lyrics
    
    char            *label;                        ///< A string containing a lyric attached to the owner chord. Lyrics are a feature which is handled by slot-attachment.
                                                ///< This means that the user decides that a text slot will be used to contain lyrics. Once bach knows it, the lyrics
                                                ///< are classicaly displayed below the chords, and always kept up to date with the slot content (lyrics may change via 
                                                ///< the mouse&keyboard interface, and slot content as well!). Yet, this pointer is NOT the same pointer as the text slot item
                                                ///< it refers to: the content of the slot is copied . With this, we handle the case of lyrics terminating with a dash "-",
                                                ///< in which case, the dash is NOT saved inside the portion of lyrics (or syllable), and the lyrics_dashed_extension flag is set to 1.
                                                ///< The update function assigning chord lyrics starting from the text slot is assign_chord_lyrics().
    char            lyrics_dashed_extension;    ///< A flag which is 1 if a dashed line "- - - -" must start after this portion of lyrics (syllable) till the next one. 0 otherwise. 
    double            lyrics_ux_shift;            ///< Unscaled horizontal shift (in pixels) of the left boundary of the text box to write the lyrics, with respect to the chord alignment horizontal point.
                                                ///< This is calculated in assign_chord_lyrics() depending on the field lyrics_alignment of the #t_notation_obj.
    double            lyrics_uwidth;                ///< Unscaled width (in pixels) of the text box needed to write the portion of lyrics for this chord
    double            lyrics_uheight;                ///< Unscaled height (in pixels) of the text box needed to write the portion of lyrics for this chord
} t_lyrics;



/** List of possible connectors of dynamics
 @ingroup    dynamics
 */
typedef enum _dynamics_hairpin
{
    k_DYNAMICS_HAIRPIN_NONE = 0,        ///< Just space between dynamics
    k_DYNAMICS_HAIRPIN_DIM = -1,        ///< Diminuendo
    k_DYNAMICS_HAIRPIN_CRESC = 1,       ///< Crescendo
    k_DYNAMICS_HAIRPIN_DIMEXP = -2,     ///< Exponential diminuendo
    k_DYNAMICS_HAIRPIN_CRESCEXP = 2,    ///< Exponential crescendo
    k_DYNAMICS_HAIRPIN_DIMDASHED = -3,  ///< Diminuendo with dashes
    k_DYNAMICS_HAIRPIN_CRESCDASHED = 3, ///< Crescendo with dashes
    k_DYNAMICS_HAIRPIN_DASHED = 4,      ///< Generic dashed line between dynamics
} e_dynamics_hairpin;


/** List of possible positioning of dynamics marking
 @ingroup    dynamics
 */
typedef enum _dynamics_mark_attachment
{
    k_DYNAMICS_MARK_ATTACHMENT_AUTO = 0,            ///< Automatic placement
    k_DYNAMICS_MARK_ATTACHMENT_MANUAL = 1,          ///< Manually adjust
    k_DYNAMICS_MARK_ATTACHMENT_SNAPTOBPT = 2,       ///< Snap to a breakpoint
} e_dynamics_mark_attachment;




typedef struct _dynamics_mark
{
    long     num_words;             ///< Number of words in the mark
    char     *is_roman;             ///< For each word:  1 if the word is textual, 0 if it's a dynamics
    t_symbol **text_typographic;    ///< For each word: The typographic text of the dynamics sign to be displayed
                                   ///< Unlike the text_deparsed fields  this contains the unicode data to
                                   ///  display the dynamics in November for bach, not a readable deparsing
    t_symbol **text_deparsed;       ///< For each word: The typographic text of the dynamics sign readable in plain text

    char                    dynamics_mark_attachment;   ///< One of the #e_dynamics_mark_attachment
    long                    snap_to_breakpoint; ///< If non-zero, it is the index of breakpoint to which it should be snapped
                                                ///  (1 being the first actual breakpoint, not the notehead).
    double                  relative_position;  ///< If #snap_to_breakpoint is 0, this sets the relative position of the dynamic sign
                                                ///< If you want the actual relative position in all #snap_to_breakpoint cases, then use dynamics_mark_get_relative_position()

    long                    hairpin_to_next;    ///< Hairpin going to the next sign, one of the e_dynamics_hairpin

    short                   start_energy;   ///< "Energy value" (an internal number to order dynamics) at the beginning of dynamic mark
    short                   end_energy;     ///< "Energy value" (an internal number to order dynamics) at the end of dynamic mark
                                            ///< This can differ in case of dynamics such as "fp" et similia
                                            ///< Energy are assigned as follows:
                                            ///< energy < 0 ----> cannot be computed
                                            ///< energy == 0 ----> o
                                            ///< ...ppp, pp, p, mp, mf, f, ff, fff ----> ..., 97, 98, 99, 100, 101, 102, 103, 104,...
                                            ///< sf(z), sff(z), sfff(z), .... ----> 200, 201, 202, ...

    struct _dynamics_mark   *next;
    struct _dynamics_mark   *prev;
} t_dynamics_mark;


/** The data structure representing a piece of dynamics (associated with a chord).
    Dynamics are a feature which is handled by slot-attachment.
    This means that the user decides that a text slot will be used to contain lyrics. Once bach knows it, the dynamics
    are classicaly displayed below the chords, and always kept up to date with the slot content (dynamics may change
    via mouse&keyboard interface, and slot content as well!).
    The updating function to assign dynamics from slots is chord_assign_dynamics()
    @ingroup    dynamics
 */
typedef struct _dynamics
{
    t_notation_item        r_it;        ///< Notation item, containing common stuff for all notation items.
    
    t_notation_item        *owner_item;        ///< The notation item owning the piece of dynamics
    
    // dynamics structures
    t_symbol            *text_deparsed;         ///< The deparsed text of the whole dynamics, such as "mp<ff>o"
    t_dynamics_mark     *firstmark;             ///< The first native representation of dynamics as a double-linked list of dynamics signs
    t_dynamics_mark     *lastmark;             ///< The last native representation of dynamics as a double-linked list of dynamics signs
    long                num_marks;              ///< Number of dynamics "nodes" (e.g. in the "mp<ff>o" case: 3)

    char            extend;                     ///< Extend flag: if this is 1, the final hairpin extends till the end of the chord,
                                                ///< if this is 2, it stretches till next dynamic marking.

    // typographic fields
    double            dynamics_left_uext;       ///< Unscaled left extension (in pixels) of the dynamics, from the center of the first dynamic mark
    double            dynamics_right_uext;      ///< Unscaled right extension (in pixels) of the dynamics, from the center of the last dynamic mark
    double            dynamics_min_uwidth;      ///< Minimum unscaled extension (in pixels) of the dynamics
} t_dynamics;


// Internal
typedef struct _dynamics_params
{
    long    dynamics_spectrum_halfwidth;
    double  a;
    double  b;
    t_symbol    *maxdyn;
    t_symbol    *mindyn;
} t_dynamics_params;


/** The data structure representing a chord. Chord, inside a measure (for [bach.score]) or a voice (for [bach.roll]), form a double linked list.
    @remark        Notice that, for [bach.score] a REST is still a chord, having no notes. Yet, the property which (by convention) identifies a rest
                is that its r_sym_duration field is NEGATIVE. This does NOT mean that its symbolic value is negative: the actual symbolic value
                is the absolute value of r_sym_duration. This is just a convention. Thus, to determine if a chord is a rest, you should do something like this:
    @code
    t_chord *chord = do_something_and_get_or_build_a_chord();
    char is_it_a_rest = (chord->r_sym_duration.r_num < 0);
    @endcode
 
    @remark        VERY IMPORTANT - A general remark throughout all bach notationAPI:
                Some pixel values are marked as "unscaled" and have an "u" in their name.
                Every unscaled value is not the ACTUAL graphic value, but is the graphic value computed for a base zoom: zoom_y = 1, zoom_x = 1. 
                It needs to be change proportionally to the zoom_y (and, if needed, also to zoom_x), to be used in the actual graphic surface.
 
    @remark        It is worth underlying that two quantities are important for the chord alignment: the stem_x (which is a field of the #t_chord structure)
                and the chord x alignment point (which is not a field). The latter differs from the first one because it is either half-notehead-with at left 
                (if chord has stem up) or half-notehead-width at right (if chord has stem down).
                This is well explained in the bach function documentation, section "Score spacing".
 
    @ingroup    notation
 */
typedef struct _chord
{
    t_notation_item        r_it;            ///< Notation item, containing common stuff for all notation items.
    
    long                num_notes;        ///< Number of notes in the chord (length of the note double linked list)
    t_note                *firstnote;        ///< Pointer to the first note in the chord
    t_note                *lastnote;        ///< Pointer to the last note in the chord
    double                onset;            ///< Onset of the chord in milliseconds 
    char                direction;        ///< Direction of the stem. 1 = stem upwards, -1 = stem downwards, 0 = direction undefined, or yet to define 
                                        ///< (the algorithm fills automatically the direction when the chord parameters are recomputed)
                                        ///< This value can NOT be set, only get: the direction is automatically calculated and cannot be changed (for the moment)
    
    // flags
    char        is_score_chord;                    ///< Flag telling if the chord is a [bach.score] chord (1) or a [bach.roll] chord (0)
    char        imposed_direction;                ///< Internal flag, private use, to impose a direction to the chord stem (then calculate_chord_parameters() will set the direction flag), as before 1 = stem up, -1 = stem down.
    char        need_recompute_parameters;        ///< Flag telling if we need to recompute the chord parameters. If yes, as soon as needed, some functions are run: assign_chord_lyrics(), chord_assign_dynamics() and calculate_chord_parameters(),
                                                ///< which sets the chord lyrics from the slot content (if any) andall the chord parameters such as direction, left_uextension, right_uextension... 
    char        need_recalculate_onset;            ///< Internal flag, privat use, telling if we need to recalculate the onset of the chord. Only used by score, where the
    
    char        locked;                            ///< Flag telling if the chord is locked
    char        muted;                            ///< Flag telling if the chord is muted
    char        played;                            ///< Flag telling if AT LEAST one note of the chord is being played
    char        solo;                            ///< Flag telling if the chord is soloed

    char        just_added_from_separate_parameters;        ///< Private flag, used in [bach.roll], telling if the chord has just been added from a separate parameters input
    

    // parents
    struct _rollvoice    *voiceparent;    ///< Pointer to the chord parent, if the chord parent is a #t_rollvoice - only used by [bach.roll]
    struct _measure        *parent;        ///< Pointer to the chord parent, if the chord parent is a #t_measure - only used by [bach.score]

    
    // These are only used by [bach.score] and ignored by [bach.roll]
    t_rational        r_sym_onset;                ///< Symbolic onset (rational) of the chord with respect to the measure beginning. A chord starting 7/8 after the beginning of the measure, has r_sym_onset = 7/8. 
    t_rational        r_sym_duration;                ///< Symbolic duration of the chord. By convention, if this is negative, it means that the element is a rest lasting the absolute value of this r_sym_duration.
                                                ///     For instance, a value of -1/4 means a rest during 1/4. To retrieve absolute value of a #t_rational, use rat_abs().
                                                ///     This r_sym_duration should NEVER be zero.
    double            measure_onset_ms;
    double            tuttipoint_onset_ms;        ///< Onset in milliseconds of the chord with respect to the tuttipoint beginning: this value is a double. 
    double            duration_ms;                ///< Duration of the chord in milliseconds. In [bach.score], this is also the duration of each note - in [bach.roll], as we said, all these values are unused.
    
// PLAY VERSIONS, accounting for grace notes
    double            play_measure_onset_ms;        ///< As <r_measure_onset_sec> but changed with respect to the presence of grace notes
    double            play_duration_ms;            ///< As <r_duration_sec> but changed with respect to the presence of grace notes
    t_rational        play_r_sym_onset;            ///< Symbolic onset used by the play system, changed with respect to the presence of grace notes before the next chord â€“ only used by [bach.score]
    t_rational        play_r_sym_duration;        ///< Symbolic duration used by the play system, changed with respect to the presence of grace notes before the next chord â€“ only used by [bach.score]

    // painting parameters
    unicodeChar        notehead_unicode_character;            ///< The default unicode character used to display the chord noteheads (only necessary in [bach.score], where notes can be filled, blank...)
    double            left_uextension;                    ///< Left unscaled extension of the chord: horizontal space needed at the left of the stem line to completely paint the chord.
    double            right_uextension;                    ///< Right unscaled extension of the chord: horizontal space needed at the right of the stem line to completely paint the chord.
    double            lyrics_portion_of_left_uextension;    ///< Part of the left unscaled extension merely due to the fact that there are some lyrics displayed below the chord.
    double            lyrics_portion_of_right_uextension;    ///< Part of the right unscaled extension merely due to the fact that there are some lyrics displayed below the chord.
    double            dynamics_portion_of_left_uextension;    ///< Part of the left unscaled extension merely due to the fact that there are some dynamics displayed below the chord.
    double            dynamics_portion_of_right_uextension;    ///< Part of the right unscaled extension merely due to the fact that there are some dynamics displayed below the chord.
    
    double            stem_x;                                ///< x pixel of the chord stem
    double            firstnote_y_real;                    ///< y pixel of the notehead center of the bottommost note
    double            lastnote_y_real;                    ///< y pixel of the notehead center of the topmost note
    double            topmost_y;                            ///< y pixel of the topmost point in the chord similarly
    double            bottommost_y;                        ///< y pixel of the bottommost point in the chord
    double            topmost_y_noacc;                    ///< y pixel of the topmost point in the chord, if we ignore the accidentals
    double            bottommost_y_noacc;                    ///< y pixel of the bottommost point in the chord, if we ignore the accidentals
    long            system_index;                        ///< 0-based index of the system where the chord is.
    
    // used by tree beaming handling and for groups linking
    double            stemtip_stafftop_uy;                ///< Unscaled vertical shift (in pixels) of the topmost stem point, with respect to the staff top
    double            topmost_stafftop_uy;                ///< Unscaled vertical shift (in pixels) of the topmost point in the chord, with respect to the staff top
    double            bottommost_stafftop_uy;                ///< Unscaled vertical shift (in pixels) of the bottommost point in the chord, with respect to the staff top
    double            topmost_stafftop_uy_noacc;            ///< Unscaled vertical shift (in pixels) of the topmost point in the chord, if we ignore the accidentals
    double            bottommost_stafftop_uy_noacc;        ///< Unscaled vertical shift (in pixels) of the bottommost point in the chord, if we ignore the accidentals
//    double            beam_stafftop_uy;                    ///< Unscaled vertical shift (in pixels) of the point of the flag or beam nearest to the a note
    double            topmostnote_stafftop_uy;            ///< Unscaled vertical shift (in pixels) of the topmost note center, with respect to the staff top
    double            bottommostnote_stafftop_uy;            ///< Unscaled vertical shift (in pixels) of the bottommost note center, with respect to the staff top
    
    // painting parameters only used by [bach.score]:
    double            beam_y;                                ///< y pixel of the point of the main flag or beam
    double            alignment_ux;                        ///< Offset (in pixels) of the chord alignment point with respect to the tuttipoint start point
    double            stem_offset_ux;                        ///< Unscaled horizontal offset (in pixels) of the stem with
            // respect to the tuttipoint start point;
            //beware TODO: this is ***dirty***, since we are using ux/uwidth/uheight to represent quantities that will have to be
            // multiplied by zoomx AND zoomy, whereas sometimes (as in notehead_uwidth) it only has to be multiplied by zoomy and NOT zoomx
            // (wouldn't make sense). This should be fixed. In particular, stem_offset_ux has a true ux component (alignment_ux) + a delta
            // which only needs to be multiplied by zoomy, hence it's dirt
            // TO DO: name some of them uux, and ux the others.
    
    double            duration_ux;                        ///< Unscaled horizontal extension (in pixels) of the duration line of the chord (unscaled "chord graphical duration")
    long            float_steps;                        ///< Only used for floating rests: number of vertical "steps" that the rest is shifted up or down.
                                                        ///< Positive values shift up, negative values shift down.
                                                        ///< Remark: the "step" is the graphical distance between two consecutive notes on the diatonic scale, i.e. it is HALF of the distance between two staff lines.
                                                        ///< This is a commonly used quantity, its value of course depend on the vertical zoom factor zoom_y of the #t_notation_obj, and it is
                                                        ///< constantly saved and updated in the step_y field of the same #t_notation_obj.

    // parameters for the symbolic screen printing only used by [bach.score]
    t_rational        figure;                                ///< Symbolic figure used to display the chord. Consider that, in general, this does NOT coincide with the r_sym_duration field.
                                                        ///< For instance, if we have a quaver tuplet, each element lasting 1/12, the field <figure> will contain 1/8, which is the
                                                        ///< actual symbolic figure used to display the 1/12 chord. Analogously, a chord lasting 3/8 will have a figure of 1/4, and then a dot.
                                                        ///< The chord figure is always positive, even if the chord is a rest.
                                                        ///< Also: for rests spanning the whole measure, the figure is simply 1. 
    char            num_dots;                            ///< Number of dots that the chord has.
    
    // tuplet parameters, only used by [bach.score] 
    t_rational        overall_tuplet_ratio;        ///< If the chord is within a tuplet, here we have the tuplet ratio (for instance, a quaver tuplet, having symbolic duration of 1/12, has ratio 2/3)
                                                ///< Please consider that this is the OVERALL ratio (should the chord be in nested tuplets). This means that this is the precise
                                                ///< ratio between the symbolic duration <r_sym_duration> and the <figure>.
    
    // beamings
    long            beams_depth;                ///< Number of beaming lines over the chord
    
    // articulations (for the moment, only implemented in [bach.score])
    // These are deprecated: use the articulation-typed slots instead
    long            num_articulations;        ///< (DEPRECATED) Number of articulations really attached to the note
    t_articulation    *articulation;            ///< (DEPRECATED) The array containing the articulations for the note (#num_articulations elements are allocated, NULL if none).
    
    struct _lyrics      *lyrics;                ///< The chord piece of lyrics (it is always allocated).
    t_slot              *dynamics_slot;          ///< Pointer to the slot containing the dynamics

    // grace?
    char            is_grace_chord;                ///< Is the chord a grace chord?

    // rhythmic tree
    char            dont_split_for_ts_boxes;    ///< Don't split this chord when gathering into ts boxes
    t_llllelem        *rhythmic_tree_elem;        ///< Pointer to the #t_llllelem corresponding to the chord in the measure beaming tree
    
#ifdef BACH_CHORDS_HAVE_SLOTS
    t_slot        slot[CONST_MAX_SLOTS];          ///< The array containing the slot content for the chord (for each slot)
                                                ///< This is ONLY meaningful (and only used) when the chord is a REST, otherwise notes have their own slots, use them!
#endif
    
    // double linked list
    struct _chord*    next;        ///< Pointer to the next chord in the measure (for [bach.score]) or in the voice (for [bach.roll])
    struct _chord*    prev;        ///< Pointer to the previous chord in the measure (for [bach.score]) or in the voice (for [bach.roll])
} t_chord;


/** The data structure representing a time signature (only used inside [bach.score]).
    bach can represent time signatures of the form n/d, or the form (n1+n2+n3...)/d. For instance, 5/8 belongs to the first category, (3+2)/8 belongs to the second one.
    Notice that a time signature is NOT simply a rational, even in the simplest n/d form (and the n/d writing is an abuse), but is more an ordered couple (n, d).
    Indeed 4/4 is different from 2/2 and 8/8, and we don't want to gather them in the rational number 1!

    @ingroup notation
*/ 
typedef struct _timesignature 
{
//    t_notation_item    r_it;    ///< Notation item, containing common stuff for all notation items.

    long num_numerator_elements;                                    ///< Number of elements at the numerator of the time signature. If this is 1, we're in the simplest n/d form.
    long numerator_elements[CONST_MAX_TS_NUMERATOR_ELEMENTS];    ///< Array of numerator elements (they must all be > 0). Only num_numerator_elements elements are meaningful.
    long numerator;                                                ///< Global numerator. If num_numerator_elements = 1, this is the actual numerator n of the form n/d
                                                                ///< If num_numerator_elements > 1, and thus we are in the form (n1+n2+n3...)/d, this contains the sum of all the
                                                                ///< elements of the numerator; As an example, consider the time signature (3+4+3)/8: this is represented by
                                                                ///< num_numerator_elements = 3, numerator_elements = (3 4 3), numerator = 10.
    long denominator;                                            ///< The denominator of the time signature (must be > 0)
    
    unicodeChar num_unicode[150];    ///< Unicode characters containing the string to write the numerator
    unicodeChar den_unicode[50];    ///< Unicode characters containing the string to write the denominator
    long len_num;                    ///< Number of ascii characters needed to write the numerator (e.g. for (3+4+3)/8 this is 5: "3+4+3")
    long len_den;                    ///< Number of ascii characters needed to write the denominator (e.g. for 1/128 this is 3: "128")
} t_timesignature;


/** The data structure representing a timepoint (only used inside [bach.score]). A timepoint is just a given point inside a given measure.
    @ingroup notation
 */ 
typedef struct _timepoint
{
    long        measure_num;    ///< 0-based measure number of the measure which contains the point 
    t_rational    pt_in_measure;    ///< Symbolic onset of the point with respect to the measure
    long        voice_num;        ///< 0-based voice number of the measure. (RARELY USED, only FOR MARKERS!)
} t_timepoint;


// Private
typedef double (*notation_obj_timepoint_to_ux_fn)(void *notation_obj, t_timepoint tp, long flags);
typedef double (*notation_obj_undo_redo_fn)(void *notation_obj, char direction);




/** The data structure representing a tempo (only used inside [bach.score]). 
    A tempo is assigned punctually at a given point in a measure. They can be interpolated one towards the next (and thus generate
    accelerandi or ritardandi), or not.
    Inside each measure, tempi form a double linked list. 
    @remark        Two tempo values are stored in the structure: the first one (<figure_tempo_value>) referred to the possibly defined symbolic duration, 
                and the second one (<tempo_value>) referred to the default quarternote. Both of them are #t_rational, and NOT double.
                This "limitation" is due to the fact that, if we do so, we can
    @ingroup    notation
 */ 
typedef struct _tempo 
{
    t_notation_item        r_it;                        ///< Notation item, containing common stuff for all notation items.

    struct _measure*    owner;                        ///< Measure which contains a tempo
    t_rational            changepoint;                ///< Symbolic onset of the point where the tempo changes inside the measure <owner>
    
    t_rational            tempo_figure;                ///< Symbolic figure according to which the tempo is defined, appearing in the written tempo relation <tempo_figure> = <figure_tempo_value>. By default it is 1/4 (quarternote). E.g. for a quaver = 80 tempo, figure = 1/8 (quaver)
    t_rational            figure_tempo_value;            ///< Tempo value referred to the <tempo_figure>, i.e. the quantity appearing in the written tempo relation <tempo_figure> = <figure_tempo_value>
    t_rational            tempo_value;                ///< Tempo referred to the standard 1/4 tempo-figure
    char                interpolation_type;            ///< Type of interpolation towards the NEXT tempo: 0 = no interpolation (next tempo, if any, changes abruptly), 1 = linear interpolation (accelerando or rallentando towards next tempo, if any, and depending on the next tempo value)

    double                measure_onset_ms;
    double                tuttipoint_onset_ms;        ///< Tempo onset in milliseconds with respect to the tuttipoint
    double                onset;                        ///< Tempo GLOBAL onset in milliseconds (with respect to the score beginning!) 

    // flags
    char                hidden;                        ///< Flag telling if the tempo is hidden (this is set by the function check_tempi(), which analyzes the tempi sequences and tells which tempi have to be shown, and which don't.)
    
    char                need_recalculate_onset;        ///< Flag telling if we have to recalculate the tempo onset values
    
    double                tuttipoint_offset_ux;        ///< Unscaled offset of the tempo position with respect to the reference tuttipoint (which is the <owner> reference tuttipoint).
    double                uy_offset;                    ///< Additional unscaled y offset with respect to the standard tempo vertical position above the staff. This is currently UNUSED, but may be immediately used if needed.
    double                real_x_width;                ///< Overall width of the text box(es) needed to write the tempo 

    long                hack_measure_number;        ///< (Essentially private, don't use it) It's an hack to have a measure number even when the owner is not defined 
                                                    ///< (for instance when we build tempi independently from t_measure structures, like in [bach.quantize]).

    // double linked list
    struct _tempo*        prev;    ///< Pointer to the previous tempo (within the measure!)
    struct _tempo*        next;    ///< Pointer to the next tempo (within the measure!)
} t_tempo;


/** The data structure representing all the information needed for a tuplet to be correctly handled.
    @ingroup    notation
 */ 
typedef struct _tupletinfo
{
    t_rational        tuplet_local_ratio;                    ///< Local tuplet ratio. This is the ratio between real duration and symbolic written duration (for instance, a quaver tuplet, having symbolic 
                                                        ///< duration of 1/12, has ratio 2/3). This is \f$r'\f$ in the function documentation.
    t_rational        tuplet_pregressed_ratio;            ///< Previous ratio due to the fact that the tuplet is possibly inside other tuplets, so that the symbolic values have to be accounted for those ratios.
                                                        ///< This is \f$r^{\ast}\f$ in the function documentation.
    t_rational        tuplet_local_unit;                    ///< The local tuplet unit. This is the tuplet unit ignoring the pregressed ratio, i.e. ignoring the fact that the tuplet is inside a tuplet (e.g. a 5-in-3 tuplet of (1/60 1/60 1/60 1/60 1/60) (1/60..) (1/60...) the inside tuplets
                                                        ///< have pregressed ratio of 2/3, ratio of 3/5. If there was no external tuplet, all durations would be multiplied by 3/2, thus yielding (1/40 1/40 1/40 1/40 1/40)
                                                        ///< so that the <tuplet_local_unit> is 1/40, and the ratio is namely (1/32)/(1/40) = 4/5
                                                        ///< On the other hand, the overall ratio is obtained by multiplying <tuplet_local_ratio> * <tuplet_pregressed_ratio>, which in this case is the
                                                        ///< global 2/3 * 4/5 = 8/15, accounting (indeed) for the fact that globally we have 15 32th notes in the space of 8
                                                        ///< This is \f$u'\f$ in the function documentation.
    t_rational        tuplet_unit;                        ///< The global tuplet unit. This is the real symbolic duration of the tuplet unit, e.g. 1/12.
                                                        ///< This is \f$u\f$ in the function documentation.
    t_rational        tuplet_graphical_unit;                ///< The tuplet graphical unit. The graphical unit used to represent the tuplet_unit, e.g. 1/8. 
                                                        ///< Of course, <tuplet_local_unit>/<tuplet_graphical_unit> = <tuplet_local_ratio>.
                                                        ///< This is \f$f\f$ in the function documentation.
    t_rational        tuplet_sym_duration;                ///< The symbolic duration needed for the whole tuplet. For instance a quaver tuplet has duration 3 * 1/12 = 1/4.
                                                        ///     One has: <tuplet_unit> * <tuplet_local_ratio>.r_den = <tuplet_graphical_unit> * <tuplet_local_ratio>.r_num
                                                        ///< This is Delta \f$t_{sym}\f$ in the function documentation.
    t_rational        tuplet_multiplier;                    ///< The tuplet multiplier. This is the number of analogous tuplets which are being gathered into a single one.
                                                        ///< For instance, a 6-plet of 1/16, has a 2/3 ratio and multiplier 2, since we have the "3 sixteenth in the space of 2" configuration twice.
                                                        ///     One has: <tuplet_unit> * <tuplet_local_ratio>.r_den * <tuplet_multiplier> = <tuplet_sym_duration>
                                                        ///< This is usually integer; for non-complete tuplets, this will be rational.
                                                        ///< This is \f$m\f$ in the function documentation.
    
    char            is_tuplet_completed;                    ///< Is tuplet exactly achieved?
    char            is_tuplet_under_linear_edit;            ///< Is tuplet just built from speedy edit?
    char            is_completely_on_solitary_beam_level;    ///< Is the tuplet corresponding exactly to a solitary beam level? (can we put the tuplet number directly over the beam, without bracket, without ambiguity?)
    char            is_over_beam;                            ///< Is the tuplet over a beam (no matter if it does not span the WHOLE beam: it is needed to match the bracket slope with the beam slope)
    char            bracket_slope;                            ///< Forced bracket slope, in case <is_over_beam> is true
} t_tupletinfo;


/** The data structure representing a beaming.
    @ingroup    notation
 */ 
typedef struct _beam
{
    char            has_beam_line;            ///< Do we show the beam line? (0 only if the beaming group is actually a non-beamed tuplet group)
    char            depth;                    ///< Depth of the beam: 1 is 1/8, 2 is 1/16 and so on.
    char            is_tuplet;                ///< Has the beam a tuplet information?
    char            grace;                    ///< Is it a grace beaming?
    char            slashed;                ///< Is the grace beaming slashed?
    char            direction;                ///< Beam direction
    char            dashed;                    ///< Beam is dashed? (for tuplet lines)
    
    struct _measure    *owner;            ///< Measure owning the beam

    char            is_tick;                ///< Is the beam just a tick? In this case, <beam_start_uy> = <beam_end_uy>, and we handle the proper tick positioning in the paint function
    char            tick_direction;            ///< If the beam is a tick, here's its direction: 1 = right, -1 = left.

    t_chord            *beam_start_chord;        ///< Starting chord for the beam
    t_chord            *beam_end_chord;        ///< Ending chord for the beam
    
    double            beam_start_uy;            ///< Unscaled vertical shift (in pixels) of the beam start with respect to the topmost staff line
    double            beam_end_uy;            ///< Unscaled vertical shift (in pixels) of the beam end with respect to the topmost staff line
    double            slope;                    ///< Beam slope as (beam_end_uy - beam_start_uy)/(beam_end_ux - beam_start_ux) 
    
    
    // tuplet fields (only accounted for if <is_tuplet> is 1)
    char            tuplet_show_bracket;                    ///< Do we show the tuplet shape? (bracket or slur)
    char            tuplet_number_display_type;                ///< How do we show the tuplet number? One of the #e_tuplet_number_types
    char            tuplet_text1[CONST_MAX_TUPLET_CHARS];    ///< Main string for the tuplet text (e.g. "3" or "3:2" or "2/3")
    char            tuplet_text2[CONST_MAX_TUPLET_CHARS];    ///< Additional string for the tuplet text, only needed for the #k_TUPLET_DISPLAY_SHOW_RATIO_AND_FIGURES representation.
                                                            ///< For instance in the case of 3q:5, <tuplet_text1> = "3" and <tuplet_text2> = ":5". 
    double            tuplet_text1_delta_ux;                    ///< Unscaled horizontal shift (pixel) of the left boundary of the text1 box with respect to the middle position between 
                                                            ///< the chords it is referred to
    double            tuplet_text1_uy;                        ///< Unscaled vertical shift (in pixels) of the top boundary of the text1 box with respect to the topmost staff line
    t_rational        tuplet_graphical_unit;                    ///< Tuplet graphical unit, used to paint the "q" in the 3q : 5 representation
    
    struct _beam    *prev;                    ///< Pointer to the previous beam (within the measure)
    struct _beam    *next;                    ///< Pointer to the next beam (within the measure)
} t_beam;


/** The data structure representing the information of a specific rhythmic tree level.
    This is usually stored in the t_llll#l_thing field of each (sub-)llll in the rhythmic_tree of a measure
    @ingroup    rhythmic_trees
 */ 
typedef struct _rhythm_level_properties
{
    long            level_type;            ///< A combination of #e_rhythm_level_types (see for info)
    
    char            max_beam_number;                ///< Maximum number of beams that the level can have over itself
    char            max_beam_number_if_under_beam;    ///< Maximum tolerable number of beams that the level can have over itsself if it the level is put under a beam.
                                                    ///< E.g. the group (1/32 -1/32) can tolerate up to 3 beamings, but not 4.
                                                    ///< <max_beam_number> and <max_beam_number_if_under_beam> will NOT coincide in general, since
                                                    ///< the second one can be higher, due to the #e_rests_within_beam_handling options - for instance, with unbeamed non-internal rests
                                                    ///< (1/32 -1/32) will have max_beam_number = 0 and max_beam_number_if_under_beam = 3

    char            direction;            ///< Beaming (if level is beamed) or tuplet (if level is a tuplet) direction (1 = above, -1 = below, 0 = undefined)
    
    char            beam_number;        ///< Actual chosen number of the beams for the level. E.g. 2 for a level like (1/16 1/16), 0 for no beams.
                                        ///< -1 means that the beam has not been detected yet
    double            beam_slope;            ///< Beam slope (as delta_y/delta_x: how much it goes up divided by how long it is. Positive for upgoing slopes, negative for downwards)
    
    char            is_grace;            ///< Is it a "grace level"? Quick way to check it - instead of doing (#level_type & #k_RHYTHM_LEVEL_GRACE).
                                        ///< This must be kept up to date with the #level_type.
    char            is_tuplet;            ///< Level is a tuplet level? Quick way to check it - instead of doing (#level_type & #k_RHYTHM_LEVEL_TUPLET)
                                        ///< This must be kept up to date with the #level_type.
    
    t_tupletinfo    tupletinfo;            ///< Stored tuplet information for tuplet levels
} t_rhythm_level_properties;


/** The data structure representing a measure end barline (only used inside [bach.score]).
    @ingroup    notation
 */ 
typedef struct _measure_end_barline
{
    t_notation_item        r_it;            ///< Notation item, containing common stuff for all notation items.
    struct _measure        *owner;            ///< The measure which owns it 
    char                barline_type;    ///< Type of ending barline. Must be one of #e_barline_modifier. By default it is #k_BARLINE_AUTOMATIC.
} t_measure_end_barline;


/** The data structure representing a measure (only used inside [bach.score]).
    Inside each #t_scorevoice, measures form a double linked list. 
    @ingroup    notation
 */ 
typedef struct _measure
{
    t_notation_item    r_it;            ///< Notation item, containing common stuff for all notation items.

    long            measure_number;    ///< The measure number, 0-based. 
                                    ///< Beware: this is 1-based externally (for the user 1st measure will always be measure 1), but, as voice numbering, will always be 0-based inside
                                    ///< Also: if #force_measure_number is non-zero, this continues to be the incremental number of the measure, as always,
                                    ///< (so it is NOT FORCED, NOT TOUCHED), only it is not shown, and what is shown is the forced measure number stored in the #forced_measure_number
                                    

    t_timesignature    timesignature;            ///< Time signature of the measure 
    t_llll            *timesignature_dummy;    ///< Dummy field, needed for the bach attribute

    // chords
    long            num_chords;        ///< Number of chords inside the measure
    t_chord            *firstchord;    ///< Pointer to the first chord of the measure
    t_chord            *lastchord;        ///< Pointer to the last chord of the measure
    
    // tempi
    long                num_tempi;        ///< Number of defined tempi within the measure - may obviously be 0, so that <firsttempo> = <lasttempo> = NULL; in which case the previously used tempo continues
    struct _tempo        *firsttempo;    ///< Pointer to the first tempo of the measure
    struct _tempo        *lasttempo;        ///< pointer to the last tempo of the measure
    
    struct _scorevoice    *voiceparent;            ///< Pointer to the #t_scorevoice structure which owns the measure
    struct _tuttipoint    *tuttipoint_reference;    ///< Pointer to the reference tuttipoint for the measure (what tuttipoints are is explained in the bach function documentation, section "Score spacing")
    
    // beams
    char            custom_boxing;    ///< Use custom boxing while beaming? Default: 0.
    t_llll            *boxes;            ///< Boxes in which the measure will be subdivided for beaming. They usually coincide with beats, but can be custom. If this is NULL (default) default time signature boxes will be used. 
    long            num_beams;        ///< Number of beams in the measure
    t_beam            *firstbeam;        ///< Pointer to the first beam of the measure (beams order is aleatory, but each chord has in its structure a point to its proper beamings)
    t_beam            *lastbeam;        ///< Pointer to the last beam of the measure
    
    // time values
    double            total_duration_ms;
    double            tuttipoint_onset_ms;        ///< Onset in milliseconds of the measure beginning with respect to the reference tuttipoint

    t_rational        r_total_content_duration;    ///< Total symbolic duration of the measure _content_ in seconds: which means: if the measure is not complete, or if 
                                                ///< there's too many chords inside it, this value will be exactly the sum of the chords durations, and thus 
                                                ///< might differ from the <r_total_duration_sec> field. It won't differ for complete measures

    // pixel values
    double            start_barline_offset_ux;    ///< Unscaled offset (in pixels) of the measure start barline with respect to the start pixel of the reference tuttipoint
    double            width_ux;                    ///< Unscaled width (in pixels) of the measure
    double            timesignature_uwidth;        ///< Unscaled width (in pixels) of the rectangle needed to write the time signature on the score 
    double            timesignature_spacing_uwidth;///< Unscaled width of the spacing needed to paint the of the rectangle for the time signatures (coincides with <timesignature_uwidth> unless show_timesignature is set to 0 or 2).

    // spacing
    char            is_spacing_fixed;                        ///< Flag telling if the measure <width_ux> is fixed or floating. 
                                                            ///< 1 = fixed, i.e. won't change if the content of the measure changes); 0 = floating, i.e. 
                                                            ///< subject to change if the measure content gets more or less dense). The default is the floating measure
                                                            ///< (whose width is always updated depending on content). Locking and unlocking measure width will change this value.
                                                            ///< VERY IMPORTANT REMARK: we abused of the above terminology. Actually, what is fixed or floating is not the width of 
                                                            ///< the measure itself, but the width of the tuttipoint region to which the measure belong. This is exactly the same
                                                            ///< in the classical situation where all measure ends and start together (simply implying that the width of the n-th measure
                                                            ///< of a voice must be the same as the n-th measure of any other voice...). This is not the same, if measure have different
                                                            ///< tempi or time signatures. In this latter case, when we lock a measure, we fix the width for the whole tuttipoint region
                                                            ///< and not for the single measure itsself.
    double            fixed_spacing_uwidth;                    ///< If the spacing is fixed, this is the unscaled fixed width of the measure (in pixels)
    double            local_spacing_width_multiplier;            ///< An additional multiplier for the measure width. This is mostly useful when the spacing is NOT fixed,
                                                            ///< in which situation, we can decide to keep the spacing "floating", but make it globally tighter or looser.
                                                            ///< Values between 0. and 1. will make spacing tighter, values above 1. will make it looser. The default is 1. (no change).
                                                            ///< Notice that in the bach function documentation this parameter is named \gamma^\times. 
                                                            ///< VERY IMPORTANT REMARK: as before, this value is NOT defined for each measure, but for each tuttipoint region. 
                                                            ///< All measure inside the same tuttipoint measure will synchronyze on the new value of this parameter.
    
    // measure number and barline
    char            show_measure_number;        ///< Flag telling if we show (1) or not (0) the measure number for the current measure. By default this is 1.
                                                ///< Notice that if the general field #show_measure_numbers of the #t_notation_obj is 0, no measure number will be shown
                                                ///< disregarding this particular field.
    char            force_measure_number;        ///< Flag telling if we have to force (1) a specific measure number, or if (0, default) we show the one automatically assigned by the automatic score measure counting.
    long            forced_measure_number;        ///< If #force_measure_number = 1, this is the number that we force the measure to show as measure number
                                                ///< This is EXACTLY the forced number, thus is 1-based!!! BEWARE: this is 1-based, so not 0-based as the standard #measure_number

    struct _measure_end_barline        *end_barline;        ///< Measure end barline
    char                            end_barline_dummy;    ///< Dummy field only used by bach attribute system

    // flags
    char            need_recompute_beamings;            ///< Flag telling if we have to reanalyze the beamings inside the measure
    char            need_recompute_beams_positions;        ///< Flag telling if we have only to recompute the beaming positions, leaving the beaming structure untouched 
    char            need_check_ties;                    ///< Flag telling if we have to check the ties correctness inside the measure
    char            need_check_autocompletion;            ///< Flag telling if we have to check the autocompletion of the measure
    long            beaming_calculation_flags;            ///< One of the #e_beaming_calculation_flags, determining if some steps of the beaming calculation process must be skipped for the measure

    char            locked;            ///< Flag telling if the measure is locked
    char            muted;            ///< Flag telling if the measure is muted
    char            solo;            ///< Flag telling if the measure is soloed

    char            measure_filling;    ///< Flag telling if the measure is completed, or has more or less notes than needed.
                                        ///< 0 = measure is right completed
                                        ///< 1 = measure has more notes than needed
                                        ///< -1 = measure has less notes than needed
    
    t_llll            *info_for_pwgl;        ///< Tree information which is always update, ready for an "exportpwgl" message to ask it.

    // rhythmic tree support
    t_llll            *rhythmic_tree;        ///< Contains the chords as #H_OBJ in a nested beaming structure. E.g. ((chord1 chord2) ((chord3 chord4) chord5)...)
                                        ///< Most lllls also contain as <l_thing> field a #t_rhythm_level_properties structure specifying the type of rhythmic level
    char            lock_rhythmic_tree;    ///< This is 1 if the beaming tree is locked, 0 otherwise. In case this is 1, no retranscription is performed, unless new data from messages is inserted
                                        ///< This flag is saved, so that locked measure remain locked when the object is saved
    
    // double linked list
    struct _measure*    next;        ///< Pointer to the next measure
    struct _measure*    prev;        ///< Pointer to the previous measure
} t_measure;


/** The data structure representing a voice.
    A #t_voice is a common entity which will be furtherly specified in a #t_rollvoice (containing a list of chords) 
    and a #t_scorevoice (containing a list of measures).
    There are #CONST_MAX_VOICES #t_scorevoice and #t_rollvoice already prepared at the initialization respectively in [bach.score] and [bach.roll]

    @remark        A voice is NOT a staff! A voice is a list of chords or measures, which can be represented also on more than one staff!
                So, the staff type (actually determined by the <clef> field) is a _property_ of the voice. You can't have polyphony on the same voice,
                you need to use two voices for this.
    
    @ingroup    notation
 */ 
typedef struct _voice
{
    t_notation_item    r_it;            ///< Notation item, containing common stuff for all notation items.

    long            number;             ///< The number of the voice, 0-based
    
    /// Multivoicing stuff:
    long            part_index;              ///< The index of the part inside the voiceensemble, 0-based
    long            voiceensemble_index;     ///< The index of the voiceensemble that the voice belongs to, 0-based
    
    double            middleC_y;        ///< Y position (in pixels) of the middle C inside the voice. This is computed in compute_middleC_position_for_voice(),
                                    ///< and updated as the zoom or voice configuration change. This y position is the base to build stafflines and to place
                                    ///< notes, so it is throuroughly used in the code.
    double            offset_y;        ///< Vertical offset of the voice w.r. to the top of the roll.
    long            midichannel;    ///< Midichannel globally associated to the voice
    long            clef;            ///< Clef (and thus subsequently staff type) associated to the voice. This must be one of the #e_clefs (by default, #k_CLEF_G) 

    // key and mode
    char        mode;            ///< Global mode of the voice; this is one of the #e_modes: #k_MODE_MAJOR, #k_MODE_MINOR, #k_MODE_NONSTANDARD (so key is ignored)
    char        key;            ///< Global key signature of the voice. This value is the position of the base note with respect to the fifths circle. For instance, for major mode,
                                ///< 0 = C, 1 = G, 2 = D ..., and (the other way round): -1 = F, -2 = Bb.... and so on.
    t_rational    acc_pattern[7]; ///< Custom accidental pattern for the seven diatonic degrees (C D E F G A B). You can define an accidental for each degree
                                ///< and the seven accidentals will be taken into account as a nonstandard custom key signature. 
                                ///< This is always used, but mostly meaningful if <mode> = #k_MODE_NONSTANDARD.
                                ///< The key, mode and acc patterns are set by message via the parse_sym_to_key_and_mode() function.
    t_rational    full_repr[48];    ///< Full accidental pattern for each 8-tonal degree, allowing to specify its specific representation
    

    // staff lines
    long        num_staff_lines;                    ///< Number of staff lines (by default 5)
    char        staff_lines[CONST_MAX_STAFF_LINES];    ///< Customizable staff lines indices. Staff lines on the traditional 5-lines-staff are numbered
                                                    ///< from 1 to 5 bottom-up, the middle one being the 3rd. You can choose a subset of these lines, or even use
                                                    ///< (nontraditional) lines placed aboves or below, by properly setting these staff line values.
                                                    ///< For instance, choosing <num_staff_lines> = 3, and <staff_lines> = {1, 3, 5} will only show the bottom
                                                    ///< middle and top lines of the traditional staff. This array is thus a list of the indices of the 
                                                    ///< lines to show. You can surely use more exotic line configuration such as <staff_lines> = {-2, 6, 7}.
    char        min_staff_line;                        ///< Bottommost staff line index (by default 1). In the last example, this would be -2.
    char        max_staff_line;                        ///< Topmost staff line index (by default 5). In the last example, this would be 7.
    char        are_staff_lines_standard;            ///< Flag telling if #staff_lines are the standard staff lines for a staff having #num_staff_lines staff lines. 
    t_symbol    *staff_lines_dummy;                    ///< Dummy symbol to be associated with the stafflines to declare the "Staff Lines" attribute in the editor.
                                                    ///< This is dummy, since it is never used, and is only needed as a "placeholder" to link the stafflines attribute: 
                                                    ///< its setter/getter will deal with the real stafflines fields (the previous ones).
    
    char        locked;                ///< Flag telling if the voice is locked
    char        muted;                ///< Flag telling if the voice is muted
    char        solo;                ///< Flag telling if the voice is soloed
    char        hidden;                ///< Flag telling if the voice is hidden
    char        determines_spacing;    ///< Flag (only for [bach.score]) telling if the voice is taken into account when calculating spacing. Yet UNSUPPORTED!

    double        vertical_uspacing;    ///< Unscaled vertical spacing AFTER the voice (before the next one, or before the end of the object) 

} t_voice;


/** The data structure representing a tuttipoint (only used in [bach.score])
    As explained in the function documentation (section "Score spacing"), a tuttipoint is an instant in the score where all voices have
    at the same time a measure barline, i.e. a moment where for ALL voices a measure starts. Each tuttipoint identifies a tuttipoint region,
    which is the portion of score going from the tuttipoint to the next one. 
    The [bach.score] spacing algorithm is based on tuttipoint segmentation. Indeed, if we change something inside a tuttipoint region,
    we are sure that this change won't affect the spacing outside the tuttipoint region. Tuttipoint regions are, thus, the minimal isolated
    boxes affected by spacing algorithms. 
    Given their importance, the tuttipoints form a linked list, stored inside the t_score structure. Each #t_measure is anchored to a tuttipoint,
    stored in its <tuttipoint_reference> field. Conversely, each tuttipoint has stored the first measure of each voice in its array field <measure>.
    To run a cycle on all the measure of a given tuttipoint region, one should do something like:
    
    @code
    long i;
    t_measure *this_meas;
    for (i = 0; i < x->r_ob.num_voices; i++){ // cycle on the voices of the score 
        for (this_meas = tpt->measure[i]; ((tpt->next && this_meas != tpt->next->measure[i]) || (!tpt->next && this_meas)); this_meas = this_meas->next){ // cycle on the measures within the tuttipoin
            // do something with this_meas
        }
    }
    @endcode
 
    @remark        Of course, in a traditional context, where all voices have the same tempo and time signature, all measure barlines are synchronous,
                and thus tuttipoint regions coincide with the global score barlines. This is the simplest and most common case, but we cannot
                forget of the more general one (different tempi and time signatures, yielding various barlines asynchronicities).

    @remark        Unlike measures, chords, notes and voices, when tuttipoints are recalculated (which only happens when "big" changes are made, such as
                a creation of a measure, or a rebuilding of the object from parameter inlets), they are recalculated from scratch, so the previous
                tuttipoint linked list is deleted, and a new one is created. You should NEVER rely on a specific address of a tuttipoint. Use the address
                of a tuttipoint first measure, if you need!
    
    @ingroup    notation
 */ 
typedef struct _tuttipoint
{
    long        ID;                                ///< Number of the tuttipoint, 0-based, in the progressive order of the score
    
    t_measure    *measure[CONST_MAX_VOICES];        ///< First measures in the tuttipoint region. For each voice v there is an entry, which is the 
                                                ///< first measure in voice v which is inside the tuttipoint region, or - equivalently - 
                                                ///< the measure of voice v which is aligned to the measure of other voices at the tuttipoint. 
    
    double        offset_ux;        ///< Unscaled offset (in pixels) of the tuttipoint x position (with respect to the beginning of the score)
    double        width_ux;        ///< Unscaled width (in pixels) of the tuttipoint region (region between the tuttipoint and the next one)
    double        onset_ms;        ///< Tuttipoint onset in milliseconds, precise.
    double        duration_ms;    ///< Tuttipoint duration in milliseconds, precise.
    
    // utilities
    char        all_voices_are_together;    ///< Flag telling if all voices at the tuttipoint are together (it could be indeed that some voice is missing, because it has already ended before the others)
    char        simple_single_measure_tuttipoint;       ///< Flag telling if the tuttipoint is of the simplest kind: a single measure throughout all voices
    
    // alignment points
    struct _alignmentpoint    *firstalignmentpoint;        ///< Pointer to the first alignment point in the tuttipoint region
    struct _alignmentpoint    *lastalignmentpoint;        ///< Pointer to the last alignment point in the tuttipoint region
    long                    num_alignmentpoints;        ///< Number of alignment points in the linked list
    
    // spacing - all the spacing fields are the SAME as the ones in the #t_measure structure. Refer to them to have complete information!
    double        is_spacing_fixed;                        ///< A flag telling if the global unscaled width of the tuttipoint region is fixed (locked, 1) or floating (0, i.e. might change depending on tuttipoint content)
    double        fixed_spacing_uwidth;                    ///< If the unscaled width is locked, here is the fixed unscaled width value (in pixels) of the tuttipoint region.
    double        local_spacing_width_multiplier;            ///< Local spacing multiplier for the tuttipoint region. This is always kept up to date with the
                                                        ///< same field in the #t_measure structure (see this field to have more information), so that
                                                        ///< each tuttipoint region and all the measures inside the region always have the same local spacing multiplier
                                                        ///< Incidentally, this is \gamma^\times in the functions documentation.

    double        fixed_barline_ts_uwidth;                ///< Amount of unscaled width of the tuttipoint spacing due to the presence of time signature and barlines (in pixels)
        
    // flags
    char        need_recompute_spacing;            ///< A flag telling if we need to recompute the spacing within this tuttipoint region, one of the #e_spacing_calculation_types
    long        flag;                            ///< Internal, for private use: generic flag.
    
    ////
    double      data;                           ///< Internal
    
    // double linked list
    struct _tuttipoint*    next;        ///< Pointer to the next tuttipoint in the score
    struct _tuttipoint*    prev;        ///< Pointer to the previous tuttipoint in the score
} t_tuttipoint;


/** The data structure representing an alignment point (only used in [bach.score]).
    An alignment point is a sort of marker relying some musical entities which happen at the same time.
    Alignment points are only used inside tuttipoint_calculate_spacing() to calculate the spacing of a tuttipoint region.
 
    @remark        Alignment points are stored in each tuttipoint structure. They are just calculated innerly inside the function
                tuttipoint_calculate_spacing(), which builds them, spaces them, sets the spacing values inside the chords and measure proper fields.
                But at any new spacing, their address change, so NEVER rely on a specific address of an alignment point!
 
    @ingroup    notation
 */ 
typedef struct _alignmentpoint 
{
    struct _tuttipoint*    tuttipoint_reference;    ///< Pointer to the tuttipoint (region) reference

    long                num_aligned_obj;                    ///< Number of aligned objects
    
    // quantities depending on the aligned object (arrays)
    t_notation_item        *aligned_obj[3 * CONST_MAX_VOICES];    ///< Pointers to the aligned objects: might be either #k_CHORD or #k_TEMPO or #k_MEASURE
    t_timepoint            timepoints[3 * CONST_MAX_VOICES];    ///< Timepoint of each aligned object
    long                voice_number[3 * CONST_MAX_VOICES]; ///< Voice of each aligned object (as the inner voice index, 0-based)
    t_rational            r_onset_sym[3 * CONST_MAX_VOICES];    ///< Symbolic onset of each aligned object with respect to the tuttipoint.
                                                            ///< This symbolic onset is the "symbolic time" which has run from the tuttipoint to the event; for instance
                                                            ///< if an event happens 1 measure and a half after the tuttipoint, and measures have time signature 3/4,
                                                            ///< then this symbolic onset is 3/4 + 1/2 * 3/4 = 3/4 + 3/8 = 9/8.
    
    // general quantities for the alignment point
    double                onset_ms;
    double                offset_ux;                    ///< Unscaled horizontal offset alignment point with respect to the tuttipoint pixel position.
                                                    ///< Once again: if objects are aligned, they all share this quantity.

    double                k;    ///< Spring constant for the spring starting with the alignment point. This is only used with #k_SPACING_SPRING spacing type.

    // quantities
    double                left_uext;                        ///< Left unscaled extension: unscaled horizontal space (in pixels) needed to properly draw the aligned objects, at the LEFT of the alignment point 
    double                right_uext;                        ///< Right unscaled extension: unscaled horizontal space (in pixels) needed to properly draw the aligned objects, at the RIGHT of the alignment point 
    double                left_uext_due_to_lyrics;        ///< Portion of the left unscaled extension which is merely due to the fact that some aligned chords has some lyrics
    double                right_uext_due_to_lyrics;        ///< Portion of the right unscaled extension which is merely due to the fact that some aligned chords has some lyrics
    double                left_uext_due_to_dynamics;        ///< Portion of the left unscaled extension which is merely due to the fact that some aligned chords has some dynamics
    double                right_uext_due_to_dynamics;        ///< Portion of the right unscaled extension which is merely due to the fact that some aligned chords has some dynamics
    double                left_uext_due_to_grace_chords;    ///< (YET UNUSED) Portion of the left unscaled extension which is merely due to the fact that there are some grace notes
    double                global_lyrics_uwidth;            ///< Maximum unscaled width of the lyric content throughout all the aligned objects 
    double                global_dynamics_uwidth;            ///< Maximum unscaled width of the dynamics content throughout all the aligned objects

    // double linked list
    struct _alignmentpoint*    next;        ///< Pointer to the next alignment point
    struct _alignmentpoint*    prev;        ///< Pointer to the previous alignment point

} t_alignmentpoint;



/** The data structure representing a rollvoice (only used in [bach.roll]).
    It inherits all the #t_voice structure properties, and extends them.
    @see        #t_voice
    @ingroup    notation
 */ 
typedef struct _rollvoice
{
    t_voice        v_ob;            ///< The #t_voice object containing the common fields for #t_rollvoice and #t_scorevoice. Must ALWAYS be the first field!!!
    
    long        num_chords;        ///< Number of chords in the rollvoice
    t_chord        *firstchord;    ///< Pointer to the first chord of the voice
    t_chord        *lastchord;        ///< Pointer to the last chord of the voice

    // double linked list
    struct _rollvoice*    next;    ///< Pointer to the next rollvoice
    struct _rollvoice*    prev;    ///< Pointer to the previous rollvoice
} t_rollvoice;


/** The data structure representing a scorevoice (only used in [bach.score]).
    It inherits all the #t_voice structure properties, and extends them.
    @see        #t_voice
    @ingroup    notation
 */ 
typedef struct _scorevoice
{
    t_voice                v_ob;            ///< The #t_voice object containing the common fields for #t_rollvoice and #t_scorevoice. Must ALWAYS be the first field!!!
    
    long                num_measures;    ///< Number of measures in the rollvoice
    struct _measure*    firstmeasure;    ///< Pointer to the first measure of the voice
    struct _measure*    lastmeasure;    ///< Pointer to the last measure of the voice

    // double linked list
    struct _scorevoice*    next;            ///< Pointer to the next scorevoice
    struct _scorevoice*    prev;            ///< Pointer to the previous scorevoice
} t_scorevoice;


/** The data structure representing a marker.
    @ingroup    notation
 */ 
typedef struct _marker
{
    t_notation_item        r_it;            ///< The notation item with the common fields to all notation elements (for instance, name of the marker is inside)

    double                name_uwidth;        ///< Unscaled width of the marker name label
    char                need_update_name_uwidth; ///< Flag telling if the #name_uwidth field should be updated at the next paint() cycle
    
    char                attach_to;            ///< One of the #e_marker_attach, determining to what the marker is attached
    double                position_ms;        ///< Position of the marker in ms
    unsigned long        measure_attach_ID;    ///< ID of the measure to which the marker is attached (if attached to measure)
    t_rational            r_sym_pim_attach;    ///< Symbolic position in measure (pim) of the marker with respect to the beginning of the measure (for instance 1/8 = after 1/8 from the measure beginning) 

    e_marker_roles        role;                ///< One of the #e_marker_roles, defining the special role the marker might have in [bach.roll] (specifying, for instance, a tempo value when a midifile is imported, or a time signature value...) 
    t_llll                *content;            ///< If the role is #k_MARKER_ROLE_TEMPO or #k_MARKER_ROLE_TIME_SIGNATURE, here we'll have the content specifying the tempo, as (tempo_value) or (tempo_figure tempo_value), or the time signature, as (num den) or ((num1 num2...) den) 
    
    // utility
    char                name_painted_direction;                    ///< Field filled at painttime telling if a marker's name has been painted at the LEFT of the marker line (value -1) or at the right of the marker line (value 1). Value 0 means "still unset".
    long                name_line;                  ///< Filled at painttime telling on which "line" a markername is
    double                ux_difference_with_mousedown_marker;    ///< Used by handling mousedragging in [bach.score], difference in unscaled horizontal pixels of the marker position with respect to the marker on which the mouse is down. 
    
    // dummy fields
    long                meas_for_attr;    ///< Dummy field, only used for bach-attributes
    long                voice_for_attr;    ///< Dummy field, only used for bach-attributes
    
#ifdef BACH_MARKERS_HAVE_SLOTS
    t_slot        slot[CONST_MAX_SLOTS];          ///< The array containing the slot content for the marker (for each slot)
#endif

    // double linked list
    struct _marker*        next;            ///< Pointer to the next marker
    struct _marker*        prev;            ///< Pointer to the previous marker
} t_marker;


/** The data structure representing the starting point of the loop region
    @ingroup    notation
 */ 
typedef struct _loop_start
{
    t_notation_item        r_it;                ///< The notation item with the common fields to all notation elements
    double                position_ms;        ///< Position of the loop start in ms
    t_timepoint            timepoint;            ///< Timepoint of the loop start (for bach.score)
} t_loop_start;


/** The data structure representing the ending point of the loop region
    @ingroup    notation
 */ 
typedef struct _loop_end
{
    t_notation_item        r_it;                ///< The notation item with the common fields to all notation elements
    double                position_ms;        ///< Position of the loop end in ms
    t_timepoint            timepoint;            ///< Timepoint of the loop end (for bach.score)
} t_loop_end;


/** The data structure representing a loop region
    @ingroup    notation
 */ 
typedef struct _loop_region
{
    t_notation_item        r_it;    ///< The notation item with the common fields to all notation elements
    t_loop_start        start;    ///< Loop starting point
    t_loop_end            end;    ///< Loop ending point
} t_loop_region;



/** The data structure representing the typographical preferences for a notehead. As always, unscaled pixel values are given for zoom_y = 1.
    @ingroup    typographical
 */
typedef struct _notehead_preferences
{
    t_symbol        *fullname;                      ///< Full notehead name (e.g. "diamond")
    t_symbol        *shortname;                     ///< Short notehead name (e.g. "diam")
    t_symbol        *alias[5];                      ///< Up to 5 aliases for the name (e.g. "d")

    t_symbol        *font;                          ///< NULL if this coincides with the t_notation_obj::notation_font, otherwise specific font
    double            base_pt;                        ///< Font size for the articulation character for zoom_y = 1.

    // Different characters (for different types of noteheads) can be assigned to the same custom notehead element
    // For simple cases they should all coincide to the same unicode character
    unicodeChar        unicode_character_black;        ///< Unicode characters for "black" notes
    unicodeChar        unicode_character_white;        ///< Unicode characters for "white" notes
    unicodeChar        unicode_character_whole;        ///< Unicode characters for "whole" notes
    unicodeChar        unicode_character_doublewhole;  ///< Unicode characters for "double whole" notes
    

    double            uwidth;                ///< Unscaled widths of the notehead symbols
    double            ux_shift;                ///< Unscaled horizontal shift of the notehead, with respect to a default reference position
    double            uy_shift;                ///< Unscaled vertical shift of the notehead, with respect to a default reference position (30 pixel up are already by default)
    double            small_ux_shift;        ///< Unscaled horizontal shift of the notehead of a 'small note' (e.g. grace note), with respect to a default reference position
                                                    ///< A 'small note' is a note smaller than the normal size, appearing in tempo equalities (quarter = ...), or in tuplet
                                                    ///< symbolic ratio labels (3 sixteenth : 2 eights), or in grace notes
    double            small_uy_shift;        ///< Unscaled vertical shift of the notehead of a 'small note' (e.g. grace note), with respect to a default reference position (no pixels are by default).
                                                    ///< A 'small note' is a note smaller than the normal size, appearing in tempo equalities (quarter = ...), or in tuplet

    double            durationline_start_ux_shift;    ///< Unscaled horizontal shift of the beginning of the duration line with respect to the full note width
    
} t_notehead_preferences;



/** The data structure representing the typographical preferences for noteheads. As always, unscaled pixel values are given for zoom_y = 1.
    Defined articulations ID are listed in #e_noteheads.
    Depending on the chosen notation font, the function load_articulations_typo_preferences() updates all these values.
    
    @ingroup    typographical
 */
typedef struct _noteheads_typo_preferences
{
    long                    num_noteheads;  // number of defined noteheads (<= CONST_MAX_NOTEHEADS), including the DEFAULT ones
    t_notehead_preferences  *nhpref;        // actual notehead preferences for each one of them (allocated at startup with size #CONST_MAX_NOTEHEADS)
} t_noteheads_typo_preferences;



/** The data structure representing the typographical preferences for notation symbols (noteheads, time signatures, rests, dots, clefs, flags).
    Accidentals and articulation are separately handled via the #t_accidentals_typo_preferences and #t_articulations_typo_preferences structures.
    All the specifications are unscaled, meaning that they refer to the standard zoom_y = 1 situation.
    Depending on the chosen notation font, the function load_notation_typo_preferences() updates all these values.
 
    @remark        For information, the zoom_y = 1 situation correspond to the fact that staff lines are 6 pixels apart (vertically).
 
    @remark        Some of those values could be computed by calculating text width or height. We prefer to handle them more finely and statically.
 
    @remark        Stems are not painted as font glyphs, but as simple lines.
 
    @ingroup    typographical
 */ 
typedef struct _notation_typo_preferences
{
    // font size
    double            base_pt;        ///< Font size for notation elements corresponding to zoom_y = 1 (usually 24, at least for November for bach, Maestro, Boulez, Engraver...).
    double            base_pt_ts;        ///< Font size time signatures corresponding to zoom_y = 1 (approximativey the same as <base_pt>, but not always precisely)

    // time signatures
    double            ts_uy_shift;                        ///< Unscaled vertical shift (in pixels) of the time signature with respect to a default reference position
    unicodeChar        numbers_unicode_characters[10];        ///< Unicode characters for the 10 numbers to write in the time signature (0 1 2 3 4 5 6 7 8 9)
    unicodeChar        plus_unicode_character;                ///< Unicode character for the symbol '+' which can be found at the numerator of some time signatures, such as (2+3)/8

    // noteheads: obsolete, now there's a separate #t_noteheads_typo_preferences structure
/*    unicodeChar        noteheads_unicode_characters[4];    ///< Unicode characters for the noteheads rests having symbolic duration of: DOUBLEWHOLE, WHOLE, 1/2, 1/4
    double            notehead_uwidths[4];                ///< Unscaled widths of the notehead symbols for: DOUBLEWHOLE, WHOLE, 1/2, 1/4 characters
    double            notehead_ux_shift;                    ///< Unscaled horizontal shift of the notehead, with respect to a default reference position
    double            notehead_uy_shift;                    ///< Unscaled vertical shift of the notehead, with respect to a default reference position (30 pixel up are already by default) 
    double            small_notehead_ux_shift;            ///< Unscaled horizontal shift of the notehead of a 'small note', with respect to a default reference position
    double            small_notehead_uy_shift;            ///< Unscaled vertical shift of the notehead of a 'small note', with respect to a default reference position (no pixels are by default).
                                                        ///< A 'small note' is a note smaller than the normal size, appearing in tempo equalities (quarter = ...), or in tuplet
                                                        ///< symbolic ratio labels (3 sixteenth : 2 eights), or in grace notes
    */
    
    
    // dots
    unicodeChar        dot_unicode_character;            ///< Unicode character for the dot '.'
    
    // rests
    unicodeChar        rests_unicode_characters[9];    ///< Unicode characters for the rests having symbolic duration of: DOUBLEWHOLE, WHOLE, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128
    double            rest_uwidths[9];                ///< Unscaled widths of the rests symbols for: DOUBLEWHOLE, WHOLE, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128
    double            rest_ux_shift;                    ///< Unscaled horizontal shift of the rests, with respect to a default reference position
    double            rest_uy_shift;                    ///< Unscaled vertical shift of the rests, with respect to a default reference position

    // clefs
    unicodeChar        clefs_unicode_characters[4];    ///< Unicode characters for the clefs: G clef, F clef, C clef, Percussion clef
    double            clef_ux_shift;                    ///< Unscaled horizontal shift of the clefs, with respect to a default reference position
    double            clef_uy_shift;                    ///< Unscaled vertical shift of the clefs, with respect to a default reference position
        
    // flags
    unicodeChar        flag_unicode_characters[6];        ///< Unicode characters for the following flags: 1/8 (stem up), 1/8 (stem down), 
                                                    ///< 1/16 (stem up), 1/16 (stem down), further flag (stem up), further flag (stem down).
                                                    ///< The 1/8 flag is just the flag for the simple 1/8 note; the 1/16 flag is the double flag for 
                                                    ///< the 1/16 note. All the smaller durations, add some more flags to the 1/16 flag; each one of this
                                                    ///< additional flags is a "further flag". Thus for example, an unbeamed 1/64 note has a 1/16 flag and 
                                                    ///< two 'further flags'.
    char            flag_noteheadaligned[6];        ///< 1 if the corresponding character is notehead aligned (aligned as if there was a notehead), 0 if it is left-aligned
                                                    ///< 1/8 (stem up), 1/8 (stem down), 1/16 (stem up), 1/16 (stem down), further flag (stem up), further flag (stem down)
    double            flag_uy_shifts[6];                ///< Unscaled vertical shift (in pixels) for each flag of the previous sequence:
                                                    ///< 1/8 (stem up), 1/8 (stem down), 1/16 (stem up), 1/16 (stem down), further flag (stem up), further flag (stem down)
    double            further_flag_uy_step_stemup;    ///< Unscaled vertical distance (in pixels) between a 'further flag' and the following 'further flag', for stem UP flags
    double            further_flag_uy_step_stemdown;    ///< Unscaled vertical distance (in pixels) between a 'further flag' and the following 'further flag', for stem DOWN flags
    double            flag_uwidths[3];                ///< Unscaled widths (in pixels) for the: 1/8 flag, 1/16 flag, further flag.
    double            flag_ux_shift;                    ///< Unscaled horizontal shift (in pixels) of the flag with respect to a default reference position (should be always 0, except for extremely bad formed fonts)
} t_notation_typo_preferences;



/** The data structure representing the typographical preferences for a single articulation. As always, unscaled pixel values are given for zoom_y = 1.
    @ingroup    typographical
 */
typedef struct _articulation_preferences
{
    t_symbol        *fullname;                      ///< Full articulation name (e.g. "portato")
    t_symbol        *shortname;                     ///< Short articulation name (e.g. "port")
    t_symbol        *alias[5];                      ///< Up to 5 aliases for the name (e.g. "por")

    t_symbol        *font;                          ///< NULL if this coincides with the t_notation_obj::notation_font, otherwise specific font
    double            base_pt;                        ///< Font size for the articulation character for zoom_y = 1.

    unicodeChar        main_char;                     ///< Unicode character for the main symbol of the articulation
    unicodeChar        flipped_char;                  ///< Unicode character for the flipped symbol of the articulation

    char            positioning;                    ///< Positioning specification for the articulation: must be one of the #e_articulation_positioning
    long            options;                        ///< Option specification for the articulation: must be one of the #e_articulation_options
    
    double            main_char_ux_shift;             ///< Unscaled horizontal shift (in pixels) of the main character with respect to the chosen <positioning>
    double            main_char_uy_shift;             ///< Unscaled vertical shift (in pixels) of the main character with respect to the chosen <positioning>
    double            flipped_char_ux_shift;         ///< Unscaled horizontal shift (in pixels) of the flipped character with respect to the chosen <positioning>
    double            flipped_char_uy_shift;         ///< Unscaled vertical shift (in pixels) of the flipped character with respect to the chosen <positioning>
    double            outside_staff_uy_nudge;         ///< Additional unscaled vertical shift (in pixels) to kick the articulation symbol 'even more' outside the staff (if it should be placed outside the staff!)
    
    double            main_uy_center;                 ///< Unscaled vertical distance (in pixels) between the center of the main symbol (actually, the center of the bounding rectangleof the main symbol) and the topmost y position of the chord to which it refers to.
                                                                                ///< Change it if you want to get the articulation farther or nearer with respect to the chord.
    double            main_uheight;                  ///< Unscaled height of the bounding rectangle for the main symbol
    double            flipped_uy_center;             ///< Unscaled vertical distance (in pixels) between the center of the flipped symbol (actually, the center of the bounding rectangleof the flipped symbol) and the bottommost y position of the chord to which it refers to.
                                                                                ///< Change it if you want to get the articulation farther or nearer with respect to the chord.
    double            flipped_uheight;                ///< Unscaled height of the bounding rectangle for the flipped symbol
    
    unicodeChar        extension_line_char;            ///< Unicode character for the articulation extension (e.g. the '~' character for the tr~~~~~~)
    double            extension_line_uy_offset;      ///< Unscaled vertical offset for the articulation extension line with respect to the associated articulation position.
                                                                                ///< E.g. this is useful to shift the ~~~~~~ higher or lower with respect to the 'tr' symbol.
    
    // XML export stuff
    t_symbol        *xmlornament;
    t_symbol        *xmltechnical;
    t_symbol        *xmlarticulations;
} t_articulation_preferences;


/** The data structure representing the typographical preferences for articulations. As always, unscaled pixel values are given for zoom_y = 1.
    Defined articulations ID are listed in #e_articulations.
    Depending on the chosen notation font, the function load_articulations_typo_preferences() updates all these values.
    
    @ingroup    typographical
 */
typedef struct _articulations_typo_preferences
{
    long                        num_articulations;  // number of defined articulations (<= CONST_MAX_ARTICULATIONS), including the NONE one
    t_articulation_preferences  *artpref;           // actual articulation preferences for each one of them (allocated at startup with size #CONST_MAX_ARTICULATIONS)
} t_articulations_typo_preferences;


/** The data structure representing the typographical preferences for accidentals. As always, unscaled pixel values are given for zoom_y = 1.
    Depending on the chosen notation font, the function load_accidentals_typo_preferences() updates all these values.

    @remark        What we call 'vertical pitch reference position' for an accidental, is the y position of the center of the note to which it refers to.
                For instance, for Eb, just above the middle C, the vertical pitch reference position for the b is the vertical position of the bottommost staff line.
 
    @ingroup    typographical
 */ 
typedef struct _accidentals_typo_preferences
{
    double            base_pt;                            ///< Font size for the accidentals for zoom_y = 1.
    double            ux_shift;                            ///< Unscaled horizontal shift (in pixels) of the accidentals with respect to a default reference position (usually 0.)
    double            uy_shift;                            ///< Unscaled vertical shift (in pixels) of the accidental text box, with respect to the vertical pitch reference position.
                                                        ///< (This is usually much bigger than 0, depending on the font!)
    
    // binary accidentals
    char            binary_characters_depth;            ///< Depth of the binary character mapping. 
                                                        ///< Depending on the font, this is a number telling how deep in the binary semitone subdivision we can go, still having accidental symbols 
                                                        ///< mapped to be used as accidentals for the specified subdivision.
                                                        ///< Common values are: 2 = the font has only semitones alteration; 4 = has also quartertonal alterations; 8 = has also octotonal alterations 
                                                        ///< Values greater than 8 are not supported.
    unicodeChar        unicode_binary_character[17];        ///< Unicode characters for the eight-tone sequence of accidentals. The sequence namely is:
                                                        ///< -1 tone (double flat), -7/8 tone, -3/4 (tribemol), -5/8, -1/2 (flat), -3/8, -1/4 (mobemol), -1/8,
                                                        ///< 0 (natural), +1/8, +1/4 (monesis), +3/4, +1/2 (sharp), +5/8, +3/4 (triesis), +7/8, +1 tone (double sharp)
                                                        ///< This sequence is the sequence to which also the fields <binary_top_uextension>, <binary_bottom_uextension> and <binary_uwidth> refer to.
    double            binary_top_uextension[17];            ///< Unscaled extension (in pixels) of the accidental from the vertical pitch reference position to the topmost accidental point. Sequence is the previously exposed octotonal sequence, from -1tone to +1tone.
    double            binary_bottom_uextension[17];        ///< Unscaled extension (in pixels) of the accidental from the vertical pitch reference position to the bottommost accidental point. Sequence is the previously exposed octotonal sequence, from -1tone to +1tone.
    double            binary_uwidth[17];                    ///< Unscaled width (in pixels) of the accidental. Sequence is the previously exposed octotonal sequence, from -1tone to +1tone.
    
    // ternary accidentals: STILL UNSUPPORTED (and we don't know if it will ever be supported)
    char            ternary_characters_depth;            ///< UNSUPPORTED. 
                                                        ///< It should be the same thing as #binary_characters_depth, but for ternary subdivision. Yet it's not supported
    unicodeChar        unicode_ternary_character[13];        ///< UNSUPPORTED. 
                                                        ///< It should be the sequence of unicode symbols for the accidentals: 
                                                        ///< -1 tone, -5/6 tone, -2/3, -1/2, -1/3, -1/6, 0 (natural), +1/6, +1/3, +1/2, +2/3, +5/6, +1 tone
    double            ternary_top_extension[13];            ///< UNSUPPORTED. 
                                                        ///< It should be the unscaled extension (in pixels) of the accidental from the vertical pitch reference position to the topmost accidental point. Sequence is the previously exposed sixth-tonal sequence, from -1tone to +1tone.
    double            ternary_bottom_extension[13];        ///< UNSUPPORTED. 
                                                        ///< It should be the unscaled extension (in pixels) of the accidental from the vertical pitch reference position to the bottommost accidental point. Sequence is the previously exposed sixth-tonal sequence, from -1tone to +1tone.
    double            ternary_width[13];                    ///< UNSUPPORTED. 
                                                        ///< It should be the unscaled width (in pixels) of the accidental. Sequence is the previously exposed sixth-tonal sequence, from -1tone to +1tone.

    // bogus character
    unicodeChar        unicode_bogus_character;            ///< Unicode character of the 'bogus' character. The 'bogus' character is shown, instead of accidentals, 
                                                        ///< when the user chooses to show with classical accidental graphics some accidentals which don't have any
                                                        ///< corresponding character inside the chosen font. Usually the bogus character is a circle, such as 'o'.
    double            bogus_top_uextension;                ///< Unscaled extension (in pixels) of the bogus character, from the vertical pitch reference position to the topmost bogus character point.
    double            bogus_bottom_uextension;            ///< Unscaled extension (in pixels) of the bogus character from the vertical pitch reference position to the bottommost bogus character point
    double            bogus_uwidth;                        ///< Unscaled width (in pixels) of the bogus character.
} t_accidentals_typo_preferences;



/** A structure representing a rectangle (as a selection rectangle) in a notation object.
    @ingroup    notation
 */ 
typedef struct _notation_rect
{
    t_voice            *top_voice;        ///< Voice in which the top side of the rectangle lies
    t_voice            *bottom_voice;    ///< Voice in which the top side of the rectangle lies
    double            top_mc;            ///< Cents of the top side of the rectangle (relative to <top_voice>)
    double            bottom_mc;        ///< Cents of the bottom side of the rectangle (relative to <bottom_voice>)
    double            left_ms;        ///< Milliseconds of the left side of the rectangle (only used by [bach.roll])
    double            right_ms;        ///< Milliseconds of the right side of the rectangle  (only used by [bach.roll])
    double            left_ux;        ///< Unscaled x pixel of the left side of the rectangle (only used by [bach.score])
    double            right_ux;        ///< Unscaled x pixel of the right side of the rectangle  (only used by [bach.score])
} t_notation_rect;



/** A structure representing a cursor for linear-edit.
    @ingroup    notation
 */ 
typedef struct _notation_cursor
{
    t_voice     *voice;     ///< Current voice in which the cursor is. Used by [bach.roll]Â only: If this is NULL, the cursor is NOT active.
    t_measure    *measure;    ///< Current measure in which the cursor is. Used by [bach.score]Â only: If this is NULL, the cursor is NOT active.
    t_chord        *chord;        ///< Current chord on which the cursor is (or NULL if it is at the end of the last measure chord)
    long        step;        ///< Current (vertical) position of the cursor in steps (0 referring to the middle C position, 1 to D and so on)
    long        midicents;    ///< Current (vertical) position of the cursor in midicents
    double      onset;      ///< Cursor onset, used by [bach.roll] only
    t_llll      *touched_measures;   ///< llll containing as H_OBJs the touched measures
} t_notation_cursor;



/** A structure representing the things we might want to prevent from editing (in which case corresponding fields will be non-1)
    @ingroup    notation
 */ 
typedef struct _prevent_edit
{
    char    chord_onset;                ///< Onset of a note or chord
    char    note_duration;            ///< Duration of notes or chords
    char    note_pitch;                ///< Pitches of notes or chords
    char    note_velocity;            ///< Velocities of notes or chords
    char    note_creation;            ///< Note creation
    char    note_deletion;            ///< Note deletion
    char    chord_creation;            ///< Chord creation
    char    chord_deletion;            ///< Chord deletion
    char    note_modification;        ///< Any other note or chord modification (names, graphics, ...) â€“ but not slots, use #slot for that
    
    char    slot;                    ///< Slot modification (any)
    
    char    breakpoints_onset;        ///< Onset of (pitch) breakpoints
    char    breakpoints_pitch;        ///< Pitch of breakpoints
    char    breakpoints_velocity;    ///< Velocity of breakpoints
    char    breakpoints_creation;    ///< Breakpoints creation
    char    breakpoints_deletion;    ///< Breakpoints deletion

    char    measure_creation;        ///< Measure creation
    char    measure_deletion;        ///< Measure deletion
    char    measure_rhythmic_tree;    ///< Measure rhythmic tree
    char    measure_modification;    ///< Any other measure modification

    char    voice_creation;            ///< Creation of a voice
    char    voice_deletion;            ///< Deletion of a voice
    char    voice_name;                ///< Name of a voice
    char    voice_clef;                ///< Clefs
    char    voice_key;                ///< Keys
    char    voice_position;            ///< Positions of voices
    char    voice_modification;

    char    timesignature_modification;

    char    tempo_creation;
    char    tempo_deletion;
    char    tempo_modification;

    char    marker_onset;
    char    marker_name;
    char    marker_creation;
    char    marker_deletion;
    char    marker_modification;
    
    char    articulation_creation;
    char    articulation_deletion;

    char    selection_single;
    char    selection_multiple;

    char    zooming;
    char    dilation_rect;
    char    grouping;
    char    inspector;
    char    popup_menu;
    char    slotinfo;
    char    lyrics;
    char    dynamics;
    char    cursor;
    char    loop_region;
    char    scrollbar;
    char    drop;
} t_prevent_edit;


/** A structure representing the configuration of a single slot, i.e. the set of parameters handling its general behaviour and shape.
    @ingroup    notation
    @ingroup    slots
 */ 
typedef struct _slotinfo
{
    long        slot_num;                                ///< 0-based slot number
    t_symbol    *slot_name;                                ///< Name of the slot
    char        slot_type;                                ///< Type of the slot, must be one of #e_slot_types
    char        slot_temporalmode;                      ///< Temporal mode of the slot, must be one of the #e_slot_temporalmodes
    char        extend_beyond_tails;                    ///< Temporal slots can extend beyond note tails
    
    double        slot_domain[2];                            ///< Domain of the slot (minimum and maximum value, only for #k_SLOT_TYPE_FUNCTION slots)
    double        slot_domain_par;                        ///< Slope parameter (-1 to 1) which can desplay exponentially the slot domain
    double        slot_range[2];                            ///< Range of the slot (minimum and maximum value)
    double        slot_range_par;                            ///< Slope parameter (-1 to 1) which can display exponentially the slot range (see #t_pts to know more about the slope)
    double        slot_zrange[2];                            ///< Range of the 3rd dimension (the one "coming out from the screen) for #k_SLOT_TYPE_3DFUNCTION slots (minimum and maximum value)
    double        slot_zrange_par;                        ///< Slope parameter (-1 to 1) which can display exponentially the of the 3rd dimension (the one "coming out from the screen) for #k_SLOT_TYPE_3DFUNCTION slots

    
    t_llll        *slot_repr;                                ///< Slot representation. This can be:
                                                        ///< - a single symbol, such as "Hz", and will be understood as unit of measurement;
                                                        ///< - a plain llll, such as "(John George Ringo)", which will be understood as enumeration content for
                                                        ///<   #k_SLOT_TYPE_INT or #k_SLOT_TYPE_INTLIST types of slots (numbers of these slot will be displayed with 
                                                        ///<   the written symbols instead, first number in the range with first symbol, second possible number with 
                                                        ///<   second symbol, and so on)
                                                        ///<   The plain llll having 2 elements, such as "(3, 4)" will be understood, for matricial slots (#k_SLOT_TYPE_TOGGLEMATRIX, 
                                                        ///<   #k_SLOT_TYPE_INTMATRIX, #k_SLOT_TYPE_FLOATMATRIX) as the number of rows and columns in the matrix
                                                        ///< - an llll having depth 2, such as "((row1 row2) (col1 col2))", which will be understood for matricial slots
                                                        ///<   as the list of row names and colum names
    
    t_llll        *grid;                                  ///< Slot grid values, in the form (x1 x2 x3...) (y1 y2 y3...) or
                                                        ///< ((x1 x1_label) (x2 x2_label)...) ((y1 y1_label) (y2 y2_label)...)
    
    char        slot_key;                                ///< Ascii value of the keyboard key which is a shortcut to open the slot window
    t_llll        *slot_ysnap;                            ///< Snap points in the range for #k_SLOT_TYPE_FUNCTION slots (points to which, by adding Alt while dragging, 
                                                        ///< dragged point is immediately attracted)
    t_llll        *slot_zsnap;                            ///< Snap points in the z-range for #k_SLOT_3dFUNCTION slots (points to which, by adding Alt while dragging, 
                                                        ///< dragged point is immediately attracted)
    double        slot_default;                            ///< Default value of the slot (upon a given key combination, the slot will be set to this value)
    double        slot_uwidth;                            ///< Unscaled width (in pixel) of the slot window. If this value is negative, the slot is 'temporal', 
                                                        ///< which means: the slot window has the same extension as the note duration
    double        slot_active_uheight;                    ///< Unscaled height (in pixel) of the active part of the slot window. If this value is negative, the slot height is 'auto' (default)
    char        slot_singleslotfortiednotes;            ///< Flag telling if we want to have a single slot when some notes are tied. In this case, only a big slot window will
                                                        ///< be displayed throughout all the tied notes, and the content of this slot window will be associated to the first 
                                                        ///< tied note.
    t_jrgba        slot_color;                                ///< Color for the background of the slot window
    
    char        linked_to;                                ///< One of the #e_slot_linkages, representing the thing the slot can be linked to
    char        kept_in_background;                        ///< Is slot kept in background?
    char        appear_in_popup_menu;                    ///< Does slto appear in the contextual popup menu?
    char        pops_up_by_right_click;                    ///< Do right click directly pop up this slot?

    char        copy_when_split;                        ///< Copy slot to all split notes when a note is split into a sequence of tied notes (e.g. via quantization)
    char        trim_with_notehead;                     ///< Increase/decrease slot values as the notehead is trimmed/extended (bach.roll only)

    char        access_type;                            ///< Access type, one of the #e_slot_access_types

    
    // The following are only meaningful for matrix slots:
    double        slot_num_rows;                            ///< Number of rows of the slot
    double        slot_num_cols;                            ///< Number of columns of the slot
    char        slot_has_enum_rows;                        ///< Flag telling if the rows of the slot have names specified in the <slot_repr> (1) or not (0)
    char        slot_has_enum_cols;                        ///< Flag telling if the columns of the slot have names specified in the <slot_repr> (1) or not (0)
} t_slotinfo;


/** A structure representing the configuration of a single command.
 @ingroup    notation
 @ingroup    commands
 */
typedef struct _commandinfo
{
    char        command_key;    ///< Ascii value of the keyboard key which triggers the command.
                                ///< (Commands are a way to have an evaluation dumped from the playout, whose elements are not routed by "note" and "chord", but by any other chosen symbol.
                                ///< One can thusly define commands to operate differently on selection, and retrieve them with [bach.keys] right after the playout)
    t_symbol*    command_name;  ///< Generic name of the command
    t_symbol*    command_note;  ///< Symbol which will be output from the playout instead of the "note" symbol
    t_symbol*    command_chord; ///< Symbol which will be output from the playout instead of the "chord" symbol
    t_symbol*    command_rest;  ///< Symbol which will be output from the playout instead of the "rest" symbol
    t_symbol*    command_marker;  ///< Symbol which will be output from the playout instead of the "marker" symbol
    t_symbol*    start_sym;     ///< Symbol sent BEFORE starting to output
    t_symbol*    end_sym;       ///< Symbol sent AFTER end of output
} t_commandinfo;


/** Manager for the attributes inside the bach environment. Each notation object should have an unique allocated instance of this structure, holding all its attributes
    @ingroup attributes
 */
typedef struct _bach_attr_manager
{
    struct _bach_attribute    attr[CONST_MAX_BACH_ELEMENT_TYPES][CONST_MAX_BACH_ATTR];        ///< Attributes for each #e_element_types
    long                    num_attr[CONST_MAX_BACH_ELEMENT_TYPES];                            ///< Number of attributes for each #e_element_types
    
    bach_inspector_header_fn    inspector_header;
    bach_inspector_image_fn        inspector_image;
    
    char                        adapt_image;           ///< Tells if the inspector image jsurface will be adapted, or just painted. Unused in bach, used in dada.
    double                      adapt_image_max_ratio; ///< If #adapt_image is non-zero, sets a maximum width/height or height/width ratio. Unused in bach, used in dada.
    
//    bach_inspector_header_fn    header[CONST_MAX_BACH_ELEMENT_TYPES];        ///< Function filling a text buffer with the title of the inspector window (one for each #e_element_types), 
//                                                                            ///< which can thus depend on the inspected element. If this is NULL, the default one bach_default_inspector_header_fn() will be used
    bach_inspector_color_fn        color[CONST_MAX_BACH_ELEMENT_TYPES];        ///< Function returning the color for the inspector background. If this is NULL, the default one bach_default_inspector_header_fn() will be used
    bach_inspector_miniature_fn    miniature[CONST_MAX_BACH_ELEMENT_TYPES];    ///< Miniature function for each #e_element_types, or NULL if no miniature is needed for the element
                                                                            ///< Please notice that the miniature is currently NEVER used. It was used once, and it will not probably supported in the future.
} t_bach_attr_manager;

/** Manager for the inspector
    @ingroup inspector
 */
typedef struct _bach_inspector_manager
{
    t_bach_attr_manager            *attr_manager;        ///< Pointer to the attribute manager, containing all bach attributes

    char                        bach_managing;        ///< Flag which only needs to be set if the bach_inspector_manager is used inside the STANDARD bach distribution, and NOT in any bach extension
    
    t_object                    *owner;             ///< Owning object
    
    t_object                    *inspector_patcher;    ///< The patcher containing the external bach inspector (or NULL if inspector is not visible)
    struct _bach_inspector_ui    *inspector_ui;

    void                    *active_bach_inspector_item;        ///< Pointer to the structure whose bach inspector is open, or NULL if bach inspector is closed
    long                    active_bach_inspector_obj_type;        ///< Type of the structure (one of the #e_element_types) whose inspector is open
    t_bach_attribute        *active_inspector_enumindex;                ///< Attribute having an "open" enumindex dropdown menu in the bach inspector 
    long                    active_inspector_enumindex_mouseover_idx;    ///< 0-based index of the element in the bach inspector open enumindex, which has the mouse on it (-1 if none) 
    t_rect                    active_inspector_enumindex_rect;            ///< Rectangle for the active enumindex in the bach inspector
    t_bach_attribute        *active_inspector_color;                    ///< Attribute having an "open" color dropdown palette in the bach inspector 
    t_rect                    active_inspector_color_palette_rect;        ///< Rectangle for the color palette in the bach inspector
    t_rect                    active_inspector_color_spectrum_rect;        ///< Rectangle for the color spectrum in the bach inspector
    t_jrgba                    active_inspector_top_right_color;    ///< Used only by color-typed attributes: the color at the top right position in the color picker
    char                    bach_inspector_show_scrollbar;        ///< Do we show the vertical scrollbar in the bach inspector?
    double                    bach_inspector_scrollbar_delta_y;    ///< Pixel of the inspector vertical scrollbar
    double                    bach_inspector_scrollbar_pos;        ///< 0-1 Position of the inspector vertical scrollbar 
    double                    bach_inspector_scrollbar_height;    ///< Height of the vertical scrollbar in the bach inspector. 
    double                    bach_inspector_scrollbar_top_y;        ///< Top y of the vertical scrollbar in the bach inspector. 
    double                    bach_inspector_items_needed_height;    ///< Needed height to draw all items in the bach inspector. If this is bigger than the real height, the vertical scrollbar will be shown.
    char                    there_is_miniature_in_inspector;    ///< 1 if there is currently a miniature shown in the inspector, 0 otherwise
    t_rect                    active_inspector_miniature_rect;    ///< If there is a miniature, here is its bounding rectangle
    
    t_bach_attribute        *mousedown_attribute;   ///< Pointer to the attribute where the mouse is down (if any), or NULL if none
    t_bach_attribute        *is_editing_attribute;    ///< Pointer to the attribute being edited (if #is_editing_type = #k_BACH_INSPECTOR_ITEM)
    
    method                    redraw_callback;        ///< Paint method for callback

    // "Hack" field to used inspector with non-notation objects
    long (*get_custom_mousedown_obj_type)(void *);  ///< Custom mousedown type getter (for NON-notation objects). The #thing field is passed.
    void *(*get_custom_mousedown_ptr)(void *);       ///< Custom mousedown pointer getter (for NON-notation objects).  The #thing field is passed.
    long (*get_custom_mousedown_ptr_index)(void *);  ///< Custom mousedown type getter (for NON-notation objects). The #thing field is passed.

    void                    *thing;                    ///< Pointer to whatever you wish;
} t_bach_inspector_manager;



/** A family of notation items labeled with the same name 
    @ingroup names
 */
typedef struct _bach_label_family
{
    t_llll            *label;        ///< Label of the family
    t_llll            *items;        ///< Items belonging to the family, as llll of H_OBJs
    t_llllelem        *llelem;    ///< llllelem in families llll
    
    char            need_update_contour;    ///< Flag set if we need to update contour
    t_beziercs        *contour;                ///< Contour as a bezier closed spline
} t_bach_label_family;


/** Manager for the label-like naming 
    @ingroup names
 */
typedef struct _bach_label_manager
{
    t_llll            *families;    ///< As an llll of #t_bach_label_family elements
} t_bach_label_manager;


/** Structure holding the value of realtime attributes
    @ingroup attributes
 */
typedef struct _realtime_attrs
{
    char            legend;
    t_atom          max_undo_steps;
    char            highlight_played_notes;
} t_realtime_attrs;


/** A common structure for UI notation objects. 
    [bach.score], [bach.roll] and [bach.slot] will extend this structure, but most of the stuff is already inside here.
    Moreover, for convenience, some stuff which concerning a single object (such [bach.score]) is still in this structure, for
    possible future improvements or developement of new objects.
 
    @ingroup    notation
 */ 
typedef struct _notation_obj
{
    t_llllobj_jbox        j_box;        ///< The #t_llllobj_jbox structure, corresponding to the fact that notation objects are UI llll objects
                                    ///< (The t_jbox field will be the first field in #t_llllobj_jbox.)
    
    char        obj_type;            ///< Object type. Currently can be one of the following: #k_NOTATION_OBJECT_ROLL. #k_NOTATION_OBJECT_SCORE, #k_NOTATION_OBJECT_SLOT
    long        version_number;        ///< An increasing integer which we store here (as a hidden attribute), to keep track of the object version.
                                    ///< This can be handy to handle backward compatibility in some cases: the object is instantiated, its attributes
                                    ///< are restored, if needed one can then check the needed compatibilities, and then update this #version_number.
                                    ///< N.B.: The version_number attribute is actually EXTREMELY useful: when an object is created in Max its dictionary
                                    ///< has 0 as its default value when the new() method is called for the first time, and something > 0 when e.g.
                                    ///< it was already saved. In order to distinguish the case of a new object creation vs. loading of an already created object
                                    ///< one can easily check whether version_number is 0.

    long        num_voices;                ///< Number of voices
    long        num_voices_plus_one;    ///< Number of voices + 1 (needed as a specific field for voice vertical spacing attribute...)
    t_voice        *firstvoice;            ///< Pointer either to the first voice of the score; corresponding either to the first #t_scorevoice (for [bach.score]) or to the first #t_rollvoice (for [bach.roll]).
    t_voice        *lastvoice;                ///< Pointer either to the last voice of the score, corresponding either to the last #t_scorevoice (for [bach.score]) or to the last #t_rollvoice (for [bach.roll]).
    char        autosize;                ///< Flag which, if set, automatically changes the number of voices depending on the input lllls 
    
    // Parts and staff ensembles
    long        *voice_part;            ///< Voice to part mapping (1-based!! used as attribute)
    t_jrgba     part_colors[CONST_NUM_PART_COLORS];     ///< Colors associated to each one of the parts.
                                                        ///< The element at 0 will only be used for part_index multiples of CONST_NUM_PART_COLORS, but
                                                        ///< will not be used for part_index == 0 (the ordinary note/beam/flag/... colors will be used for index 0).
    char        show_part_colors;       ///< Display different voice parts as different colors
    long        active_part;            ///< 1-based number of the active part
    
    t_group        *firstgroup;            ///< Pointer to the first group
    t_group        *lastgroup;                ///< Pointer to the last group
    long        num_groups;                ///< Number of groups 
    char        show_groups;            ///< Do we want to graphically show the links between elements of the same group? 
    
    char        show_label_families;    ///< Do we want to graphically distinguish the label families, i.e. the groups of notation items sharing the same names?
    
    // clefs
    char            show_clefs;                     ///< Toggles the display of clefs
    char            show_aux_clefs;   ///< Toggles the display of G15ma/F15mb clefs in clef-combinations such as FFGG, FGG, FFG, etc.
    t_symbol        **clefs_as_symlist;                ///< List of clefs as symbols (one for each voice).
                                                    ///< Functions clef_symbol_to_clef_number() and clef_number_to_clef_symbol() operate conversions 
                                                    ///< between symbols (such as "G", "F"...) and numbers (such as #k_CLEF_G, #k_CLEF_F...)
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
    
    
    
    t_llll            *voicenames_as_llll;            ///< Voicenames represented in llll form (one llllelem for each voice)
    char            *hidevoices_as_charlist;        ///< List of 0's and 1's (one for each voice), depending if the voice is hidden (1) or not (0)
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
    double            *voiceuspacing_as_floatlist;    ///< List of unscaled distances (in pixel) between voices. First element is the space before 
                                                    ///< first voice, last element is the space after last voice (and thus these values are #num_voices + 1
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
                                                    ///< It is an array with #CONST_MAX_VOICES + 1 elements allocated in notation_obj_init() and freed by notation_obj_free()
    t_symbol        **keys_as_symlist;                ///< List of key signatures as symbols (one symbol for each voice). 'M' = major, 'm' = minor, so "C#M" is C# major, and so on. 
                                                    ///< Latin and anglosaxon syntax accepted. Functions parse_sym_to_key_and_mode() and notename2midicents()
                                                    ///< operate parsing and conversions
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
    long            *midichannels_as_longlist;        ///< List of midichannels (one for each voice). 
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()

    // tuttipoints, for bach.score
    t_tuttipoint    *firsttuttipoint;               ///< First tuttipoint
    t_tuttipoint    *lasttuttipoint;                ///< Last tuttipoint
    long            num_tuttipoints;                ///< Number of tuttipoints

    
    // staff lines
    t_llll            *stafflines_as_llll;    ///< Stafflines as an llll
    
    // autoclear
    char            autoclear;                ///< If this flag is set, when a reconstruction bang is received, the object is automatically cleared first, and only THEN rebuilt.

    // measure numbers
    char            *show_measure_numbers;            ///< List of flags (one for each voice) telling if we want to show the measure numbers in that voice
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
    double            measure_numbers_font_size;        ///< Font size for the measure numbers (for zoom_y = 1, will be scaled according to the zoom)
    char            show_measure_numbers_on_first_measure; ///< Whether to show also the very first measure number
    
    // private, utilities
    long        add_staff;                    ///< (PRIVATE) Flag which is 1 during the process of staff adding
    long        add_voice;                    ///< (PRIVATE) Flag which is 1 during the process of voice adding
    char        itsme;                        ///< (PRIVATE) General flag to handle calls
    long        private_flag;                ///< (PRIVATE) Generic private long flag
    char        numvoices_handled_at_startup;    ///< (PRIVATE) Flag to tell if the numvoices attribute has already been handled at startup or not
    char        creatingnewobj;                ///< (PRIVATE) Flag which is 1 before the attr_dictionary_process() and 0 afterwards
    char        firsttime;                    ///< (PRIVATE) Flag which is 1 before the first paint method has been called
    char        freeing;                    ///< (PRIVAGE) Flag which is 1 when the freeing of the notation object is started
    char        only_play_selection;        ///< (PRIVATE) Flag which is 1 when the play() function is called via the playselection function
    char        playback_deferlow;          ///< (PRIVATE) Flag which is 1 when play offline function is asked to be defer-lowed at each output
    char        defining_numerator;            ///< (PRIVATE) Flag which is 1 if the user is defining the tuplet numerator in the bach.score linear editing system
    char        item_changed_at_mousedown;    ///< (PRIVATE) Flag which is 1 after mousedown when something has been changed directly on mousedown and NOT on mousedrag; it becomes 0 at mouseup
    long        private_count;                ///< (PRIVATE) Private utility counter
    double      ux_click_marker_diff;       ///< (PRIVATE) Unscaled x pixels difference between the clicked marker and the clicked point
    
    // interface
    long        j_mouse_is_down;                ///< Flag telling if the mouse is down (still clicking, not yet released)
    char        changed_while_dragging;            ///< Flag telling if something has changed while mousedragging (in the mousedrag routine)
    int            j_mouse_is_over;                ///< Flag telling if the mouse is over the object
    int            j_mouse_cursor;                    ///< The active mouse cursor, one of the #e_mouse_cursors
    t_pt        j_mousedown_point;                ///< Last point (in pixels) where the mouse has been clicked
    t_pt        j_mousedrag_point;                ///< Last point (in pixels) where the mouse has been dragged
    t_pt        j_mousedrag_point_shift_ffk;    ///< Mousedrag point taking into account the correction due to the shift key pressed and the "faster from keyboard" Shift+Cmd key combination.
                                                ///< This will coincide with <j_mousedrag_point>, unless the faster from keyboard combination 
                                                ///< is pressed or Shift is pressed.
    char        j_isdragging;                    ///< Flag telling if the mouse is being dragged over the object
    short        j_mouse_hasbeendragged;            ///< Flag telling (mostly at mouseup) if the mouse has been dragged (or just clicked)
    short        j_selection_hasbeendragged;        ///< Flag telling (mostly at mouse up) if the selection content has been dragged
    void        *j_mousedrag_copy_ptr;            ///< Pointer to the object which is being copied (when Alt+Click&dragging on it)
    void        *j_mousedown_ptr;                ///< Pointer to the object on which the mouse is down (NULL if mouse is up)
    int            j_mousedown_obj_type;                ///< Type of the on which the mouse is down (one of #e_element_types, -1 if mouse is up)
    void        *j_last_mousedown_ptr;            ///< Pointer to the last object on which the mouse was down
    int            j_last_mousedown_obj_type;            ///< Type of the last object on which the mouse was down (one of #e_element_types)
    long        j_dragging_direction;            ///< Flag telling the dragging direction: 1 = only horizontal, -1 = only vertical, 0 = all directions (default).
                                                ///< This is typically set when the user add a Shift while dragging (and thus we select one of the 
                                                ///< two main directions, and keep it while continuing dragging)
    double        floatdragging_x;                ///< (INTERNAL) x pixel of the last point reached while dragging, in double precision (this is internal, manually updated only by pieces of code needing it)
    double        floatdragging_y;                ///< (INTERNAL) y pixel of the last point reached while dragging, in double precision (this is internal, manually updated only by pieces of code needing it)
    double        floatdragging_handle_x;            ///< Current (double-precision) value of a dragged slot handle
    long        main_dragging_direction;        ///< Flag telling which is the current main direction. Only makes sense while dragging:
                                                ///< 0 if undefined (and will be setted as soon as possible by the mousedrag function)
                                                ///< 1 if direction is mainly vertical, -1 if direction is mainly horizontal

    double        j_selected_region_ms1;            ///< Start position (in ms) of the selection rectangle
    double        j_selected_region_ms2;            ///< End position (in ms) of the selection rectangle
    double        j_selected_region_mc1;            ///< Start vertical position (in cents) of the selection rectangle
    double        j_selected_region_mc2;            ///< End vertical position (in cents) of the selection rectangle
    long        j_selected_region_voice1;        ///< Start voice number (0-based) of the selection rectangle.
                                                ///< I.e.: the selection rectangle is drawn across which voices? e.g. 2 through 5...
    long        j_selected_region_voice2;        ///< End voice number (0-based) of the selection rectangle. See #j_selected_region_voice1.

    double        j_selected_region_ux1;                ///< Current start unscaled x position of the selection rectangle (used by [bach.score])
    double        j_selected_region_ux2;                ///< Current dnd unscaled x position of the selection rectangle (used by [bach.score])

    char        j_clicked_obj_has_been_selected;    ///< Flag telling if the object on which we have clicked has been selected
    t_notation_item     *check_selection_restraint_for_item;   ///< Notation item for which we need to check whether the selection should be restrained to that only chord (for consecutive clicking)
    
    t_llll        *selected_slot_items;            ///< List containing the #t_slotitem pointers of selected slotitems, if any, or empty list if none (no internal slot selection)
    
    long        j_mouse_x;        ///< Current mouse x position on the jbox 
    long        j_mouse_y;        ///< Current mouse y position on the box
    char        j_has_focus;    ///< Flag telling if the object has the focus
    
    // preset attributes
    t_atom        *preset_av;        ///< Atomarray part of the A_GIMME signature for the list of deparsed llll elements for preset. 
                                ///< To handle very long preset, we need to deparse the llll containing the object status. This might seem limiting to a short number of elements,
                                ///< but actually, thanks to the begin_preset(), restore_preset() and end_preset(), this is not true, and we can store in a preset as many elements as we wish. 
                                ///< This is the usual "ac" part of the A_GIMME signature (number of deparsed elements for preset)
    long        preset_ac;        ///< Number of elements in the atomarray #preset_av (see it for more information).
    
    // patcher parent
    t_object    *patcher_parent;    ///< Pointer to the patcher containing the notation object
    
    // dilation rectangle; this is the rectangle which can be shrinked or enlarged and the selection inside it will change accordingly
    char                show_dilation_rectangle;        ///< 1 if the dilation rectangle is shown
    t_notation_rect        dilation_rectangle;                ///< The dilation rectangle in the current position
    
    // slots fields 
    t_slotinfo    *slotinfo;                    ///< Information about the structure of each slot)
                                            ///< It is an array with #CONST_MAX_SLOTS elements allocated in notation_obj_init() and freed by notation_obj_free()
    double        slot_minimum_window_uwidth;    ///< Unscaled minimum width (in pixels) for a slot window (only for non-temporal slots)
    
    long        active_slot_num;            ///< Number (0-based) of the slot whose slot window is being shown (-1 = normal view: no slot windows are show  n)
    t_notation_item     *active_slot_notationitem;        ///< Pointer to the notation item whose slot <active_slot_num> has an open slot window (or NULL if none)
    long        active_slot_num_1based;            ///< Number (1-based) of the slot whose slot window is being shown. This is always kept synced with
                                                ///< <active_slot_num>, and is only used by bach.slot as an attribute
    
    double        slot_window_ms1;            ///< Starting position (in milliseconds) of the slot window
    double        slot_window_ms2;            ///< Ending position (in milliseconds) of the slot window
    double        slot_window_x1;                ///< x pixel of the left beginning of the slot window
    double        slot_window_x2;                ///< x pixel of the right end of the slot window
    double        slot_window_y1;                ///< y pixel of the top of the slot window 
    double        slot_window_y2;                ///< y pixel of the bottom of the slot window
    t_rect        slot_window;                ///< Slot window as a rectangle, in pixels
    double        slot_window_active_x1;        ///< x pixel of the left usable beginning of the slot window (we've added a pad at the borders of the slot window)
    double        slot_window_active_x2;        ///< x pixel of the right usable end of the slot window (we've added a pad at the borders of the slot window)
    double        slot_window_active_y1;        ///< y pixel of the usable top of the slot window (we've added a pad at the borders of the slot window)
    double        slot_window_active_y2;        ///< y pixel of the usable bottom of the slot window (we've added a pad at the borders of the slot window)
    t_rect        slot_window_active;            ///< Active slot window as a rectangle, in pixels
    t_rect        slot_window_active_nozoom;    ///< Active slot window as a rectangle, in pixels, but ignoring the scaling due to the possible horizontal zooming of the slot window
    double      slot_window_active_unscrolled_width;    ///< Horizontal width of the slot window content, not clipped to the actual window, for slot zoom = 1.
    char        output_slot_names;            ///< If this is 1, the notation object always outputs slot names and NOT slot numbers from the playout (which means: for mode = #k_CONSIDER_FOR_EVALUATION or #k_CONSIDER_FOR_PLAYING or #k_CONSIDER_FOR_PLAYING_AS_PARTIAL_NOTE or #k_CONSIDER_FOR_SELECTION_COPYING)
    double        slot_window_zoom;            ///< Additional zoom (with respect to the #zoom_y field) for the slot windows, 100 being the default one. 
    double        bgslot_zoom;                ///< Additional zoom (with respect to the #zoom_y field) for the background displayed slots, 100 being the default one.
    
    // slope stuff:
    long        slope_mapping_type;                     ///< Slope mapping type, one of the #e_slope_mapping
    char        combine_range_slope_during_playback;    ///< Combines the range slope with the existing slopes during playback
    
    // only used by color slots
    double        slot_window_palette_width;        ///< Width (in pixels) of the main palette in the slot window for slots of type #k_SLOT_TYPE_COLOR
    double        slot_window_spectrum_width;        ///< Width (in pixels) of the spectrum column in the slot window for slots of type #k_SLOT_TYPE_COLOR
    double        slot_window_spectrum_x;            ///< x pixel of the spectrum column in the slot window for slots of type #k_SLOT_TYPE_COLOR
    t_jrgba        slot_top_right_color;            ///< Color at the top-right corner of the current palette (color selected in the right spectre columns)
    
    // only used by matrix slots
    long        slot_clicked_row;                        ///< Currently clicked row in a matrix type slotwindow
    long        slot_clicked_col;                        ///< Currently clicked column in a matrix type slotwindow
    double        slot_window_table_x1;                    ///< x pixel of the top-left angle of the matrix in the slot window 
    double        slot_window_table_y1;                    ///< y pixel of the top-left angle of the matrix in the slot window
    
    double        slot_background_alpha_percentage;    ///< Percentage of transparence of the background of the slot window. 0 = completely transparent, 100 = completely opaque. 
    double        slot_background_font_size;            ///< Font size for the text shown in the background slots (for zoom_y = 1) 

    long        num_background_slots;                ///< Number of slots to be kept drawn in background (also when slot window is closed)
    long        *background_slots;                    ///< List of the slot numbers (1-based!) which have to be kept in background, only the first <num_background_slots> elements are meaningful.
                                                    ///< It is an array with #CONST_MAX_SLOTS elements allocated in notation_obj_init() and freed by notation_obj_free()
    
    long        num_popup_menu_slots;                ///< Number of slots appearing in the contextual menu (when clicking on a note)
    long        *popup_menu_slots;                    ///< List of the slot numbers (1-based!) which have to be in the contextual menu, only the first <num_popup_menu_slots> elements are meaningful.
                                                    ///< It is an array with #CONST_MAX_SLOTS elements allocated in notation_obj_init() and freed by notation_obj_free()
    
    char        mouse_hover;                ///< Flag telling if we allow mouse hovering on the points of the #k_SLOT_TYPE_FUNCTION slots
    t_slotitem    *hovered_slotitem;            ///< Pointer to the currently hovered slot item (typically a #t_slotitem of a function slot) 
    char        hovering_segment;            ///< Flag which is 1 if the #hovered_slotitem in reality represents the segment between the hovered_slotitem->prev and hovered_slotitem (such as a segment in a breakpoint function).
    char        slot_pen_mode;                ///< Flag telling if we are in slot pen mode, i.e. if we're continuously inserting points during mousedrag in functino slots
    
    long        right_click_directly_pops_out_slot;        ///< Number (1-based) of the slot which is automatically popped out when right clicking on a note.
                                                        ///< By default this is 0 (when right clicking no slot is popped out, but the contextual menu!)
    
    char        show_slot_numbers;            ///< Do we want to show the slot number in transparence, in the slot window?
    char        show_slot_labels;            ///< Do we want to display automatically computated labels for function points in the slot windows of slots of type #k_SLOT_TYPE_FUNCTION, and the labels for the bars of the intlist and floatlist slots?
    char        show_slot_legend;            ///< Do we want to display the upper-right slot legend?
    char        dynfilter_interp_mode;        ///< Interpolation mode for the dynamic filters in a #k_SLOT_TYPE_DYNFILTER. 
                                            ///< 0 = the interpolation happens through biquad coefficients, 
                                            ///< 1 = the interpolation happens through freq/gain/Q parameters (currently the only one used â€“ and this is not user changable â€“, for this is the only one who makes sense)

    double        background_slot_text_ushift[2];        ///< Unscaled horizontal and vertical shift of the text written in background in a slot.  
    
    // used for slot window horizontal zooming
    char        allow_horizontal_slot_zooming;    ///< Allow/forbid the horizontal zooming in function, 3dfunction, spat, dynfilter, intlist, sloatlist kinds of slot (N.B.: if the slot is temporal no zooming is possible, as the zooming will be passed to the underlying notation object)
    double        slot_window_hzoom_factor;        ///< Horizontal zoom factor for slot representation (e.g. functions, ecc.)
    double        slot_window_zoomed_start;        ///< Starting point of the zoomed representation (from 0 to 1)
    
    
    // only used by function slots
    double        function_slot_pt_uradius;    ///< Unscaled radius of a function slot point
    

    // only used by filter type of slots
    double        sampling_freq;        ///< Sampling frequency used to properly compute the biquad coefficients in the #k_SLOT_TYPE_FILTER and #k_SLOT_TYPE_DYNFILTER types of slots
    
    // slot linkages: a common way to modify some parameters in bach is to link them with the content of some type of slot 
    long        link_nitemcolor_to_slot;            ///< Number of the slot (1-based) which is linked with the notation item color changes (both
                                                /// for notes and for rests), 0 being no linkage for color, and thus colors are the default ones.
                                                ///< If the the slot is #k_SLOT_TYPE_INT same colors are given to notes having same slot value
                                                ///< If the the slot is #k_SLOT_TYPE_FLOAT colors are given as a gradient (red to blue) from the slot (red) minimum to the slot maximum (blue)
                                                ///< If the the slot is #k_SLOT_TYPE_FLOATLIST, values are interpreted as RGBA values (red, green, blue, alpha coordinates)
    long        link_lyrics_to_slot;            ///< Number of the slot (1-based) which is linked with the lyrics. Must be a slot of type #k_SLOT_TYPE_TEXT (0 = no linkage, thus no lyrics) 
    long        link_notehead_to_slot;        ///< Number of the slot (1-based) which is linked with the notehead characters.
    long        link_notehead_font_to_slot;        ///< Number of the slot (1-based) which is linked with the name of the font for the notehead character.
    long        link_notehead_adjust_to_slot;    ///< Number of the slot (1-based) which is linked with the (ux, uy) adjustments of the notehead character.
                                                ///< If this is note defined, and the notehead character has a custom font (via <link_notehead_font_to_slot>),
                                                ///< the adjustments used are the ones by default loaded with the current notation font
                                                ///< If this is defined, this has to be linked with a floatlist slot, having as items: ux adjust, uy adjust.
    long        link_notesize_to_slot;            ///< Number of the slot (1-based) which is linked with the size of the note.
                                                ///< If the slot is of type #k_SLOT_TYPE_INT or #k_SLOT_TYPE_FLOAT, it has to contain a percentage resize parameter 
                                                ///< (100 = normal size) both for the note and for the accidental.
                                                ///< If the slot is of type #k_SLOT_TYPE_INTLIST or #k_SLOT_TYPE_FLOATLIST, it contains the percentage resize parameters
                                                ///< both for the notehead (first slotitem) and for the accidentals (second slotitem).
    long        link_articulations_to_slot;     ///< Number of the slot (1-based) which is linked with the articulations display.
    long        link_annotation_to_slot;        ///< Number of the slot (1-based) which is linked with the textual annotation display over the staff.
    long        link_dynamics_to_slot;          ///< Number of the slot (1-based) which is linked with the dynamics display under the staff.
    long        link_dlcolor_to_slot;           ///< Number of the slot (1-based) which is linked with the color of the duration lines.
    
    // annotations
    char        show_annotations;               ///< Flag telling if we want to show the textual annotations
    double        annotation_font_size;            ///< Font size for the textual annotations over the staff (for zoom_y = 1)
    char        thinannotations;                ///< Thinning annotation mode, on of the #e_annotations_filterdup_modes
    t_symbol    *annotations_clearingsym;       ///< Symbol to be put automatically, depending on the #thinannotations mode, to clear an annotation
    
    // dynamics
    char        show_dynamics;                  ///< Flag telling if we want to show the dynamics
    char        show_hairpins;                  ///< Flag telling if we want to show the dynamic crescendo/diminuendo hairpins
    double        dynamics_font_size;             ///< Font size for the dynamics (for zoom_y = 1)
    double      dynamics_roman_font_size;       ///< Font size for the textual dynamics-like expressions (for zoom_y = 1)
    double        dynamics_uy_pos;                ///< Unscaled y shift (in pixels) of the lyrics with respect to the staff bottom
    char        dynamics_output_mode;           ///< Output mode for the dynamics: 0 = plain textual form; 1 = detailed; 2 = verbose
    
    // lyrics
    double        lyrics_font_size;                    ///< Font size for the lyrics (for zoom_y = 1)
    double        lyrics_uy_pos;                        ///< Unscaled y shift (in pixels) of the lyrics with respect to the staff bottom
    char        lyrics_alignment;                    ///< Alignment type for the syllabes below chords, must be one of the #e_lyrics_alignments
    char        show_lyrics;                        ///< Flag which tells if we need to show lyrics (1) or not (0)
    char        show_lyrics_word_extensions;        ///< Flag which tells if we need to show the word extensions for lyrics (1) or not (0).
                                                    ///< Word extensions are the ______ lines which continue a syllable over melismas, such as "true______"
    char        lyrics_affect_spacing;                ///< Flag which tells if the lyrics in the score will also affect the spacing of the score.
                                                    ///< 0 = They never affect spacing, 
                                                    ///< 1 = They only change chord position inside measures, but they don't affect measure width
                                                    ///< 2 = They also change measure width, but only if some lyrics are overlapping
                                                    ///< 3 = They also affect measure width, always
    char        dynamics_affect_spacing;            ///< Flag which tells if the dynamics in the score will also affect the spacing of the score.
                                                    ///< 0 = They never affect spacing,
                                                    ///< 1 = They only change chord position inside measures, but they don't affect measure width
                                                    ///< 2 = They also change measure width, but only if some dynamics are overlapping
                                                    ///< 3 = They also affect measure width, always

    // command fields, arrays (containing one element for each command)
    t_commandinfo commands[CONST_MAX_COMMANDS];
    
    // text editor
    t_object *m_editor;                        ///< Text editor (for the #k_SLOT_TYPE_TEXT and #k_SLOT_TYPE_LLLL slot)

    // mutex
    t_systhread_mutex    c_general_mutex;    ///< General mutex for all the operations on the score content, except for markers
    t_systhread_mutex    c_deparse_mutex;    ///< Recursive mutex for deparsing lllls in the anything method
    t_systhread_mutex    c_markers_mutex;    ///< Specific mutex for the markers operations
    t_systhread_mutex    c_undo_mutex;        ///< Specific mutex for the undo llll
    t_bach_atomic_lock    c_atomic_lock;        ///< An atomic lock, for some rare circumstances where it is needed. We usually use the mutex, yet this atomic lock has the advantage that we can call llllobj_output_llll from inside a locked region.
    t_bach_atomic_lock    c_atomic_lock_play;        ///< An atomic lock for the play system, for some rare circumstances where it is needed. We need a dedicated one

    // atomic increments
    t_bach_atomic_lock        c_inuse;            ///< Number for atomic locks, which are currently UNUSED (mutexes are used instead)

    // selection handling
    t_notation_item    *firstpreselecteditem;    ///< Pointer to the first preselected item (see the selection module overview for more information).
    t_notation_item    *lastpreselecteditem;    ///< Pointer to the last preselected item (see the selection module overview for more information).
                                            ///     A preselected item is an item which is being selected as the mouse is being dragged, but is not yet selected. 
                                            ///     It'll be selected (or de-selected, if it was already selected) at the mouseup event.
                                            ///     The function which moves the preselection linked list to the selection linked list is move_preselecteditems_to_selection().

    t_notation_item    *firstselecteditem;        ///< Pointer to the first selected item
    t_notation_item    *lastselecteditem;        ///< Pointer to the last selected item
    long            num_selecteditems;        ///< Number of selected items
    char            selection_type;            ///< Type of the selection, will be one of the #e_element_types. 
                                            ///< E.g. if it is #k_CHORD it means that all selected items are chords,
                                            ///< and so on. If the selection is mixed, this will be #k_MIXED.
    t_notation_item *selectioncursor;       ///< Internal cursor used for selection
    
    // current window attributes in ms (mostly, but not solely, used by [bach.roll])
    double        screen_ms_start;            ///< Position in ms of the beginning of the displayed portion of score
    double        screen_ms_end;                ///< Position in ms of the end of the displayed portion of score
    double        domain;                        ///< Domain, i.e. length of the displayed portion of score shown in the window, in milliseconds (this is <screen_ms_end> - <screen_ms_start>)
    double        length_ms_till_last_note;    ///< True length of the whole score, till the end of the last note. length_ms > length_ms_till_last_note 
    double        length_ms;                    ///< Length of the whole score (in ms), where a little pad after the end of the last note is added.
                                            ///< (The unscaled pad precisely correspond to #CONST_TOTAL_ULENGTH_MARKER_ADD or #CONST_TOTAL_ULENGTH_ADD, depending if last element is a marker or not)
                                            ///< Beware: the pad is added ONLY in [bach.roll]; in [bach.score], <length_ms> = <length_ms_till_last_note>
    double        minimum_length;                ///< (For [bach.roll] only) Minimum length for the object. Even if the object is empty, this is the length it has (as if there was a dummy marker at the minimum length point)
    
    // current window attributes in ux (used by [bach.score])
    double        screen_ux_start;    ///< Unscaled x pixel at the beginning of the displayed portion of score  
    double        screen_ux_end;        ///< Unscaled x pixel at the end of the displayed portion of score
    double        domain_ux;            ///< Unscaled pixel domain, i.e. unscaled width (in pixels) of the displayed portion of score.
                                    ///< Notice that this won't correspond (because of <zoom_y>, because of <zoom_x>) to the actual width in pixels of 
                                    ///< the displayed portion of score 
    double        length_ux;            ///< Length of the whole score in unscaled pixels
                                    ///< Beware: operations like inscreenpos etc. might change this length, in order to appropriately show more portion of score.
    char        highlight_domain;   ///< If toggled, highlights the domain portion of the notation item (useful to align other Max UI objects on top of it).
    char        fade_predomain;     ///< Fade a small left portion of score, before the domain start, with an alpha gradient
    char        onset_in_domain;      ///< Only paint notes whose onset is inside the domain

    // horizontal scrolling
    char        show_hscrollbar;        ///< Flag telling if we want to show the horizontal scrollbar (in case it is needed)
    char        need_hscrollbar;        ///< Flag telling if we need (1) or not (0) the horizontal scrollbar
    double        hscrollbar_pos;            ///< Relative position (0. to 1.) of the horizontal scrollbar (0 = completely at left, 1 = completely at right)
    double        hscrollbar_x;            ///< Pixel position of the leftmost point of the horizontal scrollbar.
                                        ///< This can range from <inset_x> to <j_inset_x> + <inner_width> - <hscrollbar_width>.
    double        hscrollbar_width;        ///< Width (in pixels) of the horizontal scrollbar
    
    
    // vertical scrolling
    char        show_vscrollbar;        ///< Flag telling if we want to show the vertical scrollbar (in case it is needed)
    char        need_vscrollbar;        ///< Flag telling if we need (1) or not (0) the vertical scrollbar
    double        vscrollbar_pos;            ///< Relative position (0. to 1.) of the vertical scrollbar (0 = completely at top, 1 = completely at bottom)
    double        vscrollbar_y;            ///< Pixel position of the topmost point of the vertical scrollbar
    double        vscrollbar_pixnudge;    ///< Nudge (in pixels) of which we have to shift the whole content up or down
    double        vscrollbar_height;        ///< Height (in pixels) of the vertical scrollbar


    // some general common attributes
    char        show_durations;                ///< Flag telling if we want to show the duration-lines for the notes
    char        show_tails;                    ///< Flag telling if we want to display the note tails at the end of each notes (only works if #show_durations is set)
    double        durations_line_width;        ///< Width of the duration line in pixels
    double      breakpoints_size;              ///< Breakpoints size (diamond shape)
    char        dl_spans_ties;              ///< Duration line spans a sequence of tied notes?
    char        velocity_handling;            ///< Parameter handling the way we display the velocity on screen. This must be one of #e_velocity_handling 
    long        tone_division;                ///< Microtonal subdivision, in n-th of tone: 2 = semitone, 4 = quartertone, 17 = 17th of a tone, and so on
    char        accidentals_display_type;    ///< Type of display for the accidentals; must be one of the #e_accidentals_display_type
    e_accidentals_preferences    accidentals_preferences;    ///< Preference for the accidental choice; must be one of the #e_accidentals_preferences
    double      accidentals_decay_threshold_ms;     ///< For [bach.roll] only, handles the decay threshold for accidental naturalization display.
    t_symbol    **full_acc_repr;                    ///< List of accidental representation symbols (one for each voice).
                                                    ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
                                                    ///< Each symbol specifies the full accidental representation for a voice.
                                                    ///< For a semitonal representation a sequence like "n # n # n n b n b n # n" is expected (12 elems)
                                                    ///< For a quartertonal representation a sequence like "n + # - n + # - n + n + b - n db b - n + # #+ n +" is expected (24 elems).
                                                    ///< For a eighttonal representation a sequence like "n ^ + +^ # -v - v n ..." is expected (48 elems).
                                                    ///< # = +1/2, + = +1/4, ^ = +1/8, x = +1 (and you can combine them).
                                                    ///< b = -1/2, - or d = -1/4, v = -1/8 (and you can combine them).
    char        keep_selection_if_lost_focus;        ///< Flag telling if we want to keep the current selection when the UI notation object loses the focus (by default: yes)
    char        legend;                                ///< Flag specifying which kind of legend we want to have.
                                                    ///< 0 = No legend at all; 1 = Only the upper legend when an element is selected; 2 = Also the mouse hovering legend, bottom right.
    char        show_stems;                            ///< Flag telling if we want to show the chord stems
    char        show_auxiliary_stems;                ///< Flag telling if we want to show the chord auxiliary stems. Auxiliary stems are the secondary stems linking notes 
                                                    ///< which are not reachable by the main stem (e.g. dense chords with a lot of unisons...)
    char        allow_glissandi;                    ///< Flag telling if we allot the duration lines to bend, and breakpoints to be added and shown, in order to have glissandi
    char        continuously_output_changed_bang;    ///< Flag telling if the changed-bang has to be sent continuously when changes happen at mousedrag.
                                                    ///< The changed-bang is a bang sent through the last outlet when something in the object has been changed via the interface.
                                                    ///< By default, this if changes happen at mousedrag (e.g. a note is drawn upwards), the changed bang is sent only at mouseup
                                                    ///< since <continuously_output_changed_bang> = 0. Setting <continuously_output_changed_bang> = 1 will force the object to send
                                                    ///< this bangs also while mousedragging.
    char        need_send_changed_bang;                ///< When this is non-zero, the "changed bang" is sent at the end of the paint method 
    char        show_border;                        ///< Flag telling if we display the border
    char        show_focus;                            ///< Flag telling if we want to graphically show when the object has focus by adding a thicker border (by default: yes)
    
    char        catch_playhead;                     ///< Catch the playhead while playing
    char        play_mode;                            ///< Play mode (see e_play_modes 0 = chord-wise, 1 = note-wise, by default it is 1, which should RARELY be changed!)
    char        play_rests;                            ///< Play rests (only work if play mode is chord-wise)
    char        play_tied_elements_separately;        ///< Flag telling if we want to send through playout tied chords just once, or if we want to have each tied chord separately output.
                                                    ///< If it is set to 1, it plays all the tied elements separately; otherwise it plays tied chords just once 
                                                    ///< (if #play_mode = k_PLAYMODE_CHORDWISE) or it plays the tied notes just once (if #play_mode is k_PLAYMODE_NOTEWISE) 
    char        play_rests_separately;                ///< Same as #play_tied_elements_separately but for sequences of rests (if #play_rests is active)
    char        play_partial_notes;                    ///< Flag telling if we want to play a note whose head is before the starting playhead position, but whose tail is after it.
                                                    ///< More simply: if this is 1, when a play command starts, first of all the notes who are "active" at the play cursor position are output,
                                                    ///< with the correctly reduced duration (as if they started at the play cursor)
    char        show_playhead;                        ///< Flag telling if we want to show the play cursor or not
    double      playhead_width;                     ///< Width of the playhead in pixels
    char        playhead_dragging_mode;                ///< Dragging mode for the playhead: 0 = absolute (where one alt+clicks, there the playhead goes), 1 = relative (just clicking won't move the playhead, only pixel differences account)
    char        align_chords_with_what;                ///< (For bach.roll only) One of the #e_chord_align_mode specifying the
    char        forceround_stems_to_semiinteger;    ///< Flag telling if we need to force the stems to be rounded to semi-integers pixels (which might be best in some
                                                    ///< display context). This, on the other hand, implies that noteheads might NOT be always best vertically aligned.
    char        full_path_from_playout_syntax;        ///< If this flag is set, instead of the voice number, the full path to reach the note/chord is output in the playout syntax.
                                                    ///< For instance, instead of "note 1 1 (...)" this would be something like "note (3 4 1) 1 (...)", where 3 4 1 is the path to get to the note:
                                                    ///< namely: voice number, chord index and note index (for bach.roll) or voice number, measure number, chord index and note index (for bach.score).
    
    t_llll            *loop_region_as_llll;                ///< The loop region as a llll containing its extremes (either as single milliseconds, or as point in measures specifications)
    t_loop_region    loop_region;                        ///< The current loop region
    char            show_loop_region;                    ///< Flag telling if we show the loop region or not
    char            use_loop_region;                    ///< Flag telling if we use the loop region during play or not
    double            loop_region_pixel_start;            ///< Starting x pixel position for the loop region
    double            loop_region_pixel_end;                ///< Ending x pixel position for the loop region 
    char            dont_schedule_loop_start;            ///< (PRIVATE, INTERNAL) Flag useful to avoid scheduling the loop start (for instance, because it had already been scheduled before) 
    char            dont_schedule_loop_end;                ///< (PRIVATE, INTERNAL) Flag useful to avoid scheduling the loop end (for instance, because it had already been scheduled before) 
    char            playhead_cant_trespass_loop_end;    ///< (PRIVATE, INTERNAL) If this flag is set, the playhead cannot trespass the end of the loop. This is extremely useful in this circumstance:
                                                        ///< If the user is playing and at the same time moving the right boundary of the loop leftwards, the check_correct_scheduling() might want to skip 
                                                        ///< the scheduling of the loop end, because it has been overwhelmed (just like when you move a chord leftwards, and it MIGHT not be played if 
                                                        ///< it's "too late". Yet loop end is no chord, and we need to somehow force its scheduling: we do it via this flag: if this is set, check_correct_scheduling()  
                                                        ///< will check that the current timing is NO bigger than the loop end, otherwise it'll simply schedule immediately the loop end.
                                                        ///< This flag is updated each time the play is started.
    
    char        breakpoints_have_velocity;            ///< Flag telling if the breakpoints can have a velocity (and thus one can have diminuendi and crescendi inside a note), see #t_bpt
    char        breakpoints_have_noteheads;            ///< Flag telling if the breakpoints are shown as standard classical noteheads
    
    char        notify_when_painted;                ///< Flag telling if we want notifications to be sent whenever the object is repainted
    char        notify_also_upon_messages;          ///< Flag telling if the notifications (such as domain changes...) must be sent also when they are due to some incoming messages, and not to interface changes
    
    // choosing which command plays offline
    bool        play_offline_bitfield[128];              ///< Determines what plays offline as a bitfield of ASCII values:
                                                    ///  if a 1 is on an ascii value, that plays offline. Special values are used
                                                    ///  for clicks, see k_PLAYOFFLINE_...
    long        play_offline_via_ac;                ///< Needed to set up the Max attribute
    t_atom      play_offline_via_av[16];            ///< Needed to set up the Max attribute
//    char        play_offline_shortcut;              /// one of the k_PLAYOFFLINE_SHORTCUT_
//    char        dblclick_sends_values;                ///< Flag telling if, when we double click, the selection is sent through the playout (as when we press V)
    
    char        send_rebuild_done_at_startup;                ///< Flag telling if the "done" message is sent at startup when the object content has been reloaded
    char        send_rebuild_done_only_after_paint_method;    ///< Flag telling if the "done" message must be sent NOT after the object content has been reloaded, but after the object has been repainted (and thus a little bit later).
                                                            ///< This is the default (1), since some graphical parameters are only calculated at paint time, and one might
                                                            ///< want to have them properly set when the "done" message is sent.
    char        need_send_rebuild_done_after_paint;            ///< Internal flag, determining if the "done" message must be sent at the end of the next paint cycle.
    char        old_timepoint_syntax_bw_compatibility;        ///< If set, keeps the ancient timepoint syntax compatibility, where the voice number was the last argument (<measure_num> <point_in_measure> <voice_num>)
    char        old_playout_syntax_bw_compatibility;        ///< If set, keeps the ancient playout syntax compatibility, where the voice number, and not the complete path to the item, was the second argument

    // editing attributes
    char            allow_copy_paste;                    ///< Allows the copy-paste of data
    char            snap_pitch_to_grid_when_editing;    ///< Flag telling if we want the midicents to be automatically snapped to the chosen microtonal grid while editing the elements. This might be the case while dragging or adding a note or a chord.
    char            snap_onset_to_grid_when_editing;    ///< (Only for [bach.roll]) Flag telling if we want the onset to be automatically snapped to the grid or ruler (if any) while editing the elements. This might be the case while dragging or adding a note or a chord.
    char            snap_linear_edit_to_grid_when_editing;    ///< (Only for [bach.roll]) Flag telling if we want the linearediting to be snapped to the current grid.
    char            snap_markers_to_grid_when_editing;    ///< (Only for [bach.roll]) Flag telling if we want the markers to be automatically snapped to the grid or ruler (if any) while editing it.
    char            snap_tail_to_grid_when_editing;        ///< (Only for [bach.roll]) Flag telling if we want the note durations to be automatically snapped to the current grid or ruler (if any) while editing the elements. This might be the case while dragging or adding a note or a chord.
    char            need_snap_some_nonselected_items;   ///< Field which is set only when nonselected elements (flagged with #k_FLAG_TO_BE_SNAPPED) need to be snapped
    t_prevent_edit    prevent_edit;                        ///< Structure telling if a given element type can (0) or cannot (1) be edited via the interface
    t_atom            *prevent_editing_atom;                ///< Array with the symbols corresponding to the elements whose editing is denied (the number of such elements is #num_prevent_editing_elems
                                                        ///< It is an array with #CONST_MAX_BACH_ELEMENT_TYPES + 10 elements allocated in notation_obj_init() and freed by notation_obj_free()
    long            num_prevent_editing_elems;            ///< Number of elements whose editing is to be prevented
    char            allow_linear_edit;                    ///< Allow usage of the linear editing system (for [bach.score] only)
    t_llll            *constraint_pitches_when_editing;    ///< llll containing possible information on how pitches must be constrained while editing them.
                                                        ///< This information must be an element of the form ((<min_midicents> <max_midicents>)) or (<allowed_midicent_lists>)
                                                        ///< for each voice, or if just one of those elements is defined, it's assigned to all voices, or in general last element is padded for all remaining voices
                                                        ///< For instance ((6400 7700)) on a G-clef staff will force notes to be inside the staff; (6000 6200 6400 6500 6700 6900 7100 7200) will force notes to 
                                                        ///< lie only on diatonic C major scale. Any combination is also allowed, such as (6000 6200 (6400 7700)), allowing the union of previous notes.
    // for bach.roll
    double          linear_edit_time_step;              ///< Time step for a single "step" in the linear editing (and also for the duration associated by default with key 1)
    double          linear_edit_time_multipliers[10];   ///< Array of multipliers defining the durations associated with keys 1 through 9 and then 0 (meaning 10).
    long            linear_edit_quarter_key;            ///< Keyboard key corresponding to a quarter note in linear edit
    
    // for bach.score
    double          onset_equality_threshold_ms;        ///< A threshold in milliseconds to determine whether two onsets are equal.
                                                        ///This is needed to perform complex tempo calculations (once upon a time we used to have rationals everywhere, but it had many drawbacks...)
    
    // pitches
    char    output_pitches_gathered; ///< Flag telling if we output pitches (instead of MIDIcents) from gathered syntax
    char    output_pitches_separate; ///< Flag telling if we output pitches (instead of MIDIcents) from gathered syntax
    char    output_pitches_playout; ///< Flag telling if we output pitches (instead of MIDIcents) from gathered syntax
    
    // mute/locked/solo
    char    show_mute_color_when;    ///< Flag telling when the mute color has to be shown on muted elements; must be one of the #e_show_when 
    char    show_lock_color_when;    ///< Flag telling when the lock color has to be shown on locked elements; must be one of the #e_show_when 
    char    show_solo_color_when;     ///< Flag telling when the solo color has to be shown on soloed elements; must be one of the #e_show_when
    char    are_there_solos;        ///< Flag telling if, globally, there are soloed elements in the score (1) or not (0)
    char    allow_mute;                ///< Allow muting elements
    char    allow_solo;                ///< Allow solo-ing elements
    char    allow_lock;                ///< Allow locking elements
    char    allow_barline_lock;        ///< Allow locking barlines (i.e. fixing measure width)

    // voice names
    char        show_voice_names;                    ///< Flag telling if we want to show the voice names (1) or not (0)
    double        voice_names_uwidth;                    ///< Unscaled width (in pixels) of the space needed to write the staff names at the beginning of the staff lines
    char        voice_names_alignment;                ///< Alignment type for the voice names: -1 = left, 0 = middle, 1 = right
    t_symbol      *voice_names_font;                ///< Font used to write the voice names
    double        voice_names_font_size;                ///< Size in pt of the font used to write the voice names (for zoom_y = 1)
    char        there_are_voice_names;                ///< Flag telling if there are voice names to paint

    
    // fonts
    t_symbol    *noteheads_font;    ///< Name of the font (as symbol) used for the notation elements (all but accidentals and articulations)
    t_symbol    *accidentals_font;    ///< Name of the font (as symbol) used for the accidentals
    t_symbol    *articulations_font;///< Name of the font (as symbol) used for the articuations
    t_symbol    *lyrics_font;///< Name of the font (as symbol) used for the articuations
    t_symbol    *annotations_font;///< Name of the font (as symbol) used for the articuations
    double        legend_font_size;    ///< Size in pt of the legend (fixed!)

    
    // typographical preferences
    t_notation_typo_preferences            notation_typo_preferences;        ///< Font-related typographical preferences for the notation elements (except accidentals, articulations and noteheads: see below)
    t_accidentals_typo_preferences        accidentals_typo_preferences;    ///< Font-related typographical preferences for the accidentals
    t_articulations_typo_preferences    articulations_typo_preferences;    ///< Font-related typographical preferences for the articulations
    t_noteheads_typo_preferences        noteheads_typo_preferences;     ///< Font-related typographical preferences for the noteheads
    
    // colors
    t_jrgba        j_background_rgba;                ///< Color of the background
    t_jrgba        j_border_rgba;                    ///< Color of the border
    t_jrgba        j_mainstaves_rgba;                ///< Color of the main staves (and of the time signatures, tempi, ledger lines)
    t_jrgba        j_auxiliarystaves_rgba;            ///< Color of the auxiliary staves (e.g. the external staves in #k_CLEF_FFGG clef configuration)
    t_jrgba        j_tempi_rgba;                   ///< Color of the tempi
    t_jrgba        j_clef_rgba;                    ///< Color of the clefs
    t_jrgba     j_auxiliaryclef_rgba;           ///< Color of the auxiliary clefs
    t_jrgba        j_keysig_rgba;                    ///< Color of the key signature
    t_jrgba        j_note_rgba;                    ///< Color of the notes
    t_jrgba        j_accidentals_rgba;                ///< Color of the accidentals
    t_jrgba        j_rest_rgba;                    ///< Color of the rests
    t_jrgba        j_stem_rgba;                    ///< Color of the stems
    t_jrgba        j_flag_rgba;                    ///< Color of the flags
    t_jrgba        j_beam_rgba;                    ///< Color of the beams
    t_jrgba        j_tuplet_rgba;                    ///< Color of the tuplets
    t_jrgba        j_articulations_rgba;            ///< Color of the articulations
    t_jrgba        j_annotation_rgba;              ///< Color of the annotations
    t_jrgba        j_dynamics_rgba;                ///< Color of the dynamics
    t_jrgba        j_selection_rgba;                ///< Color related to selection (selected items...)
    t_jrgba        j_legend_rgba;                    ///< Color of the bottom-down legend
    t_jrgba        j_selectedlegend_rgba;            ///< Color of the top legend (when an element is selected)
    t_jrgba        j_scrollbar_rgba;                ///< Color of the scrollbar
    t_jrgba        j_play_rgba;                    ///< Color related to play (playbar, played notes...)
    t_jrgba        j_locked_rgba;                    ///< Color related to locking (locked notes, measures, voices...)
    t_jrgba        j_muted_rgba;                    ///< Color related to muting (muted notes, measures, voices...)
    t_jrgba        j_solo_rgba;                    ///< Color related to soloing (solo notes, measures, voices...)
    t_jrgba        j_marker_rgba;                    ///< Color of the markers attached to millisecond position
    t_jrgba        j_marker_attached_to_tp_rgba;    ///< Color of the markers attached to timepoint position (for [bach.score])
    t_jrgba        j_marker_special;                ///< Color of the "special" markers containing meta-information such as midi meta-information
    t_jrgba        j_main_grid_rgba;                ///< Color of the main grid
    t_jrgba        j_subdivision_grid_rgba;        ///< Color of the secondary grid (subdivision grid)    
    t_jrgba        j_ruler_rgba;                    ///< Color of the ruler
    t_jrgba        j_lyrics_rgba;                    ///< Color of the lyrics
    t_jrgba        j_linear_edit_rgba;                ///< Color related to the speedy edit (for [bach.score])
    t_jrgba        j_loop_rgba;                    ///< Color related to loop region

    // graphical values
    double        corner_roundness;        ///< Roundness of the corners
    long        j_inset_x;                ///< Horizontal pad (in pixels) between the object border and the beginning of the staves (with the clefs). 
                                        ///< The same pad will be at the end of the object, after the end of the staves, till the final border
    double        j_inset_y;                ///< Vertical pad (in pixels) at the top of the object. This is NOT user-set: it is constantly 0.5 
                                        ///< (in order to have non-antialiased staff lines for <zoom_y> = 1).
                                        ///< Users don't need to change this, rather they can act on the #voiceuspacing_as_floatlist attribute.
    double        width;                    ///< Width of the UI notation object in pixels
    double        height;                    ///< Height of the UI notation object in pixels
    double        inner_width;            ///< Usable width (in pixels) of the object (ignoring insets); this correspond to the object width - 2 * <j_inset_x>
    double        inner_height;            ///< Usable height (in pixel) of the object (ignoring insets); this correspond to the object height - 2 * <j_inset_y>
    double      postdomain_width;       ///< Width of a portion of score that pads the end of the domain without being inside it.
                                        ///< Currently only used in image export.
    char          exporting_image;         ///< 1 only while exporting images

    double        horizontal_zoom;        ///< User modifiable horizontal zoom, 100 = default zoom. This is the value set and get via the "zoom" attribute.
    t_atom        vertical_zoom;            ///< User modifiable value for the vertical zoom, 100 = default zoom, "auto" = automatic zoom .
                                        ///< I.e.: vertical zoom is automatically set depending on the height of the object; this is the default.
    char        link_vzoom_to_height;    ///< Flag telling if the <vertical_zoom> is "auto" (and thus the <v_zoom> is linked to the object's height) 
    double        zoom_x;                    ///< Internal horizontal zoom factor, corresponding to <horizontal_zoom>/100 (so 1. = default zoom)
    double        zoom_y;                    ///< Internal vertical zoom factor, corresponding to <vertical_zoom>/100 if <vertical_zoom> is a number (so 1. = default zoom)
    double        step_y;                    ///< Diatonic graphical step size: vertical distance (in pixels) between two consecutive notes on the diatonic scale (e.g. between C3 and D3). 
                                        ///< More precisely, this is HALF of the distance between two staff lines. This is a commonly used quantity, its value of 
                                        ///< course depend on the vertical zoom factor <zoom_y>. When <zoom_y> = 1, <step_y> = #CONST_STEP_UY pixels (which means that staff lines
                                        ///< are 2 * #CONST_STEP_UY pixels apart), thus <step_y> = #CONST_STEP_UY * <zoom_y> pixels.

    char        end_staff_with_final_measure;         ///< Ends the staff with the final measure in bach.score
    char        force_non_antialiased_staff_lines;    ///< Flag telling if we want to force the zoom to be such that only values which yields non-antialiased 
                                                    ///< staff lines are allowed. By default it is so: the user-set (or auto) zoom is approximated so that  
                                                    ///< staff lines fall vertically on a single pixel
    double        zoom_y_with_antialias;                ///< Internal vertical zoom factor, ignoring the #force_non_antialiased_staff_lines request.
                                                    ///< If #force_non_antialiased_staff_lines = 1, then the #zoom_y value is not the value the user have entered. We keep
                                                    ///< track of that value by storing it here.
    
    long        middleC_octave;                        ///< Octave of the middle C. By default this is 4 (anglosaxon, so middle C = C4)
    char        note_names_style;                    ///< Style for the note names, one of the #e_note_names_styles: either #k_NOTE_NAMES_LATIN or #k_NOTE_NAMES_ANGLOSAXON.
                                                    ///< REMARK: this is only for the display and the output; when you send a note name in input, the objects understand both
                                                    ///< the anglosaxon and the latin syntaxes.
    char        show_note_names;                    ///< Flags telling if we want to show the note names in the upper legend when a note is selected
    long        last_used_octave;                    ///< Internal, private use: it keeps track of the last used octave while entering notes with notenames, so that when a user
                                                    ///< enters "C3 D E", the object understands that D and E are always at the 3rd octave. 
    double        additional_ux_start_pad;            ///< Unscaled width of an additional starting pad, to shift the beginning of the staff farther or nearer with respect to the clefs 
    char        show_ledger_lines;                    ///< Flags telling if we want to show the ledger lines: 
                                                    ///< 0 = Never show ledger lines; 1 = Show them in the standard way (default) ; 2 = Always refer ledger lines to the main staves, 
                                                    ///< which means that if there's a note in a auxiliary staff, we'll show ledger lines between the auxiliary and the main staff 
    double        head_vertical_additional_uspace;    ///< Unscaled additional vertical space at the top of the object. 
                                                    ///< This value is retreived and synchronized with the first element of #voiceuspacing_as_floatlist. 
    double        key_signature_uwidth;                ///< Unscaled width (in pixels) of the space needed to paint the key signature after the clefs
    char        smart_markername_placement;         ///< Toggles smart multi-line marker names placement
    
    // page view fields (THESE ARE STILL UNSUPPORTED)
    char        view;                            ///< (UNSUPPORTED) Current type of view, one of the #e_views
    long        num_systems;                    ///< (UNSUPPORTED) Current number of systems (always 1 in scroll view) 
    long        first_shown_system;                ///< (UNSUPPORTED) ID of the first shown system
    long        last_shown_system;                ///< (UNSUPPORTED) ID of the last shown system
    long        current_page;                    ///< (UNSUPPORTED) Current page number (0-based)
    char        show_page_numbers;                ///< (UNSUPPORTED) Flag telling if we want to show (1) or not (0) the page numbers (only works in #k_VIEW_PAGE mode)
    long        page_number_offset;                ///< (UNSUPPORTED) Offset for page numbering (default: 0)
    double        needed_uheight_for_one_system;    ///< (UNSUPPORTED) Needed unscaled height of one system, in order for it to contain all the staves properly
    double        needed_uheight;                    ///< (UNSUPPORTED) needed unscaled height of the object, in order for it to contain all the systems properly
    double        system_jump;                    ///< (UNSUPPORTED) Vertical space (in pixels) needed to jump from one system to the next one.
                                                ///< (UNSUPPORTED) (in pixels) between two equal staff positions (e.g. corresponding to the same midicents) in two consecutive systems.
    double        ms_on_a_line;                    ///< (UNSUPPORTED) (Only used by [bach.roll]) Duration (in ms) of each system
    

    // undo & save
    char        save_data_with_patcher;                ///< Flag telling if the score content is saved with the patcher. The dirty bit is also set when the score is modified, 
                                                    ///< so that user is certainly asked to save when he closes the patch.
    char        allow_undo;                            ///< Flag telling if we allow undo. 
    
    t_llll        **old_undo_llll;                    ///< (OBSOLETE!) Array containing the #CONST_MAX_UNDO_STEPS undo steps (NULL if step is not defined)
                                                    ///< It is an array with #CONST_MAX_UNDO_STEPS elements allocated in notation_obj_init() and freed by notation_obj_free()
    t_llll        **old_redo_llll;                    ///< (OBSOLETE!) Array containing the #CONST_MAX_UNDO_STEPS redo steps (NULL if step is not defined) 
                                                    ///< It is an array with #CONST_MAX_UNDO_STEPS elements allocated in notation_obj_init() and freed by notation_obj_free()
    
    double        last_undo_time;                        ///< (UNUSED) Operating system's time (in milliseconds) of the last time when un undo step has been performed 

    char        inhibited_undo;                        ///< Flag which, if it is 1, will inhibit the creation of undo ticks and steps. Of course, by default it is 0.
                                                    ///< It is put to 1 only by messages like "inhibitundo 1", and put back to 0 by "inhibitundo 0"
    char        send_undo_redo_bang;                ///< Flag which tells if the changed bang must be sent for "undo"/"redo" actions (by default it is on)
    t_llll        *undo_llll;                            ///< List containing undo information (see the Undo module for more information) 
    t_llll        *redo_llll;                            ///< List containing redo information (see the Undo module for more information)
    t_atom        max_undo_steps;                        ///< Maximum number of undo steps. If this is 0, the undo is turned off. If this is the symbol gensym("inf"), the number of undo steps is unlimited.
    long        num_undo_steps;                        ///< Current number of undo steps stored in the undo llll (it corresponds to the number of undo markers inside it) 
    long        num_redo_steps;                        ///< Current number of redo steps stored in the redo llll (it corresponds to the number of redo markers inside it)
    char        verbose_undo_redo;                    ///< If this is 1, bach posts each undo/redo step in the Max window.
    t_llll        *undo_notation_items_under_tick;    ///< A llll containing as #H_OBJ the notation items whose undo information is currently being prepended to the undo list.
    long        undo_header_elements_under_tick;    ///< A #e_header_elems combination specifying which header elements are under tick
                                                    ///< Each undo tick on a notation item adds an element to this list. When the undo step marker is created (and thus the undo step is finalized), this list is emptied.
    long        whole_obj_under_tick;               ///< Tells if the whole notation object is under tick
    long        header_undo_flags;                    ///< Combination of #e_header_elems which are currently being prepended to the undo list as undo ticks
    long        last_event_number;                    ///< Event number corresponding to the time when the last undo marker was placed
    t_llllelem    *last_undo_marker;                    ///< Pointer to the last positioned marker inside the undo llll
    
    
    // simple hash table
    t_shashtable    *IDtable;    ///< A simple hash table containing the notation items whose information can be undone and the ones who can be subjected to the lambda message.
                                ///< So please remark that NOT all notation items appear in this table. By default all voices, measures and chords appear (since their information can be undone).
                                ///< Since undoing note information means saving all its chord information, no note appear in this table, except if it is evaluated and could be subjected to the lambda loop.
    
    // qelem
    void    *n_qelem_send_rebuild_done;                ///< Qelem for sending the "done" message after an object has been rebuilt
    
    // notation parameters for [bach.score]
    char        max_dots;                                ///< Maximum number of allowed dots for a single note
    double        syncopation_asym_ratio;                    ///< Maximum allowed ratio for a syncopation between the bigger part and the smaller part of the syncopation. 
                                                        ///< E.g.: sixteenth quarter dotted_eight in 2/4 time, this value = 3 (quarter = dotted_eight (3/16) + sixteenth (1/16), and 3/16 / 1/16 = 3.
    double        syncopation_pos_dur_ratio;                ///< Maximum allowed ratio between the the position of the syncopation in the measure (but with numerator 1) and the left-side (symbolic) duration of the syncopation. 
                                                        ///< A good value is 2.5; don't change it if not sure of what it is. 
    long        syncopation_max_dots;                   ///< Maximum number of dots for a figure to be allowed inside a syncopation (default: 0)
    char        allow_beaming;                            ///< Flag telling if we allow notes to be beamed or not (by default: yes)
    
    // tempi
    char        show_tempi;                                ///< Flag telling if we want to show tempi
    double      tempi_uy_pos;                           ///< Unscaled vertical shift for tempi
    char        show_tempi_interp_line;                 ///< Show/hide dashed rall/acc line
    
    char        show_barlines;                            ///< Flag telling if we want to show barlines
    char        show_barline_locks;                        ///< Flag telling if we want to show the barline locks (appearing when barline width has been locked, fixed)
    char        draw_barlines_across_staves;            ///< Flag telling if we want to draw the barlines across all the staves, when possible
    double      barline_ushift_for_proportional_spacing;    ///< unscaled shift of barlines in proportional spacing display
    char        show_time_signatures;                    ///< Flag telline if we want to show the time signatures (0 = hide, 1 = classically, 2 = above staff)
    double      big_time_signatures_ratio;              ///< Expansion ratio for big time signatures
    long        measure_number_offset;                    ///< Offset for the measure numbering (by default: 0)
    
// changed from e_show_accidentals_preferences to char to avoid VC++ complaints
    char        show_accidentals_preferences;            ///< Preferences for accidental handling. When do we want to show the accidentals.
    e_show_accidentals_tie_preferences        show_accidentals_tie_preferences;        ///< Flag telling when we want to show accidentals at the end of a tie.
    char        cautionary_accidentals;                    ///< Flag telling when we want to show the cautionary accidentals.
                                                        ///< 0 = Never, 1 = Only for notes on the same staff position and in the same octave, 2 = Also for all the octaves 
    long        cautionary_accidentals_decay;            ///< Number specifying after how many chords the cautionary (annulation) accidental is no more necessary 
    long        cautionary_accidentals_remind;            ///< Number specifying after how many chords the cautionary (non-annulation) accidental is necessary again to remind it  
    double        max_beam_slope;                            ///< (No more supported, used only up to bach 0.6.7) Maximum slope for the beamings (has been replaced by <max_beam_delta_y>) 
    long        max_beam_delta_y;                        ///< Maximum possible vertical distance between the end and the start point of a beaming. This value is in steps.
    char        constraint_beam_start_end_in_spaces;    ///< If 1, beams cannot start and end in any position, but only on a vertical grid of half-steps
    char        tie_assign_pitch;                        ///< Flag telling if when we tie two notes having same screen midicents and accidentals, their actual midicents are set equal (to the first one). 
                                                        ///< For instance we may tie a C3 of 6004 cents with a C3 of 6009 cents, and the latter will become
                                                        ///< a C3 of 6004 cents.
    char        edit_tied_notes_together;               ///< Select all tied sequences of notes whenever selecting a single note
    char        auto_complete_measures;                    ///< Flag telling if we want to automatically complete the incomplete measures
    char        show_tuplets_preferences;                ///< Flag telling how we want to show the tuplet ratios, one of the #e_tuplet_ratio_display_types. 
                                                        ///< 0 = Show nothing, 1 = Auto, 2 = Show single number (e.g. 3), 3 = Show ratio (e.g. 3:2), 
                                                        ///< 4 = Show ratio and figure (e.g. 3q:2q), 5 = Show the fraction (e.g. 2/3)
                                                        ///< The "auto" value (default, 1) automatically chooses between the following possibilities, according to the tuplet type.
    char        tuplet_shape;                            ///< Shape used to gather tuplets; one of the #e_tuplet_shapes
    char        only_use_shape_on_unbeamed_tuplets;        ///< Flag telling if we draw the specified <tuplet_shape> only in the case the tuplet is not (solitarily) beamed
    char        dont_beam_tuplets_with_other_things;    ///< Flag telling if we don't have to beam tuplets with chords outside the tuplet (1 to have this behaviour, 0 not to have it, default)  
    char        admit_dotted_tuplets;                    ///< Flag telling if we admit tuplets having dots in their units (e.g. do we want a dotted-sixteenth tuplet?) 
    char        change_cents_to_measures_by_dragging;    ///< Flag telling if we allow the measures to be dragged up and down, and their chord pitches to change accordingly? 
    char        rests_within_beaming;                    ///< Flag specifying what to do when rests might lie inside a beaming, one of the #e_rests_within_beam_handling (see it for more information)
    long        max_rest_floating_steps;                ///< Maximum number of floating steps for a rest
    char        hide_tempi_when_equal_on_all_voices;    ///< Flag specifying if we can hide the tempi which are equal and synchronous on all voices, and just show the one in the first voice
    char        autoparse_rhythms;                ///< Flag telling if we want the rhythm to be constantly automatically parsed and retranscribed in the 'most natural way' (according to algorithms)
    char        need_perform_analysis_and_change;        ///< Internal flag, set when the recalculations need to be done. This force to to enter in the 
                                                        ///< perform_analysis_and_change() method, which is either done immediately (by calling it explicitely)
                                                        ///< or (in case the change is a merely graphic one) it is done at the next paint cycle, before painting stuff. 
    char        need_recompute_tuttipoints;                ///< Internal flag, used by bach.score, telling if the tuttipoints have to be re-parsed from scratch.
    char        need_recompute_chords_double_onset;        ///< Internal flag, telling that in the next perform_analysis_and_change() method, the chord onsets in double precision need to be recomputed
    char        tempi_are_all_synchronous;                ///< Flag telling if all the voices have the same tempi at the same moments throughout the whole score
    char        nullify_incorrect_ties;                    ///< Internal flag, used to delete incorrect ties at some points of the code
    char        all_voices_end_together;                ///< Flag telling if all the voices of the score end together (1) or not (0)
    char        need_reassign_local_spacing;            ///< Do we need to reassign the local spacing for some measure?
    char        need_update_markers_uwidth;             ///< Do we need to update the uwidth for some marker? 
    
    // automessage, i.e. a message in its A_GIMME signature (ac, av) which is automatically sent to the object when there have been interface changes
    t_atom        automessage_av[100];                ///< The atoms composing the automessage
    long        automessage_ac;                        ///< The number of atoms composing the automessage
    char        is_sending_automessage;                ///< Flag telling if we are currently sending an automessage (to avoid loops, we won't send other automessages if an automessage is being sent!)
    char        need_send_automessage;                ///< When this is non-zero, the automessage is sent at the end of the paint method 
    
    // articulations
    char        show_articulations;                ///< Flag telling if we want to show the articulations
    char        show_articulations_extensions;    ///< Flag telling if we want to show the articulations extensions (such as the ~~~~~ of the tr~~~~~ articulation)
    
    // show flags/beams
    char        show_flags;                     ///< Flag telling if we want to show the chord flags
    char        show_beams;                     ///< Flag telling if we want to show the beams
    char        show_ties;                      ///< Flag telling if we want to show the ties
    char        show_dots;                      ///< Flag telling if we want to show the augmentation dots
    e_show_rests_preferences    show_rests;     ///< Flag telling if we want to show the rests
    
    
    // slurs (THESE ARE YET UNSUPPORTED)
    char        show_slurs;                    ///< (UNSUPPORTED) Flag telling if we want to show the slurs
    char        slurs_shown_chordwise;        ///< (UNSUPPORTED) Flag telling if slurs "act" as they were shown chord-wisely: in this case they may also get to the stem of a chord, and not to the note. 
    char        slurs_avoid_accidentals;    ///< (UNSUPPORTED) Flag telling if slurs avoid the accidentals
    char        slurs_always_symmetrical;    ///< (UNSUPPORTED) Flag telling if slurs are always symmetrical, i.e. the bezier bounding box is a perfecty symmetric trapece. 

    
    // markers
    char        show_markers;        ///< Flag telling if we want to show the markers
    t_marker    *firstmarker;        ///< Pointer to the first marker in the score
    t_marker    *lastmarker;        ///< Pointer to the last marker in the score
    long        num_markers;        ///< Number of markers in the score
    t_symbol      *markers_font;        ///< Font used to display marker text
    double        markers_font_size;    ///< Size in pt of the font for writing the marker names (for <zoom_y> = 1)

    
    // default elements
    long        default_velocity;
    t_symbol    *default_markername;
    t_llll      *default_noteslots;
    
    // rulers & grids
    char        ruler;                    ///< Type of ruler to be shown: 0 = No ruler, 1 = Ruler Above, 2 = Ruler Below, 3 = Both
    char        ruler_mode;                ///< Ruler mode: 0 = Manual (user sets the <grid_step_ms> and the <grid_subdivisions>), 1 = Smart (automatical, depending on zoom)
    char        show_ruler_labels;        ///< Flag telling if we want to show the ruler labels, indicating time. Their positioning is automatically calculated (depending on tick density)
    char        show_grid;                ///< Flag telling if we want to show the grid
    double        grid_step_ms;            ///< Step interval in milliseconds for the main grid, i.e. interval between two "long" ticks
    long        grid_subdivisions;        ///< Number of secondary subdivision of the main grid, i.e. number of "smaller" ticks between the "long" ticks (+ 1)
    double        ruler_labels_font_size;    ///< Size in pt of the font for writing the ruler labels (for <zoom_y> = 1)

    double        current_first_grid_ms;            ///< (Internal) Current first (division or subdivision) "ticks" in the grid or rulers.
    double        current_grid_subdivision_ms;    ///< (Internal) Current distance in milliseconds between two (division or subdivision) "ticks" in the rulers.
    long        current_num_grid_subdivisions;    ///< (Internal) Current number of subdivision for the main divisions of the grid.
    
    // spacing
    char        spacing_type;                                ///< 0 = Smart (parameter = measure width), 1 = NoteSpacing->TimeSignatureSpacing (parameter = 0.to 1. Note to TS), 2 = merely proportional
    double        spacing_parameter;                            ///< NO LONGER USED, kept for attribute legacy
    double        spacing_width;                                ///< This is the \f$\gamma\f$ parameter in function documentation. 1 = minimal spacing; <1 compressed, >1 stretched
    double        spacing_proportionality;                    ///< This is the \f$\mu\f$ parameter in function documentation. 0 = strictly space-needed-spacing, 1 = strictly proportional; any value 0<=x<=1 is usable
    double        minimum_uwidth_for_measure;                    ///< Unscaled minimum width for ANY measure, leave 0 for unused
    double        minimum_uwidth_per_sym_unit_for_measure;    ///< Unscaled minimum width per symbolic unit for ANY measure, leave 0. for unused

    
    // play
    char        allow_play_from_interface;    ///< Flag telling if we allow playing from the interface
    char        playing;                    ///< Flag telling if the object is currently playing
    char        playing_scheduling_type;    ///< Scheduling type for playing, one of the #e_scheduling_type
    t_llll      *to_preschedule;            ///< List containing t_scheduled_events to be scheduled, ONLY for the PRESCHEDULED mode.
    t_llllelem  *preschedule_cursor;        ///< Cursor while reading the prescheduled list
    
    double        play_head_start_ms;        ///< Position in milliseconds of the OFFLINE play cursor
    double        play_head_start_ux;        ///< Unscaled x pixel of the OFFLINE play cursor (only used in [bach.score]) 
    double        play_head_ms;            ///< Current position in milliseconds of the PLAYTIME play cursor
    double        play_head_ux;            ///< Current unscaled x pixel of the PLAYTIME play cursor (only used in [bach.score]).
                                        ///< REMARK: We have to distinguish between the fixed offline playcursor (which always indicates the beginning of the play region, i.e.
                                        ///< if one press the spacebar, the play starts from there) and the mobile playcursor at playtime: when we send a "play" command, the 
                                        ///< offline playcursor does not move AT ALL, but it is the playtime playcursor which takes its place and start moving. You have to 
                                        ///< think at the offline playcursor as the indication of the play start region (which graphically disappear while playing, substituted
                                        ///< by the mobile playtime playcursor)
    double        play_head_fixed_end_ms; ///< Fixed end in milliseconds for the play to stop. Once reached this millisecond position, the stop function is called, and the play is over.
                                        ///< If this value is negative (e.g. -1), no end is given, and the play stops only when the score reading is over.
    
    double        theoretical_play_step_ms;    ///< Approximative step (in milliseconds) for playhead redraw. 0 means that the score is redrawn at each
                                            ///< scheduled event. The "approximative" adjective is due to the fact that we need an integer number of ticks 
                                            ///< between two scheduled events, so this might slightly vary in each scheduled interval
    char        highlight_played_notes;        ///< Highlights the played notes with the playcolor. It's a bit more CPU-expensive, but more clear.
    char        play_markers;                ///< Send markers during play
    char        play_tempi;                 ///< Send tempi during play
    char        play_measures;              ///< Send measure start barlines during play
    
    void        *m_clock;                            ///< The clock for the play and task routine
    t_symbol    *setclock;                            ///< The setclock, to handle the change of clock speed
    long        play_num_steps;                        ///< Internal, number of steps to schedule between the output of a chord and the output of the next one.
    long        play_step_count;                    ///< Currently reached step out of the <play_num_steps>
    double        play_step_ms;                        ///< Duration in milliseconds of one of the <play_num_steps> steps to schedule
    long        max_num_chord_per_scheduler_event;    ///< Maximum number of synchronous chords being output within the same scheduler event. Somehow, it's a bach Play Poll Throttle.
                                                    ///< Synchoronous chords exceeding this number will be played 'as soon as possible' in the next scheduler tick (scheduled immediately)

    t_chord        **chord_play_cursor;        ///< Multicursor (one element for each voice) containing the last played chords, or generally (when possible) the chords happening _before_ the already scheduled events. 
                                            ///< It is an array with #CONST_MAX_VOICES elements allocated in notation_obj_init() and freed by notation_obj_free()
                                            ///< The idea is that, to play the next chord, we start to look ahead from the ones we have already played, and
                                            ///< we keep track of this 'looking ahead' with this multicursor.
    t_tempo     **tempo_play_cursor;         ///< Cursor containing the last played tempo for each voice, or generally (when possible) the tempo happening _before_ the already scheduled events (exactly linke #chord_play_cursor)
    t_measure    **measure_play_cursor;         ///< Cursor containing the last played measure for each voice, or generally (when possible) the tempo happening _before_ the already scheduled events (exactly linke #chord_play_cursor). Measures are "played" when they start, outputting measure number and measureinfo.
    t_marker    *marker_play_cursor;        ///< Cursor containing the last played marker, or generally (when possible) the markers happening _before_ the already scheduled events (see #chord_play_cursor)
    t_notation_item        *scheduled_item;    ///< Pointer to the notation item currently being scheduled
    double                scheduled_ms;        ///< Onset (in milliseconds) of the chord currently being scheduled
    double                start_play_time;    ///< Time (in milliseconds) obtained by setclock_getftime() at the very beginning of the play.
                                            ///< We'll use this time to handle rescheduling if needed. Indeed the play system is robust to score changes: 
                                            ///< if you add a note (having onset later than the current playtime playhead), bach will try to reschedule events,
                                            ///< in order to play the note. This rescheduling is performed in the check_correct_scheduling() routine, where this 
                                            ///< <start_play_time> is essential.
    t_llll        *notes_being_played;        ///< llll containing all the notes (as #H_OBJ elements) currently being played. 
                                            ///< Important: for bach.score, this llll will only contain the starting note of a tied sequence of notes (if any, and if playtiedelementsseparately is set to 0).
    
    // contextual menu (obtained by right clicking)
    t_jpopupmenu *popup_voice;                    ///< Main contextual menu when clicking on a voice 
    t_jpopupmenu *popup_voice_clefs;            ///< Contextual submenu for the clefs (when clicking on a voice)
    t_jpopupmenu *popup_voice_midichannels;        ///< Contextual submenu for the midichannels (when clicking on a voice)
    t_jpopupmenu *popup_voice_keys;                ///< Contextual submenu for the keys (when clicking on a voice)
    t_jpopupmenu *popup_voice_keys_major;        ///< Contextual subsubmenu for the major keys (when clicking on a voice)
    t_jpopupmenu *popup_voice_keys_minor;        ///< Contextual subsubmenu for the minor keys (when clicking on a voice)
    t_jpopupmenu *popup_note;                    ///< Main contextual menu when clicking on a note or chord, or a mixed selection
    t_jpopupmenu *popup_durationline;            ///< Main contextual menu when clicking on a duration line
    t_jpopupmenu *popup_note_slots;                ///< Contextual submenu for the slots (when clicking on a note, chord, or mixed selection)
    t_jpopupmenu *popup_note_enharmonicity;        ///< Contextual submenu for the enharmonicity possibilities (when clicking on a note, chord, or mixed selection)
    t_jpopupmenu *popup_note_copy;              ///< Contextual submenu when copying selection
    t_jpopupmenu *popup_note_copy_slot;         ///< Contextual subsubmenu when copying a given slot
    t_jpopupmenu *popup_note_paste_slot;        ///< Contextual subsubmenu when pasting a given slot
    t_jpopupmenu *popup_note_paste;             ///< Contextual submenu when pasting selection
    t_jpopupmenu *popup_measure;                ///< Main contextual menu when clicking on a measure
    t_jpopupmenu *popup_measure_timesignature;    ///< Contextual submenu for the time signatures (when clicking on a measure)
    t_jpopupmenu *popup_background;                ///< Contextual menu when clicking on the background
    t_jpopupmenu *popup_barline;                ///< Contextual menu when clicking on a barline
    t_jpopupmenu *popup_filters;                ///< Contextual menu when clicking on a slotwindow of a #k_SLOT_TYPE_FILTER type of slot
    t_jpopupmenu *popup_articulations;            ///< Contextual menu when clicking on an articulation

    long        current_enharmonic_list_screenmc[5];    ///< The enharmonic possibilities which pops up when using contextual menus, are saved in these two fields.
                                                        ///< This first one keeps the 5 possibilities for the screen midicents (diatonic pitch shown on screen, ignoring accidentals)
    t_rational    current_enharmonic_list_screenacc[5];    ///< This second one keeps the 5 possibilities for the accidentals (related to the 5 screen midicents possibilities)

    t_jfont *popup_main_font;                    ///< Font name (as symbol) for the main contextual menus
    t_jfont *popup_secondary_font;                ///< Font name (as symbol) for the contextual submenus

    
    // lambda information
    unsigned long    lambda_selected_item_ID;    ///< ID of the lambda selected item, i.e. of the item whose content is being output from the play output "right now".
                                                ///< User might close the lambda loop by using "lambda ..." message, and then for instance change some parameter of this 
                                                ///< very same item. If nothing is being output, this is 0. 
                                                ///< More precisely, before outputting any thing from the playout, the #lambda_selected_item_ID is set, then its values are output,
                                                ///< and then the #lambda_selected_item_ID is unset (= set to 0). If the user closes the lambda loop, the #lambda_selected_item_ID is 
                                                ///< still set, and can be retrieven by any message accepting the lambda prefix (such as "lambda cents" or "lambda changeslotitem").
                                                ///< This is thread safe, since if another thread deletes the object, when the "cents" or "changeslotitem" function tries to retrieve
                                                ///< the notation item from its ID, it fails (item has been deleted).
    
    // expression evaluations
    t_lexpr        *n_lexpr;        ///< Expression evaluator, used to parse and evaluate expression for the "select if" command
    
    
    // score cursor and linear editing
    char                is_linear_editing;                                    ///< Flag telling if we are currently linear editing
    t_notation_cursor    notation_cursor;                                    ///< The notation cursor for a "speedy-edit" inputting (used only by [bach.score]).
    char                auto_jump_to_next_chord;                            ///< Automatically jump to next chord while editing
    char                playback_during_linear_editing;                        ///< Chord playback during speedy editing (when a chord is inserted, it is sent through the playout)
    t_urrational        speedy_tuplet[CONST_MAX_NESTED_TUPLETS_FOR_SPEEDY];    ///< An array containing the ratios of the tuplets being inserted while speedy editing. E.g. if it contains 3/2 and 4/3, and
                                                                            ///< <num_speedy_tuplets> == 2, this means, that user is inserting a tuplet of 3/2 nested with one of 4/3 
    char                speedy_tuplet_numerator_defined[CONST_MAX_NESTED_TUPLETS_FOR_SPEEDY]; ///< Flag telling if numerator of a tuplet being introduced in speedy edit is also user-defined. Which means: did the user enter e.g. "5:3", and not only "5" 
    long                num_speedy_tuplets;                                    ///< The number of the elements used in the #speedy_tuplet array (the nesting depth of the tuplet which is being inserted)
    long                force_diatonic_step;                                ///< Forced diatonic step
    double              linear_edit_last_inserted_dur;                      ///< Last duration inserted via linear edit
    
    
    // textedit information: the UI object text editor is used, each time, to edit the different texts (such as lyrics, marker names, voice names, slot content)
    char        is_editing_type;            ///< Type of the element which is being edited as a textbox. Must be one of the followings:
                                            ///< #k_VOICENAME, #k_LYRICS, #k_DYNAMICS, #k_MARKERNAME, #k_TEXT_IN_SLOT, #k_LLLL_IN_SLOT or #k_DYNAMICS_IN_SLOT (all belonging to #e_element_types)
    long        is_editing_voice_name;        ///< Number of the voice whose name is being edited (if <is_editing_type> = #k_VOICENAME)
    long        is_editing_slot_number;        ///< Number of the slot being edited (if #is_editing_type = #k_TEXT_IN_SLOT)
    t_marker    *is_editing_marker;            ///< Pointer to the marker being edited (if #is_editing_type = #k_MARKERNAME)
    t_chord        *is_editing_chord;            ///< Pointer to the chord whose lyrics are being edited (if #is_editing_type = #k_LYRICS or #k_DYNAMICS)

    
    // rhythmic trees
    char        tree_handling;                        ///< One of the #e_rhythmic_tree_modes, determining the behaviour of the calculate_measure_beamings_and_tuplets_with_trees() function when the user inserts a given tree.
    char        tree_to_beaming_correspondence;        ///< Way of converting levels into beams: one of the #e_tree_to_beams_correspondences
    char        always_break_first_level_beams;        ///< Always break the beams on the root level (whole list). Notice that the beams corresponding to the time signature
                                                    ///< are automatically isolated, so that if <make_tree_compatible_with_ts> is set, this is often unuseful (but not always! for instance if the tree is locked!) 
    char        make_tree_compatible_with_ts;        ///< Makes the tree compatible with the time signature but make it compatible with the time signature, possibly by re-boxing it properly.
                                                    ///< Beware: if r_ob->tree_handling = k_RHYTHMIC_TREE_HANDLING_IGNORE, this is automatically set to 1 and can't be changed
    char        always_reduce_tree_idle_levels;        ///< Always eliminates the levels in the tree which are idle, meaning that they are exactly doubling another level.
                                                    ///< E.g. (((a b)) (((c))))...
                                                    ///< If this flag is 1, this reduction is performed even if the <tree_handling> mode is #k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED
    char        extend_beams_over_rests;            ///< How do we want to extend the beams over rests? One of the #e_beams_over_rests 
    char        show_half_stem_for_beamed_rests;    ///< Do we want to show a half-stem for beamed rests?
    char        show_rhythmic_tree;                    ///< Graphically paints the beaming tree for each measure
    char        output_trees;                        ///< Output beaming trees while dumping?
    char        write_trees;                        ///< Include tree information while saving via "write" or "writetxt"
    char        output_full_duration_tree;            ///< Flag telling if we want to output the full duration tree while dumping. This only make sense if #output_trees >= 2, and if 1, this means that
                                                    ///< in addition to all the levels, also the ties information is output as "t" if a chord is all tied
    char        show_rhythmic_tree_locks;            ///< Flag telling if we want to show the rhythmic tree locks (appearing when the rhythmic tree has been locked, fixed)
    char        output_and_save_level_types;        ///< Also output or save the level type information for each level, consisting in a list of (leveltype <num>), where <num> is a generic combination of #e_rhythm_level_types.
    char        try_to_join_tuplets;                ///< Try to join tuplets such as (1/24 1/24 1/24) (1/24 1/24 1/24) in tuplets having a larger number (e.g. two triplets into a 6-plet).
                                                    ///< In any case, this only affets non-TS beaming levels, and respecting the <tree_handling> chosen flag.
    char        try_to_make_tuplets_simple;            ///< Try to make tuplets simple, by merging levels into a bigger one. If this is 1, tuplets are tried to be simplified no matter the tree_handling field.
    char        try_to_beam_grace_sequences;        ///< Try to beam together the sequence of consecutive grace notes. This only works if tree handling is NOT #k_RHYTHMIC_TREE_HANDLING_TAKE_FOR_GRANTED or if we're in the Linear Editing mode. 

    char        take_rhythmic_tree_for_granted;        ///< (INTERNAL) Flag set only at undo time, meaning that the rhythmic tree must be kept "as-is" (and _essentially_ not reparsed) from the information given in the undo content
                                                    ///<  "Essentially" means that the parsing is always necessary, but will be done in a non-intrusive and non-destructive way.
    char        whole_rests_in_empty_measures;      ///< If 1 (default), allows to have centered whole rest notes in empty measures, or in measures having a single rest lasting for the whole measure

    // grace notes
    char        slash_grace_flags;                                ///< If 1, put a slash on any grace chord flag
    char        slash_grace_beams;                                ///< If 1, put a slash on any grace chord beamed figuration
    char        reverse_grace_chord_direction;                    ///< If 1, grace chord has always reversed direction with respect to the note it refers to
    t_symbol    *grace_note_equivalent_sym;                        ///< Playing equivalent for a 1/8 grace note (if this is 1/64, it'll mean that a grace quaver note will be played as a 64th note) 
    t_rational    grace_note_equivalent;                            ///< As #grace_note_equivalent_sym, but translated into a rational value
    double        max_percentage_of_chord_taken_by_grace_notes;    ///< Maximum percentage of the chord duration that can be taken by subsequent grace notes
    
    // functions
    rebuild_fn                        rebuild_function;                ///< Pointer to the function setting the whole object from llll
    notation_obj_fn                    whole_obj_undo_tick_function;    ///< Pointer to the function creating the undo tick for the whole object
    notation_obj_notation_item_fn    force_notation_item_inscreen;    ///< Pointer to a function forcing a given notation item to be inside the screen
    notation_obj_timepoint_to_ux_fn timepoint_to_unscaled_xposition;///< Pointer to a function (if any), converting a timepoint into an unscaled x position (makes sense for bach.score only)
    notation_obj_undo_redo_fn       undo_redo_function;             ///< Function for undo/redo
    bach_paint_ext_fn               paint_ext_function;             ///< Pointer to the function painting the object (in extended bach mode)
    notation_obj_inscreenmeas_fn    inscreenmeas_function;          ///< Pointer to the inscreenmeas function
    
    // attributes
    t_bach_inspector_manager    m_inspector;                        ///< Inspector manager
    
    // naming
    t_bach_label_manager        m_labels;                            ///< Name-labeling manager
    
    // used by [bach.slot]
    t_note            *dummynote;        ///< A dummy note for [bach.slot]

    // private
    char            also_changing_in_inspector_all_sync_tempi;    ///< PRIVATE, flag used to determine, when changing a tempo value in the inspector, whether to change also all synchronous tempi 
    double            curr_sampling_ms;                            ///< PRIVATE, field used to contain current samplint point in ms

    // surfaces for bitmapping most often painted elements (however we don't gain that much cpu with this...)
    t_jsurface        *quarternotehead_surface;            ///< Surface which at each paint method will be filled with the standard quarter notehead
    t_jsurface        *selected_quarternotehead_surface;    ///< Surface which at each paint method will be filled with the selection-colored quarter notehead
    t_jsurface        *solo_quarternotehead_surface;        ///< Surface which at each paint method will be filled with the solo-colored quarter notehead
    t_jsurface        *mute_quarternotehead_surface;        ///< Surface which at each paint method will be filled with the mute-colored quarter notehead
    t_jsurface        *lock_quarternotehead_surface;        ///< Surface which at each paint method will be filled with the lock-colored quarter notehead

    t_jsurface        *clef_gradient_surface;                ///< Surface to paint a gradient near the clefs for letting notation elements fade slowly 
    
    // lambda communication for custom spacing
    // changed to char to avoid complaints from vc++
    char        lambda_spacing;    ///< Spacing is delegated to lambda functions, if active
    double                      lambda_val;        ///< Field containing the return value for spacing
    
    long            tempo_approx_digits;        ///< Number of digits for tempo approximation
    
    // realtime mode stuff
    char                curr_realtime_mode;     ///< Flag telling if realtime mode is currently active
    t_realtime_attrs    curr_realtime_attrs;    ///< Current value of the realtime attributes (updated right before the realtime mode is turned on)
    
    // jitter painting stuff
    t_symbol            *jit_destination_matrix; ///< If non-NULL, also mirrors the painting of the canvas on the selected jitter Matrix.
    char                pagelike_barlines;       ///< If non-null, the barlines and measure numbers (in bach.score) are drawn as if they were on a page
    
    // mira/miraweb: stuff designed to work with mira.multitouch
    char mt_finger_state[10];                   ///< State of each finger
    t_pt mt_finger_pos[10];                     ///< Positions of each finger (in pixels)
    char mt_pinching;                           ///< Flag telling whether there's pinching going on
    double mt_zoom_at_pinch_start;              ///< Zoom at the moment the pinch started

    // backward compatibility stuff
    long                bwcompatible;           ///< Number of the version of bach towards which the object needs to be compatible. E.g. if 7900, this
                                                ///< will ensure compatibility (whenever possible...) with bach 0.7.9, and so on.
    
    char                dont_change_size_now;   ///< Internal flag to overcome an issue of  jbox_set_fontname() changing the size of the object
} t_notation_obj;



/** The object representing the external bach inspector. The information about the displayed element in the inspector is contained in the
    notation object to which the inspector is linked.
    @ingroup    attributes
 */ 
typedef struct _bach_inspector_ui {
    t_jbox            u_box;                ///< The jbox structure
    t_notation_obj                *notation_obj;        ///< The notation object to which the inspector is linked
    t_bach_inspector_manager    *inspector_manager;

//    long            dragging_y;            ///< y pixel of the last point reached while dragging (DEPRECATED)
    
    double            floatdragging_y;    ///< The same as <dragging_y>, but in double precision (DEPRECATED)
    t_bach_attribute    *edited_attribute;    ///< Attribute currently being edited as a text field
} t_bach_inspector_ui;



/** Information about some operation that can be undone.
    With the new undo system (since bach 0.7), an undo step is computed BEFORE any interface modification is performed.
    Nevertheless, not the whole object structure is saved inside the step, but only the minimal part.
    For instance, changing the onset of two chords, will produce two #t_undo_redo_information structure, which will be saved inside the
    notation object's undo_redo llll.
    @ingroup    interface
 */ 
typedef struct _undo_information
{
    long    n_it_ID;            ///< ID of the notation item whose information need to be stored.
                                ///< We stress the fact that items cannot be pointed by reference, since their pointers are volatile, so we
                                ///< keep track in a hash table of all notation items whose information could be undoed (namely, chords, measure, voices).
                                ///< If the information concerns the whole object, then this ID won't be accounted.
    
    e_element_types                n_it_type;            ///< Type of the notation item whose information need to be stored (one of the #e_element_types).
                                                    ///< If the information concerns the whole object, then this should be #k_WHOLE_NOTATION_OBJECT, if it concerns the header, this should be #k_HEADER_DATA.
    e_undo_modification_types    modification_type;    ///< Type of possible modification of the object (one of the #e_undo_modification_types)
    
    long    voice_num;            ///< Voice number of the element (if it is a #k_VOICE), or where the modified element is (this is only used if the modification is erasing the element) 
    long    meas_num;            ///< Measure number of the element (if it is a #k_MEASURE), or where the modified element is (this is only used if the modification is erasing the element).
                                ///< Of course, this is meaningless if the element is a #k_VOICE.
    e_header_elems    header_info;        ///< Header information to be undone (a combination of the #e_header_elems)
    
    t_llll    *n_it_content;        ///< Gathered-syntax values for the notation item having id n_it_ID, or for the whole notation object (if #n_it_type == #k_WHOLE_NOTATION_OBJECT or #k_HEADER_DATA)
} t_undo_redo_information;


/** Tuplet information about a given chord, in MusicXML form.
    @ingroup    import_export
 */ 
typedef struct _xml_chord_tuplet_info
{
    char        placement;                ///< Tuplet graphical placement: -1 = below, 1 = above
    char        type;                    ///< Position of the chord with respect to the tuplet, one of the #e_xml_tags.

    t_rational    normal_type;            ///< Tuplet graphical unit figure (numerator will be 1, dots are accounted for in the next field).
    char        normal_dots;            ///< Number of dots of the tuplet graphical unit.
    long        actual_notes;            ///< Actual number of tuplet graphical units (<tuplet_local_ratio>.r_num * <tuplet_multiplier>.r_num)
    long        normal_notes;            ///< Normal number of tuplet graphical units (<tuplet_local_ratio>.r_den * <tuplet_multiplier>.r_num)
    
    long        tuplet_actual_number;    ///< localtuplet_ratio_r_den * multiplier 
    t_rational    tuplet_actual_type;        ///< unitÃ  grafica della tuplet corrente, rappresentaibile! tipo se Ã¨ 3/8 l'unitÃ   
    char        tuplet_actual_dots;        ///< Numero di dots dell'unitÃ  grafica

    long        tuplet_normal_number;    ///< localtuplet_ratio_r_num * multiplier
    t_rational    tuplet_normal_type;        ///< UnitÃ  grafica della tuplet corrente
    char        tuplet_normal_dots;        ///< Numero di dots dell'unitÃ  grafica
    
} t_xml_chord_tuplet_info;


/** Beam information about a given chord, in MusicXML form.
    @ingroup    import_export
 */ 
typedef struct _xml_chord_beam_info
{
    long num_beams;                        ///< Number of beams under which a chord is.
    char beam_type[CONST_MAX_BEAMS];    ///< One of the #e_xml_tags determining the beam behaviour for any of the beamings (position 0 is the 1/8 beam, position 1 is 1/16 beam, and so on).
                                        ///< Consider that only the first #num_beams position make sense, all the rest is uninitialized.
} t_xml_chord_beam_info;







#ifndef DOXYGEN_SHOULD_SKIP_THIS
BEGIN_CHECK_LINKAGE
#endif


// ------------------- PROTOTYPES -------------------


// -----------------------------------
// NOTATION CONVERSIONS 
// -----------------------------------

/**    Convert an onset, in milliseconds, into its x position in pixels (only usable by [bach.roll]) 
    @ingroup            conversions
    @param r_ob            The notation object
    @param onset        Onset in milliseconds
    @param system        Pointer which contains either the system number (if it is >= 0), or (if it is < 0) that will be FILLED by the function with the system number.
                        If you want to get the conversion for the first system (or if you just have one system, like in #k_VIEW_SCROLL), you can leave it NULL.
    @return                The x position in pixels
 */
double onset_to_xposition_roll(t_notation_obj *r_ob, double onset, long *system); 

// private
double get_ux_left_start(t_notation_obj *r_ob);

/**    Convert a x position in pixels into an onset in milliseconds (only usable by [bach.roll]) 
    @ingroup            conversions
    @param r_ob            The notation object
    @param xposition    The x position in pixels
    @param system        Pointer which contains either the system number (if it is >= 0), or (if it is < 0) that will be FILLED by the function with the system number.
                        If you want to get the conversion for the first system (or if you just have one system, like in #k_VIEW_SCROLL), you can leave it NULL.
    @return                The onset in milliseconds
 */
double xposition_to_onset(t_notation_obj *r_ob, double xposition, long system);


/**    Get the horizontal width of the portion of score at the left of the domain starting point (including clefs, key signatures, etc.)
    @ingroup            conversions
    @param r_ob            The notation object
    @return                The horizontal width of the portion of score at the left of the domain, in pixels
 */
double get_predomain_width_pixels(t_notation_obj *r_ob);


/**    Get the horizontal width of the domain in pixels
 @ingroup            conversions
 @param r_ob            The notation object
 @return                The horizontal width of the domain in pixels
 */
double get_domain_width_pixels(t_notation_obj *r_ob);


/**    Convert a horizontal pixel distance into a time distance in milliseconds (only usable by [bach.roll]) 
    @ingroup            conversions
    @param r_ob            The notation object
    @param deltaxpixels    The horizontal pixel distance
    @return                The time distance in milliseconds
 */
double deltaxpixels_to_deltaonset(t_notation_obj *r_ob, double deltaxpixels);


/**    Convert a time distance in milliseconds into a horizontal pixel distance (only usable by [bach.roll]) 
    @ingroup            conversions
    @param r_ob            The notation object
    @param deltaxpixels    The time distance in milliseconds
    @return                The horizontal pixel distance
 */
double deltaonset_to_deltaxpixels(t_notation_obj *r_ob, double deltaonset);


/**    Convert an y pixel into the 0-based voice number
    @ingroup            conversions
    @param r_ob            The notation object
    @param yposition    The y position
    @param system       The system number (or leave -1 for auto count)
    @param voiceensemble_policy   One of the e_voiceensemble_interface_policy
    @return                The 0-based voice number of the clicked voice
 */
long yposition_to_voicenumber(t_notation_obj *r_ob, double yposition, long system, e_voiceensemble_interface_policy voiceensemble_policy);


/**    Convert an y pixel into the corresponding midicents value
    @ingroup            conversions
    @param r_ob            The notation object
    @param yposition    The y position
    @param voice        The voice
    @param system       The system number (or leave -1 for auto count)
    @return                The midicents
 */
double yposition_to_mc(t_notation_obj *r_ob, double yposition, t_voice *voice, long *system);


/**    Convert a number steps (from the middle C) into the vertical position in pixels 
    @ingroup                    conversions
    @param r_ob                    The notation object
    @param scaleposition        Number of steps of graphical vertical distance of the note with respect to the middle C (see #e_clefs for more info about steps)
    @param v_ob                    The voice for which we need to calculate the y position
    @return                        The y position in pixels of the middle of the notehead
 */
double scaleposition_to_yposition(t_notation_obj *r_ob, long scaleposition, t_voice *v_ob);


/**    Convert a number steps (from the middle C) into the vertical unscaled position in pixels
    @ingroup                    conversions
    @param r_ob                    The notation object
    @param scaleposition        Number of steps of graphical vertical distance of the note with respect to the middle C (see #e_clefs for more info about steps)
    @param v_ob                    The voice for which we need to calculate the y position
    @return                        The y position in pixels of the middle of the notehead, not scaled for vzoom.
 */
double scaleposition_to_uyposition(t_notation_obj *r_ob, long scaleposition, t_voice *v_ob);


/**    Convert midicents to vertical position in pixels 
    @ingroup        conversions
    @param r_ob        The notation object
    @param mc        Midicents
    @param v_ob        The voice for which we need to calculate the y position
    @return            The y position in pixels
 
    @remark            Differently from mc_to_yposition_in_scale(), the result is interpolated between steps. Which means that the vertical position is not
                    forced to be either on the lines or in the middle of a space: it can be anywhere. E.g. for standard G clef, if <mc> = 6410, the
                    result will be SLIGHTLY over the bottom staff line.
    @see            mc_to_yposition_in_scale()
 */
double mc_to_yposition(t_notation_obj *r_ob, double mc, t_voice *v_ob);


/**    Convert midicents to vertical position in pixels, but snapped either on the staff lines or in the staff space (middle of the staff lines),
    by using the default approximation provided by mc_to_screen_approximations()
    @ingroup        conversions
    @param r_ob        The notation object
    @param mc        Midicents
    @param v_ob        The voice for which we need to calculate the y position
    @return            The y position in pixels
 
    @remark            This works like mc_to_yposition(), but the result is NOT interpolated, and it is forced to be either on the lines or in the middle of a space.
 E.g. for standard G clef, if <mc> = 6410, the result will be EXACTLY over the bottom staff line.
    @see            mc_to_yposition()
 */
double mc_to_yposition_quantized(t_notation_obj *r_ob, double mc, t_voice *v_ob);


/**    Faster version of mc_to_yposition_quantized() using a rough floor() approximation instead of the mc_to_screen_approximations().
    @ingroup        conversions
    @param r_ob        The notation object
    @param mc        Midicents
    @param v_ob        The voice for which we need to calculate the y position
    @return            The y position in pixels
    @see            mc_to_yposition_quantized()
 */
double mc_to_yposition_in_scale(t_notation_obj *r_ob, double mc, t_voice *v_ob);


/**    Given a note, calculate the vertical position in pixels of the textbox where the notehead character will be written.
    @ingroup                conversions
    @param r_ob                The notation object
    @param note                Pointer to the note
    @param v_ob                The voice for which we need to calculate the y position
    @param notehead_resize    Resize factor for the notehead (1. = standard size)
    @param ignore_custom_noteheads  If non-zero ignores custom noteheads
    @return                    The y position in pixels of the textbox which will contain the notehead character
 
    @remark                    This works exactly like mc_to_yposition_in_scale(), but an additional vertical shift (which is the shift of the textbox top) is added.
    @see                    mc_to_yposition()
 */
double mc_to_yposition_in_scale_for_notes(t_notation_obj *r_ob, t_note *note, t_voice *v_ob, double notehead_resize, char ignore_custom_noteheads);


/**    Convert midicents into graphical pitch data: i.e. the midicents of the displayed diatonic note and the displayed accidental. 
    @ingroup                    conversions
    @param r_ob                    The notation object
    @param mc                    Midicents
    @param screen_note            Pointer to a long which will be filled with the midicents of the displayed diatonic note (_diatonic_, i.e. IGNORING accidental!!!)
    @param screen_accidental    Pointer to a #t_rational which will be filled with the displayed accidental of the note (EVEN if the accidental is then hidden, e.g. because there was an equal note right before in the measure!!!) 
    @param key_acc_pattern        The accidental pattern of the current key signature (see the <key> field of #t_voice to know more about it)
    @param full_repr            The current full eight-tonal accidental pattern, specifying the representation for each eight-tonal degree (leave NULL if none, see #t_voice for more)

    @remark                        For instance, if <mc> = 6610, in a C major situation, the algorithm will fill <screen_note> = 6500 (F), <screen_accidental> = 1/2. 
    @remark                        This is an easy wrapper of the mc_to_screen_approximations_do() function.
 */
void mc_to_screen_approximations(t_notation_obj *r_ob, double mc, long *screen_note, t_rational *screen_accidental, t_rational *key_acc_pattern, t_rational *full_repr);


/**    Convert midicents into graphical pitch data: i.e. the midicents of the displayed diatonic note and the displayed accidental (without needing a #t_notation_obj).
    The primary key for the conversion is the full_repr array. If this is not given (or can't solve the problem), the scale key degrees are tested,
    then the natural notes, and finally the intermediate steps.
    @ingroup                        conversions
    @param tone_division            The microtonal division (2 = semitones, 4 = quartertones, ...)
    @param accidental_preferences    The accidental preferences, one of the #e_accidentals_preferences
    @param mc                        Midicents
    @param screen_midicents                Pointer to a long which will be filled with the midicents of the displayed diatonic note (_diatonic_, i.e. IGNORING accidental!!!)
    @param screen_accidental        Pointer to a #t_rational which will be filled with the displayed accidental of the note (EVEN if the accidental is then hidden, e.g. because there was an equal note right before in the measure!!!) 
    @param key_acc_pattern            The accidental pattern of the current key signature (see the <key> field of #t_voice to know more about it)
     @param full_repr                The current full eight-tonal accidental pattern, specifying the representation for each eight-tonal degree (leave NULL if none, see #t_voice for more)

    @remark                            If works exactly like mc_to_screen_approximations() but it doesn't neead an r_ob. For instance, it is used by [bach.mc2n].
 */
void mc_to_screen_approximations_do(long tone_division, char accidentals_preferences, double mc, long *screen_midicents, t_rational *screen_accidental, t_rational *key_acc_pattern, t_rational *full_repr);


/**    Convert midicents into the number of (diatonic) steps from the middle C. 
    @ingroup            conversions
    @param r_ob            The notation object (or NULL if none)
    @param midicents    Midicents
    @return                The number of diatonic steps from the middle C (see #e_clefs for more info about steps)
 
    @remark                For instance, if <midicents> is 6400, the function returns 2 (since the note is 2 steps above middle C
    @remark                Use this function only when <midicents> are a diatonic midicent value.
                        For instance, do this:
                        @code
                        t_note *note;
                        long note_steps;
                        note = obtain_note_somewhere(...);
                        note_compute_approximation(r_ob, note); // This line is only needed if the note is newly created, and its approximation values have not been yet computed
                        note_steps = midicents_to_diatsteps_from_middleC(r_ob, note_get_screen_midicents(note));
                        @endcode
                        And NOT this:
                        @code
                        note_steps = midicents_to_diatsteps_from_middleC(r_ob, note->midicents);
                        @endcode
    @see                scaleposition_to_midicents()
*/
long midicents_to_diatsteps_from_middleC(t_notation_obj *r_ob, long midicents);

/**    As midicents_to_diatsteps_from_middleC() but steps are computed from C0 = 0
    @ingroup            conversions
    @param r_ob            The notation object (or NULL if none)
    @param midicents    Midicents
    @return                The number of diatonic steps from C0
    @see                midicents_to_diatsteps_from_middleC()
*/
long midicents_to_diatsteps_from_C0(t_notation_obj *r_ob, long midicents);


/**    Convert a scaleposition in steps into the midicents value (considering step 0 = middle C, step 7 = higher C and so on).
    @ingroup            conversions
    @param midicents    The number of steps from the middle C
    @return                The midicents for the specified <scaleposition>
    @see                midicents_to_diatsteps_from_middleC()
*/
long scaleposition_to_midicents(long scaleposition);


/**    Convert a millisecond position into the unscaled horizontal position in pixels (only usable by [bach.roll]).
    @ingroup                conversions
    @param r_ob                The notation object
    @param onset            The onset in milliseconds
    @return                    The unscaled x position in pixels
    @see                    onset_to_xposition_roll()
 */
double onset_to_unscaled_xposition(t_notation_obj *r_ob, double onset);


/**    Convert an unscaled horizontal position, in pixels, into the real horizontal position in pixels.
    @ingroup                conversions
    @param r_ob                The notation object
    @param unscaled_x_pos    The unscaled horizontal position (in pixels)
    @return                    The real x position in pixels
    @see                    xposition_to_unscaled_xposition()
 */
double unscaled_xposition_to_xposition(t_notation_obj *r_ob, double unscaled_x_pos);


/**    Convert an horizontal position, in pixels, into the corresponding unscaled horizontal position in pixels.
    @ingroup                conversions
    @param r_ob                The notation object
    @param unscaled_x_pos    The horizontal position (in pixels)
    @return                    The unscaled horizontal position (in pixels)
    @see                    unscaled_xposition_to_xposition()
 */
double xposition_to_unscaled_xposition(t_notation_obj *r_ob, double x_position);


/**    Convert a millisecond position into an horizontal pixel position (for [bach.roll], this is equivalent to calling onset_to_xposition_roll()).
    @ingroup                conversions
    @param r_ob                The notation object
    @param ms               The millisecond position
    @param mode             If this is 1, the position is computed only BEFORE the next barline.
    @return                    The real x position in pixels
    @see                    ms_to_unscaled_xposition()
 */
double ms_to_xposition(t_notation_obj *r_ob, double ms, char mode = 1);


/**    Convert a millisecond position into an unscaled horizontal pixel position.
    @ingroup                conversions
    @param r_ob                The notation object
    @param ms               The millisecond position
    @param mode             If this is 1,  the position is computed only BEFORE the next barline.
    @return                    The unscaled x position
    @see                    ms_to_xposition()
 */
double ms_to_unscaled_xposition(t_notation_obj *r_ob, double ms, char mode, bool accurate = true);


/**    Convert an unscaled horizontal pixel position into a millisecond position.
    @ingroup                conversions
    @param r_ob                The notation object
    @param ux               The unscaled x position
    @param mode             If this is 1,  the position is computed only BEFORE the next barline.
    @param accurate         If accurate is 1, then a slower but more accurate computation is used than the one based on the item fields
    @return                    The millisecond position
 */
double unscaled_xposition_to_ms(t_notation_obj *r_ob, double ux, char mode, char accurate = false);


/**    Convert an horizontal pixel position into a millisecond position.
    @ingroup                conversions
    @param r_ob                The notation object
    @param xposition        The x position
    @param mode             If this is 1,  the position is computed only BEFORE the next barline.
    @return                    The millisecond position
 */
double xposition_to_ms(t_notation_obj *r_ob, double xposition, char mode);



/**    Obtain the midicents of the displayed note, without the accidental.
    @ingroup                notation
    @param note             The note
    @return                    The midicents of the displayed note, without accidental
 */
long note_get_screen_midicents(t_note *nt);


/**    Obtain the accidental of the displayed note.
    @ingroup                notation
    @param note             The note
    @return                    The accidental of the displayed note
 */
t_shortRational note_get_screen_accidental(t_note *nt);


/**    Obtain the midicents of the displayed note (accidentals are also accounted for).
    @ingroup                notation
    @param note             The note
    @return                    The midicents of the displayed note
 */
t_rational note_get_screen_midicents_with_accidental(t_note *nt);


/**    Flag telling if the note pitch is user defined or not.
    @ingroup                notation
    @param note             The note
    @return                    1 if pitch is user-defined, 0 otherwise
 */
char note_is_enharmonicity_userdefined(t_note *nt);


/**    Flags the note as not having a user-defined pitch (automatic enharmonicity)
    @ingroup                notation
    @param note             The note
 */
void note_set_auto_enharmonicity(t_note *nt);


/**    Flags the note as having an user-defined pitch, and sets it
    @ingroup                notation
    @param note             The note
    @param screen_mc        The midicents of the diatonic note (no accidental)
    @param screen_acc       The accidental of the note
    @param also_assign_mc       Also assign midicents depending on the diatonic note values
 */
void note_set_user_enharmonicity_from_screen_representation(t_note *nt, double screen_mc, t_rational screen_acc, char also_assign_mc = true);
void note_set_user_enharmonicity(t_note *nt, t_pitch pitch, char also_assign_mc = true);
void note_set_enharmonicity(t_note *nt, t_pitch pitch); // if pitch is NaP it'll be auto, otherwise user
void note_set_displayed_user_enharmonicity_from_screen_representation(t_note *nt, double screen_mc, t_rational screen_acc);
void note_set_displayed_user_enharmonicity(t_note *nt, t_pitch pitch);

void note_appendpitch_to_llll_for_gathered_syntax_or_playout(t_notation_obj *r_ob, t_llll *ll, t_note *note, e_data_considering_types mode);
void note_appendpitch_to_llll_for_separate_syntax(t_notation_obj *r_ob, t_llll *ll, t_note *note, e_output_pitches pitch_output_mode = k_OUTPUT_PITCHES_DEFAULT);



/** Internal flags, typically assigned to the #t_notation_item <flag> field.
 @ingroup    notation
 */
typedef enum _bach_timepointtoux_flags {
    k_PARSETIMEPOINT_FLAG_NONE = 0,
    k_PARSETIMEPOINT_FLAG_SAMPLEALLVOICES = 1, // sample all the voices to convert
    k_PARSETIMEPOINT_FLAG_ZEROPIMISFIRSTCHORD = 2, // a zero point in measure (pim) corresponds to the first chord
    k_PARSETIMEPOINT_FLAG_MANUALGRACEBEHAVIOR = 4, // toggles a manual setting for handling graces (see below)
    k_PARSETIMEPOINT_FLAG_NUDGEBACKFORGRACES = 8, // nudge back if the timepoint has a grace note (only meaningful if previous one is set)
    k_PARSETIMEPOINT_FLAG_ACCURATE = 16, // more CPU-intensive accurate computation
} e_bach_timepointtoux_flags;

typedef enum _bach_parsetimepoint_syntaxtype {
    k_PARSETIMEPOINT_SYNTAXTYPE_NONE = 0,
    k_PARSETIMEPOINT_SYNTAXTYPE_MS,
    k_PARSETIMEPOINT_SYNTAXTYPE_NAME,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_MEASURE,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_MEASUREFLOAT,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_MEASURE_PIM,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_VOICE_MEASURE_PIM,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_GLOBAL_VOICE_PIM,
    k_PARSETIMEPOINT_SYNTAXTYPE_TP_GLOBAL_PIM,
} _bach_parsetimepoint_syntaxtype;



/// TIMEPOINT CONVERSIONS FOR [bach.score] only, TBD
double timepoint_to_ms(t_notation_obj *r_ob, t_timepoint tp, long voicenum);
t_timepoint ms_to_timepoint_autochoose_voice(t_notation_obj *r_ob, double ms, char mode, long *chosen_voice);
//t_timepoint rat_sec_to_timepoint(t_notation_obj *r_ob, t_rational rat_sec, long voicenum);
t_timepoint ms_to_timepoint(t_notation_obj *r_ob, double ms, long voicenum, char mode, t_llll *include_denominators = NULL);
double timepoint_to_unscaled_xposition(t_notation_obj *r_ob, t_timepoint tp, long flags); // flags are e_bach_timepointtoux_flags

// syntaxtype is one of the e_bach_parsetimepoint_syntaxtype
char parse_open_timepoint_syntax_from_llllelem(t_notation_obj *r_ob, t_llllelem *arguments, double *ux, double *ms, t_timepoint *tp, long flags = 0, long *syntaxtype = NULL);
char parse_open_timepoint_syntax(t_notation_obj *r_ob, t_llll *arguments, double *ux, double *ms, t_timepoint *tp, long flags = 0, long *syntaxtype = NULL);




/**    Convert a unscaled horizontal position in pixel into the underlying measure (if any) (works for [bach.score] only).
    @ingroup                conversions
    @param r_ob                The notation object
    @param ux               The unscaled x position
    @param voice            The voice
    @param barline_clicked  Pointer which will be filled with 1 if the underlying element is the measure right barline
    @return                    The pointer to the measure, or NULL if none
 */
t_measure *ux_to_measure(t_notation_obj *r_ob, double ux, t_voice *voice, char *barline_clicked);


/**    Convert an horizontal distance into its unscaled corresponding horizontal distance.
    @ingroup                conversions
    @param    r_ob            The notation object
    @param    deltaxpixels    The horizontal distance (in pixels)
    @return                    The corresponding unscaled horizontal distance (in pixels)
    @see                    deltauxpixels_to_deltaxpixels()
 */
double deltaxpixels_to_deltauxpixels(t_notation_obj *r_ob, double deltaxpixels);


/**    Convert an unscaled horizontal distance into the real horizontal distance.
    @ingroup                conversions
    @param    r_ob            The notation object
    @param    deltauxpixels    The unscaled horizontal distance (in pixels)
    @return                    The corresponding real horizontal distance (in pixels)
    @see                    deltaxpixels_to_deltauxpixels()
 */
double deltauxpixels_to_deltaxpixels(t_notation_obj *r_ob, double deltauxpixels);


// TBD
t_symbol *clef_llllelem_to_symbol(t_llllelem *el);


/**    Convert a clef (represented as long) into its name (represented as a symbol)
    @ingroup        conversions
    @param    r_ob    The notation object
    @param    clef    The clef as one of the #e_clefs
    @return            The clef name as symbol
    @see    clef_symbol_to_clef_number()
*/ 
t_symbol* clef_number_to_clef_symbol(t_notation_obj *r_ob, long clef);


/**    Convert a clef name (represented as a symbol) into its representation as longs (#e_clefs)
    @ingroup        conversions
    @param    r_ob    The notation object
    @param    clef    The clef name as a symbol
    @return            The clef as one of the #e_clefs
    @see    clef_number_to_clef_symbol()
 */ 
long clef_symbol_to_clef_number(t_notation_obj *r_ob, t_symbol *clef);


/**    Convert a pitch (screen midicent and a screen accidental) into its note name.
    @ingroup                conversions
    @param    middleC_octave    The octave number of middle C (usually 3, 4, or 5)
    @param    screen_mc        The shown screen midicents for the diatonic note (ignoring the accidental)
    @param    screen_acc        The screen accidental
    @param    name_style        One of the #e_note_names_styles, to specify which convention you want to use for naming (latin or anglosaxon)
    @param  print_octave    If non-zero, adds the note octave number
    @param    outname            Pointer which will be initialized and filled with the resulting string
                            If *outname is NULL, it also allocates the memory.
    @remark                    For instance, if <middleC_octave> = 4, <screen_mc> = 6200, <screen_acc> = -1 (double flat),
                            <name_style> = k_NOTE_NAMES_LATIN, then outname will be "Rebb4".
    @see                    notename2midicents()
    @see                    ezmidicents2notename()
*/ 
void midicents2notename(long middleC_octave, long screen_mc, t_rational screen_acc, char name_style, char print_octave, char **outname);


/**    Quick'n'dirty conversion of a midicent pitch into its note name. It is a wrapper of midicents2notename(), in which the screen midicents and
    screen accidental are computed by default
    @ingroup                conversions
    @param    middleC_octave    The octave number of middle C (usually 3, 4, or 5)
    @param    midicents        The midicents
    @param    name_style        One of the #e_note_names_styles, to specify which convention you want to use for naming (latin or anglosaxon)
    @param  print_octave    If non-zero, adds the note octave number
    @param    outname            Pointer which will be initialized and filled with the resulting string
    @param    tonedivision    The microtonal grid (2 = semitones, 4 = quartertones...)
    @see                    midicents2notename()
*/ 
void ezmidicents2notename(long middleC_octave, double midicents, char name_style, char print_octave, char **outname, long tonedivision);


/**    Convert a note name into its screen midicents and accidental.
    @ingroup                    conversions
    @param    middleC_octave        The octave number of middle C (usually 3, 4, or 5)
    @param    last_used_octave    A pointer to a long containing the octave of the last introduced note. This pointer will be in turn filled with the
                                octave of this same note. This is useful when parsing strings like "C4 D E F# G5 A B", with the convention that
                                whenever the octave is not specified, the last used one is kept valid.
    @param    name                A string containing the name of the note.
    @param    screen_mc            Pointer to a long which will be filled with the midicents of the diatonic note (ignoring accidentals). Leave NULL if unneeded.
    @param    screen_acc            Pointer to a #t_rational which will be filled with the accidental to display. Leave NULL if unneeded.
    @return                        The midicents of the note (also considering accidentals).
    @remark                        For instance, if <middleC_octave> = 3, <last_used_octave> points on 4, name is "C#5", <screen_mc> will be filled with
                                8400, <screen_acc> will be filled with 1/2, <last_used_octave> will be filled with 5, and 8500 will be returned.
    @see                        midicents2notename()
*/ 
double notename2midicents(long middleC_octave, long *last_used_octave, char *name, long *screen_mc, t_rational *screen_acc);


/**    Convert a diatonic step (0 to 6) into its corresponding diatonic midicent value, in a given octave.
    @ingroup        conversions
    @param    step    The diatonic step (0 to 6, 0 being C and 6 being upper B)
    @param    acc        The accidental
    @param    name_style        One of the #e_note_names_styles, to specify which convention you want to use for naming (latin or anglosaxon)
    @param    outname            Pointer which will be initialized and filled with the resulting string
    @remark            For instance, 2 and 1/4 are converted into "E+"; 0 and -1/2 are converted into "Cb"...
*/ 
void diatonicstep_and_accidental2notename(long step, t_rational acc, char name_style, char **outname);


/**    Convert a diatonic midicent value into the corresponding diatonic step (0 to 6) in the diatonic scale from C to upper C.
    @ingroup        conversions
    @param    mc        The midicent value
    @return            The corresponding diatonic step, from 0 = C (do) to 6 = B (si). If <mc> was NOT a diatonic midicent value, -1 is returned.
    @remark            For instance, 6400 is converted into 2 (note E, third step).
    @see            diatonicstep2midicents()
*/ 
long midicents2diatonicstep(long mc);


/**    Convert a diatonic step (0 to 6) into its corresponding diatonic midicent value, in a given octave.
    @ingroup        conversions
    @param    step    The diatonic step (0 to 6, 0 being C and 6 being upper B)
    @param    octave    The octave in which we want to place the step to get the midicents.
    @return            The corresponding midicents value.
    @remark            For instance, 2 and octave = 3 is converted into 3 * 1200 + 400 (corresponding to the major third).
    @see            midicents2diatonicstep()
*/ 
long diatonicstep2midicents(long step, long octave);


/**    Convert a diatonic step (0 to 6) and an accidental into the number of chromatic steps in a given microtonal grid.
    @ingroup                conversions
    @param    diatonic_step    The diatonic step (0 to 6, 0 being C and 6 being upper B)
    @param    accidental        The accidental
    @param    tonedivision    The microtonal grid (2 = semitones, 4 = quartertones...)
    @return                    The corresponding midicents value.
    @remark                    For instance, if tonedivision = 4, diatonic_step = 2 and accidental = 1/4, the result is 9 (position of E+ on the 24 "bins" of the quartertonal grid)
*/ 
long diatonic_step_and_accidental_to_chromatic_step(char diatonic_step, t_rational accidental, long tonedivision);


/**    Convert a note and mode into its key value, and fill the accidental pattern
    @ingroup                    conversions
    @param    r_ob                The notation object
    @param    screen_midicents    The midicent values
    @param    screen_acc            The accidental values
    @param    mode                The voice mode
    @param    acc_pattern            Array of 7 #t_rational, representing the accidentals, which will be filled with the accidental pattern 
    @return                        The corresponding key in the circle of fifths (see the <key> field in the #t_voice structure) or -100 if nonstandard.
*/ 
char basenote2key(t_notation_obj *r_ob, double screen_midicents, t_rational screen_acc, char mode, t_rational *acc_pattern);


/**    Parse a symbol identifying a key signature into its three related fields in the voice structure: key, mode and accidental pattern.
    @ingroup                    conversions
    @param    r_ob                The notation object
    @param    sym                    The symbol
    @param    key                    Pointer which will be filled with the key (see t_voice::key)
    @param    mode                Pointer which will be filled with the mode (see t_voice::mode)
    @param    acc_pattern            Pointer to the array of 7 #t_rational will be filled with the accidental pattern (see t_voice::acc_pattern)
*/ 
void parse_sym_to_key_and_mode(t_notation_obj *r_ob, t_symbol *sym, char *key, char *mode, t_rational *acc_pattern);


/**    Convert a key, mode and accidental pattern information into the step of the tonic and the accidental related to this step.
    @remark                        For instance, if key = 2, mode = #k_MODE_MAJOR, corresponding to D major, this will fill step = 1 (D) and accidental = 0. 
    @ingroup                    conversions
    @param    key                    The key
    @param    mode                The mode
    @param    acc_pattern            Array of 7 #t_rational, representing the accidental pattern
    @param    step                Pointer which will be filled with the resulting step (0 to 6, representing C to upper B)
    @param    accidental            Pointer which will be filled with the accidental of the resulting step
*/ 
void key_and_mode_to_step_and_accidental(char key, char mode, t_rational *acc_pattern, char *step, t_rational *accidental);


/**    Convert an accidental into its symbolic representation (e.g. -1/2 is translated into "b" and 1/4 into "+").
    @ingroup        conversions
    @param    acc        The accidental, as rational fraction of the tone
    @return            The accidental as a symbol
    @see            symbol_to_acc()
*/ 
t_symbol *acc_to_symbol(t_rational acc);


/**    Convert a symbol representing an accidental into the accidental as a rational value
    @ingroup        conversions
    @param    symbo    The accidental as a symbol
    @return            The accidental, as rational fraction of the tone
    @see            acc_to_symbol()
*/ 
t_rational symbol_to_acc(t_symbol *sym);


/**    Convert the current key and mode (and accidental pattern) to a symbol expressing the key signature (e.g. "Cm" or, for nonstandard modes
    also symbols like "+ n n n n - b").
    @ingroup                    conversions
    @param    r_ob                The notation object
    @param    key                    The voice key
    @param    mode                The voice mode (one of the #e_modes)
    @param    acc_pattern            Array of 7 #t_rational, representing the accidental pattern. It is only taken into account if the mode is nonstandard
    @return                        A symbol expressing the key and mode.
*/ 
t_symbol *key_and_mode_to_sym(t_notation_obj *r_ob, char key, e_modes mode, t_rational *acc_pattern);


/** Convert an OpenMusic rhythmic tree into a bach rhythmic tree.
    @ingroup    conversions
    @param        omtree        The tree in the Open-Music form
    @param        measureinfo    Pointer which will be filled with an llll containing the measureinfo 
    @return                    The tree in the bach form
 */
t_llll *om_rhythmic_tree_to_bach_rhythmic_tree(t_llll *omtree, t_llll **measureinfo);    // fills the measureinfo


/** Convert a bach rhythmic tree into an OpenMusic rhythmic tree. 
    @ingroup    conversions
    @param        durs        The bach durations rhythmic tree. 
                            Notice that this is not the bach rhythmic tree: this tree does NOT contain #H_OBJs, but rather the durations as #H_RATs
                            and possibly some "t" symbols to indicate ties.
    @param        measureinfo    The measureinfo 
    @return                    The tree in the OpenMusic form
 */
t_llll *bach_rhythmic_tree_to_om_rhythmic_tree(t_llll *durs, t_llll *measureinfo);


/** Convert a symbolic graphic representation (figure) and a number of dots into the corresponding global symbolic duration
    @ingroup    conversions
    @param        figure        The figure (symbolic graphic representation)
    @param        num_dots    The number of dots that the figure has.
    @return                    The overall symbolic duration of the figure with the dots
 */
t_rational figure_and_dots_to_figure_sym_duration(t_rational figure, char num_dots);


/** Convert a symbol into one of the #e_element_types. The symbol can usually be either plural or singular. 
    For instance, gensym("chords") and gensym("chord") are both converted into #k_CHORD. Not for all #e_element_types this conversion
    is defined, but only for the ones which make sense for editing
    @ingroup    conversions
    @param        sym        The symbol
    @return        The element type as one of the #e_element_types
 */
long elementtypesym2elementtypeid(t_symbol *sym);


/** Convert a symbol into one of the #e_element_actions.
    @ingroup    conversions
    @param        sym        The symbol
    @return        The action as one of the #e_element_actions
 */
long actiontypesym2actiontypeid(t_symbol *sym);


/** Convert an llll containing the symbols of header objects into a combination of #e_header_elems.
    @ingroup    conversions
    @param        llll        The llll containing a sequence of symbols of header objects ("body", "header", "clefs", "markers", "groups", "midichannel", "commands", "keys", "slotinfo", "voicenames", "stafflines"...)
    @return        The combination of header objects as a number (combination of #e_header_elems).
 */
e_header_elems header_objects_to_long(t_llll *header_objects_llll);


/** Convert a symbol to the corresponding long in the enumeration of #e_slot_linkages. For instance, gensym("lyrics") is converted into k_SLOT_LINKAGE_LYRICS.
    @ingroup    conversions
    @param    r_ob    The    notation object
    @param    sym        The symbol
    @return            The corresponding element of the #e_slot_linkages
 */
long linkto_sym_to_linkto_elem(t_notation_obj *r_ob, t_symbol *sym);


/**    Convert a measure as bach structure into an llll representing the measure in PWGL syntax.
    @ingroup                conversions
    @param        r_ob        The notation object
    @param        meas        The measure
    @param        need_set_double    Pointer to a char containing the information if the first chord in the measure is completely tied from the measure before.
                                This information is also set while parsing the measure, and at the end will contain true if and only if the last chord of the
                                measure is completely tied to the starting chord of the next measure.
 */
t_llll *bach_measure_to_pwgl_measure(t_notation_obj *r_ob, t_measure *meas, char *need_set_double);


/**    Convert a rhythmic level into an llll representing the measure in PWGL syntax.
    @ingroup                conversions
    @param        r_ob        The notation object
    @param        meas        The measure
    @param        need_set_double    Pointer to a char containing the information if the first chord in the level is completely tied from the chord before.
                                This information is also set while parsing the level, and at the end will contain true if and only if the last chord of the
                                level is completely tied to the following one.
    @remark        This function is called by bach_measure_to_pwgl_measure()
 */
void bach2pwgl_measure_level(t_notation_obj *r_ob, t_llll *box, char *need_set_double);


/**    Convert the bach.score separate syntax into the bach.score gathered syntax.
    @ingroup                conversions
    @param    measureinfo    The measureinfo
    @param    cents        The cents
    @param    durations    The durations
    @param    velocities    The velocities
    @param    ties        The ties
    @param    extras        The extras
    @return    An llll with the score's gathered syntax corresponding to the input separate parameters.
    @see    score_gathered2separate_syntax()
 */
t_llll *score_separate2gathered_syntax(t_llll *measureinfo, t_llll *cents, t_llll *durations, t_llll *velocities, t_llll *ties, t_llll *extras);


/**    Convert the bach.score gathered syntax into the bach.score separate syntax.
    @ingroup                conversions
    @param    gathered    The bach.score gathered syntax
    @param    measureinfo    Pointer to an llll which will be filled with the measureinfo
    @param    cents        Pointer to an llll which will be filled with the cents
    @param    durations    Pointer to an llll which will be filled with the durations
    @param    velocities    Pointer to an llll which will be filled with the velocities
    @param    ties        Pointer to an llll which will be filled with the ties
    @param    extras        Pointer to an llll which will be filled with the extras
    @param    put_all_grace_notes_to_zero_duration    If this is non-zero, all grace chords will be represented with chords having duration = 0. Otherwise, grace chords
                                                    will be represented inside grace levels (levels starting with the "g" symbol). Both forms are accepted in input by bach.score.
    @see    score_separate2gathered_syntax()
 */
void score_gathered2separate_syntax(t_llll *gathered, t_llll **measureinfo, t_llll **cents, t_llll **durations, t_llll **velocities, t_llll **ties, t_llll **extras,
                                    char put_all_grace_notes_to_zero_duration);

// TO DO, IF NEEDED: analogous bach.roll conversions?


// -----------------------------------
// NOTATION UTILITIES 
// -----------------------------------

/**    Tell if the diatonic step, in the white-keys pattern on the keyboard, after a given degree, is a semitone.
    @ingroup            notation_utilities
    @param        degree    The degree in the diatonic C scale (0 = C, 1 = D, 2 = E, 3 = F, 4 = G, 5 = A, 6 = B).
    @return                1 if the diatonic step after the degree is a semitone, 1 if it is a tone.
*/ 
char is_diatonic_step_after_degree_semitone(long degree);


/** Obtain midicents from an llllelem containing either a double or a note name (symbol). 
    @ingroup            notation_utilities
     @param    r_ob        The notation object
    @param    elem        The llllelem containing either the pitch of the note as double or a note name
    @return                The midicents of the note
*/
double get_midicents_from_double_elem_or_notename(t_notation_obj *r_ob, t_llllelem *elem);


/**    Retrieve some standard enharmonic possibilities for the graphical representation of a note.
    These possibilities are stored in the #current_enharmonic_list_screenmc and #current_enharmonic_list_screenacc fields of the #t_notation_obj structure.
    The algorithm also fills the #curr_idx pointer with the index, within the lists, of the current note representation.
    @ingroup            notation_utilities
    @param    r_ob        The notation object
    @param    note        The note
    @param    curr_idx    Pointer which will be filled with the index of the current representation (the index is referred to the #current_enharmonic_list_screenmc and #current_enharmonic_list_screenacc arrays).
                        This will be filled with -1 if the note enharmonical representation is not in the arrays. 
*/ 
void note_get_enharmonic_possibilities(t_notation_obj *r_ob, t_note *note, long *curr_idx);


/**    Fills a full-representation array (array of 48 #t_rational containing accidental representation for each eighttonal step) 
    with default values.
    @ingroup            notation_utilities
    @param    r_ob        The notation object
    @param    full_repr    The full representation array (sized at least 48 #t_rational) to be filled
    @param    key            The key
    @param    mode        The mode
    @param    acc_pattern    The accidental pattern
*/ 
void fill_default_full_repr(t_notation_obj *r_ob, t_rational *full_repr, char key, char mode, t_rational *acc_pattern);


/**    Parse the full accidental patterns of all voices (see #t_voice) into a single symbol for each voice
    to be put in the t_notation_obj::full_acc_repr field. 
    @ingroup            notation_utilities
    @param    r_ob        The notation object
*/ 
void parse_fullaccpattern_to_voices(t_notation_obj *r_ob);


/**    Convert the full representation array of a given voice into a symbol (also according to the tonedivision value of the notation object)
    @ingroup            notation_utilities
    @param    r_ob        The notation object
    @param    voice        The voice
    @return                The symbol representing the full representation field of the voice (see #t_voice)
*/ 
t_symbol *full_repr_to_symbol(t_notation_obj *r_ob, t_voice *voice);


/**    Compare two timepoints, telling which one comes first.
    @ingroup            notation_utilities
    @param    tp1        First timepoint
    @param    tp2        Second timepoint
    @return            0 if the timepoints happen in the same moment, -1 if #tp1 happens first, 1 if #tp2 happens first.
*/ 
char timepoint_compare(t_timepoint tp1, t_timepoint tp2);


/**    Interpolate two timepoints lying in the same measure of the same voice.
    @ingroup        notation_utilities
    @param    tp1        First timepoint
    @param    tp2        Second timepoint
    @param    param    Parameter, 0 to 1, for the interpolation, 0 being #tp1 and 1 being #tp2
    @param    include_denominators    A flat list of allowed denominators for the interpolation
    @return            The interpolated timepoint.
    @remark            The two timepoints must lie within the same measure of the same voice!
*/ 
t_timepoint interpolate_timepoints(t_timepoint tp1, t_timepoint tp2, double param, t_llll *include_denominators = NULL);


/**    Convert a llll in the form of (measure_number position_in_measure voice_number), or any of the subforms (measure_number) or (measure_number position_in_measure)
    into the corresponding timepoint.
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    ll        The llll
    @param    is_voice_defined                If non-NULL, this is a pointer which will be filled with 1 if the voice number is defined, 0 otherwise
    @param    also_clip                       If non-zero, the goodness of voice number and measure numbers will be checked, otherwise they will be clipped.
    @param    syntaxtype                    If non-null, will be filled with one of the e_bach_parsetimepoint_syntaxtype
    @return            The timepoint corresponding to the llll, with the syntax explained above.
*/ 
t_timepoint llll_to_timepoint(t_notation_obj *r_ob, t_llll *innerllll, char *is_voice_defined, char also_clip, long *syntaxtype = NULL);


/**    Retrieve the number of sub-lllls of a given llll (but only at the base level) which do NOT start with an attribute symbol, such as "name", "ID", "lyrics...".
    Please notice that they are totally allowed to start with a note name (still symbol).
    This is useful to know for instance how many notes are there in a gathered-syntax chord llll.
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    inllll    The llll
    @return            The number of sub-lllls at the root level of the incoming llll which do NOT start with an attribute symbol
    @see            is_symbol_attribute()
*/ 
long get_num_llll_no_first_attribute_sym_in_llll(t_llll *inllll);


/**    Retrieve the next element which is an llll and does not have an attribute as head.
    @ingroup        notation_utilities
    @param    elem    The current llllelem
    @return            The next llllelem being an llll and not having an attribute as head.
    @see            get_num_llll_no_first_attribute_sym_in_llll()
    @see            is_symbol_attribute()
*/ 
t_llllelem *get_next_llll_no_first_attribute_sym_elem(t_llllelem *elem);


/**    Tells if a given symbol specifies a property of a notation item, such as "name", "ID", "lyrics...".
    @ingroup        notation_utilities
    @param    sym        The symbol
    @return            1 if the symbol specifies a property, 0 otherwise (for instance with notenames such as "F#2" this would return 0)
    @see            get_num_llll_no_first_attribute_sym_in_llll()
*/ 
char is_symbol_attribute(t_symbol *sym);


/** Shift and copy the arrays which, in the notation object structure, are related to voicewise stuff (one element for each voie).
    One might want to call this function, for instance, because a voice was inserted or deleted. 
    The arrays which are altered are, namely, the following ones: t_notation_obj::clefs_as_symlist, t_notation_obj::keys_as_symlist,
    t_notation_obj::hidevoices_as_charlist, t_notation_obj::voiceuspacing_as_floatlist, t_notation_obj::show_measure_numbers,
    t_notation_obj::midichannels_as_longlist.
    @ingroup    notation_utilities
    @param    r_ob        The    notation object
    @param    from_idx    0-based index of the first voice to be shifted
    @param    to_idx        0-based index of the target element where the elements will be shifted
    @param    num_elems_to_shift    Number of elements which will be copied from the start position <from_idx> to the target position <to_idx>
    @remark    For instance, if <from_idx> = 0, <to_idx> = 1, <num_elems_to_shift> = 3, the first three elements will be copied-shifted 
            of one position forward. If midichannels were (7 11 12 14 18), now they'll be (7 7 11 12 18).
 */
void shift_voicewise_arrays(t_notation_obj *r_ob, long from_idx, long to_idx, long num_elems_to_shift);


/** Swap two elements in the arrays which, in the notation object structure, are related to voicewise stuff (one element for each voie).
    One might want to call this function, for instance, because two voices were swapped. 
    The arrays which are altered are, namely, the following ones: t_notation_obj::clefs_as_symlist, t_notation_obj::keys_as_symlist,
    t_notation_obj::hidevoices_as_charlist, t_notation_obj::voiceuspacing_as_floatlist, t_notation_obj::show_measure_numbers,
    t_notation_obj::midichannels_as_longlist.
    @ingroup    notation_utilities
    @param    r_ob        The    notation object
    @param    idx1        0-based index of the first voice to swap
    @param    idx2        0-based index of the second voice to swap
 */
void swapelem_voicewise_arrays(t_notation_obj *r_ob, long idx1, long idx2);


/** Infer the most appropriate clefs with which to display a certain sequence of pitches. 
    Data falling farther than <cutoff_threshold> * stdev(pitches) are ignored, then the data range is compared with the staff ranges for any
    possible clef, and the best one is chosen.
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    pitches    A not-necessarily-plain llll containing all the pitches as H_DOUBLE elements.
    @param    cutoff_threshold    Cutoff threshold for pitch ignoring. Pitches falling farther than <cutoff_threshold> * stdev(pitches) are ignored.
    @param  allowed_clefs       If non-null, sets the list of clefs that are allowed. If NULL, a default set is used.
    @return            One of the #e_clefs, the most appropriate key to display the pitch content.
*/ 
long infer_most_appropriate_clef(t_notation_obj *r_ob, t_llll *pitches, double cutoff_threshold, t_llll *allowed_clefs = NULL);


/** Infer the most appropriate clefs with which to display the pitches of a given voice. 
    Data falling farther than <cutoff_threshold> * stdev(pitches) are ignored, then the data range is compared with the staff ranges for any
    possible clef, and the best one is chosen.
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    voice    The voice containing the pitches.
    @param    cutoff_threshold    Cutoff threshold for pitch ignoring. Pitches falling farther than <cutoff_threshold> * stdev(pitches) are ignored.
    @param  allowed_clefs       If non-null, sets the list of clefs that are allowed. If NULL, a default set is used.
    @return            One of the #e_clefs, the most appropriate key to display the pitch content.
 */ 
long infer_most_appropriate_clef_for_voice(t_notation_obj *r_ob, t_voice *voice, double cutoff_threshold, t_llll *allowed_clefs = NULL);



/** Resynchronize the t_notation_obj::full_acc_repr array according to each voice t_voice::full_repr (unless it is the default one), and then parse it 
    again to properly fill the t_voice::full_repr and t_notation::full_acc_repr arrays.
    @ingroup        notation_utilities
    @param    r_ob    The notation object
*/ 
void check_all_voices_fullaccpatterns(t_notation_obj *r_ob);

/** Tell if a given reference midicent position lies inside the staff (or staves) of a given voice, that is: if it is higher (or equal) than the midicents of the 
    bottommost staff line and lower (or equal) than the midicents of the uppermost staffline
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    mc        The reference midicents
    @param    clef    The clef of the voice (determining the staff)
    @return            1 if the midicents position is inside the voice's staff (or staves), 0 otherwise.
    @remark            VERY IMPORTANT: Beware! this function does NOT account for nonstandard staff lines.
    @remark            This function is different from is_mc_within_staff() since it also includes as "good" the blank space between the staves
                    of multi-staff voices. See is_mc_within_staff() for more information.
    @see    is_y_within_voice_staff()
    @see    is_mc_within_staff()
*/ 
char is_mc_within_whole_staves_range(t_notation_obj *r_ob, double mc, int clef);


/** Tell if a given reference midicent position lies inside one of the staves of a given voice. Differently from is_mc_within_whole_staves_range()
    the blank space between the staves of multi-staff voices is not accounted, so that, for instance, the <mc> = 6000 position for a #k_CLEF_FG would
    return 0 (= false). Only positions inside one of the staves will be accounted for. 
    @ingroup        notation_utilities
    @param    r_ob    The notation object
    @param    mc        The reference midicents
    @param    clef    The clef of the voice (determining the staff)
    @return            1 if the midicents position is inside the voice's staff (or staves), 0 otherwise.
    @remark            VERY IMPORTANT: Beware! this function does NOT account for nonstandard staff lines.
    @see    is_y_within_voice_staff()
    @see    is_mc_within_whole_staves_range()
*/ 
char is_mc_within_staff(t_notation_obj *r_ob, double mc, int clef);

// TBD
char is_rest_within_staff(t_notation_obj *r_ob, t_chord *rest);


/** Get the midicents corresponding to the bottommost and uppermost staff lines for a given staff (clef). 
    @ingroup        notation_utilities
    @param    clef    The clef of the voice (determining the staff)
    @param    mc_min    Pointer which will be filled with the bottommost staff line midicents
    @param    mc_max    Pointer which will be filled with the uppermost staff line midicents
*/ 
void get_staff_range_mc(int clef, long *mc_min, long *mc_max);


/** Obtain a default number of beams associated with a given figure (= displayed rational duration).
    For instance, if <figure> = 1/32, the number of beams is 3. 
    @ingroup        notation_utilities
    @param    figure    The symbolic figure (displayed rational duration)
    @return    The number of beams associated by default with the figure.
    @remark Only standard figures should be introduced; nevertheless if nonstandard figures are introduced, they are considered as default tuplets
            and the corresponding beams number is returned (e.g. 1/24 -> 2).
*/ 
long get_num_beams_from_figure(t_rational figure);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
// OLD AND DEPRECATED
long get_bits_from_figure(t_rational figure);
#endif




// -----------------------------------
// GRAPHICAL 
// -----------------------------------

/**    Obtain the unscaled width of a barline in pixels.
    Won't accept "automatic" as barline mode (use measure_get_barline_ux_width() instead)
    @ingroup        notation_graphics
    @param r_ob        The notation object
    @param barline    Barline type (one of the #e_barline_modifier)
    @return            The unscaled width of the barline
 */
double get_barline_ux_width(t_notation_obj *r_ob, char barline);


/**    Obtain the unscaled width of a measure barline in pixels.
    @ingroup        notation_graphics
    @param r_ob        The notation object
    @param measure    The measure
    @return            The unscaled width of the barline
 */
double measure_get_barline_ux_width(t_notation_obj *r_ob, t_measure *meas);



/**    If the <force_non_antialiased_staff_lines> field of the notation object is non-zero, it changes the <zoom_y> field
    in order to display the staff lines on exact pixels (thus to have then NON-antialiased).
    @ingroup        notation_graphics
    @param r_ob        The notation object
    @remark            Remember that antialiased value is still saved in the <zoom_y_with_antialias> field
 */
void adjust_zoom_for_non_antialiased_lines(t_notation_obj *r_ob);


/**    Refresh the position of the horizontal scrollbar (refresh all the horizontal scrollbar fields in the structure.
    @ingroup            notation_graphics
    @param r_ob            The notation object
    @param from_what    Flag telling which is the master value to refresh the scrollbar.
                        If <from_what> = 0, the field which gives the information is the <hscrollbar_x> field (starting horizontal pixel of the scrollbar rectangle)
                        If <from_what> = 1, the field which gives the information is the <hscrollbar_pos> field (normalized position of the scrollbar from 0. = debut to 1. = end)
                        If <from_what> = 2, the field which gives the information is the <screen_ms_start> field (starting milliseconds of the current screen window)
                        All the other fields are recomputed according to this master value.
    @remark                Also updates domain. It does not ask for repaint.
 */
void update_hscrollbar(t_notation_obj *r_ob, char from_what);


/**    Refresh the position of the horizontal scrollbar (refresh all the horizontal scrollbar fields in the structure.
    @ingroup            notation_graphics
    @param r_ob            The notation object
    @param from_what    Flag telling which is the master value to refresh the scrollbar.
                        If <from_what> = 0, the field which gives the information is the <hscrollbar_x> field (starting horizontal pixel of the scrollbar rectangle)
                        If <from_what> = 1, the field which gives the information is the <hscrollbar_pos> field (normalized position of the scrollbar from 0. = debut to 1. = end)
                        If <from_what> = 2, the field which gives the information is the <screen_ms_start> field (starting milliseconds of the current screen window)
                        All the other fields are recomputed according to this master value.
    @remark                Also updates domain. It does not ask for repaint.
 */
void update_vscrollbar(t_notation_obj *r_ob, char from_what);


/**    Update the horizontal scrollbar, and redraw the object if needed
    @ingroup            notation_graphics
    @param r_ob            The notation object
    @param from_what    Flag telling which is the master value to refresh the scrollbar, see update_hscrollbar() for more information
    @see                update_hscrollbar()
 */
void redraw_hscrollbar(t_notation_obj *r_ob, char from_pos);


/**    Update the vertical scrollbar, and redraw the object if needed
    @ingroup            notation_graphics
    @param r_ob            The notation object
    @param from_what    Flag telling which is the master value to refresh the scrollbar, see update_vscrollbar() for more information
    @see                update_vscrollbar()
 */
void redraw_vscrollbar(t_notation_obj *r_ob, char from_pos);


/**    Automatically update the horizontal scrollbar, and paint it if needed 
    @ingroup                notation_graphics
    @ingroup                notation_paint
    @param r_ob                The notation object
    @param g                The graphic context
    @param graphic_rect        The object rectangle
    @see                    update_hscrollbar()
 */
void update_hscrollbar_and_paint_it_if_needed(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect);


/**    Automatically update the vertical scrollbar, and paint it if needed 
    @ingroup            notation_graphics
    @ingroup            notation_paint
    @param r_ob            The notation object
    @param g            The graphic context
    @param graphic_rect    The object rectangle
    @see                update_vscrollbar()
 */
void update_vscrollbar_and_paint_it_if_needed(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect);


//TBD
void update_all_accidentals_if_needed(t_notation_obj *r_ob);
void update_all_accidentals_for_voice_if_needed(t_notation_obj *r_ob, t_voice *voice);
void update_all_accidentals_for_chord_if_needed(t_notation_obj *r_ob, t_chord *chord);


/**    Obtain the horizontal width of the vertical scrollbar (in pixels) 
    @ingroup            notation_graphics
    @param r_ob            The notation object
 */
double get_vscrollbar_width(t_notation_obj *r_ob);


/**    Obtain the maximum between the horizontal width of the vertical scrollbar or the ending horizontal inset (both in pixels) 
    @ingroup            notation_graphics
    @param r_ob            The notation object
 */
double get_max_vscrollbar_width_or_inset_x(t_notation_obj *r_ob);


/**    Detect if a chord is inside the screen, or in the hidden left or right part (only used by [bach.score]).
    @ingroup            notation_graphics
    @param r_ob            The notation object
    @param chord        The chord
    @return                0 if the chord is INSIDE the screen, -1 if it is hidden in the left part, 1 if it is hidden in the right part, -2 if can't compute 
    @remark                BEWARE: only used it with [bach.score]!!!
 */
char chord_get_placement_in_screen(t_notation_obj *r_ob, t_chord *chord);


/** Tell if a given vertical pixel position is inside the staff (or staves) of a given voice.
    @ingroup        notation_graphics
    @param    r_ob    The notation object
    @param    y        The vertical pixel position
    @param    voice    The voice
    @return            1 if the pixel is inside the voice's staff (or staves), 0 otherwise.
    @see is_mc_within_staff()
*/ 
char is_y_within_voice_staff(t_notation_obj *r_ob, double y, t_voice *voice);


/** Tell if a given vertical pixel position is inside the staff (or staves) of any voice.
    @ingroup        notation_graphics
    @param    r_ob    The notation object
    @param    y        The vertical pixel position
    @return            1 if the pixel is inside some voice's staff (or staves), 0 otherwise.
    @see is_y_within_voice_staff()
 */
char is_y_within_any_staff(t_notation_obj *r_ob, double y);


/** Tell if a given vertical pixel position is inside the blank space below the staff (or staves) of a given voice and above the
    staff (or staves) of the next one (if any), or the same with the previous voice
    @ingroup        notation_graphics
    @param    r_ob    The notation object
    @param    y        The vertical pixel position
    @param    voice    The voice
    @return            1 if the pixel is below the voice's staff (or staves), but above the next voice's staff (or staves); 
                    -1 if the pixel is below the previous voice's staff (or staves) but above this voice's staff (or staves);
                    0 otherwise (also 0 if voice was the only voice).
    @see is_y_within_voice_staff()
    @remark    This function is used to select measures when t_notation_obj::draw_barlines_across_staves is set.
*/ 
char is_y_between_this_staff_and_the_next_or_prev(t_notation_obj *r_ob, double y, t_voice *voice);


/** Fill or update the t_voice::middleC_y field for a given voice. That field contains the pixel y position of the middle C inside the voice.
    @ingroup    notation_graphics
    @param    r_ob    The notation object
    @param    voice    The voice
    @see    compute_middleC_position_for_all_voices()
*/
void compute_middleC_position_for_voice(t_notation_obj *r_ob, t_voice *voice);


/** Fill or update the t_voice::middleC_y field for all voices. That field contains the pixel y position of the middle C inside the voice.
    @ingroup    notation_graphics
    @param    r_ob    The notation object
    @param    voice    The voice
    @see    compute_middleC_position_for_voice()
*/
void compute_middleC_position_for_all_voices(t_notation_obj *r_ob);


/** Fill or update the t_voice::offset_y fields for all voices. That field contains the vertical offset in pixel of the voice with respect 
    to the top of the drawing rectangle.
    @ingroup        notation_graphics
    @param    r_ob    The notation object.
*/
void calculate_voice_offsets(t_notation_obj *r_ob);


/** Obtain the maximum width (in unscaled pixels) needed for key signature painting.
    @ingroup        notation_graphics
    @param    r_ob    The notation object.
    @return            The width (in unscaled pixels) needed for key signature painting
*/
double get_max_key_uwidth(t_notation_obj *r_ob);


/** Set automatically the size of the rectangle containing a roll or score, depending on the vertical zoom, on the number of voices, and on the voices distances.
    This size accounts for all the voices being properly drawn, without needing a vertical scrollbar.
    @ingroup        notation_graphics
    @param    r_ob    The notation object.
    @remark            A typical code is:
    @code
        if (r_ob->link_vzoom_to_height)
            auto_set_rectangle_size(r_ob);
    @endcode
*/
void auto_set_rectangle_size(t_notation_obj *r_ob);

// (private)
void auto_set_rectangle_size_do(t_notation_obj *r_ob);


/** Obtain the top and bottom positions of the playhead line, in pixels.
    @ingroup notation_graphics
    @param    r_ob        The notation object
    @param    rect        The drawing rectangle corresponding to the patcherview
    @param    y1            Pointer which will be filled with the y position of the top of the playhead line
    @param    y2            Pointer which will be filled with the y position of the bottom of the playhead line
*/
void get_playhead_ypos(t_notation_obj *r_ob, t_rect rect, double *y1, double *y2);



// -----------------------------------
// TYPOGRAPHICAL
// -----------------------------------

/**    Returns the Unicode character for an accidental, given the current <accidentals_typo_preferences> of the notation object.
    @ingroup            typographical
    @param r_ob            The notation object
    @param accidental    Accidental (in rational form, e.g. -1/2 = flat...)
    @return                Unicode character for the accidental
 */
unicodeChar get_accidental_character(t_notation_obj *r_ob, t_rational accidental);


/**    Returns the unscaled top extension of an accidental, given the current <accidentals_typo_preferences> of the notation object.
    See #e_accidentals_typo_preferences for more informatino about what the unscaled top extension is.
    @ingroup            typographical
    @param r_ob            The notation object
    @param accidental    Accidental (in rational form, e.g. -1/2 = flat...)
    @return                Unscaled top exension of the accidental
 */
double get_accidental_top_uextension(t_notation_obj *r_ob, t_rational accidental); 


/**    Returns the unscaled bottom extension of an accidental, given the current <accidentals_typo_preferences> of the notation object.
    See #e_accidentals_typo_preferences for more informatino about what the unscaled bottom extension is.
    @ingroup            typographical
    @param r_ob            The notation object
    @param accidental    Accidental (in rational form, e.g. -1/2 = flat...)
    @return                Unscaled bottom exension of the accidental
 */
double get_accidental_bottom_uextension(t_notation_obj *r_ob, t_rational accidental);


//TBD
double note_get_accidental_top_uextension(t_notation_obj *r_ob, t_note *note);
double note_get_accidental_bottom_uextension(t_notation_obj *r_ob, t_note *note);


/**    Returns the unscaled width of an accidental, given the current <accidentals_typo_preferences> of the notation object.
    @ingroup            typographical
    @param r_ob            The notation object
    @param accidental    Accidental (in rational form, e.g. -1/2 = flat...)
    @param always_classical_display    If this flag is non-zero, the accidentals are always assumed to be displayed classically,
                                    via #k_ACCIDENTALS_CLASSICAL. This is handy when painting the key signatures, which 
                                    is always painted with classical accidentals. Leave this to 0 otherwise.
    @return                Unscaled width of the accidental
 */
double get_accidental_uwidth(t_notation_obj *r_ob, t_rational accidental, char always_classical_display);


/**    Convert a number into a sequence of unicode characters. 
    @ingroup                typographical
    @param r_ob                The notation object
    @param number            The number to be converted
    @param utfchars            The array whose elements will be filled with the utfchars. 
                            It must be already big enough to contain data; typically one can set <maxchars> equal to the size of <utfchars> to be sure not to have troubles
    @param num_ascii_chars    Pointer which will be filled with the number of ascii characters necessary to paint the number correctly
    @param plus_sign        If this is 1, a plus sign is added at the beginning of nonnegative numbers
 */
void long_to_unicodeChars(t_notation_obj *r_ob, long number, unicodeChar* utfchars, long *num_ascii_chars, long maxchars, char plus_sign);


/**    Load the graphical preference for notation for the specified <font>. 
     @ingroup        typographical
    @param r_ob        The notation object
    @param font        The font name
 */
void load_notation_typo_preferences(t_notation_obj *r_ob, t_symbol *font);


/**    Set the graphical preference for notation from a given llll.
    @ingroup        typographical
    @param r_ob        The notation object
    @param ll       The llll, in the form (<spec> <value>) (<spec> <value>)...
 */
void set_notation_typo_preferences_from_llll(t_notation_obj *r_ob, t_llll *ll);


/**    Load the graphical preference for accidentals for the specified <font>. 
    @ingroup        typographical
    @param r_ob        The notation object
    @param font        The font name
 */
void load_accidentals_typo_preferences(t_notation_obj *r_ob, t_symbol *font);


/**    Load the graphical preference for noteheads for the specified <font>.
    @ingroup        typographical
    @param r_ob        The notation object
    @param font        The font name
 */
void load_noteheads_typo_preferences(t_notation_obj *r_ob, t_symbol *font);


/**    Load the graphical preference for articulations for the specified <font>. 
    @ingroup        typographical
    @param r_ob        The notation object
    @param font        The font name
 */
void load_articulations_typo_preferences(t_articulations_typo_preferences *atp, t_symbol *font);


// Internal
void set_articulation_names(t_articulations_typo_preferences *atp, long art_ID, t_symbol *fullname, t_symbol *shortname, t_symbol *alias1 = NULL, t_symbol *alias2 = NULL, t_symbol *alias3 = NULL, t_symbol *alias4 = NULL, t_symbol *alias5 = NULL);

void set_notehead_names(t_noteheads_typo_preferences *ntp, long art_ID, t_symbol *fullname, t_symbol *shortname, t_symbol *alias1 = NULL, t_symbol *alias2 = NULL, t_symbol *alias3 = NULL, t_symbol *alias4 = NULL, t_symbol *alias5 = NULL);


/**    Obtain the vertical pixel position a rest should have (in a similar way as mc_to_yposition_in_scale() does for midicents).
    This is considered to correspond to the vertical baricenter of the rest (middle point). So, for instance, in most cases 
    this will be the middle point of the staff where the rest will be (and the function will choose this staff properly, in case
    the voice has two or more staves, depending on the musical content before and after the rest), but in case of floating rest this
    might of course vary. If needed, the function also fills a pointer with the dummy midicent value corresponding to the returned pixel position. 
    @ingroup        typographical
    @param r_ob        The notation object
    @param rest        The rest (as a chord)
    @param mc        Pointer to a double which will be filled with the dummy midicent value corresponding to the rest vertical pixel position.
    @param steps    Pointer to a long which will be filled with the scaleposition corresponding to the rest
    @return            The vertical pixel corresponding to the vertical position of the rest.
    @see            mc_to_yposition_in_scale()
 */
double rest_get_nonfloating_yposition(t_notation_obj *r_ob, t_chord *rest, double *mc, long *steps);


/**    As rest_get_nonfloating_yposition() but also accounts for the #float_step field of the rest.
    @ingroup        typographical
    @param r_ob        The notation object
    @param rest        The rest (as a chord)
    @param mc        Pointer to a double which will be filled with the dummy midicent value corresponding to the rest vertical pixel position.
    @param steps    Pointer to a long which will be filled with the scaleposition corresponding to the rest
    @return            The vertical pixel corresponding to the vertical position of the rest.
    @see            rest_get_nonfloating_yposition()
 */
double rest_get_floating_yposition(t_notation_obj *r_ob, t_chord *rest, double *mc, long *steps);


/**    Obtain the vertical pixel position a rest should have in midicents. This is nothing but a small wrapper of rest_get_nonfloating_yposition(),
    returning the value which was stored into the <mc> array.
    @ingroup        typographical
    @param r_ob        The notation object
    @param rest        The rest (as a chord)
    @return            The vertical position of the rest in midicents. 
    @see            rest_get_nonfloating_yposition()
 */
double rest_get_dummy_mc(t_notation_obj *r_ob, t_chord *rest);


/**    Get the unicode character for a notehead depending on the symbolic rational duration.
    @ingroup            typographical
    @param    r_ob        The notation object (or NULL if used outside a notation object, in which case the functions return the November for bach font black notehead width)
    @param    duration    The duration of the chord
    @param    uwidth        Pointer which will be filled with the unscaled width of the notehead.
    @return                The unicode character of the notehead.
 */
unicodeChar get_notehead_unicode_character(t_notation_obj *r_ob, t_rational duration, double *uwidth);


/**    Get the unscaled width of a notehead of a given note or associated with a given symbolic duration.
    @ingroup                notation
    @param    r_ob            The notation object
    @param    r_sym_duration    The duration of the chord
    @param    note            If requested, the note of which we want to retrieve the unscaled width.
                            This is useful since, if notehead was associated with some slot content,
                            this is taken into account. This can't be taken into account if this field is left NULL,
                            in which case, however, the function will output the default width for the introduced duration 
    @param account_for_grace_chords Also account for reduction factor due to grace chords
    @return                    The unscaled width of the notehead
 */
double notehead_get_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration, t_note *note, char account_for_grace_chords);

// TBD
void get_notehead_specs(t_notation_obj *r_ob, long notehead_ID, t_rational rdur, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift);
long get_notehead_specs_from_rdur(t_notation_obj *r_ob, t_rational rdur, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift);
long get_notehead_specs_from_note(t_notation_obj *r_ob, t_note *note, unicodeChar *character, double *uwidth, double *ux_shift, double *uy_shift, double *small_ux_shift, double *small_uy_shift, double *duration_line_start_ux_shift, char avoid_returning_default, char ignore_custom_noteheads);


/**    Get the default width for a portion of score. This function is used inside tuttipoint_calculate_spacing() in order to determine the
    width that each tuttipoint section might have. (If tuttipoints coincide with measures, we'll ask for the default unscaled width of the entire measure). 
    @ingroup                    typographical
    @param    r_ob                The notation object
    @param    density                The symbolic event density of the portion of the score (number of chords per whole note)
    @param    symbolic_duration    The rational symbolic duration of the portion of the score
    @param    min_needed_uwidth    Minimum unscaled width needed to draw all the musical content of the portion of the score. 
                                This roughly corresponds to the sum of the unscaled widths of all the elements (plus some 'minimum distance' constants). 
    @param    is_entire_measure    Flag which has to be 1 if the portion of the score for which we ask the width correspond to an entire measure
    @param    gamma                The 'gamma' parameter in the function documentation, i.e. the spacing multiplicative parameter.
                                Beware: the behaviour of modifying 'gamma' is not always multiplicative, since the algorithm uses some minimum thresholds
                                for a given measure with a given density, so that the returned uwidth will not be less than a given spacing (and even 
                                setting gamma = 0 will just return this minimal fixed spacing). 
    @param    return                The default unscaled width for the portion of the score.
*/
double get_default_uwidth(t_notation_obj *r_ob, t_rational density, t_rational symbolic_duration, double min_needed_uwidth, char is_entire_measure, double gamma);


/**    Round a number to the nearest semiinteger number. This is used to correct an horizontal pixel position (supposedly a stem position) 
    into the nearest pixel position the stem may have. Indeed, a stem will only assume (for graphical beauty) just
    semiinteger horizontal pixel positions (0.5, 1.5, 2.5,...), so this function is just a little wrapper of round(stem_x - 0.5) + 0.5.
    @ingroup            typographical
    @param    stem_x        The original stem position;
    @param    return        The corrected stem position.
*/
double round_to_semiinteger(double stem_x);


/**    Get the unicode character for a given rest
    @ingroup                typographical
    @param    r_ob            The notation object
    @param    r_sym_duration    The symbolic duration of the rest
    @param    return            The unicode character corresponding to the rest symbolic duration.
*/
unicodeChar rest_get_unicode_character(t_notation_obj *r_ob, t_rational r_sym_duration);


/**    Get the maximum unscaled width of the notes gathering on the right side of the chord stem. 
    @remark            If the chord is a thick cluster, this is in general different than the unscaled with of a single notehead.
    @ingroup        typographical
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    return    The unscaled width of the part of the chord on the right side of the stem.
*/
double chord_get_right_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord);


/**    Get the unscaled width of the part of the chord on the left side of the stem.
    @remark            If the chord is a thick cluster, this is in general different than the unscaled with of a single notehead.
    @ingroup        typographical
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    return    The unscaled width of the part of the chord on the left side of the stem.
*/
double chord_get_left_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord);


/**    Get the principal note of a chord.
    The principal note is the note located at the main side of the stem which is nearest to the stem.
    @ingroup        typographical
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    return    The principal note
 */
t_note *get_principal_note(t_notation_obj *r_ob, t_chord *chord);


/**    Get the notehead unscaled width for the principal note notehead.
    The principal note is the note located at the main side of the stem which is nearest to the stem.
    @ingroup        typographical
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    return    The unscaled width of the principal note notehead.
*/
double get_principal_notehead_uwidth(t_notation_obj *r_ob, t_chord *chord);




/**    Get the unscaled width of the part of the chord on main side of the stem. The main side of the stem is the side of the stem
    where a single note would be put by default, so it's the left one (in case the stem is up) or the right one (in case the stem is down).
    If a chord reference is given, this takes into account precisely the chord notes (if the chord is a thick cluster, this is 
    in general different than the unscaled with of a single notehead). If a chord reference is not given, the input symbolic duration
    is taken into account, and the output will simply correspond to the notehead_get_uwidth() function.
    @ingroup                typographical
    @param    r_ob            The notation object
    @param    r_sym_duration    The symbolic duration (accounted for only if no chord reference is given)
    @param    chord            The chord (or leave NULL if you want to calculate it simply for a default 1-note chord, in which case 
                            the #r_sym_duration is taken into account)
    @param    return            The unscaled width of the part of the chord on the main side of the stem (left side if the chord has stem up, 
                            right side if the chord has stem down).
*/
double chord_get_mainside_notehead_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration, t_chord *chord);


/**    For bach.roll, retrieves the stem position given the alignment point. (For bach.roll only)
    @ingroup                    typographical
    @param    r_ob                The notation object
    @param    chord                The chord
    @param    chord_alignment_x    The alignment point in pixels
    @param    return                The chord stem horizontal position, in pixels.
*/
double get_stem_x_from_alignment_point_x(t_notation_obj *r_ob, t_chord *chord, double chord_alignment_x);


/**    Get the unscaled width of a rest.
    @ingroup                typographical
    @param    r_ob            The    notation object
    @param    r_sym_duration    The rest symbolic duration
    @param    return            The unscaled width of the rest.
*/
double rest_get_uwidth(t_notation_obj *r_ob, t_rational r_sym_duration);


/**    Get the top vertical extension (from the rest vertical barycenter position upwards) of a rest, in steps.
    @ingroup                typographical
    @param    r_ob            The    notation object
    @param    r_sym_duration    The rest symbolic duration
    @param    return            The top vertical extension of the rest, in step.
*/
double rest_get_top_extension_in_steps(t_notation_obj *r_ob, t_rational r_sym_duration);


/**    Get the bottom vertical extension (from the rest vertical barycenter position downwards) of a rest, in steps.
    @ingroup                typographical
    @param    r_ob            The    notation object
    @param    r_sym_duration    The rest symbolic duration
    @param    return            The bottom vertical extension of the rest, in step.
*/
double rest_get_bottom_extension_in_steps(t_notation_obj *r_ob, t_rational r_sym_duration);




// -----------------------------------
// NOTATION COLORS
// -----------------------------------

/**    Change a given color depending if the element is selected, played, locked, muted, solo or speedy-edited.
    So the element might assume the selection color, play color, locked color, muted color, solo color or a combination of these. Or the speedy edit color.
    @ingroup            notation_colors
    @param r_ob            The notation object
    @param color        The color to be changed
    @param selected        Is element selected?
    @param play            Is element played?
    @param locked        Is element locked?
    @param muted        Is element muted?
    @param solo            Is element solo?
    @param linear_edited    Is element being speedy-edited? (for [bach.score] only)
 */
void change_color_depending_on_playlockmute(t_notation_obj *r_ob, t_jrgba *color, char selected, char play, char locked, char muted, char solo, char linear_edited);


/**    Obtain the color of a notehead
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param note                        Pointer to the note
    @param is_note_selected            Is note selected?
    @param is_note_played            Is note played?
    @param is_note_locked            Is note locked?
    @param is_note_muted            Is note muted?
    @param is_note_solo                Is note solo?
    @param is_note_linear_edited    Is note being speedy-edited?
    @param velocity                    Velocity of the note
    @return                            Resulting color for the notehead
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba note_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity);


/**    Obtain the color of a duration line
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param note                        Pointer to the note
    @param is_note_selected            Is note selected?
    @param is_note_played            Is note played?
    @param is_note_locked            Is note locked?
    @param is_note_muted            Is note muted?
    @param is_note_solo                Is note solo?
    @param is_note_linear_edited    Is note being speedy-edited?
    @param velocity                    Velocity of the note
    @return                            Resulting color for the line
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba durationline_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity);


/**    Obtain the color of a accidental
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param note                        Pointer to the note beraing the accidental
    @param is_note_selected            Is note selected?
    @param is_note_played            Is note played?
    @param is_note_locked            Is note locked?
    @param is_note_muted            Is note muted?
    @param is_note_solo                Is note solo?
    @param is_note_linear_edited    Is note being speedy-edited?
    @param velocity                    Velocity of the note
    @return                            Resulting color for the accidental
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba accidental_get_color(t_notation_obj *r_ob, t_note* note, char is_note_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity);


/**    Obtain the color of the note tail
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param note                        Pointer to the note
    @param is_note_selected            Is note selected?
    @param is_note_played            Is note played?
    @param is_note_locked            Is note locked?
    @param is_note_muted            Is note muted?
    @param is_note_solo                Is note solo?
    @param is_note_linear_edited    Is note being speedy-edited?
    @param velocity                    Velocity of the note
    @return                            Resulting color for the note tail
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba tail_get_color(t_notation_obj *r_ob, t_note* note, char is_tail_selected, char is_note_played, char is_note_locked, char is_note_muted, char is_note_solo, char is_note_linear_edited, double velocity);


/**    Obtain the color of a chord stem
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the chord stem
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba stem_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);

t_jrgba chord_get_stem_color(t_notation_obj *r_ob, t_chord* chord);


/**    Obtain the color of a chord flag
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the chord flag
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba flag_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);


/**    Obtain the color of a rest
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the rest
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba rest_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);

/**    Obtain the color of an articulation
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord bearing the articulation
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the articulation
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba articulation_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);


/**    Obtain the color of a textual annotation
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord bearing the annotation
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the text annotation
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba annotation_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);


/**    Obtain the color of a dynamic marking
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param chord                    Pointer to the chord bearing the dynamic
    @param is_chord_selected        Is chord selected?
    @param is_chord_played            Is chord played?
    @param is_chord_locked            Is chord locked?
    @param is_chord_muted            Is chord muted?
    @param is_chord_solo            Is chord solo?
    @param is_chord_linear_edited    Is chord being speedy-edited?
    @return                            Resulting color for the dynamic
    @remark                            This is based on change_color_depending_on_playlockmute()
 */
t_jrgba dynamics_get_color(t_notation_obj *r_ob, t_chord* chord, char is_chord_selected, char is_chord_played, char is_chord_locked, char is_chord_muted, char is_chord_solo, char is_chord_linear_edited);


/**    Get the color of beams.
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param voice                    The voice
    @return                            Color for the beams
 */
t_jrgba beam_get_color(t_notation_obj *r_ob, t_voice *voice);


/**    Get the color of tuplet elements.
    @ingroup                        notation_colors
    @param r_ob                        The notation object
    @param voice                    The voice
    @return                            Color for tuplet elements
 */
t_jrgba tuplet_get_color(t_notation_obj *r_ob, t_voice *voice);


/**    Obtain the color of a measure
    @ingroup                        notation_colors
     @param r_ob                        The notation object
     @param is_measure_selected        Is measure selected?
    @param is_measure_locked        Is measure locked?
     @param is_measure_muted            Is measure muted?
    @param is_measure_solo            Is measure solo?
    @param is_measure_linear_edited    Is measure being speedy-edited?
    @return                            Resulting color for the measure
    @remark                            This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba measure_get_color(t_notation_obj *r_ob, char is_measure_selected, char is_measure_locked, char is_measure_muted, char is_measure_solo, char is_measure_linear_edited);


/**    Obtain the color of the main staves of a voice
    @ingroup                    notation_colors
    @param r_ob                    The notation object
    @param is_voice_selected    Is voice selected?
    @param is_voice_locked        Is voice locked?
    @param is_voice_muted        Is voice muted?
    @param is_voice_solo        Is voice solo?
    @return                        Resulting color for the main staves of the voice
    @remark                        This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba get_mainstaff_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo);


/**    Obtain the color of the clefs of a voice
    @ingroup                    notation_colors
    @param r_ob                    The notation object
    @param is_voice_selected    Is voice selected?
    @param is_voice_locked        Is voice locked?
    @param is_voice_muted        Is voice muted?
    @param is_voice_solo        Is voice solo?
    @return                        Resulting color for the clefs of the voice
    @remark                        This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba clef_get_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo);


/**    Obtain the color of the auxiliary clefs of a voice
    @ingroup                    notation_colors
    @param r_ob                 The notation object
    @param is_voice_selected    Is voice selected?
    @param is_voice_locked      Is voice locked?
    @param is_voice_muted       Is voice muted?
    @param is_voice_solo        Is voice solo?
    @return                     Resulting color for the auxiliary clefs of the voice
    @remark                     This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba get_auxclef_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo);


/**    Obtain the color of the key signature of a voice
    @ingroup                    notation_colors
    @param r_ob                    The notation object
    @param is_voice_selected    Is voice selected?
    @param is_voice_locked        Is voice locked?
    @param is_voice_muted        Is voice muted?
    @param is_voice_solo        Is voice solo?
    @return                        Resulting color for the key signature of the voice
    @remark                        This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba get_keysig_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo);


/**    Obtain the color of the auxiliary staves of a voice
    @ingroup                    notation_colors
    @param r_ob                    The notation object
    @param is_voice_selected    Is voice selected?
    @param is_voice_locked        Is voice locked?
    @param is_voice_muted        Is voice muted?
    @param is_voice_solo        Is voice solo?
    @return                        Resulting color for the auxiliary staves of the voice
    @remark                        This is a convenience wrapper for change_color_depending_on_playlockmute()
 */
t_jrgba get_auxstaff_color(t_notation_obj *r_ob, char is_voice_selected, char is_voice_locked, char is_voice_muted, char is_voice_solo);


/**    Obtain the filling color of the selection rectangle (which currently is a default one and can't be changed).
    @ingroup    notation_colors
    @return        The filling color of the selection rectangle
 */
t_jrgba get_default_selection_rectangle_fill_color();


/**    Obtain the border color of the selection rectangle (which currently is a default one and can't be changed).
    @ingroup    notation_colors
    @return        The border color of the selection rectangle
 */
t_jrgba get_default_selection_rectangle_border_color();


/**    Obtain the filling color of the zooming rectangle (which currently is a default one and can't be changed).
    @ingroup    notation_colors
    @return        The filling color of the zooming rectangle
 */
t_jrgba get_default_selection_rectangle_zooming_fill_color();


/**    Modify a color by assigning to it rgba components contained as doubles in a llll.
    @ingroup    notation_colors
    @param        color            Pointer to the color to be modified
    @param        llll            The llll containing 1 to 4 elements (rgba components)
 */
void change_color_according_to_llll(t_jrgba *color, t_llll *llll);


/**    Changes a color depending on a velocity, applying apply_velocity_colorscale(), apply_velocity_colorspectrum(),
    apply_velocity_alphascale(), depending on the velocity_handling field of the notation object
    @ingroup            colors
    @param    color       Pointer to the color
    @param    velocity    The velocity
    @param    is_selected Is element selected?
    @param  is_played   Is element played?
 */
void apply_velocity_handling(t_notation_obj *r_ob, t_jrgba *color, double velocity, char is_selected, char is_played);


/**    Changes a note color depending on a color slot linkage
    @ingroup            colors
    @param  r_ob        The notation object
    @param    color       Pointer to the color
    @param    note        The note containing the slots
 */
void note_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_note *note);


/**    Changes a notation item color depending on a color slot linkage
    @ingroup            colors
    @param   r_ob        The notation object
    @param    color       Pointer to the color
    @param    nitem        The notation item containing the slots
 */
void notation_item_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_notation_item *nitem);



/**    Changes a duration line color depending on a color slot linkage
    @ingroup            colors
    @param  r_ob        The notation object
    @param    color       Pointer to the color
    @param    note        The note containing the slots
 */
void durationline_change_color_depending_on_slot_linkage(t_notation_obj *r_ob, t_jrgba *color, t_note *note);



// -----------------------------------
// QUERIES AND CALCULATIONS
// -----------------------------------

/**    Retrieve a querying label from an llll containing the query parameters
    @ingroup                    notation_utilities
    @param r_ob                    The notation object
    @param input_as_llll        The input llll
    @param also_destroy_label    Do we destroy the (label ...) llll if we find it?
    @return                        The querying label, if any; NULL if no querying label is defined
    @see                        get_querying_label_from_GIMME()
 */
t_symbol *get_querying_label_from_querying_llll(t_notation_obj *r_ob, t_llll *input_as_llll, char also_destroy_label);



/**    Retrieve a querying label from the A_GIMME message introduced by the user
    @ingroup            notation_utilities
    @param r_ob            The notation object
    @param s            The symbol in the A_GIMME signature
    @param ac            The number of atoms in the A_GIMME signature
    @param av            The array of atoms in the A_GIMME signature
    @return                The querying label, if any; NULL if no querying label is defined
    @see                get_querying_label_from_querying_llll()
 */
t_symbol *get_querying_label_from_GIMME(t_notation_obj *r_ob, t_symbol *s, long ac, t_atom *av);


/**    Recompute the length of the object. Only works for [bach.roll], by filling the t_notation_obj::length_ms and t_notation_obj::length_ms_till_last_note fields.
    @ingroup            notation
    @param r_ob            The notation object
 */
void recompute_total_length(t_notation_obj *r_ob);


/**    Update the t_notation_obj::length_ms and t_notation_obj::length_ms_till_last_note fields starting from a new total_length_ms_till_last_note. Only works for [bach.roll].
    @remark                This function has to be preferred to recompute_total_length() when a new chord is ADDED: in this case, there's no need of recomputing the total lenght,
                        but only to check whether the lenghts are still valid or have been increased by the presence of the new chord
    @ingroup            notation
    @param    r_ob                            The notation object
    @param    total_length_ms_till_last_note    The new real total length of the content (till the end of the last note). 
 */
void update_total_length_from_length_ms_till_last_note(t_notation_obj *r_ob, double total_length_ms_till_last_note);


/**    Recalculate the end of the window and the domain, starting from the value .
    As often, for [bach.roll] this fills the <domain> and <screen_ms_end> fields (both in milliseconds); for [bach.score] this fills the 
    <domain_ux> and <screen_ux_end> fields, both in unscaled horizontal pixels.
    @ingroup            notation
    @param r_ob            The notation object
 */
void update_domain(t_notation_obj *r_ob);


/**    Updates the domain by using update_domain() and then returns it. Only used by [bach.roll]
    @ingroup            notation
    @param r_ob            The notation object
    @return                The domain in milliseconds; returns -1 if the object hasn't been painted yet
 */
long getdomain(t_notation_obj *r_ob);


/**    Changes the current horizontal zoom (correctly fills both <zoom_x> and <horizontal_zoom> fields). 
    @ingroup                    notation
    @param r_ob                    The notation object
    @param    new_zoom_100_based    The new zoom, 100 being the 100%.
    @remark                Zoom values are clipped between 1 and #CONST_MAX_ZOOM.
 */
void change_zoom(t_notation_obj *r_ob, double new_zoom_100_based);





// -----------------------------------
// INITIALIZATION STUFF
// -----------------------------------

/**    Initialize commands information with default commands
    @ingroup            notation_utilities
    @param r_ob            The notation object
 */
void initialize_commands(t_notation_obj *r_ob);


/**    Initialize a #t_voice element with default values
    @ingroup            notation_utilities
    @param r_ob            The notation object
    @param v_ob            The #t_voice voice
    @param number        Number of the voice
 */
void initialize_voice_by_default(t_notation_obj *r_ob, t_voice *v_ob, long number);


/**    Initialize a #t_scorevoice element.
    @ingroup            notation_utilities
    @param    r_ob        The notation object
    @param    v_ob        The #t_scorevoice voice
    @param    number        Number of the voice
    @param    key            Symbol specifying the key signature (e.g. "Ebm")
 */
void initialize_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, long voice_number, t_symbol *key);


/**    Initialize a #t_rollvoice element.
    @ingroup            notation_utilities
    @param    r_ob        The notation object
    @param    v_ob        The #t_rollvoice voice
    @param    number        Number of the voice
    @param    key            Symbol specifying the key signature (e.g. "Ebm")
 */
void initialize_rollvoice(t_notation_obj *r_ob, t_rollvoice *voice, long voice_number, t_symbol *key);


/**    Initialize a notation object
    @ingroup                notation_utilities
    @param    r_ob            The notation object
    @param    obj_type        One of the #e_notation_objects, determining which is the notation object.
    @param    rebuild            Pointer to the function rebuilding the whole object from a given llll. Must be implemented for each notation object.
    @param    whole_undo_tick    Pointer to the function creating an undo tick for the whole notation object. Must be implemented for each notation object.
    @param    force_notation_item_inscreen        Pointer to a function forcing a notation item to be inside the screen; leave NULL if unneeded.
    @param    undo_redo_fn                       Pointer to the undo/redo function; leave NULL if unneeded.
    @param  bach_paint_ext_fn paint_extended    Pointer to the paint function (in extended bach mode, i.e. with a bach_paint_ext_fn signature)
*/
void notation_obj_init(t_notation_obj *r_ob, char obj_type, rebuild_fn rebuild, notation_obj_fn whole_undo_tick, notation_obj_notation_item_fn force_notation_item_inscreen, notation_obj_undo_redo_fn undo_redo_fn, bach_paint_ext_fn paint_extended);


/**    Initialize (or re-initialize) slot information with a default slotinfo 
    @ingroup            notation_utilities
    @param r_ob            The notation object
    @param reinitialize    If this is 1, this function works as a re-initialization of slots, which is different from the initialization
                        because it entails slot types conversion. Leave it to 0 for the first time you use it, leave it to 1 for
                        any time you call it later.
 */
void initialize_slots(t_notation_obj *r_ob, char reinitialize);


/** Initialize all popup menus, by setting the pointers to NULL, and by creating the popup menu fonts.
    @ingroup    notation_utilities
    @ingroup    popup_menus
    @param        r_ob        The notation object
 */
void initialize_popup_menus(t_notation_obj *r_ob);


/** Perform the attr_dictionary_process() routine, but before and after the function takes care of the possible
    backward attribute compatibilities, and of possible arguments.
    @ingroup    notation_utilities
    @param        x        Pointer to the notation object
    @param        d        The dictionary
    @see        attr_dictionary_process()
 */
void notation_obj_arg_attr_dictionary_process_with_bw_compatibility(void *x, t_dictionary *d);



// PRE-SCHEDULING
void notation_obj_clear_prescheduled_events(t_notation_obj *r_ob);
void notation_obj_preschedule_end(t_notation_obj *x, t_symbol *s, long argc, t_atom *argv);
void notation_obj_preschedule_task(t_notation_obj *r_ob);
void notation_obj_append_prescheduled_event(t_notation_obj *r_ob, double time, t_llll *content, char is_notewise, char is_end);





// -----------------------------------
// FREEING STUFF
// -----------------------------------

/**    Free memory of a notation object
    @ingroup        notation_free
    @param r_ob        The notation object
 */
void notation_obj_free(t_notation_obj *r_ob);


/**    Free the memory of a notation item (created via build_notation_item())
    @ingroup        notation_free
    @param it        The notation item
 */
void notation_item_free(t_notation_item *it);


/**    Free the memory of slots of a notation item
    @ingroup        notation_free
    @param r_ob        The notation object
    @param nitem    The notation item
 */
void free_notationitem_slots(t_notation_obj *r_ob, t_notation_item *nitem);


/**    Free memory of a note
    @ingroup        notation_free
    @param r_ob        The notation object
    @param note        The note
 */
void free_note(t_notation_obj *r_ob, t_note *note);


/**    Free memory of a chord
    @ingroup        notation_free
    @param r_ob        The notation object
    @param chord    The chord
 */
void free_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Free memory of a voice
    @ingroup        notation_free
    @param r_ob        The notation object
    @param voice    The voice
 */
void free_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Free memory of a piece of lyrics
    @ingroup        notation_free
    @param r_ob        The notation object
    @param ly        The piece of lyrics
 */
void free_lyrics(t_notation_obj *r_ob, t_lyrics *ly);


/**    Free memory of a piece of dynamics
    @ingroup        notation_free
    @param r_ob        The notation object
    @param dy        The piece of dynamics
 */
void free_dynamics(t_notation_obj *r_ob, t_dynamics *dy);


/**    Free memory of a tempo
    @ingroup        notation_free
    @param r_ob        The notation object (might be NULL if the tempo has been created independently from any notation object).
     @param tempo    The tempo
 */
void free_tempo(t_notation_obj *r_ob, t_tempo *tempo);


/**    Free memory of a beam
    @ingroup        notation_free
    @param r_ob        The notation object
     @param beam        The beam
 */
void free_beam(t_notation_obj *r_ob, t_beam *beam);


/**    Free memory of a measure.
    @ingroup        notation_free
    @param r_ob        The notation object
    @param measure    The measure
    @remark            It also frees the memory of the chords, tempi and beamings contained in the measure (so you must NOT explicitely call free_tempo() and free_beam() on any of them)
 */
void free_measure(t_notation_obj *r_ob, t_measure *measure);


/**    Free memory of a measure, but with the possibility not to free some stuff
    @ingroup        notation_free
    @param r_ob        The notation object
    @param measure    The measure
    @param dont_free_chords If non-zero, don't frees the memory of the chords (if 0, it does)
    @param dont_free_rhythmic_tree If non-zero doesn't free the rhythmic tree llll
    @remark            It also frees the memory of the tempi and beamings contained in the measure (so you must NOT explicitely call free_tempo() and free_beam() on any of them)
 */
void free_measure_ext(t_notation_obj *r_ob, t_measure *measure, char dont_free_chords, char dont_free_rhythmic_tree);


/**    Free memory of a tuttipoint
    @ingroup            notation_free
    @param r_ob        The notation object
     @param tuttipoint    The tuttipoint
 */
void free_tuttipoint(t_notation_obj *r_ob, t_tuttipoint *tuttipoint);


/**    Free memory of a marker.
    @ingroup            notation_free
    @param r_ob        The notation object
    @param marker        The marker
 */
void free_marker(t_notation_obj *r_ob, t_marker *marker);


/**    Free memory of the notation object associated with slotinfo content.
    @ingroup        notation_free
    @param r_ob        The notation object
    @param r_ob        Pointer ot the notation object
 */
void free_slotinfos(t_notation_obj *r_ob);


/**    Free the memory of all the alignment points for a tuttipoint
    @ingroup        notation_free
    @param r_ob        The notation object
    @param tpt        The tuttipoint
 */
void tuttipoint_free_alignmentpoints(t_notation_obj *r_ob, t_tuttipoint *tpt);

    
/**    Free the memory of a measure's rhythmic tree
    @ingroup        notation_free
    @ingroup        rhythmic_trees
    @param measure    The measure
 */
void free_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure);


/**    Free the memory of a group
    @ingroup        notation_free
    @ingroup        rhythmic_trees
    @param group    The group
 */
void free_group(t_notation_obj *r_ob, t_group *group);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
// Quick utility function to check if the order of alignment points is correct
void check_alignment_points(t_alignmentpoint *firstalignmentpoint, t_alignmentpoint *lastalignmentpoint);
#endif



// -----------------------------------
// NOTATION ELEMENTS
// -----------------------------------


/**    Tells if a given notation item type is allowed to have a name.
    @ingroup            notation
    @param item_type    Type of the notation item, one of the #e_element_types.
    @return                1 if the item type is allowed to have names, 0 otherwise.
 */
char item_type_has_names(e_element_types item_type);


/**    Initialize a notation item.
    @ingroup            notation
    @param it            Pointer to the notation item
    @param item_type    Type of the notation item, one of the #e_element_types.
 */
void notation_item_init(t_notation_item *it, e_element_types item_type);


/**    Initialize a notation item via cloning an existing ones. Names and groups are properly handled.
    @ingroup            notation
    @param r_ob            The notation object
    @param new_it        Pointer to the new notation item
    @param old_it        Pointer to the existing notation item
 */
void notation_item_clone(t_notation_obj *r_ob, t_notation_item *new_it, t_notation_item *old_it);


/** Retrieve the pointer to a notation item from the notation item ID.
    @ingroup           notation
    @param r_ob        The notation object
    @param ID          The ID
    @return            The pointer to the notation item
 */
t_notation_item *notation_item_retrieve_from_ID(t_notation_obj *r_ob, long ID);

// private
t_notation_item *notation_item_get_first_selected_account_for_lambda(t_notation_obj *r_ob, char lambda);


/**    Build a note (allocate the memory for #t_note and fills it), with given cents, duration and velocity.
    @ingroup            notation
    @param r_ob         The notation object
    @param cents        The cents of the note
    @param duration        The duration of the note
    @param velocity        The velocity of the note
    @return                The built #t_note structure
 */
t_note *build_note(t_notation_obj *r_ob, double cents, double duration, long velocity);


/**    Build a note (allocate the memory for #t_note and fills it) starting from an array of doubles
    This array can be one of the following:
    - duration midicents
    - duration midicents velocity
    - duration midicents velocity accidental_numerator accidental_denominator 
    - duration midicents velocity accidental_numerator accidental_denominator acc_flag
    where acc_flag is one of the #e_accidentals_type
 
    @ingroup            notation
    @param r_ob         The notation object
    @param argc            The number of elements in the array of doubles
    @param argv            The pointer to the first element in the array of doubles
    @return                The built #t_note structure
 */
t_note *build_note_from_ac_av(t_notation_obj *r_ob, long argc, double *argv);


/**    Build a default note (allocate the memory for #t_note and fills it). 
    Pitch will be #CONST_DEFAULT_NEW_NOTE_CENTS, duration will be #CONST_DEFAULT_NEW_NOTE_DURATION, velocity will be #CONST_DEFAULT_NEW_NOTE_VELOCITY.
    @ingroup            notation
    @param r_ob         The notation object
    @return                The built default #t_note structure
 */
t_note *build_default_note(t_notation_obj *r_ob);


/**    (WARNING!!! UNTESTED, EXPERIMENTAL) Build a chord from a collection of notes (allocate the memory for #t_chord and fills it).
    @remark                WARNING!!! UNTESTED, EXPERIMENTAL
    @ingroup            notation
    @param    r_ob        The notation object (can also be NULL if used outside a notation object)
    @param    firstnote    The first note of the chord (or NULL if none)
    @param    lastnote    The last note of the chord (or NULL if none)
    @return                The built #t_chord structure
 */
t_chord *build_chord_from_notes(t_notation_obj *r_ob, t_note *firstnote, t_note *lastnote);


/**    Build a breakpoint (allocate the memory for #t_bpt and fills it) starting from the relative x position
    of the breakpoint (0 = note start, 1 = note end), the midicent difference with the note pitch, the velocity
    and its note parent.
    @ingroup            notation
    @param    rel_x_pos    The relative horizontal position of the breakpoint (0 to 1, 0 being the note beginning and 1 the note end)
    @param    delta_mc    Pitch difference (in midicents) with the parent note pitch
    @param    velocity    Velocity of the breakpoint. Leave -1 if breakpoint does not have velocity
    @param    slope        The slope of the duration line segment _before_ the breakpoint (-1 to 1, 0 = linear).
    @param    owner        The note in whose duration line the brekpoint is.
    @return                The built #t_bpt structure
 */
t_bpt *build_breakpoint(double rel_x_pos, double delta_mc, double velocity, double slope, t_note *owner);

    
/**    Build a duration line (allocate the memory for #t_duration_line and fills it) for a given owner note.
    @ingroup        notation
    @param owner    The note owning the duration line.
    @return            The duration line structure
 */
t_duration_line *build_duration_line(t_note *owner);

    
/**    Build a piece of lyrics (allocate the memory for #t_lyrics and fills it with default values).
    @ingroup        notation
    @param owner    The chord owning the piece of lyrics.
    @return            The allocated #t_lyrics structure
 */
t_lyrics *build_lyrics(t_chord *owner);


/**    Build a piece of dynamics (allocate the memory for #t_dynamics and fills it with default values).
    @ingroup        notation
    @param owner    The notation item owning the piece of dynamics.
    @return            The allocated #t_dynamics structure
 */
t_dynamics *build_dynamics(t_notation_item *owner);

/**    Insert a note in a chord, by setting the note in the right position in the notes linked list.
    Indeed, notes in a chord are sorted by increasing midicents
    @ingroup            notation
    @param r_ob            The notation object
    @param chord        The chord
    @param note            The note to insert
    @param forced_ID    An ID which the note will be forced to have
 */
void note_insert(t_notation_obj *r_ob, t_chord *chord, t_note *note, unsigned long forced_ID);


/**    Append a note to a chord (forcing the insertion as last element, and not depending on the pitch).
    This function should be considered private and NEVER used (unless you really know what you're doing).
    This is mostly used internally when we need ordering NOT be done unless we decide it has to be done.
    @ingroup            notation
    @param r_ob            The notation object
    @param chord        The chord
    @param note            The note to append
    @param forced_ID    An ID which the note will be forced to have
 */
void note_append_force(t_notation_obj *r_ob, t_chord *chord, t_note *note, unsigned long force_ID);


/**    Slices a note into a left and right part. It modifies the origianl note, making it become the left part of the split, and returns 
    the allocated and properly structured right part of the slice (another #t_note).
    @ingroup            notation
    @param r_ob            The notation object
    @param note            The note
    @param left_slice_duration    The split point, in milliseconds, after the beginning of the note (corresponding to the duration of the left slice, in milliseconds)
    @returns            The right part of the sliced note.
 */
t_note *slice_note(t_notation_obj *r_ob, t_note *note, double left_slice_duration);


/**    Clone a note. 
    @ingroup                    notation
    @param r_ob                    The notation object
    @param chord                The    note to be cloned
    @param clone_for            One of the #e_clone_for types
    @return                        The cloned note
 */
t_note *clone_note(t_notation_obj *r_ob, t_note *note, e_clone_for_types clone_for);

//Internal
void check_note_breakpoints(t_note *note);


/**    Clone a chord. 
    @ingroup                    notation
    @param r_ob                    The notation object
    @param chord                The    chord to be cloned
    @param clone_for            One of the #e_clone_for types
    @return                        The cloned chord
 */
t_chord* clone_chord(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for);


/**    Clone a chord without cloning the slot associated to the lyrics (if any)
    @ingroup                    notation
    @param r_ob                    The notation object
    @param chord                The    chord to be cloned
    @param clone_for            One of the #e_clone_for types
    @return                        The cloned chord
 */
t_chord *clone_chord_without_lyrics(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for);


/**    Clone the notes of a chord which are selected into a new chord.
    @ingroup                    notation
    @param r_ob                    The notation object
    @param chord                The    chord containing some possibly selected notes
    @param clone_for            One of the #e_clone_for types
    @return                        The new chord, made by the cloned selected notes
 */
t_chord* clone_selected_notes_into_chord(t_notation_obj *r_ob, t_chord *chord, e_clone_for_types clone_for);


// TBD
void clone_slots_for_notation_item(t_notation_obj *r_ob, t_notation_item *from, t_notation_item *to, e_clone_for_types clone_for, char force_clone_for_chords = 0);

/**    Clone a measure.
    @ingroup                    notation
    @param r_ob                    The notation object
    @param    measure                The measure
    @param clone_for            One of the #e_clone_for types
    @return                        The cloned measure
 */
t_measure* clone_measure(t_notation_obj *r_ob, t_measure *measure, e_clone_for_types clone_for);


/**    Clone a tempo.
    @ingroup                    notation
    @param    r_ob                The notation object
    @param    tempo                The tempo
    @return                        The cloned tempo
 */
t_tempo* clone_tempo(t_notation_obj *r_ob, t_tempo *tempo);


/**    Get the n-th chord of a given measure
    @ingroup    notation
    @param meas    The measure
    @param n    The 0-based chord index
    @return        The n-th chord of measure <meas>
 */
t_chord* nth_chord(t_measure *meas, long n);


/**    Get the n-th note of a given chord
     @ingroup    notation
     @param ch    The chord
    @param n    The 0-based note index
    @return        The n-th note of chord <ch>
 */
t_note* nth_note(t_chord *ch, long n);

/**    Get the n-th breakpoint of a given note
    @ingroup    notation
    @param nt    The note
    @param n    The 0-based breakpoint index
    @return        The n-th breakpoint of note #nt
 */
t_bpt* nth_breakpoint(t_note *nt, long n);


/**    Get the n-th slotitem of a given notation item slot
    @ingroup    notation
    @param    r_ob    The notation object
    @param nitem    The notation item
    @param slotnum    The slot number
    @param n    The 0-based slotitem index
    @return        The n-th slotitem of slot #slotnum of note #nt
 */
t_slotitem *nth_slotitem(t_notation_obj *r_ob, t_notation_item *nitem, long slotnum, long n);
    

/**    Get the nth measure of a given scorevoice
    @ingroup        notation
    @param    voice    The scorevoice
    @param    n        The 0-based index of the measure to retrieve
 */
t_measure* nth_measure_of_scorevoice(t_scorevoice *voice, long n);


/**    Get the nth voice of a notation object
    @ingroup        notation
    @param    r_ob    The notation object
    @param    n        The 0-based index of the voice to retrieve
 */
t_voice* nth_voice(t_notation_obj *r_ob, long n);


/**    Checks if the order of notes in a chord is "correct", and if incorrect, the function corrects the order.
    bach consider notes as correctly ordered if they're ordered by their increasing cents value (notes having lower pitch come first). 
    @ingroup        notation
    @param chord    The chord
    @return            1 if the order was NOT correct (and had to be changed), 0 if the order was already correct
 */
char check_notes_order(t_chord *chord);


/**    Compute the approximation of a note, which means: fill its <screen_midicents>, <screen_accidental> and <screen_midicents_with_accidental> fields, starting
    from the <midicents>, and depending if the accidental is user defined or automatically defined
    @ingroup        notation
    @param r_ob        The notation object
    @param nt        Pointer to the note
 */
void note_compute_approximation(t_notation_obj *r_ob, t_note *nt);


/**    Snap a pitch (in midicents) to the current microtonal grid for the notation object.
    @ingroup        notation
    @param r_ob        The notation object
    @param pitch    Midicents to be snapped
    @return            Midicents snapped to the microtonal grid
 */
double snap_to_microtonal_grid(t_notation_obj *r_ob, double pitch);


/**    Snap a pitch (in midicents) to the current microtonal grid for a given tone division.
    @remark            This is as snap_to_microtonal_grid(), but doesn't need a notation obejct.
    @ingroup        notation
    @param pitch    Midicents to be snapped
    @param tone_division    The tone division (number of steps in which the tone is divided: 2 = semitonal, 4 = quartertonal...)
    @return            Midicents snapped to the microtonal grid
 */
double snap_to_microtonal_grid_do(double pitch, long tone_division);


/**    Modify a pitch in order to be sure that it isn't a NaN or infinite.
    More precisely: the function takes the incoming number and, if it is a NaN or +inf or -inf, sets it to #CONST_DEFAULT_NEW_NOTE_CENTS,
    and posts a warning message in the Max window. Otherwise, nothing happens and the number is left unchanged. 
    @ingroup        notation
    @param r_ob        The notation object
    @param cents    Midicents to be tested (and possibly modified if NaN or infinite)
 */
void modify_cents_if_nan_or_inf_and_warn(t_notation_obj *r_ob, double *cents);


/**    Tell if some midicents correspond to a diatonic natural note.
    @ingroup    notation
    @param mc    Midicents
    @return        1 if the midicents correspond to a diatonic natural note, 0 otherwise.        
 */
char is_natural_note(long mc);


/**    Get the step position (with respect of the middle C) of the vertical middle position of a staff or staff combination (corresponding to a voice).
    For instance, for a #k_CLEF_FG, this is 0 (middle C); for a #k_CLEF_G this is 6 (steps of the B above middle C).
    @ingroup        notation_utilities
    @param clef        Clef (see #e_clefs for representation)
    @return            Step position of the middle vertical point in a voice having as staff the <clef> clef or clef-combination.
 */
int get_middle_scaleposition(int clef);


/**    Calculate the important graphical parameters of a given chord, and fill the corresponding fields in the chord and notes structure. 
    If the chord is a [bach.roll] chord, it first calls note_compute_approximation() on each note. Then it calculates:
    - the <notehead_resize>, <accidentals_resize>, <notehead_uwidth> fields of all notes
    - the <scaleposition> field for all notes
    - the <show_accidental> fields (only for [bach.roll]: for [bach.score] this is done in validate_accidentals_for_measure())
    - the <direction> field (chord direction), you can impose it by setting the <imposed_direction> field different from 0, before calling 
        for calculate_chord_parameters(); leave it to 0 for automatic calculatio - if we're in [bach.roll] and we don't show stems, by default the stem will be upward
    - the <left_uextension> and <right_uextension>, <lyrics_portion_of_left_uextension> fields of the chord (representing the unscaled amount of pixels, 
        at the left and right of the stem line, needed to paint the chord)
    - the <notecenter_stem_delta_ux> field for each note (the position of each notehead with respect to the stem) 
    - the <need_auxiliary_stem> field for each note (does the note need an auxiliary stem?) 
    - all the fields concerning accidentals for the note, and their positioning. The function calculates the <num_accidentals>, the <accidental_text> (text sequence 
        of all accidentals, e.g. "bbbb"), the <accidental_stem_delta_ux> (position of accidental text box with respect to the stem), <accidental_top_uextension> and
        <accidental_bottom_uextension> (upper/lower extension of accidentals)
    - the default <notehead_unicode_character>, but only for [bach.score] chords
    @ingroup                                notation
    @param    r_ob                            The notation object
    @param    chord                            The chord
    @param    clef                            The clef or clef combination, as one of the #e_clefs (typically this could be in roll the chord->voiceparent->v_ob.clef, 
                                            in score the chord->parent->voiceparent->v_ob.clef)
    @param    reset_graphical_position_values    Set this to 1 if you also want to reset the graphical position values. Namely this resets the <topmost_y>, <bottommost_y>, 
                                            <beam_y>, <topmost_y_noacc>, <bottommost_y_noacc> fields, and then call for reset_articulation_position_for_chord()
 */
void calculate_chord_parameters(t_notation_obj *r_ob, t_chord *chord, int clef, char reset_graphical_position_values);


/**    Fill the <notehead_resize> and <accidentals_resize> fields for a given note, depening if the note size is linked to some slot, or
    if it is linked to the velocity handling. 
    @ingroup        notation
    @param    r_ob    The notation object
    @param    note    The note
    @remark            This is used in calculate_chord_parameters().
*/ 
void calculate_note_sizes_from_slots(t_notation_obj *r_ob, t_note *note);
double velocity_to_notesize_factor(t_notation_obj *r_ob, long velocity);


/**    Retrieve the y position of the ledger lines relative to a given scaleposition (see the <scaleposition> field in the #t_note structure). 
    @ingroup    notation
    @param    r_ob                The notation object
    @param    v_ob                The voice (as #t_voice) for which we want to retrieve the ledger lines
    @param    scaleposition        The scaleposition for which we want to find the ledger lines
    @param    num_ledger_lines    Will be filled with the number of ledger lines (which will be surely <= #CONST_MAX_LEDGER_LINES)
    @param    ledger_y            Array (enough memory MUST already be allocated) whose elements will be the y position in (pixels) of the ledger lines for the given scaleposition
                                VERY IMPORTANT: to avoid any trouble, be sure to initialize <ledger_y> at least as CONST_MAX_LEDGER_LINES * sizeof(double).
 */ 
void get_ledger_lines(t_notation_obj *r_ob, t_voice *v_ob, long scaleposition, int *num_ledger_lines, double *ledger_y);


/**    Returns the number of dots that a given symbolic duration will have if represented. For instance, 7/16 -> 2.
    If the symbolic duration can't be represented, such as for 5/16, result will be -1.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    duration    The duration to be represented
    @return                The number of dots that #duration will have if represented, -1 if no representation is possible 
 */
char get_num_dots(t_notation_obj *r_ob, t_rational duration);


/**    Tell if a given duration is representable as a single chord; in this case it also fills the #screen_duration and #num_dots pointers,
    which will contain the required screen duration (ignoring dots) and the number of dots.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    duration    The duration to be represented
    @param    screen_duration    Pointer which will be filled with the screen duration of the represented chord, ignoring its dots
    @param    num_dots        Pointer which will be filled with the number of dots that will need to represented the duration 
    @return                1 if the duration is representable as a single chord, 0 otherwise.
    @remark                For instance, if duration = 7/16, we have screen_duration = 1/4, num_dots = 2, and the function will return 1.
                        For duration = 5/16, the function will return 0.
    @remark                Beware: "drawability" does NOT take into account the t_notation_obj::max_dots field: in the previous case,
                        if r_ob->max_dots = 1, the function will still return 1: it's up to you to verify outside the function that num_dots <= r_ob->max_dots.
 */
char is_duration_drawable(t_notation_obj *r_ob, t_rational duration, t_rational *screen_duration, char *num_dots);


/**    Check and erase all the dependencies for a chord (supposedly because we want to delete the chord right after).
    In other words: it searches for all fields which might contain the chord address as a reference (playing fields, lambda fields, selection, inspector...)
    and in case the given chord is found, the dependency is corrected as if the chord were to be eliminated (e.g. the item is deleted from the selection,
    or the inspector is closed...)
    @remark                This also takes care of deleting the dependencies of the notes (so one only needs to call this function before deleting the whole chord).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The chord whose dependencies must be erased.
    @param    also_remove_previous_ties    If this is 1, the algorithm also erase the t_note::tie_to field for all notes who had a tie ending on the given chord.
    @param    update_chord_play_cursor_to_this_chord_if_needed    Chord to which the chord play cursor should be set if the current cursor is on the chord to be deleted
    @return                1 if the function check_correct_scheduling() should be called, because the scheduling is now invalid; 0 otherwise
 */
char chord_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_chord *chord, char also_remove_previous_ties, t_chord *update_chord_play_cursor_to_this_chord_if_needed);


/**    Check and erase all the dependencies for a note (supposedly because we want to delete the note right after).
    In other words: it searches for all fields which might contain the note address as a reference (playing fields, lambda fields, selection, inspector...)
    and in case the given note is found, the dependency is corrected as if the note were to be eliminated (e.g. the item is deleted from the selection,
    or the inspector is closed...)
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The note whose dependencies must be erased.
    @param    also_remove_previous_ties    If this is 1, the algorithm also erase the t_note::tie_to field for all notes who had a tie ending on the given chord.
    @see    chord_check_dependencies_before_deleting_it()
 */
void note_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_note *note, char also_remove_previous_ties);


/**    Check and erase all the dependencies for a measure (supposedly because we want to delete the measure right after).
    In other words: it searches for all fields which might contain the measure address as a reference (lambda fields, selection, inspector...)
    and in case the given measure is found, the dependency is corrected as if the measure were to be eliminated (e.g. the item is deleted from the selection,
    or the inspector is closed...)
    @remark                This also takes care of deleting the dependencies of the chords and notes (so one only needs to call this function before deleting the whole measure).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The measure whose dependencies must be erased.
    @return                1 if the function check_correct_scheduling() should be called, because the scheduling is now invalid; 0 otherwise
    @see    chord_check_dependencies_before_deleting_it()
 */
char measure_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_measure *meas);


/**    Check and erase all the dependencies for a tempo (supposedly because we want to delete the tempo right after).
    In other words: it searches for all fields which might contain the tempo address as a reference (selection, inspector...)
    and in case the given tempo is found, the dependency is corrected as if the tempo were to be eliminated (e.g. the item is deleted from the selection,
    or the inspector is closed...)
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The tempo whose dependencies must be erased.
    @return                1 if the function check_correct_scheduling() should be called, because the scheduling is now invalid; 0 otherwise
    @see    chord_check_dependencies_before_deleting_it()
 */
char tempo_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_tempo *tempo);


/**    Check and erase all the dependencies for a marker (supposedly because we want to delete the marker right after).
    In other words: it searches for all fields which might contain the marker address as a reference (selection, inspector...)
    and in case the given marker is found, the dependency is corrected as if the marker were to be eliminated (e.g. the item is deleted from the selection,
    or the inspector is closed...)
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The marker whose dependencies must be erased.
    @see    chord_check_dependencies_before_deleting_it()
 */
void marker_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_marker *marker);


/**    Check and erase all the dependencies for a dynamics (supposedly because we want to delete the dynamics right after).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    dyn        The dynamics whose dependencies must be erased.
    @see    chord_check_dependencies_before_deleting_it()
 */
void dynamics_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_dynamics *dyn);

/**    Check and erase all the dependencies for a pitch breakpoint (supposedly because we want to delete the breakpoint right after).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    bpt        The pitch breakpoint whose dependencies must be erased.
    @see    chord_check_dependencies_before_deleting_it()
 */
void breakpoint_check_dependencies_before_deleting_it(t_notation_obj *r_ob, t_bpt *bpt);


/**    Properly delete a chord from a measure (and clean all fields referencing it).
    @ingroup                notation
    @param    r_ob            The notation object
    @param    chord_to_delete    The chord to be deleted
    @param    also_remove_previous_ties    If this is 1, the algorithm also erase the t_note::tie_to field for all notes who had a tie ending on the given chord.
 */
void chord_delete_from_measure(t_notation_obj *r_ob, t_chord *chord_to_delete, char also_remove_previous_ties);


/**    Properly delete a note from a chord (and clean all fields referencing it).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    note    The note to be deleted
    @param    also_recompute_total_length    Flag also forcing recalculation the total length
 */
void note_delete(t_notation_obj *r_ob, t_note *note, char also_recompute_total_length);


/** Obtain the onset in milliseconds of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return    The onset in milliseconds of the notation item.
*/ 
double notation_item_get_onset_ms(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the y position of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return    The y pixel of the notation item center (if any).
    @remark Warning: currently only works for notes and (partially) for chords
 */
double notation_item_get_center_y(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the tail in milliseconds of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The tail in milliseconds of the notation item.
 */ 
double notation_item_get_tail_ms(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the duration in milliseconds of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The duration in milliseconds of the notation item.
 */ 
double notation_item_get_duration_ms(t_notation_obj *r_ob, t_notation_item *it);

/** Obtain the MIDI velocity a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The MIDI velocity of the notation item.
 */
double notation_item_get_velocity(t_notation_obj *r_ob, t_notation_item *it);

// Slower but more accurate versions, based on the rational values, less prone to floating point arithmetic errors
double notation_item_get_onset_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);
double notation_item_get_tail_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);
double notation_item_get_duration_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);

// Identical to the previous one, except that they account for grace notes as entities having a duration
double notation_item_get_play_onset_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);
double notation_item_get_play_tail_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);
double notation_item_get_play_duration_ms_accurate(t_notation_obj *r_ob, t_notation_item *it);


/// TBD
double notation_item_get_duration_ms_for_slots_account_for_ties(t_notation_obj *r_ob, long slotnum, t_notation_item *it);


/** Obtain the pitch in cents of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The pitch in cents of the notation item.
 */ 
double notation_item_get_cents(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the pitch of a given notation item (or t_pitch::NaP if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The pitch of the notation item.
 */
t_pitch notation_item_get_pitch(t_notation_obj *r_ob, t_notation_item *it);

/** Obtain the pitch or cents of a given notation item (or 0 if none).
    If the pitch is user defined, then it is put inside the <poc> variable, otherwise cents are put there.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @param    poc       Pointer that will be filled with the pitch or cents of the notation item.
 */
void notation_item_get_poc(t_notation_obj *r_ob, t_notation_item *it, t_hatom *poc);


/** Obtain the rational symbolic onset of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The symbolic onset of the notation item.
 */ 
t_rational notation_item_get_symonset(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the rational symbolic duration of a given notation item (or zero if none).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The symbolic duration of the notation item.
 */ 
t_rational notation_item_get_symduration(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the t_voice of a given notation item, or NULL if the notation item is not assigned to any voice.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The voice
 */
t_voice *notation_item_get_voice(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 0-based voice number of a given notation item, or -1 if the notation item is not assigned to any voice.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 0-based voice number of the notation item.
 */
long notation_item_get_voicenumber(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 0-based part number of a given notation item, or -1 if the notation item is not assigned to any voice.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 0-based part number of the notation item.
 */
long notation_item_get_partnumber(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 0-based voice ensemble index of a given notation item, or -1 if the notation item is not assigned to any voice.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 0-based voice ensemble index of the notation item.
 */
long notation_item_get_voiceensemble(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 0-based measure namber of a given notation item, or -1 if the notation item is not assigned to any measure.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 0-based measure number of the notation item.
 */ 
long notation_item_get_measurenumber(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the number of chords inside a notation item (or 0 if not applicable).
 @ingroup        notation
 @param    r_ob    The notation object
 @param    it        The notation item
 @return            The number of chords in the notation item
 */
long notation_item_get_numchords(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the number of notes inside a notation item (or 0 if not applicable).
 @ingroup        notation
 @param    r_ob    The notation object
 @param    it        The notation item
 @return            The number of notes in the notation item
 */
long notation_item_get_numnotes(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the number of measures inside a notation item (or 0 if not applicable).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The number of measures in the notation item
 */
long notation_item_get_nummeasures(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain a tie information about a notation item: 1 if a tie starts, 2 if a tie ends, 3 if both, 0 otherwise.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            1 if a tie starts, 2 if a tie ends, 3 if both, 0 otherwise.
 */ 
long notation_item_get_tie_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 1-based note index index of a notation item. Notes are numbered bottom up.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 1-based note index of the notation item
 */ 
long notation_item_get_noteindex_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 1-based chord index of a notation item. Chords are numbered left to right.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return        The 1-based chord index of the notation item
 */ 
long notation_item_get_chordindex_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the 1-based index of a notation item.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The 1-based index of the notation item
 */ 
long notation_item_get_index_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


/** Returns 1 if the notation item is a grace chord or is inside a grace chord, 0 otherwise.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            1 if grace, 0 otherwise
 */
long notation_item_get_grace_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


/** Obtain the role of a notation item (only used by markers, otherwise "none")
    @ingroup        notation
    @param    r_ob    The notation object
    @param    it        The notation item
    @return            The role of the notation item, as a symbol
 */
t_symbol *notation_item_get_role_for_lexpr(t_notation_obj *r_ob, t_notation_item *it);


// TBD
t_notation_item *notation_item_cast(t_notation_obj *r_ob, t_notation_item *nitem, e_element_types new_type, char also_cast_downwards);
t_chord *voice_get_first_chord(t_notation_obj *r_ob, t_voice *voice);
t_chord *voice_get_last_chord(t_notation_obj *r_ob, t_voice *voice);
t_tempo *voice_get_first_tempo(t_notation_obj *r_ob, t_voice *voice);
t_marker *voice_get_first_marker(t_notation_obj *r_ob, t_voice *voice);


/** Obtain a time signature in llll representation
    @ingroup    notation
    @param    ts    The time signature
    @return    An llll containing the time signature in llll form.
    @see    get_timesignature_from_llll()
*/ 
t_llll* get_timesignature_as_llll(t_timesignature *ts);


/**    Obtain a time signature structure from a time signature in llll form.
    @ingroup        notation
    @param    n_ob    The object asking it (either a notation object or not, can also be NULL)
    @param    time_signature    The time signature in llll form, either as (numerator denominator) or ((num1 num2...) denominator). 
    @return            The time signature as a #t_time_signature structure.
    @see    get_timesignature_as_llll()
 */
t_timesignature get_timesignature_from_llll(t_object *n_ob, t_llll *time_signature);


/** Obtain all the tempi which are synchronous with a given reference tempo.
    @ingroup    notation
    @param    r_ob        The notation object
    @param    this_tempo    The reference tempo
    @param    sync_tempi    The array which will be filled with all the synchronous tempi. This array must be already allocated and
                        sized at least CONST_MAX_VOICES * sizeof(t_tempo *).
    @return    The number of synchronous tempi found (included the reference one).
*/ 
long get_synchronous_tempi(t_notation_obj *r_ob, t_tempo *this_tempo, t_tempo **sync_tempi);


/** Find in a given voice a tempo which is synchronous to a given reference tempo.
    @ingroup    notation
    @param    r_ob                The notation object
    @param    sync_to_this_tempo    The reference tempo
    @param    voice_to_search        The voice to be searched
    @return    The synchronous tempo if any, or NULL if none.
*/ 
t_tempo *find_sync_tempo(t_notation_obj *r_ob, t_tempo *sync_to_this_tempo, t_scorevoice *voice_to_search);


/** Set all the t_note::tie_to fields of each note of the chord to WHITENULL (meaning: a tie starts, but it will be parsed later by check_measure_ties()).
    @ingroup    notation
    @param        ch        The chord
*/ 
void whitenull_tie_from(t_chord *ch);


/** Copy the t_note::tie_from fields of each note from a chord to another.
    @ingroup    notation
    @param        from        The source chord
    @param        to            The target chord
    @remark        The t_note::tie_from fields are copied by iterating in parallel the notes of the two chords, until the shortest chord is over.
*/ 
void transfer_tie_from(t_chord *from, t_chord *to);


/** Copy the t_note::tie_to fields of each note from a chord to another.
    @ingroup    notation
    @param        from        The source chord
    @param        to            The target chord
    @remark        The t_note::tie_to fields are copied by iterating in parallel the notes of the two chords, until the shortest chord is over.
 */
void transfer_tie_to(t_chord *from, t_chord *to);


/** Quick'n'dirty recomputation of all the chord parameters in the score. As usual, the recomputation is not immediately done, but the
    t_chord::need_recompute_parameters fields are set for all chords, so that at the next painting routine the information is processed.
    @ingroup    notation
    @param        r_ob        The notation object
*/ 
void quick_notation_obj_recompute_all_chord_parameters(t_notation_obj *r_ob);


/** Tell if a tempo is really necessary, or if it could be deleted and nothing at all changes in the score timings.
    (A non-necessary tempo is, for instance, a completely repeated tempo.)
    @ingroup    notation
    @param        tempo        The tempo
    @return        1 if the tempo is necessary, 0 if the score timings remain exactly the same without the tempo.
*/ 
char tempo_is_necessary(t_tempo *tempo);


/**    Simply build a time signature from a numerator/denominator couple.
    @ingroup        notation
    @param    r_ob    The notation object (can also be NULL)
    @param    numerator    The numerator
    @param    denominator    The denominator
    @return            The time signature as a #t_time_signature structure
 */
t_timesignature build_simple_timesignature(t_notation_obj *r_ob, long numerator, long denominator);

/**    Build a time signature having as numerator a sum of two elements, such as ((3 2) 8) = (3+2)/8.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    numerator1    The first element in the numerator sum
    @param    numerator2    The second element in the numerator sum
    @param    denominator    The denominator
    @return            The time signature as a #t_time_signature structure
 */
t_timesignature build_2compound_timesignature(t_notation_obj *r_ob, long numerator1, long numerator2, long denominator);


/**    Build a time signature having as numerator a sum of three elements, such as ((3 2 3) 8) = (3+2+3)/8.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    numerator1    The first element in the numerator sum
    @param    numerator2    The second element in the numerator sum
    @param    numerator3    The third element in the numerator sum
    @param    denominator    The denominator
    @return            The time signature as a #t_time_signature structure
 */
t_timesignature build_3compound_timesignature(t_notation_obj *r_ob, long numerator1, long numerator2, long numerator3, long denominator);


/**    Get a chord from its path in the score. The path is given as a starting llllelem, and is considered to be the following elements.
    For instance, in the llll (sel 1 4 2) one might give the 1 llllelem as #start_llllelem for the path, and the path
    will be set to be 1 4 2. The full path form is: <voice_num> <chord_num> for bach.roll and
    <voice_num> <meas_num> <chord_num> for bach.score. If less elements are given, the first ones are assumed to be 1.
    For instance, if one just gives 1 element as path for bach.score, this element is considered to be the <chord_num>,
    while <voice_num> and <meas_num> are both set to 1.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    start_llllelem    The llllelem starting the path
    @param    tiemode_all       Flag telling whether sequence of tied chords should be consider a single one
    @param    skiprests       Flag telling whether rests should be skipped
    @param    restseqmode_all       Flag telling whether sequence of rests should be considered a single one
    @return            The chord at the given path, or NULL if none
 */
t_chord *chord_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem, char tiemode_all, char skiprests, char restseqmode_all);


/**    Get a note from its path in the score. The path is given as a starting llllelem, and is considered to be the following elements.
    For instance, in the llll (sel 1 4 2) one might give the 1 llllelem as #start_llllelem for the path, and the path
    will be set to be 1 4 2. The full path form is: <voice_num> <chord_num> <note_num> for bach.roll and
    <voice_num> <meas_num> <chord_num> <note_num> for bach.score. If less elements are given, the first ones are assumed to be 1.
    For instance, if one just gives 1 element as path for bach.score, this element is considered to be the <note_num>,
    while <voice_num>, <meas_num> and <chord_num> are all set to 1.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    start_llllelem    The llllelem starting the path
    @param    tiemode_all       Flag telling whether sequence of tied chords should be consider a single one
    @param    skiprests       Flag telling whether rests should be skipped
    @param    restseqmode_all       Flag telling whether sequence of rests should be considered a single one
    @return            The note at the given path, or NULL if none
 */
t_note *note_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem, char tiemode_all, char skiprests, char restseqmode_all);


/**    Get a measure from its path in the score. The path is given as a starting llllelem, and is considered to be the following elements.
    For instance, in the llll (sel 1 3) one might give the 1 llllelem as #start_llllelem for the path, and the path
    will be set to be 1 2. The full path form is: <voice_num> <measure_num>. If less elements are given, the first ones are assumed to be 1.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    start_llllelem    The llllelem starting the path
    @return            The measure at the given path, or NULL if none
 */
t_measure *measure_get_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem);


/**    Get a marker from its path in the score.
    The path is given as a starting llllelem, and is considered to be the single marker index
    @ingroup        notation
    @param    r_ob    The notation object
    @param    start_llllelem    The llllelem starting the path
    @return            The marker at the given path, or NULL if none
 */
t_marker *get_marker_from_path_as_llllelem_range(t_notation_obj *r_ob, t_llllelem *start_llllelem);



// -----------------------------------
// SLOT DATA MANIPULATION
// -----------------------------------


/**    Tell if a given slot is temporal (of any kind).
    @ingroup            slots
    @param r_ob            The notation object
    @param slotnum        The 0-based slot number
    @return                1 if the slot is temporal, 0 otherwise
 */
char slot_is_temporal(t_notation_obj *r_ob, long slotnum);


/**    Tell if a given slot is temporal in absolute mode (i.e. non-relative).
    @ingroup            slots
    @param r_ob            The notation object
    @param slotnum        The 0-based slot number
    @return                1 if the slot is temporal in absolute mode, 0 otherwise
 */
char slot_is_temporal_absolute(t_notation_obj *r_ob, long slotnum);

// TBD
char slot_can_extend_beyond_note_tail(t_notation_obj *r_ob, long slotnum);


/**    Allocates the memory for a new #t_slotitem.
    @ingroup            slots
    @param r_ob            The notation object
    @param parent        Pointer to the parent slot
    @return                The allocated #t_slotitem structure
 */
t_slotitem *build_slotitem(t_notation_obj *r_ob, t_slot *parent);


/**    Allocates the memory for a new #t_slotitem, and fills it with a default item (only if the slot type is int, intlist, float or floatlist, 
    otherwise the slotitem will be empty).
    @ingroup            slots
    @param r_ob            The notation object
    @param parent        Pointer to the parent slot
    @param slot_num        Slot number
    @return                The allocated #t_slotitem structure
 */
t_slotitem *build_default_slotitem(t_notation_obj *r_ob, t_slot *parent, long slot_num);


/**    Modify the type of a slot.
    @ingroup                slots
    @param r_ob                The notation object
    @param slot_num            Number (0-based) of the slot to modify
    @param new_type            New type of the slot (as symbol)
 */
void change_slot_type(t_notation_obj *r_ob, long slot_num, t_symbol *new_type);


/**    Convert the content of a slot (i.e. convert each note's slot content for a given slot) 
    so that it matches a newly defined slot type.
    @ingroup                slots
    @param r_ob                The notation object
    @param slot_num            Number (0-based) of the slot to modify
    @param old_type            Old type of the slot (as one of the #e_slot_types)
    @param new_type            New type of the slot (as one of the #e_slot_types)
    @return                    1 if the conversion could not be performed (incompatible slots) and thus the slot content should be deleted.,
                            0 otherwise.
 */
char convert_slot_type(t_notation_obj *r_ob, long slot_num, long old_slottype, long new_slottype);


/**    Convert the content of a note's slot so that it matches a newly defined slot type.
    @ingroup                slots
    @param r_ob                The notation object
    @param note                The note
    @param slot_num            Number (0-based) of the slot to modify
    @param conversion_type    0 for no conversion, 1 for conversion from long to double, 2 for conversion from double to long.
 */
void convert_note_slot_type(t_notation_obj *r_ob, t_note *note, long slot_num, long conversion_type);


/**    Retrieve slot type as symbol from slot type as #e_slot_types
    @ingroup                slots
    @param slot_type        One of the #e_slot_types (e.g. #k_SLOT_TYPE_FUNCTION)
    @return                    The slot type as symbol (e.g. _llllobj_sym_function)
 */
t_symbol *slot_type_to_symbol(e_slot_types slot_type);


/**    Retrieve slot type as #e_slot_types from a symbol
    @ingroup                slots
    @param type                The slot type as symbol (e.g. _llllobj_sym_function)
    @return        One of the #e_slot_types (e.g. #k_SLOT_TYPE_FUNCTION)
 */
e_slot_types slot_symbol_to_type(t_symbol *type);



// TBD
void change_slot_temporalmode(t_notation_obj *r_ob, long slot_num, t_symbol *new_temporalmode);
t_symbol *slot_temporalmode_to_symbol(e_slot_temporalmodes slot_temporalmode);
e_slot_temporalmodes slot_symbol_to_temporalmode(t_symbol *temporalmode);
void notationobj_slot_remove_extensions(t_notation_obj *r_ob, long slot_num);


/**    Get last item of a slot.
    @ingroup            slots
    @param  slot    The slot
    @return            Pointer to the last slotitem
 */
t_slotitem *slot_get_last_item(t_slot *slot);


/**    Get last active item in a slot (or NULL if none)
    @ingroup            slots
    @param  slot    The slot
    @return            Pointer to the active slotitem
 */
t_slotitem *slot_get_active_slotitem(t_slot *slot);


/**    Set last active item of a slot
    @ingroup            slots
    @param  slot                        The slot
    @param  item_to_be_set_as_active    Item to be set as active
 */
void slot_set_active_item(t_slot *slot, t_slotitem *item_to_be_set_as_active);


/**    Insert a slotitem at the beginning of a slot.
    @ingroup            slots
    @param item            Pointer to the slotitem to insert
    @remark                IMPORTANT: <item> must already have defined the <parent> field, so the #t_slot containing the slotitems linked list is surely item->parent 
 */
void slotitem_prepend(t_slotitem *item);


/**    Insert a slotitem at the end of a slot.
    @ingroup            slots
    @param item            Pointer to the slotitem to insert
     @remark                IMPORTANT: <item> must already have defined the <parent> field, so the #t_slot containing the slotitems linked list is surely item->parent 
 */
void slotitem_append(t_slotitem *item);


/// TBD
void slotitem_insert_extended(t_notation_obj *r_ob, long slotnum, t_slotitem *item, e_slot_changeslotitem_modes mode, long insertion_position_0based);
t_slotitem *slot_xcoord_to_slotitem(t_notation_obj *r_ob, long slotnum, t_slot *s, double x_val, double thresh, long *idx, double *dist);


/**    Insert a slotitem between two existing slotitems.
    @ingroup            slots
    @param item            Pointer to the slotitem to insert
    @param prev_item    Pointer to the left slotitem 
    @param next_item    Pointer to the right slotitem
    @remark                IMPORTANT: <item> must already have defined the <parent> field, so the #t_slot containing the slotitems linked list is surely item->parent 
 */
void slotitem_insert(t_slotitem *item, t_slotitem *prev_item, t_slotitem *next_item);


/**    Delete a slotitem from slot.
    @ingroup            slots
    @param    r_ob        The notation object
    @param    slot_num    The 0-based number of the slot
    @param    item        Pointer to the slotitem to delete
 */
void slotitem_delete(t_notation_obj *r_ob, long slot_num, t_slotitem *item);


/**    Retrieve the index (0-based) index of a slotitem (in in the parent slot linked list) 
    @ingroup            slots
    @param item            Pointer to the slotitem
    @return                0-based index of the slotitem
 */
long slotitem_to_index(t_slotitem *slotitem);

    
/**    Fills a slot of type #k_SLOT_TYPE_TEXT wizh a slotitem containing empty text.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @remark                        Please be sure that the slot is of type #k_SLOT_TYPE_TEXT and that it doesn't already contain a slotitem!
 */
void build_default_data_for_text_slot(t_notation_obj *r_ob, t_notation_item *nitem, long slot_num);


/**    Fills a slot of type #k_SLOT_LLL with a slotitem containing a null llll.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @remark                        Please be sure that the slot is of type #k_SLOT_TYPE_LLLL and that it doesn't already contain an llll!
 */
void build_default_data_for_llll_slot(t_notation_obj *r_ob, t_notation_item *nitem, long slot_num);


/**    Change the value of the (only) slotitem in a slot of type #k_SLOT_TYPE_INT.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @param new_val                The new slot value
    @param val_given_as_delta    If this is non-zero the new value will be summed to the old value of the slotitem, otherwise it'll substitute the old value  
 */
void change_slot_long_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, long new_val, char val_given_as_delta);


/**    Change the value of the (only) slotitem in a slot of type #k_SLOT_TYPE_FLOAT.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @param new_val                The new slot value
    @param val_given_as_delta    If this is non-zero the new value will be summed to the old value of the slotitem, otherwise it'll substitute the old value  
 */
void change_slot_float_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, double new_val, char val_given_as_delta);


/**    Change the value of a slotitem in a slot of type #k_SLOT_TYPE_INTLIST.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @param slotitem                The slotitem whose value has to be changed
    @param new_val                The new slot value
    @param val_given_as_delta    If this is non-zero the new value will be summed to the old value of the slotitem, otherwise it'll substitute the old value  
 */
void change_slot_longlist_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, t_slotitem *slotitem, long new_val, char val_given_as_delta);


/**    Change the value of a slotitem in a slot of type #k_SLOT_TYPE_FLOATLIST.
    @ingroup                    slots
    @param r_ob                    The notation object
    @param    nitem                The notation item which owns the slot
    @param slot_num                The number (0-based) of the slot
    @param slotitem                The slotitem whose value has to be changed
    @param new_val                The new slot value
    @param val_given_as_delta    If this is non-zero the new value will be summed to the old value of the slotitem, otherwise it'll substitute the old value  
 */
void change_slot_floatlist_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, t_slotitem *slotitem, double new_val, char val_given_as_delta);


/**    Change the value of a slotitem in a slot of type #k_SLOT_TYPE_FUNCTION, i.e. change the value of a function point.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    nitem                The notation item which owns the slot
    @param    slot_num            The number (0-based) of the slot
    @param    slotitem            The slotitem whose value has to be changed (it'll contain as <item> a #t_pts: (x, y, slope)) 
    @param    new_x_val            The new x value for the function point
    @param    new_y_val            The new y value for the function point
    @param    new_slope_val        The new slope value for the function point
    @param    val_given_as_delta    If this is non-zero the all the values will be summed to the old values, otherwise they'll substitute the old ones  
    @param    modifiers            The keyboard modifiers. In particular:
                                - if (modifiers & eShiftKey) then the x value will be forced NOT to change
                                - if (modifiers & eAltKey) then while changing the x position, the neighbour points (and thus slotitems) can be deleted if needed 
                                  (otherwise the new_x_val will always be obliged to lie between the x values of the previous and of the next slotitems)
 */
void change_slot_pts_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, t_slotitem *slotitem, double new_x_val, double new_y_val, double new_slope_val, char val_given_as_delta, long modifiers);


/**    Change the value of a slotitem in a slot of type #k_SLOT_TYPE_3DFUNCTION, i.e. change the value of a 3d-function point.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    nitem                The notation item which owns the slot
    @param    slot_num            The number (0-based) of the slot
    @param    slotitem            The slotitem whose value has to be changed (it'll contain as <item> a #t_pts: (x, y, slope)) 
    @param    new_x_val            The new x value for the function point
    @param    new_y_val            The new y value for the function point
    @param    new_z_val            The new z value for the function point
    @param    new_slope_val        The new slope value for the function point
    @param    val_given_as_delta    If this is non-zero the all the values will be summed to the old values, otherwise they'll substitute the old ones  
    @param    modifiers            The keyboard modifiers. In particular:
                                - if (modifiers & eShiftKey) then the x value will be forced NOT to change
                                - if (modifiers & eAltKey) then while changing the x position, the neighbour points (and thus slotitems) can be deleted if needed 
                                  (otherwise the new_x_val will always be obliged to lie between the x values of the previous and of the next slotitems)
 */
void change_slot_3dpts_value(t_notation_obj *r_ob, t_notation_item *nitem, int slot_num, t_slotitem *slotitem, double new_x_val, double new_y_val, double new_z_val, double new_slope_val, char val_given_as_delta, long modifiers);


/**    Change the value of a slotitem in a slot of type #k_SLOT_TYPE_SPAT, i.e. change the value of a spat point.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note which owns the slot
    @param    slot_num            The number (0-based) of the slot
    @param    slotitem            The slotitem whose value has to be changed (it'll contain as <item> a #t_spatpt: (t, radius, angle, inter)) 
     @param    new_t_val            The new t value for the function point
    @param    new_r_val            The new radius value for the function point
    @param    new_angle_val        The new angle value for the function point (in radiants)
    @param    val_given_as_delta    If this is non-zero the all the values will be summed to the old values, otherwise they'll substitute the old ones  
    @param    modifiers            The keyboard modifiers. In particular:
                                - if (modifiers & eShiftKey) then the x value will be forced NOT to change
                                - if (modifiers & eAltKey) then while changing the x position, the neighbour points (and thus slotitems) can be deleted if needed 
                                (otherwise the new_x_val will always be obliged to lie between the x values of the previous and of the next slotitems)
 */
void change_slot_spatpts_value(t_notation_obj *r_ob, t_note *note, int slot_num, t_slotitem *slotitem, double new_t_val, double new_r_val, double new_angle_val, char val_given_as_delta, long modifiers);


/**    Change the value of a cell of a matrix contained in a slot of type #k_SLOT_TYPE_TOGGLEMATRIX or #k_SLOT_TYPE_INTMATRIX or #k_SLOT_TYPE_FLOATMATRIX.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note which owns the slot
    @param    slot_num            The number (0-based) of the slot
    @param    slotitem            The slotitem whose value has to be changed (it'll always need to be the first one!) 
    @param    row                    The number of row (1-based) of the cell
    @param    col                    The number of column (1-based) of the cell
    @param    new_val                The new value for the cell
    @param    val_given_as_delta    If this is non-zero the new value will be summed to the old value, otherwise it'll substitute the old one  
 */
void change_slot_matrix_value(t_notation_obj *r_ob, t_note *note, int slot_num, t_slotitem *slotitem, long row, long col, double new_val, char val_given_as_delta);


/**    Change a specific slotitem of a note; new item is expressed as an llll.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note which owns the slot
    @param    slot_num            The slot number (0-based!)
    @param    position            The 1-based index of the item which you want to change (e.g. to change second value in a #k_SLOT_TYPE_INTLIST, set <position> = 2)
    @param    new_values_as_llll    The new slotitem value, expressed as an llll (as the 'changeslotitem' message syntax)
    @param  mode                The operation mode, one of the #e_slot_changeslotitem_modes
    @param  modify_existing     If non-zero, it'll try to modify existing function points whenever the nex X coordinate coincides with an existing X coordinate
                                up to the #modification_x_thresh
    @param  modification_x_thresh   Threshold for X coordinates to be modified (if #modify_existing is non-zero)
 */
void note_change_slot_item(t_notation_obj *r_ob, t_note *note, long slotnum, long position, t_llll *new_values_as_llll, e_slot_changeslotitem_modes mode = k_CHANGESLOTITEM_MODE_MODIFY_ONE, char modify_existing = 0, double modification_x_thresh = 0.);


/**    Change a specific slotitem of a notation item; new item is expressed as an llll.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note which owns the slot
    @param    slot_num            The slot number (0-based!)
    @param    position_1based        The 1-based index of the item which you want to change (e.g. to change second value in a #k_SLOT_TYPE_INTLIST, set <position> = 2)
    @param    new_values_as_llll    The new slotitem value, expressed as an llll (as the 'changeslotitem' message syntax)
 @param  mode                The operation mode, one of the #e_slot_changeslotitem_modes
 */
void notation_item_change_slotitem(t_notation_obj *r_ob, t_notation_item *nitem, long slotnum, long position_1based, t_llll *new_values_as_llll, e_slot_changeslotitem_modes mode = k_CHANGESLOTITEM_MODE_MODIFY_ONE, char modify_existing = 0, double modification_x_thresh = 0.);


/**    Completely erase a note's slot.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note which owns the slot
    @param    slot_number            The slot number (0-based!)
    @param    also_check_slot_recomputations            Also checks slot recomputation and linkages
 */
void note_clear_slot(t_notation_obj *r_ob, t_note *note, int slot_number, char also_check_slot_recomputations = 1);

// TBD
void notation_item_clear_slot(t_notation_obj *r_ob, t_notation_item *nitem, int slot_number, char also_check_slot_recomputations = 1);
void erase_all_notationitem_slots(t_notation_obj *r_ob, t_notation_item *nitem, char also_check_slot_recomputations = 1);


// erase slot for selection
void notationobj_sel_erase_slot(t_notation_obj *r_ob, long slotnum, char lambda);

// move a slot to another one for the selection
void notationobj_sel_move_slot(t_notation_obj *r_ob, long slotfrom, long slotto, char keeporiginal, char lambda);

// TBD
void move_notationitem_slot(t_notation_obj *r_ob, t_notation_item *nitem, int slot_from, int slot_to, char keep_original, char also_check_slot_recomputations = 1);
void move_note_slot(t_notation_obj *r_ob, t_note *note, int slot_from, int slot_to, char keep_original, char also_check_slot_recomputations = 1);
void notationobj_sel_change_slot_item_from_params(t_notation_obj *r_ob, t_llll *args, char lambda, e_slot_changeslotitem_modes mode);

// reducefunction
long notation_item_reducefunction(t_notation_obj *r_ob, t_notation_item *nitem, long slot_number, long maxnumpoints, double thresh, long p, long relative, long slope, long algorithm, e_slope_mapping slopemapping);
void notationobj_sel_reducefunction(t_notation_obj *r_ob, t_llll *args_orig, char lambda);


/**    Check if all the slot data in a notation object correctly lie within the slot domain. If not, it forces data to lie within the slot domain.
    This function is useful if called after a slot domain change.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    slot_num            The slot number (0-based!) to check
 */
void slot_check_domain(t_notation_obj *r_ob, long slot_num);


/**    Check if all the slot data in a notation object correclty lie within the slot range. If not, it forces data to lie within the slot range.
    This function is useful if called after a slot range change.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    slot_num            The slot number (0-based!) to check
 */
void slot_check_range(t_notation_obj *r_ob, long slot_num);


/**    Check if all the slot data in a notation object correclty lie within the slot zrange (the range of the 3rd dimension). If not, it forces data to lie within the slot range.
    This is only meaningful for k_SLOT_TYPE_3DFUNCTION types of slot. This function is useful if called after a slot zrange change.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    slot_num            The slot number (0-based!) to check
 */
void slot_check_zrange(t_notation_obj *r_ob, long slot_num);

// TBD
void slot_check_access(t_notation_obj *r_ob, long slot_num);


// -----------------------------------
// SLOT ITEMS SELECTION
// -----------------------------------

/**    Remove all slot items from the selection. 
    @ingroup            slot_interface
    @param r_ob            The notation object
 */
void clear_slot_window_selection(t_notation_obj *r_ob);


/**    Add or remove a slot item to the the selection (depending on the selection mode
    @ingroup            slot_interface
    @param    r_ob        The notation object
    @param    item        The slot item
    @param    mode        The selection mode
 */
void select_slotitem(t_notation_obj *r_ob, t_slotitem *item, e_selection_modes mode);


t_notation_item *notation_item_to_notation_item_for_slot_win_opening(t_notation_obj *r_ob, t_notation_item *item);


// -----------------------------------
// GET AND SET SLOT INFORMATION
// -----------------------------------

/**    Properly reinitialize the slotinfo for a given notation object, i.e. it reverts it to the default values. 
    @ingroup            slots
    @param r_ob            The notation object
*/
void notation_obj_reset_slotinfo(t_notation_obj *r_ob);

/**    Reinitialize the commands.
 @ingroup            commands
 @param r_ob            The notation object
 */
void notation_obj_reset_commands(t_notation_obj *r_ob);


/**    Set or update the slotinfo in the notation object structure, starting from a slotinfo-llll
    @ingroup            slots
    @param r_ob            The notation object
    @param slotinfo        llll containing the slotinfo (slot numbers are 1-based)
    @return                An llll containing the number (0-based) of the slots that have to be erased,
                        because their previously-defined type and their new-defined type are incompatible.
 */
t_llll* set_slotinfo_from_llll(t_notation_obj *r_ob, t_llll* slotinfo);


/**    Get the complete information about the content of all the slots of a note in a llll form.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note
    @param    mode                One of the #e_data_considering_types, informing on the aim for which you want to collect the information
    @param    force_all_slots        If this is 1 the algorithm will return all the note slots, if this is 0 (advised) only the one containing real slot information, and not the empty ones.
    @return                        An llll containing all the note slots information.
 */
t_llll* note_get_slots_values_as_llll(t_notation_obj *r_ob, t_note *note, char mode, char get_even_if_empty);


// TBD
t_llll* notation_item_get_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char get_even_if_empty);
t_llll* notation_item_get_multiple_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char get_even_if_empty, t_llll *which_slots_1based);
t_llll *notation_item_get_slots_to_be_copied(t_notation_obj *r_ob, t_notation_item *from, t_llll *which_slots_1based, char even_if_empty);// this one is private
void notation_item_copy_slots(t_notation_obj *r_ob, t_notation_item *from, t_notation_item *to, t_llll *which_slots_1based, char even_if_empty);
void note_transfer_slots_to_siebling(t_notation_obj *r_ob, t_note *nt, t_llll *which_slots_1based, char even_if_empty, char even_to_rests);
t_llll *get_default_slots_to_transfer_1based(t_notation_obj * r_ob);


/**    Get the complete information about the content of all the slots of a portion of a notation item in a llll form.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    nitem                The notation item
    @param    mode                One of the #e_data_considering_types, informing on the aim for which you want to collect the information
    @param    force_all_slots        If this is 1 the algorithm will return all the note slots, if this is 0 (advised) only the one containing real slot information, and not the empty ones.
    @param    start_rel_x_pos        The starting point of the part of slot which will be output, in relative form (0 = beginning of slot, 1 = end of slot)
    @param    end_rel_x_pos        The ending point of the part of slot which will be output, in relative form (0 = beginning of slot, 1 = end of slot)
    @return                        An llll containing all the note slots information.
 */
t_llll* notation_item_get_partial_slots_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, char force_all_slots, double start_rel_x_pos, double end_rel_x_pos);


/**    Get the information about the content of a given slot of a given note in a llll form.
    @ingroup            slots
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the #e_data_considering_types, informing on the aim for which you want to collect the information
    @param    slotnum        The 0-based slot number in which we are interested
    @param    only_get_selected_items        If this is non-zero, the function only returns selected items.
                                        Important: setting non-zero flags is only effective with slots supporting selection! 
    @return                An llll containing the specified slot information.
 */
t_llll* note_get_single_slot_values_as_llll(t_notation_obj *r_ob, t_note *note, char mode, long slotnum, char only_get_selected_items);

// TBD
t_llll* notation_item_get_single_slot_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, long slotnum, char only_get_selected_items);

t_notation_item *dynamics_get_owner(t_notation_obj *r_ob, t_dynamics *dyn);

t_notation_item *notation_item_get_bearing_dynamics(t_notation_obj *r_ob, t_notation_item *nitem, long dynamics_slot_num);
t_notation_item *notation_item_get_to_which_dynamics_should_be_assigned(t_notation_obj *r_ob, t_notation_item *nitem);

/**    Get the information about the content of a part given slot of a given notation item in a llll form.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    nitem                The notation item
    @param    mode                One of the #e_data_considering_types, informing on the aim for which you want to collect the information
    @param    slotnum                The 0-based slot number in which we are interested
    @param    start_rel_x_pos        The starting point of the part of slot which will be output, in relative form (0 = beginning of slot, 1 = end of slot)
    @param    end_rel_x_pos        The ending point of the part of slot which will be output, in relative form (0 = beginning of slot, 1 = end of slot)
    @return                        An llll containing the specified slot information.
 */
t_llll* notation_item_get_partial_single_slot_values_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char mode, long slotnum, double start_rel_x_pos, double end_rel_x_pos);


/**    Retrieve all the information about the slotinfo of a given notation object.
    @ingroup            slots
    @param    r_ob        The notation object
    @param    explicitly_get_also_default_stuff    If this is 1, the function returns all slotinfo attributes, even if they are irrelevant for the slot type, and 
                                                even if they coincide with the default slottype value (ex. the slot color). This is useful when dealing with undo,
                                                but should be kept to 0 for most other purposes.
    @param    also_get_fields_saved_in_max_inspector    If this is 1, the function also returs the fields which are already saved as Max attributes for the object
                                                    and saved in the Max inspector (for instance: popup, background... determining which slots have to appear in the
                                                    popup menu or have to be kept in background: if this flag is 1, for each slotinfo a specification (popup 1) or
                                                    (popup 0) is added, and similarly for all the alreday-saved-with-the-Max-inspector stuff).
    @param bw_compatible      Guarantees backward compatibility with bach 0.7.9 or previous (i.e. only outputs 30 slots)
    @return                An llll containing the slotinfo information for the notation object.
 */
t_llll* get_slotinfo_as_llll(t_notation_obj *r_ob, char explicitly_get_also_default_stuff, char also_get_fields_saved_in_max_inspector, char bw_compatible);

// TBD
t_llll* get_single_slotinfo_as_llll(t_notation_obj *r_ob, long slotnum, char explicitly_get_also_default_stuff, char also_get_fields_saved_in_max_inspector);



/**    Just like note_get_slots_values_as_llll() but it removes the gensym("slots") symbol.
    The mode is by set as #k_CONSIDER_FOR_DUMPING.
    @ingroup                    slots
    @param    r_ob                The notation object
    @param    note                The note
    @param    force_all_slots        If this is 1 the algorithm will return all the note slots, if this is 0 (advised) only the one containing real slot information, and not the empty ones.
    @return                        An llll containing all the note slots information (with no "slots" starting symbol).
    @see                        note_get_slots_values_as_llll;
 */
t_llll* note_get_slots_values_no_header_as_llll(t_notation_obj *r_ob, t_note *note, char force_all_slots);


/**    Just like notation_item_get_slots_values_as_llll() but it removes the gensym("slots") symbol.
 The mode is by set as #k_CONSIDER_FOR_DUMPING.
 @ingroup                    slots
 @param    r_ob                The notation object
 @param    nitem                The notation item
 @param    force_all_slots        If this is 1 the algorithm will return all the note slots, if this is 0 (advised) only the one containing real slot information, and not the empty ones.
 @return                        An llll containing all the notation item slots information (with no "slots" starting symbol).
 @see                        notation_item_get_slots_values_as_llll;
 */
t_llll* notation_item_get_slots_values_no_header_as_llll(t_notation_obj *r_ob, t_notation_item *nitem, char force_all_slots);


/**    From an llll containing the slot information, it set all the information to a note's slots.
    @ingroup            slots
    @param    r_ob        The notation object
    @param    note        The note to which the slot information must be set
    @param    slots        An llll containing the slot information
 */
void note_set_slots_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* slots);

//TBD
void notation_item_set_slots_from_llll(t_notation_obj *r_ob, t_notation_item *nitem, t_llll* slots);

// Private
void notation_item_check_slots(t_notation_obj *r_ob, t_notation_item *nitem);
void notation_item_check(t_notation_obj *r_ob, t_notation_item *nitem);
void notation_obj_check(t_notation_obj *r_ob);
void notation_item_check_against_tuttipoints(t_notation_obj *r_ob, t_notation_item *nitem);
void notation_obj_check_against_tuttipoints(t_notation_obj *r_ob);
void notation_obj_check_all_measure_tuttipoints(t_notation_obj *r_ob);
void clear_all_measure_tuttipoint_references(t_notation_obj *r_ob);
void notation_obj_check_force(t_notation_obj *r_ob, char also_lock_mutext);


/**    Set a slot content (one of more slots) to all the selected notes in a notation object.
    @ingroup        slots
    @param    r_ob    The notation object
    @param    slots    The slot(s) content as llll
    @param also_set_slots_to_rests  Flag to set whether slots should be also set to rests
    @return            1 if notation object has changed, 0 otherwise.
 */
char set_slots_to_selection(t_notation_obj *r_ob, t_llll *slots, char also_set_slots_to_rests);

/**    Set a slot content (one of more slots) to all the selected notes in a notation object.
    @ingroup        slots
    @param    r_ob    The notation object
    @param    slots    The breakpoints (duration line as llll
    @return            1 if notation object has changed, 0 otherwise.
 */
char set_breakpoints_to_selection(t_notation_obj *r_ob, t_llll *breakpoints);



/**    Obtain the biquad llll full representation, in the form: b0 b1 b2 a1 a2 (filtertype cutoff_freq gain_dB Q_or_S)
    @ingroup        slots
    @param    r_ob    The notation object
    @param    bqd        The biquad filter
    @return            The biquad filter in llll form
 */
t_llll *get_biquad_as_full_llll(t_notation_obj *r_ob, t_biquad *bqd);


// INTERNAL, YET UNDOCUMENTED
t_llll *find_sublist_with_router(t_notation_obj *r_ob, t_llll *note_llll, t_symbol *sym);
void glue_portion_of_single_temporal_slot(t_notation_obj *r_ob, t_note *receiver, t_llll *slot_llll, long slotnum,
                                          double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                          double portion_duration_ratio_to_receiver, char direction, double smooth_ms, double giver_duration, double final_duration);
void glue_portion_of_temporal_slots(t_notation_obj *r_ob, t_note *receiver, t_llll *note_llll, 
                                    double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                    double portion_duration_ratio_to_receiver, char direction, double smooth_ms, double giver_duration, double final_duration);
void glue_portion_of_breakpoints(t_notation_obj *r_ob, t_note *receiver, t_llll *note_llll, t_note *dummy_giver,
                                 double start_glued_note_portion_rel_x, double end_glued_note_portion_rel_x, 
                                 double portion_duration_ratio_to_receiver, char direction, double smooth_ms);
void rescale_domain_of_single_temporal_slot(t_notation_obj *r_ob, t_note *receiver, long slotnum, 
                                            double relative_start_x, double relative_end_x);
void rescale_breakpoints(t_notation_obj *r_ob, t_note *receiver, double relative_start_x, double relative_end_x);


// ACTIVE ITEM SLOTS
t_slotitem *get_activeitem_activeslot_firstitem(t_notation_obj *r_ob);
t_slotitem *get_activeitem_slot_firstitem(t_notation_obj *r_ob, long slotnum);
long get_activeitem_slot_length(t_notation_obj *r_ob, long slotnum);
t_slot *get_activeitem_activeslot(t_notation_obj *r_ob);
t_slot *get_activeitem_slot(t_notation_obj *r_ob, long slotnumber);
t_slot *notation_item_get_slot(t_notation_obj *r_ob, t_notation_item *nitem, long slotnumber);
t_slot *notation_item_get_slot_extended(t_notation_obj *r_ob, t_notation_item *nitem, long slotnumber, char force_get_for_chords);
t_slotitem *notation_item_get_slot_firstitem(t_notation_obj *r_ob, t_notation_item *nitem, long slotnumber);
t_slotitem *notation_item_get_slot_nth_item(t_notation_obj *r_ob, t_notation_item *nitem, long slotnumber, long n);
t_slotitem *slot_get_nth_item(t_slot *s, long n);
t_chord *notation_item_get_parent_chord(t_notation_obj *r_ob, t_notation_item *nitem);
long notation_item_get_slot_numitems(t_notation_obj *r_ob, t_notation_item *nitem, long slotnumber); // private




// -----------------------------------
// SLOT INTERFACE
// -----------------------------------


/**    Tell if a point is inside the open slot window
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param point_x        The x coordinate of the point (pixel)
    @param point_y        The y coordinate of the point (pixel)
    @return                1 if the point is inside the active slot window, 0 otherwise
 
    @remark                Using this function (and all the following ones!) makes sense only if you have previously tested that there's an open slot window
                        by checking that r_ob->active_slot_note is NOT null
 */
char is_pt_in_slot_window(t_notation_obj *r_ob, long point_x, long point_y);


/**    Tell if a point is inside the (unique) handle of a #k_SLOT_TYPE_INT or a #k_SLOT_TYPE_FLOAT type of slot.
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param point_x        The x coordinate of the point (pixel)
    @param point_y        The y coordinate of the point (pixel)
    @return                1 if the point is inside the handle of the #k_SLOT_TYPE_INT or a #k_SLOT_TYPE_FLOAT slot, 0 otherwise
 
    @remark                Using this function makes sense only if you have previously tested that there's an open slot window
                        and that the open slot type is #k_SLOT_TYPE_INT or #k_SLOT_TYPE_FLOAT, Which is by checking that
    @code
    if (r_ob->active_slot_note && (r_ob->slot_type[r_ob->active_slot_num] == k_SLOT_TYPE_INT || r_ob->slot_type[r_ob->active_slot_num] == k_SLOT_TYPE_FLOAT)) {
        ...
    }
    @endcode
 */
char is_pt_in_slot_longfloat_strip(t_notation_obj *r_ob, long point_x, long point_y);


/**    Get the width of a bar of an #k_SLOT_TYPE_INTLIST or #k_SLOT_TYPE_FLOATLIST type of slot.
    The width also decreases with the number of slot items (if slot items can't be all represented. 
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param slot_num        The 0-based slot number
    @param nitem        The notation item whose slot is to be accounted for
    @return                The width of a bar in pixels.
    @endcode
 */
double get_slot_numberlist_single_bar_width(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem);


/**    Tell if a point is inside the n-th handle of a #k_SLOT_TYPE_INTLIST or a #k_SLOT_TYPE_FLOATLIST type of slot.
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param index        Index (0-based) of the handle, starting from the top 
    @param slotitem        Pointer to the <index>-th slotitem. You can obtain <index> from <slotitem> via slotitem_to_index()
    @param point_x        The x coordinate of the point (pixel)
    @param point_y        The y coordinate of the point (pixel)
    @return                1 if the point is inside the <index>-th handle of the #k_SLOT_TYPE_INTLIST or a #k_SLOT_TYPE_FLOATLIST slot, 0 otherwise
 
    @remark                Using this function makes sense only if you have previously tested that there's an open slot window
                        and that the open slot type is #k_SLOT_TYPE_INTLIST or #k_SLOT_TYPE_FLOATLIST, Which is by checking that
    @code
    if (r_ob->active_slot_note && (r_ob->slot_type[r_ob->active_slot_num] == k_SLOT_TYPE_INTLIST || r_ob->slot_type[r_ob->active_slot_num] == k_SLOT_TYPE_FLOATLIST)) {
        ...
    }
    @endcode
 */
char is_pt_in_slot_longfloatlistbar_strip(t_notation_obj *r_ob, long index, t_slotitem *slotitem, long point_x, long point_y);


/**    Tell if a point is inside the "inner part" of a slot window.
    For slot like #k_SLOT_TYPE_FUNCTION, #k_SLOT_TYPE_3DFUNCTION or a #k_SLOT_SLOT type of slot, this corresponds to the part where the function is actually drawn,
    whose background has a lighter color. For other types of slot, this is not marked with a different background color, yet this still correponds to the part
    where the slot content is displayed (everything but the bar where the slot name and legend is and the other 3 little "insets" on each one of the other edges).
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param pt            The point on the screen (in pixels) as a #t_pt structure
    @return                1 if the point is inside the "inner part" of the slot window, 0 otherwise
 
    @remark                Using this function makes sense only if you have previously tested that there's an open slot window, like:
    @code
    if (r_ob->active_slot_note) {
        ...
    }
    @endcode
 */
char is_pt_in_inner_slot_subwindow(t_notation_obj *r_ob, t_pt pt);


/**    Retrieve the clicked slotitem (point) in a function starting from a screen point (pixels).
    @ingroup                    slot_graphic
    @param    r_ob                The notation object
    @param    pt                    The point on the screen (in pixels) as a #t_pt structure
    @param    slot_number            The 0-based slot number
    @param    also_find_segments    Also retrieve the segments (or curves) between two points. In this case, the ENDING point of the segment is returned.
    @param    found_item            Pointer which will contain either #k_SLOT_FUNCTION_POINT or #k_SLOT_FUNCTION_SEGMENT, depending on what has been found.
                                Leave NULL if unneeded.
    @return                A slotitem containing the #t_pts structure for the point in the function corresponding to the point <pt>.
                        Or NULL if no biquad has been retrieven.
    @remark                Before getting the point value in the slot function, you might want to be sure that the screen point 
                        IS inside the slot function window, with is_pt_in_inner_slot_subwindow()
    @see                pt_to_function_xy_values()
 */
t_slotitem *pt_to_function_slot_point(t_notation_obj *r_ob, t_pt pt, long slot_number, char also_find_segments, long *found_item);


/**    Retrieve the clicked slotitem (point) in a 3dfunction starting from a screen point (pixels).
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param pt            The point on the screen (in pixels) as a #t_pt structure
    @return                A slotitem containing the #t_pts structure for the point in the function corresponding to the point <pt>.
                        Or NULL if no biquad has been retrieven.
    @remark                Before getting the point value in the slot function, you might want to be sure that the screen point 
                        IS inside the slot function window, with is_pt_in_inner_slot_subwindow()
 */
t_slotitem *pt_to_3dfunction_slot_point(t_notation_obj *r_ob, t_pt pt, long slot_number);

// TBD
t_slotitem *pt_to_spat_slot_point(t_notation_obj *r_ob, t_pt pt, long slot_number);


/**    Retrieve the clicked biquad filter in a dynfilter type of slot window, starting from a screen point (pixels).
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param pt            The point on the screen (in pixels) as a #t_pt structure
    @return                A slotitem containing the #t_biquad structure for the biquad corresponding to the point <pt>.
                        Or NULL if no biquad has been retrieven.
    @see                pt_to_function_xy_values()
 */
t_slotitem *pt_to_dynfilter_biquad(t_notation_obj *r_ob, t_pt pt, long slot_number);


/**    Convert a screen point (pixels) into its coordinates in a function slot, by retrieving the x and y coordinates.
    @ingroup            slot_graphic
    @param r_ob            The notation object
    @param nitem        The notation item owning the slot
    @param pt            The point on the screen (in pixels) as a #t_pt structure
    @param slot_number    Number (0-based) of the (function) slot
    @param active_slot_window    The rectangle containing the pixels for the active part of the slotwindow
    @param xval            Pointer which will be filled with the x coordinate of the function point
    @param yval            Pointer which will be filled with the y coordinate of the function point
    
    @remark                It works like pt_to_function_slot_point() but it doesn't allocate memory for a slotitem, it just fills the <xval> and <yval> pointers.
    @see                pt_to_function_slot_point()
 */
void pt_to_function_xy_values(t_notation_obj *r_ob, t_notation_item *nitem, t_pt pt, long slot_number, t_rect active_slot_window, double *xval, double *yval);


/**    Convert the coordinates of a point in a function slot into its screen coordinates (in pixels).
    @ingroup                    slot_graphic
    @param r_ob                    The notation object
    @param nitem                The notation item owning the slot
    @param xval                    x coordinate of the function point
    @param yval                    y coordinate of the function point
    @param slot_number            Number (0-based) of the (function) slot
    @param active_slot_window    The rectangle containing the pixels for the active part of the slotwindow
    @param pt                    Pointer which will be filled with the point in the screen
    
    @see                        pt_to_function_xy_values()
    @see                        function_xyz_values_to_pt()
 */
void function_xy_values_to_pt(t_notation_obj *r_ob, t_notation_item *nitem, double xval, double yval, long slot_number, t_rect active_slot_window, t_pt *pt);


/**    Convert the coordinates of a point in a 3d-function slot into its screen coordinates (in pixels).
    @ingroup                    slot_graphic
    @param r_ob                    The notation object
    @param nitem                The notation item owning the slot
    @param xval                    x coordinate of the function point
    @param yval                    y coordinate of the function point
    @param zval                    z coordinate of the function point
    @param slot_number            Number (0-based) of the (function) slot
    @param active_slot_window    The rectangle containing the pixels for the active part of the slotwindow
    @param pt                    Pointer which will be filled with the point in the screen
    @param slot_zoom            Additional zoom factor for slots, 100 being the default one. 
                                This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)
    
    @see                        function_xy_values_to_pt()
 */
void function_xyz_values_to_pt(t_notation_obj *r_ob, t_notation_item *nitem, double xval, double yval, double zval, long slot_number, t_rect active_slot_window, t_pt *pt, double slot_zoom);


// TBD
long pt_to_card_id_in_slot(t_notation_obj *r_ob, t_pt pt, long slot_number, t_rect active_slot_window);
t_slotitem *articulation_id_to_slotitem(t_notation_obj *r_ob, t_note *note, long slot_number, long art_ID);
t_slotitem *pt_to_articulation_slotitem(t_notation_obj *r_ob, t_pt pt, long slot_number, t_rect active_slot_window, long *art_ID);
t_slotitem *pt_to_notehead_slotitem(t_notation_obj *r_ob, t_pt pt, long slot_number, t_rect active_slot_window, long *nh_ID);
t_slotitem *notehead_id_to_slotitem(t_notation_obj *r_ob, t_note *note, long slot_number, long nh_ID);



/**    Handle the action of mousedragging on a slot.
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param patcherview    Pointer to the current patcher view
    @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
    @param changed        Pointer that will be filled with 1 if some slot content has changed, with 0 otherwise
    @param redraw        Pointer that will be filled with 1 if we need to redraw the jbox, with 0 otherwise
    @return                1 if slotwindow was active, 0 otherwise
 
    @remark                The function does NOT redraw automatically the jbox, you have to do it after.
 */
char slot_handle_mousedrag(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers, char *changed, char *redraw);


/**    Handle the action of clicking (mouse-down) on a slot.
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param patcherview    Pointer to the current patcher view
    @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
    @param clicked_obj    Pointer that will be filled with the element type of the clicked object (one of the #e_element_types) 
    @param clicked_ptr    Pointer that will be filled with the pointer to the clicked object 
     @param changed        Pointer that will be filled with 1 if some slot content has changed, with 0 otherwise
    @param need_popup    Pass 1 if the click is a right-mouse click (and thus popup might appear), 0 otherwise
    @return                1 if slotwindow was active, 0 otherwise

    @remark                The function does automatically redraws the jbox, if needed.
    @remark                VERY IMPORTANT: ALWAYS call this function inside a general_mutex lock! (since inside it unlocks-and-relocks in some special cases)
                        so ALWAYS do something like this:
    @code
    lock_general_mutex(r_ob);
    slot_handle_mousedown(...);
    unlock_general_mutex(r_ob);
    @endcode
*/
char slot_handle_mousedown(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers, e_element_types *clicked_obj, void **clicked_ptr, char *changed, char need_popup);


/**    Handle the action of releasing the click (mouse-up) on a slot.
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param patcherview    Pointer to the current patcher view
    @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
    @remark                VERY IMPORTANT: ALWAYS call this function inside a general_mutex lock! (since inside it unlocks-and-relocks in some special cases)
                        so ALWAYS do something like this:
                        @code
                        lock_general_mutex(r_ob);
                        slot_handle_mouseup(...);
                        unlock_general_mutex(r_ob);
                        @endcode
 */
void slot_handle_mouseup(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers);


/**    Handle the action of scrolling the mousewheel on a slot window.
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param patcherview    Pointer to the current patcher view
    @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
    @param x_inc        Scroll x increment
    @param y_inc        Scroll y increment
    @return                1 if mousewheel was possible in slot window, 0 if scrolling has to be passed to notation object 
    @remark                VERY IMPORTANT: ALWAYS call this function inside a general_mutex lock! (since inside it unlocks-and-relocks in some special cases)
                        so ALWAYS do something like this:
                        @code
                        lock_general_mutex(r_ob);
                        slot_handle_mousewheel(...);
                        unlock_general_mutex(r_ob);
                        @endcode
 */
char slot_handle_mousewheel(t_notation_obj *r_ob, t_object *view, t_pt pt, long modifiers, double x_inc, double y_inc);


/**    Handle the action of doubleclicking on a slot.
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param patcherview    Pointer to the current patcher view
     @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
     @param changed        Pointer that will be filled with 1 if some slot content has changed, with 0 otherwise
    @return                1 if slotwindow was active, 0 otherwise

    @remark                The function does NOT redraw automatically the jbox, you have to do it after.
 */
char slot_handle_mousedoubleclick(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers, char *changed);


/**    Handle the action of mouse-hovering on a slot. Currently it only handles the #k_SLOT_TYPE_FUNCTION types of slot (hovering will update legend and show bigger circles on function points)
    @ingroup            slot_interface
    @param r_ob            The notation object
     @param patcherview    Pointer to the current patcher view
     @param pt            Current mouse point
    @param modifiers    Keyboard modifiers
    @param redraw        Pointer that will be filled with 1 if we need to redraw the jbox, with 0 otherwise
    @param mousepointer_changed        Pointer that will be filled with 1 if we need the mouse pointe has been changed, with 0 otherwise
    @return                1 if slotwindow was active, 0 otherwise

    @remark                The function does NOT redraw automatically the jbox, you have to do it after.
 */
char slot_handle_mousemove(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers, char *redraw, char *mousepointer_changed);


/**    Delete all the selected function points from a given slot
    @ingroup            slot_interface
    @param r_ob            The notation object
    @param slot_num        Slot number (0-based)
 */
void delete_all_selected_function_points(t_notation_obj *r_ob, long slot_num);


/**    Get the default notation item to be undone when the active slot is changed.
    @ingroup            undo_redo
    @param r_ob            The notation object
    @remark                For [bach.roll] and [bach.score] this returns the parent chord of the note whose slot is edited; for [bach.slot] this returns the note itself. 
 */
t_notation_item *get_activeitem_undo_item(t_notation_obj *r_ob);





// -----------------------------------
// SLOT-LINKED CONTENT
// -----------------------------------


/**    Check if the change in a given note slot will need to force a change in some graphical representation of the slot linked content.
    For instance, if the slot was linked with the notehead size, we have to recalculate the note parameters, and so on.
    If some change need to be done, the function will automatically force it (so you just need to call the function, and then nothing more).
    @ingroup    slots
    @param        r_ob                The notation object
    @param        nitem                The notation item whose slot has changed
    @param        changed_slot_index    The 0-based index of the changed slot
 */
void check_slot_linkage_recomputations_for_notationitem(t_notation_obj *r_ob, t_notation_item *nitem, long changed_slot_index);


/**    Check if the change in the notation item whose slot is active will need to force a change in some graphical representation of the slot linked content;
    and if it is the case, perform the changes.
    @ingroup    slots
    @param        r_ob                The notation object
    @param        changed_slot_index    The 0-based index of the changed slot
    @see        check_slot_linkage_recomputations_for_note()
 */
void check_slot_linkage_recomputations_for_active_notationitem(t_notation_obj *r_ob);


/**    Check if the change in some slot (throughout the score) will need to force a change in some graphical representation of the slot linked content; 
    and if it is the case, perform the changes.
    @ingroup    slots
    @param        r_ob                The notation object
    @param        changed_slot_index    The 0-based index of the changed slot
    @see        check_slot_linkage_recomputations_for_note()
 */
void check_slot_linkage_recomputations_for_everything(t_notation_obj *r_ob, long changed_slot_index);


/** Add to a class the common attributes concerning slots
    @ingroup    slots
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_slots_attributes(t_class *c, char obj_type);


/** Add to a class the common attributes concerning play
    @ingroup    slots
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_play_attributes(t_class *c, char obj_type);


// private
void append_note_slot_formatted_for_pwgl(t_notation_obj *r_ob, t_llll *this_note_llll, t_note *note);

// @ingroup import_export
t_xml_chord_beam_info get_xml_chord_beam_info(t_notation_obj *r_ob, t_chord *chord);

/// Returns the tuplet depth: number of tuplets in which the chord is situated.
/// If this is 0, the chord has no tuplet; otherwise, this is the number of nested tuplets under which the chord is situated.
// IT IS ESSENTIAL!!! ESSENTIAL!!! that info be AT LEAST sized CONST_MAX_XML_NESTED_TUPLETS. EVEN IF YOUHAVE LESS TUPLETS THE 
// ALGORITHM USES ALL THE ARRAY POSITIONS!!!!
long get_xml_chord_tuplet_info(t_notation_obj *r_ob, t_chord *chord, t_xml_chord_tuplet_info *info);



// -----------------------------------
// FILTER FUNCTIONS 
// -----------------------------------

// These functions are needed to deal with slots of type #k_SLOT_TYPE_FILTER

/**    Get the (linear) gain response of a biquad filter at a given frequency
    @ingroup        filters
    @param freq                The frequency at which the response is calculated
    @param sampling_freq    The current sampling frequency
    @param a1                The \f$z^{-1}\f$ coefficient in the denominator of the transfert function
    @param a2                the \f$z^{-2}\f$ coefficient in the denominator of the transfert function
    @param b0                The zero-degree coefficient in the numerator
    @param b1                The \f$z^{-1}\f$ coefficient in the numerator of the transfert function
    @param b2                the \f$z^{-2}\f$ coefficient in the numerator of the transfert function
    @returns                The linear gain by which the <freq> frequency is amplified or softened
 
    @remark                The transfert function is given by
                        \f[ H(z) = \displaytype\frac{b_0 + b_1z^{-1} + b_2z^{-2}}{a_0 + a_1z^{-1}+a_2z^{-2}}\f]
                        \f$a0\f$ is considered to be always 1 (so please normalize everything so that \f$a_0\f$ = 1)
    @remark                Beware: in Max objects (such as [biquad~] or [filtergraph~]) the a and b letters are swapped!
 */
double gain_response(double freq, double sampling_freq, double a1, double a2, double b0, double b1, double b2);


/**    Get the gain response (in decibels) of a biquad filter at a given frequency
    @ingroup        filters
    @param freq                The frequency at which the response is calculated
    @param sampling_freq    The current sampling frequency
    @param a1                The \f$z^{-1}\f$ coefficient in the denominator of the transfert function
    @param a2                the \f$z^{-2}\f$ coefficient in the denominator of the transfert function
    @param b0                The zero-degree coefficient in the numerator
    @param b1                The \f$z^{-1}\f$ coefficient in the numerator of the transfert function
    @param b2                the \f$z^{-2}\f$ coefficient in the numerator of the transfert function
    @returns                The gain in decibels by which the <freq> frequency is amplified or softened

    @see    gain_response()
 */
double gain_response_dB(double freq, double sampling_freq, double a1, double a2, double b0, double b1, double b2);


/**    Starting from the <filter_type>, <cutoff_freq>, <gain_dB> and <Q> fields of a biquad filter, fills 
    the fields relative to the biquad coefficients \f$a_0 = 1\f$, \f$a_1\f$, \f$a_2\f$, \f$b_0\f$, \f$b_1\f$, \f$b_2\f$.
    @ingroup        filters
    @param biquad            The biquad filter structure
    @param sampling_freq    The current sampling frequency
 
    @remark        For good formulas you can refer to http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt 
 */
void synchronize_biquad_coeff_from_freq_gain_and_Q(t_biquad *biquad, double sampling_freq);


/**    Fills both the  biquad starting from the content of an llll.
    @ingroup        filters
    @param r_ob        The notation object
    @param biquad    The biquad filter structure
    @param llll        The llll containing the info for the biquad. This information can be either:
                    - (filter_type cutoff_freq gain_dB Q), separate parameters - and the algorithm will fill the biquad 
                            coefficients 
                    - (b0 b1 b2 a0 a1), biquad coefficients as in the max standard object, and the algorithm will NOT fill the 
                            separate parameters, but will turn the type of the filter to k_FILTER_DISPLAY
                    - (b0 b1 b2 a0 a1 (filter_type cutoff_freq gain_dB Q)), which is the information contained in the object 
                            dump - and the algorithm will just take the separate parameters, and will re-calculate the biquad 
                            coefficients 
                    - (t <one_of_the_previous>): if the second element is a llll, the first element is considered as the onset of the biquad
                            e.g. for the case of #k_SLOT_TYPE_DYNFILTER type of slot. For instance this could be (t (b0 b1 b2 a0 a1)).
                    When using the first option, you can use "nil" instead of any parameter to keep the 
                    value it already had in the <biquad> (e.g. (nil 880 nil 2) will only change frequency and Q).
    @remark            If you only give the biquad coefficients (second option), the type of the filter will be automatically 
                    assigned as #k_FILTER_DISPLAY.
 */
void set_biquad_filter_from_llll(t_notation_obj *r_ob, t_biquad *biquad, t_llll *llll);


/**    Initialize a biquad with dummy default values (e.g. as filter type one has k_FILTER_NONE).
    @ingroup        filters
    @param biquad    The biquad filter structure
    @remark            This is only needed to avoid having noninitialized rubbish in the biquad structure.
 */
void initialize_biquad(t_biquad *biquad);


/**    Get the interpolation of two biquads, happening at a certain time <t> (in their fields), at the time <t_interp>.
    @ingroup        filters
    @param biquad1    The first biquad
    @param biquad2    The second biquad
    @param            The interpolation time. In order to avoid extrapolations, this needs to be between the biquad1->t and biquad2->t 
    @param            The interpolation mode. If this is 0, interpolation is performed on the biquad coefficients (BEWARE: THIS DOESN'T MAKE ALMOST ANY 
                    SENSE, AND CAN LEAD TO WEIRD RESULTS; DON'T PUT THIS TO 0 UNLESS YOU KNOW WHAT YOU ARE DOING). If this is 1 (recommended), interpolation
                    is performed on freq/Q/gain parameters.
    @return            The interpolated biquad
 */
t_biquad interpolate_biquad(t_notation_obj *r_ob, t_biquad biquad1, t_biquad biquad2, double t_interp, char mode);


/**    Convert a symbol into one of the #e_filter_types (e.g. gensym("bandpass") will be converted into #k_FILTER_BANDPASS)
    @ingroup        filters
    @param sym        The symbol to convert
    @return            One of the #e_filter_types corresponding to the symbol (if no matches are found, will return #k_FILTER_NONE)
 */
e_filter_types filtersym_to_filtertype(t_symbol *sym);


/**    Convert a filter type into the relative symbol (e.g. #k_FILTER_BANDPASS will be converted into #_llllobj_sym_bypass)
    @ingroup            filters
    @param filtertype    The type of the filter (one of the #e_filter_types)
    @return                The symbol corresponding to the filtertype (if no matches are found, will return #_llllobj_sym_none)
 */
t_symbol *filtertype_to_filtersym(long filtertype);


/**    Properly set all the file fields, starting from a symbol identifying a path. 
    Tries to retrieve the file in its location, and then in the max search path; if not found, it sets the exists field of the #t_file to 0.
     @ingroup            slots
    @param    r_ob        The notation object
    @param    file        The file
    @param    sym            The symbol containing the file path
 */
void set_file_from_symbol(t_notation_obj *r_ob, t_file *file, t_symbol *sym);



// -----------------------------------
// SLOTS MISCELLANEA
// -----------------------------------

/**    Open the slot window for a given notation item, for editing.
    @ingroup            slots
    @param r_ob            The notation object
    @param slot_num        The 0-based slot number
    @param nitem        The notation item to which the slot to open is referred
    @param resync_with_inspector    Also resync with inspector if needed
 */
void open_slot_window(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem, char resync_with_inspector = true);
    

/**    Open the slot window of the currently selected note. The number or the slot window (or symbol of the slot name)
    is contained in a A_GIMME signature, which is expected to have a single atom (#argc = 1, if more are given only
    the first one is accounted for) either of type int (1-based number of slot whose window shouuld be opened) or of type symbol 
    (name of the slot whose window should be opened). 
    Beware: if more than one note is selected, nothing will happen.
    Important: doesn't work for bach.slot.
    @ingroup            slots
    @param r_ob            The notation object
    @param s            The symbol in the A_GIMME signature
    @param argc            The number of atoms in the A_GIMME signature
    @param argv            The atoms of the A_GIMME signature
 */
void notation_obj_openslotwin(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


/**    End editing a slot window.
    @ingroup            slots
    @param r_ob            The notation object
 */
void close_slot_window(t_notation_obj *r_ob);
    

/**    Tell if a notation item has some slot content in any of its slots.
    @ingroup        slots
    @param    r_ob    The notation object
    @param    nitem    The notation item
    @param    mode     The data considering type
    @return            1 if the notation item has some slot content (of any type), 0 if all slots are empty
 */
char notation_item_has_slot_content(t_notation_obj *r_ob, t_notation_item *nitem, e_data_considering_types mode = k_CONSIDER_FOR_DUMPING);


/**    Obtain the standard color for a given slot window
    @ingroup            slots
    @ingroup            notation_colors
    @param num_slot        The slot number (0-based)
    @return                The default color for the slot window of the specified slot
 */
t_jrgba get_default_slotcolor(int num_slot);


/**    Obtain the slot index from the slot name.
    Also accepts the "active" symbol meaning: the "active" slot = the one whose slot window if displayed (if any, otherwise -1 is returned)
    @ingroup            slots
    @param    name        The name of the slot
    @return                The 0-based index of the slot having the specified name (or the active one if "active" was input); -1 if it no slot with such name was found.
 */
long slotname_to_slotnum(t_notation_obj *r_ob, t_symbol *name);


/**    Get the slot number from a llllelem, containing either the slot number itself, or the slot name, or the word "active".
    @ingroup                slots
    @param    elem            The llllelem
    @param    elem_is_1based    Flag telling if the input llllelem is to be considered 1 based (and thus possibly converted to 0-based)
    @return                    The 0-based index of the slot corresponding to the input llllelem (either by number, slot name or "active" word).
    @see    slotname_to_slotnum
    @see    atom_to_slotnum()
 */
long llllelem_to_slotnum(t_notation_obj *r_ob, t_llllelem *elem, char elem_is_1based);


/**    Get the slot number from a t_atom, containing either the slot number itself, or the slot name, or the word "active".
    @ingroup                slots
    @param    av                The atom
    @param    atom_is_1based    Flag telling if the input atom is to be considered 1 based (and thus possibly converted to 0-based)
    @return                    The 0-based index of the slot corresponding to the input atom (either by number, slot name or "active" word).
    @see    slotname_to_slotnum()
    @see    llllelem_to_slotnum()
 */
long atom_to_slotnum(t_notation_obj *r_ob, t_atom *av, char atom_is_1based);


/**    Obtain the 0-based index of the first free slot (such that no notes have that slot's content) 
    @ingroup            slots
    @param        r_ob    The notation object
    @return                The 0-based index of the first free slot
 */
long find_first_free_slot(t_notation_obj *r_ob);


/**    Completely erase a certain number of slots for all notes throughout the score. 
    @ingroup                    slots
    @param        r_ob            The notation object
    @param        slot_numbers    An llll containing a plain list of 0-based indices, representing the slots to be erased.
 */
void notationobj_erase_slots_from_llll(t_notation_obj *r_ob, t_llll *slot_numbers);


/**    Completely erase a given slot for all notes throughout the score. 
    @ingroup                slots
    @param        r_ob        The notation object
    @param        slot_number    The 0-based index of the slot to be erased
 */
void notationobj_erase_slot(t_notation_obj *r_ob, int slot_number);


/**    Properly set the t_slotinfo::slot_num_rows, t_slotinfo::slot_num_cols, t_slotinfo::slot_has_enum_rows and t_slotinfo::slot_has_enum_cols fields
    of a given slotinfo structure, starting from the information given inside the slot representation (t_slotinfo::slot_repr).
    This is of course valid only for matrix-typed slots. For such slots, one can give as representation the dimensions of the matrix, such as (2 3), or 
    also the names of each row/column, such as ((foo fee) (doo dee daa)), or any combination such as (2 (doo dee daa)). This information is then parsed
    into the actual number of row and columns (and into the information about the rows/columns having names, "enums").
    @ingroup                slots
    @param        r_ob        The notation object
    @param        slot_number    The 0-based index of the slot whose slotinfo has to be parsed
 */
void set_matrix_parameters_from_slotinfo(t_notation_obj *r_ob, long slot_num);



// -----------------------------------
// INTERFACE ACTIONS
// -----------------------------------

/**    Snap the pitch of a note to the microtonal grid. More precisely, set the <midicent> field of a note as the <screen_midicents_with_accidental> field,
    which means: sets as midicent of the note the midicents it has _graphically_.
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param    note    The note
    @see            snap_pitch_to_grid_for_selection()
 */ 
void snap_pitch_to_grid_for_note(t_notation_obj *r_ob, t_note *note);


/**    Snap the pitch of all the selected notes to the microtonal grid (works exactly as snap_pitch_to_grid_for_note(), but for all the notes in 
    the current object selection).
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @see            snap_pitch_to_grid_for_note()
 */ 
char snap_pitch_to_grid_for_selection(t_notation_obj *r_ob);


/**    Snap the onset of a chord to the time grid (ruler or grid, if any). Only works for [bach.roll], currently.
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param    note    The note
    @param    dummy    A dummy parameter, so that we can use snap_onset_to_grid_for_chord() inside iterators
    @see            snap_onset_to_grid_for_selection()
 */ 
void snap_onset_to_grid_for_chord(t_notation_obj *r_ob, t_chord *ch, void *dummy);


/**    Snap the onset of a marker to the time grid (ruler or grid, if any). Only works for [bach.roll], currently.
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param    mk      The marker
    @param    dummy    A dummy parameter, so that we can use snap_onset_to_grid_for_chord() inside iterators
    @see            snap_onset_to_grid_for_selection()
 */
void snap_onset_to_grid_for_marker(t_notation_obj *r_ob, t_marker *mk, void *dummy);


/**    Snap the tail of a note to the time grid (ruler or grid, if any).
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param    note    The note
    @param    dummy    A dummy parameter, so that we can use snap_onset_to_grid_for_chord() inside iterators
    @see            snap_tail_to_grid_for_selection()
 */ 
void snap_tail_to_grid_for_note(t_notation_obj *r_ob, t_note *nt, void *dummy);


/**    Snap the tails of all the selected chords to the time grid (if any). Currently it only works for [bach.roll].
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @see            snap_tail_to_grid_for_note()
 */ 
char snap_tail_to_grid_for_selection(t_notation_obj *r_ob);


/**    Retranscribe enharmonically a note. More precisely, change the displayed pitch, and then performs the
    note_compute_approximation() for the note.
    @ingroup                        notation_actions
     @param    r_ob                    The notation object
    @param    note                    The note
    @param    auto_mode                If this is 0, the algorithm will take for granted the two following <new_screen_midicents> and <new_screen_accidental> 
                                    arguments as the new screen midicents and accidental. If this is 1, the algorithmi will ignore them, and calculate 
                                    automatically a default graphical representation of the note. For instance, if the note was Eb, it'll automatically
                                    convert it to D#; if it was a D#, it'll convert it to a Eb, and so on.
    @param    new_screen_midicents    The screen midicents of the note (see the <screen_midicents> field of #t_note), only used if <auto_mode> = 0 
    @param    new_screen_accidental    The screen accidental of the note (see the <screen_accidental> field of #t_note), only used if <auto_mode> = 0 
 */ 
void enharmonically_retranscribe_note(t_notation_obj *r_ob, t_note *note, char auto_mode, long new_screen_midicents, t_rational new_screen_accidental);


/**    Enharmonically retranscribe the pitch of all the selected note (works exactly as enharmonically_retranscribe_note(), but for all the notes in 
    the current object selection, and only in the default automatic mode, <auto_mode> = 1) 
    @ingroup        notation_actions
    @param    r_ob    The notation object
 */ 
char enharmonically_respell_selection(t_notation_obj *r_ob);


/**    DEPRECATED, OBSOLETE: use note_set_pitch().
    Properly set all the note pitch and accidental fields (also screen ones) starting from a note name (as symbo).
    @ingroup                        notation_actions
     @param    r_ob                    The notation object
    @param    note                    The note
    @param    note_name                The name of the note, as symbol (see midicents2notename())
    @param    dont_change_cents_for_enharmonic_changes    If this is non-zero, when the #note_name is an enharmonic equivalent of the previous name, 
                                                        the t_note::midicent field is left untouched (in all other cases, it is filled with the 
                                                        precise midicent value associated with the note name)
 */ 
void note_set_pitch_from_notename(t_notation_obj *r_ob, t_note *note, t_symbol *note_name, char dont_change_cents_for_enharmonic_changes);


/**    Properly set the pitch of a note, and synchronizes the midicents and displayed representation.
    @ingroup                        notation_actions
    @param    r_ob                    The notation object
    @param    note                    The note
    @param    pitch                   The pitch
 */
void note_set_pitch(t_notation_obj *r_ob, t_note *note, t_pitch pitch);


/**    Get the pitch of a note. If the note has user-defined pitch, this is the pitch that the user inserted 
    (which might differ from the displayed one, for instance because it was incompatible for microtonality),
    otherwise it returns the displayed pitch.
    @ingroup                        notation_actions
    @param    r_ob                    The notation object
    @param    note                    The note
    @return                         The pitch of the note
 */
t_pitch note_get_pitch(t_notation_obj *r_ob, t_note *note);


// TBD: pitch-or-cents
void note_get_poc(t_notation_obj *r_ob, t_note *note, t_hatom *h);


/**    Set the velocity of a note, and also sync the velocity of the first breakpoint (that should always coincide
        with the main velocity.
 @ingroup                        notation_actions
 @param    r_ob                    The notation object
 @param    note                    The note
 @param    velocity                    The velocity
 */
void note_set_velocity(t_notation_obj *r_ob, t_note *note, long velocity);

/**    Revert the enharmony of a note to its default value (e.g. turns Eb to D#, and leaves D# to D#, differently from enharmonically_retranscribe_note())
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param    note    The note
*/
char reset_note_enharmonicity(t_notation_obj *r_ob, t_note *note);


/**    Revert the enharmony of all the selected notes (works exactly as reset_note_enharmonicity(), but for all the notes in the current object selection)
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param  ignore_locked_notes     If non-zero, does not respell locked notes
 */
char reset_selection_enharmonicity(t_notation_obj *r_ob, char ignore_locked_notes = true);


/**    Revert the enharmony of all the notes
    @ingroup        notation_actions
    @param    r_ob    The notation object
    @param  ignore_locked_notes     If non-zero, does not respell locked notes
 */
char reset_all_enharmonicity(t_notation_obj *r_ob, char ignore_locked_notes = true);


/**    Tie a note to a note of the next chord (if possible). 
    @ingroup        notation_actions
    @param    note    The note
 */
void tie_note(t_note *note);


/**    Add an ending tie to a given note (if possible), i.e. add a starting tie to the note of the previous chord having the same
    screend midicents+accidental representation.
    @ingroup        notation_actions
    @param    note    The note
 */
void tie_note_from(t_note *note);


/**    Remove the tie starting from a note (if any).
    @ingroup        notation_actions
    @param    note    The note
 */
void untie_note(t_note *note);


/**    Tie a note (if it is untied) or remove the tie (if there was a tie starting).
    @ingroup        notation_actions
    @param    note    The note
    @see    tie_note()
    @see    untie_note()
 */
void tie_untie_note(t_note *note);


/**    Tie all notes of a chord.
    @ingroup        notation_actions
    @param    chord    The chord
 */
void tie_chord(t_chord *chord);


/**    Remove all the ties starting from a chord (if any).
    @ingroup        notation_actions
    @param    chord    The chord
 */
void untie_chord(t_chord *chord);


/**    Tie the notes of the chord (when they have no tie starting) or remove the tie (when they already had a tie starting).
    @ingroup        notation_actions
    @param    chord    The chord
    @see    tie_note()
    @see    untie_note()
 */
void tie_untie_chord(t_chord *chord);


/** Change the pitches of the selection, so that they correspond exactly to a given diatonic step of the current key.
    The octave will depend on the previous pitch of each element inside the selection.
    @ingroup                notation_actions
    @param    r_ob            The    notation object
    @param    diatonic_step    The 0-based diatonic step
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_pitch_to_selection_from_diatonic_step(t_notation_obj *r_ob, long diatonic_step);


/** Set or clear a given flag (one of the #e_bach_internal_notation_flags) in the t_notation_item::flag field of all chords.
    @ingroup        notation_actions
    @param    r_ob    The    notation object
    @param    flag    The flag to be set or cleared, one of the #e_bach_internal_notation_flags
    @param    val        If this is 1, the flag is set, otherwise it is cleared
    @param    also_apply_if_single_note_selected    If this is non-zero, the chord flag is set/unset even if just a single note of the chord is selected, and not the whole chord.
 */
void set_unset_flag_to_selected_chords(t_notation_obj *r_ob, long flag, char val, char also_apply_if_single_note_selected);



// -----------------------------------
// PREVENT EDIT 
// -----------------------------------

/** Completely clear a prevent-edit structure.
    @ingroup        prevent_edit
    @param    pe        The prevent-edit structure.
 */
void clear_prevent_edit(t_prevent_edit *pe);


/** Completely fill a prevent-edit structure with a value (most likely 0, corresponding with clear_prevent_edit(), or 1, i.e. setting all elements to be prevented from editing)
    @ingroup        prevent_edit
    @param    val        The value
    @param    pe        The prevent-edit structure.
 */
void set_all_prevent_edit_to_value(t_prevent_edit *pe, long val);


/** Correct midicents so that they satisfy the t_notation_obj::constraint_pitches_when_editing llll (possibly reducing the possible pitch range). 
    @ingroup            prevent_edit
    @param    r_ob        The notation object
    @param    midicents    Pointer to the midicents to be checked (and possibly corrected)
    @param    voicenum    The 0-based number of the voices in which the note lies.
 */
void constraint_midicents_depending_on_editing_ranges(t_notation_obj *r_ob, double *midicents, long voicenum);



/** Obtain the midicents a cerain number "steps" above or below a certain midicent. This number of steps is the #delta_steps,
    and in the general case, the result is (delta_steps * (200. / x->r_ob.tone_division)). Yet, if some 
    t_notation_obj::constraint_pitches_when_editing is defined, the steps may be custom steps, such as (6000 6200 6400 6500 6700 6900 7100 7200).
    @ingroup            prevent_edit
    @param    r_ob        The notation object
    @param    midicents    The current midicents
    @param    voicenum    The 0-based number of the voices in which the current note lies.
    @param    delta_steps    The number of steps of which we want to move from the current note (positive: above, negative: below)
    @return                The midicents of the step distant #delta_steps from the current note.
 */
double get_next_step_depending_on_editing_ranges(t_notation_obj *r_ob, double midicents, long voicenum, long delta_steps);




// -----------------------------------
// VOICE NAMES
// -----------------------------------

/**    Assign the voice names starting from an llll containing the names.
    @ingroup            voice_attributes
    @param    r_ob        The notation object
    @param    voicenames    The llll containing the voice names (each element, supposely an H_SYM, is a voice name)
    @param    char also_update_notation_obj_voicenames_llll    If this is non-0 the t_notation_obj::voienames_as_llll field is also updated.
                                                            Set this to 0 if voicenames is exactly that llll, otherwise it'll hang!
 */ 
void set_voicenames_from_llll(t_notation_obj *r_ob, t_llll* voicenames, char also_update_notation_obj_voicenames_llll);


/**    Change the name of a specific voice.
    @ingroup            voice_attributes
    @param    r_ob        The notation object
    @param    voice        The voice
    @param    new_names    The new name as an llll
    @param    also_add_undo_ticks    Also adds an undo tick before changing
 */ 
void change_single_voicename(t_notation_obj *r_ob, t_voice *voice, t_llll *new_names, char also_add_undo_tick);


/**    Change the name of a specific voice from an A_GIMME signature
    @ingroup            voice_attributes
    @param    r_ob        The notation object
    @param    voice        The voice
    @param    ac            The length of the A_GIMME signature
    @param    av            The atoms of the A_GIMME signature
    @param    also_add_undo_ticks    Also adds an undo tick before changing
 */ 
void change_single_voicename_from_ac_av(t_notation_obj *r_ob, t_voice *voice, long ac, t_atom *av, char also_add_undo_tick);


/**    Recalculate the unscaled width at the left beginning of the object, due to the fact that there are some voicenames to write.
    Namely, it fills the <voice_names_uwidth> and <there_are_voice_names> fields of the notation object. This function is called
    each time any voice names is changed.
    @ingroup        voice_attributes
    @param    r_ob    The notation object
 */ 
void recalculate_voicenames_width(t_notation_obj *r_ob);






// -----------------------------------
// LYRICS
// -----------------------------------

/**    Assign some lyrics to a chord, and also sets the <lyrics_uwidth> and <lyrics_uheight> fields, accounting for lyrics-box dimensions.
    The chord lyrics are essentially stored in the field <lyrics>. This function analizes if there's a slot linked with lyrics (via the
    <link_lyrics_to_slot> field of the notation object), and if yes, it _copies_ the slot content of the first note having some content
    in this slot into the <lyrics> field. It is worthed to underline that the content is COPIED instead of just referenced.
    @ingroup                    lyrics
    @param    r_ob                The notation object
    @param    chord                The chord whose lyrics we want to assign (lyrics have to be stored in the proper text slot linked with them!)
    @param    jf_lyrics_nozoom    The text font used for lyrics (unscaled, i.e. for <zoom_y> = 1). This is used to retrieve <lyrics_uwidth> and <lyrics_uheight>.
 */ 
void assign_chord_lyrics(t_notation_obj *r_ob, t_chord *chord, t_jfont *jf_lyrics_nozoom);



/**    Delete the lyrics associated to a chord. More precisely: erase the chord slot linked with the lyrics content (if any), and then
    sets the <need_recompute_parameters> field, which will oblige to call for assign_chord_lyrics() and calculate_chord_parameters().
    The first function will be such that (since there's no more slot content), also the <lyrics> field of the chord will be erased.
     @ingroup        lyrics
    @param    r_ob    The notation object
    @param    chord    The chord whose lyrics we want to delete
    @return            1 if chord had lyrics, 0 otherwise.
 */
char delete_chord_lyrics(t_notation_obj *r_ob, t_chord *chord);


/**    When ended editing some lyrics, store the textfield lyric information back into the proper slot of the note whose slotwindow is active.
    The funciton then sets the <need_recompute_parameters>, in order to perform assign_chord_lyrics() and update the <lyrics> field of the note's chord.
    @ingroup        lyrics
    @param    r_ob    The notation object
    @param    text    The new text for the lyrics of the note whose slotwindow is active (r_ob->active_slot_note)
 */ 
void set_textfield_info_to_lyrics_slot(t_notation_obj *r_ob, char *text);


/**    Retrieve the y pixel for drawing the word extensions line of a syllable (the "______" line following a syllable e.g. in a melisma).
    @ingroup                lyrics
    @param    r_ob            The notation object
    @param    staff_bottom    The y of the bottom line of the staff to which the lyrics are referred
    @return                     Y position for drawing word extensions.
 */
double get_lyrics_word_extension_y_pos(t_notation_obj *r_ob, double staff_bottom);



// TBD
void chord_assign_dynamics(t_notation_obj *r_ob, t_chord *chord, t_jfont *jf_dynamics_nozoom, t_jfont *jf_dynamics_roman_nozoom);
char chord_delete_dynamics(t_notation_obj *r_ob, t_chord *chord, char add_undo_tick);
void set_textfield_info_to_dynamics_slot(t_notation_obj *r_ob, char *text);



// -----------------------------------
// NOTATION GRAPHICS
// -----------------------------------


/**    Tell if a point is inside the clef shape (at the beginning of the staff).
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @param    voice        The voice corresponding to the clef.
    @return                1 if the point is inside the clef shape, 0 otherwise.
 */
char is_in_clef_shape(t_notation_obj *r_ob, long point_x, long point_y, t_voice *voice);


/**    Tell if a point is inside on the voice name (at the beginning of the staff.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @param    voice        The voice corresponding to the voice name.
    @return                1 if the point is inside the voie name shape, 0 otherwise.
 */
char is_in_voicename_shape(t_notation_obj *r_ob, long point_x, long point_y, t_voice *voice);


/**    Tell if a point is over the horizontal scrollbar.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is within the scrollbar handle;
                        -1 if the point is on the scrollbar row, but NOT on the scrollbar handle and BEFORE the scrollbar;
                        -2 if the point is on the scrollbar row, but NOT on the scrollbar handle and AFTER the scrollbar;
                        0 if the point is not even on the scrollbar row
 */
int is_in_scrollbar_shape(t_notation_obj *r_ob, long point_x, long point_y);


/**    Tell if a point is over the vertical scrollbar.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is within the vscrollbar handle;
                        -1 if the point is on the vscrollbar column, but NOT on the vscrollbar handle and OVER the scrollbar;
                        -2 if the point is on the vscrollbar column, but NOT on the vscrollbar handle and UNDER the scrollbar;
                        0 if the point is not even on the vscrollbar column.
 */
int is_in_vscrollbar_shape(t_notation_obj *r_ob, long point_x, long point_y);


/**    Tell if a point is inside a given notehead.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    note        The note corresponding to the notehead
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the notehead, 0 otherwise.
 */
int is_in_note_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y);


/**    Tell if a point is inside a given rest.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    restchord        The chord corresponding to the rest
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the rest shape, 0 otherwise.
 */
int is_in_rest_shape(t_notation_obj *r_ob, t_chord *restchord, long point_x, long point_y);


/**    Tell if a point is inside a given lyrics for a chord.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    note        The chord
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the lyrics, 0 otherwise.
 */
char is_in_chord_lyrics_shape(t_notation_obj *r_ob, t_chord *chord, long point_x, long point_y);


/**    Tell if a point is inside a given dynamics.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    dyn        The dynamics
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the dynamics, 0 otherwise.
 */
char is_in_dynamics_shape(t_notation_obj *r_ob, t_dynamics *dyn, long point_x, long point_y);


/**    Tell if a point is inside a given note tail.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    note        The note
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the note tail, 0 otherwise.
 */
int is_in_tail_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y);


/**    Tell if a point is inside a given note's duration line.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    note        The note
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the note's duration line, 0 otherwise.
 */
int is_in_durationline_shape(t_notation_obj *r_ob, t_note *note, long point_x, long point_y);


/**    Tell if a point is inside a given breakpoint.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    breakpoint    The breakpoint
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the note's duration line, 0 otherwise.
 */
int is_in_breakpoint_shape(t_notation_obj *r_ob, t_bpt *breakpoint, long point_x, long point_y);


/**    Tell if a point is inside a given articulation.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    art         The articulation
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the articulation, 0 otherwise.
 */
int is_in_articulation_shape(t_notation_obj *r_ob, t_articulation *art, long point_x, long point_y);


/**    Tell if a point is on a given marker.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    marker      The marker
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the marker, 0 otherwise.
 */
int is_in_marker_shape(t_notation_obj *r_ob, t_marker *marker, long point_x, long point_y);


/**    Tell if a point is on a given marker name.
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    marker      The marker
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @return                1 if the point is over the marker name, 0 otherwise.
*/
int is_in_markername_shape(t_notation_obj *r_ob, t_marker *marker, long point_x, long point_y);


// TBD
double notationobj_get_marker_voffset(t_notation_obj *r_ob, t_marker *mk);

/**    Tell if a point is on the loop region (or on the loop region extremes).
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    point_x        The x coordinate of the point (pixel)
    @param    point_y        The y coordinate of the point (pixel)
    @param    note        The note corresponding to the notehead
    @return                #k_LOOP_START if the point is over the loop start line;
                        #k_LOOP_END if the point is over the loop end line;
                        #k_LOOP_REGION if the point is over the loop region lower global handle (the dashed one);
                        #k_LOOP_NONE if none of the previous is true.
 */
e_element_types is_in_loop_region(t_notation_obj *r_ob, t_rect rect, long point_x, long point_y);


/**    Tell if a point is on the dilation rectangle (or on one of its corners).
    @ingroup            notation_graphic
    @param     r_ob        The notation object
    @param    pt            The point
    @return                One of the #k_DILATION_RECTANGLE_TOPLEFT_SQ, #k_DILATION_RECTANGLE_TOPMIDDLE_SQ, #k_DILATION_RECTANGLE_TOPRIGHT_SQ,
                        #k_DILATION_RECTANGLE_MIDDLELEFT_SQ, #k_DILATION_RECTANGLE_MIDDLERIGHT_SQ, 
                        #k_DILATION_RECTANGLE_BOTTOMLEFT_SQ, #k_DILATION_RECTANGLE_BOTTOMRIGHT_SQ, #k_DILATION_RECTANGLE_BOTTOMMIDDLE_SQ
                        if the point is on one of the dilation rectangle corners;
                        #k_DILATION_RECTANGLE_BODY if the point is inside the dilation rectangle;
                        #k_NONE if none of the previous is true.
 */
e_element_types pt_to_dilation_rectangle_obj(t_notation_obj *r_ob, t_pt pt);



// -----------------------------------
// INTERFACE
// -----------------------------------


/**    Tell if a given type of element is editable.
    @ingroup                interface
     @param    r_ob            The notation object
    @param    element_type    The type of the element as one of the #e_element_types
    @param    action            The editing action as one of the #e_element_actions;
    @return                    1 if the element is editable, 0 otherwise
*/ 
char is_editable(t_notation_obj *r_ob, e_element_types element_type, e_element_actions action);


/**    Set the <j_mousedown_ptr>, <j_mousedown_obj_type> and the <j_last_mousedown_ptr>, <j_last_mousedown_obj_type> fields on a given element
    (representing the object on which the mouse is down, and the last object which had the mousedown).
    @ingroup            interface
     @param    r_ob        The notation object
    @param    item        Pointer to the element which has to have the mousedown
    @param    type        Type of the element (one of the #e_element_types)
    @param  also_set_last_fields    Also set the <j_last_mousedown_ptr> and <j_last_mousedown_obj_type> fields
 */ 
void set_mousedown(t_notation_obj *r_ob, void *item, e_element_types type, char also_set_last_fields = true);


/**    If a dilation rectangle is active, change the mouse cursor depending if it is on the dilation squares or in the inner part
    @ingroup            interface
     @param    r_ob        The notation object
    @param    patcherview    The patcher view
    @param    pt            The point where the mouse is
 */ 
void handle_dilation_rectangle_mouse_cursor(t_notation_obj *r_ob, t_object *patcherview, t_pt pt);






// -----------------------------------
// NOTATION PAINTING WRAPPERS
// -----------------------------------

/** Invalidate the static layers of a bach.roll or bach.score, and then repaint it (this latter operation calls a jbox_redraw(), thus is deferred). 
    If called on a bach.slot, this just calls the jbox_redraw() function.
    The painting of bach.roll and bach.score is based on a layer system. Two static layers are drawn, containing notes, measure, and chords. In addition to them,
    some other non static stuff is drawn, such as the mousemove legend or the selection rectangle. The idea is that the static layer graphic is recalculated 
    only when something inside it need to be redrawn (e.g. a note is added, a note is selected). For instance, when the mouse move the object needs to be repainted for
    its mouse-hovering legend (if any), yet this function should NOT be called (since there's no need to repaint any of the music content, 
    but jbox_redraw() should be directly called instead.
    @ingroup        notation_paint
    @param    r_ob    The notation object
*/
void notationobj_invalidate_notation_static_layer_and_redraw(t_notation_obj *r_ob);


/** Call jbox_redraw() to repaint the notation object.
    @ingroup        notation_paint
    @param    r_ob    The notation object
 */
void notationobj_redraw(t_notation_obj *r_ob);


// TBD
void notationobj_scroll(t_notation_obj *r_ob, t_symbol *direction, double amount, t_symbol *mode, char delta);
void notationobj_scroll_from_gimme(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


/**    Paint a tie (as a simple cubic bezier curve).
    @ingroup            notation_paint
    @param    r_ob        The notation object
    @param    g            The graphic context
    @param    color        The tie color
    @param    x1            The x of the tie starting point
    @param    y1            The y of the tie starting point
    @param    x2            The x of the tie ending point
    @param    y2            The y of the tie ending point
    @param    direction    The direction of the tie (1 being upwards, -1 being downwards) 
 */ 
void paint_tie(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, double x1, double y1, double x2, double y2, char direction);


/**    Paint a clef (actually writes it as a text box)    
    @ingroup            notation_paint
    @param    r_ob        The notation object
    @param    g            The graphic context
    @param    jf            The font to write the clef
    @param    middleC_y    The y of the middle C (of the voice inside the system to which the clef is referred)
    @param    clef        The clef or clef combination as one of the #e_clefs
    @param    color        The color of the main clefs
    @param  auxcolor    The color of the auxiliary clefs
 */
void paint_clef(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf, double middleC_y, long clef, t_jrgba color, t_jrgba auxcolor);


/**    Paint the accollatura for a clef combination (if the <clef> is a simple clef, it does nothing)
    @ingroup            notation_paint
    @param    r_ob        The notation object
    @param    g            The graphic context
    @param    stafftop_y    The y of the topmost staff point
    @param    staffbottom_y    The y of the bottommost staff point
    @param    color        The color of the accollatura
 */ 
void paint_accollatura(t_notation_obj *r_ob, t_jgraphics* g, double stafftop_y, double staffbottom, t_jrgba color);


// TBD
void paint_playhead(t_notation_obj *r_ob, t_jgraphics* g, t_rect rect);
char is_clef_multistaff(t_notation_obj *r_ob, long clef);


/**    Paint the key signature of a voice
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    jf_acc            The font for the accidentals
    @param    jf_acc_bogus    The font for the 'bogus' accidental (should some accidental not be supported)
    @param    middleC_y        The y of the middle C (of the voice inside the system to which the key signature is referred)
    @param    voice            The voice to which the key signature is referred
    @param    color            The color of the key signature
    @remark                    This function detects the midicent position of the accidentals to be painted, and their order,
                            and then calls paint_keysigaccidentals()
 */ 
void paint_keysignature(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_acc_bogus, double middleC_y, t_voice *voice, t_jrgba color);


/**    Paint the key signature of a voice, starting from the specification of the scaleposition of each accidental to be painted, and 
    the left-to-right order for their painting (<clef_mcs> and <mapsto>)
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    jf_acc            The font for the accidentals
    @param    jf_acc_bogus    The font for the 'bogus' accidental (should some accidental not be supported)
    @param    acc_pattern        The accidental pattern for the key signature
    @param    voice            The voice to which the key signature is referred
    @param    color            The color of the key signature
    @param    clef_mcs        An array (sized 7 longs) specifying the cents of the natural notes on whose line the seven accidentals have to be painted.
                            For instance, in a #k_CLEF_G staff, a sharp key signature will have the C# always at 7200, the D# always at 7400, and so on,
                            yielding an array of {7200, 7400, 7600, 7700, 7900, 6900, 7100}, corresponding to {C, D, E, F, G, A, B}
                            These seven steps are required for any key (also nonstandard ones).
    @param    mapsto            An array (sized 7 longs) specifying the left-to-right order in which the accidentals have to be painted. 
                            For instance, in sharp key signatures the standard sequence (left to right) is F# C# G# D# A# E# B#, yielding the array 
                            {3, 0, 4, 1, 5, 2, 6}, considering C = 0, D = 1 and so. This sequence is the <mapsto> sequence (for nonstandard key 
                            signatures, this is usually the trivial {0, 1, 2, 3, 4, 5, 6} sequence).
    @remark                    This function is called by paint_keysignature(), which is in charge for finding <clef_mcs> and <mapsto>. 
 */ 
void paint_keysigaccidentals(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_acc_bogus, t_rational *acc_pattern, t_voice *voice, t_jrgba color, long *clef_mcs, long *mapsto);


/**    Paint a beam line.
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    color            The color of the beam line
    @param    x1                The x of the starting point
    @param    y1                The y of the starting point
    @param    x2                The x of the ending point
    @param    y2                The y of the ending point
    @param    width            The width of the beam
    @param    direction        The direction of the beaming.
    @remark                    Since the beaming has a certain width, the y1 and y2 refer to the topmost (if direction is 1, upwards) or bottommost 
                            (if direction is -1, downwards) vertical position of the beaming.
 */ 
void paint_beam_line(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, double x1, double y1, double x2, double y2, double width, char direction);


/**    Paint a marker line and write the marker name
    @ingroup                    notation_paint
    @remark                        The marker name will be painted (if requested) on the direction choosen by the t_marker::name_painted_direction field.
    @param    r_ob                The notation object
     @param    g                    The graphic context
    @param    color                The color of the marker line and name
    @param    jf                    The font for the markername
    @param    marker                The marker to be painted
    @param    marker_x            The x position (pixel) for the marker line
    @param    marker_y1            The starting y (pixel) of the marker line
    @param    marker_y2            The ending y (pixel) of the marker line
    @param    width                The width of the marker line
    @param    also_paint_name        This has to be 1 if we also need to paint the name of the marker, 0 otherwise 
    @param  namewidth           Pointer that will be filled with the width of the marker name (can be NULL)
 */ 
void paint_marker(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_jfont* jf, t_marker *marker, 
                    double marker_x, double marker_y1, double marker_y2, double linewidth, char also_paint_name, double *namewidth);

/**    Paint the loop region.
    @ingroup                    notation_paint
    @param    r_ob                The notation object
    @param    g                    The graphic context
    @param    rect                The rectangle of the current view
    @param    color                The color of the loop region
    @param    start_x                The x position (pixel) for the loop start
    @param    end_x                The x position (pixel) for the loop end
    @param    playhead_y1            The starting y (pixel) of the playhead (used by loop also)
    @param    playhead_y2            The ending y (pixel) of the playhead (used by loop also)
    @param    width                The width of the loop lines
 */ 
void paint_loop_region(t_notation_obj *r_ob, t_jgraphics* g, t_rect rect, t_jrgba color, double start_x, double end_x, double playhead_y1, double playhead_y2, double width);


/**    Paint a notehead (actually write it).
    @ingroup                    notation_paint
    @param    r_ob                The notation object
    @param    view                The patcherview
    @param    g                    The graphic context
    @param    jf                    The notation font to write the notehead
    @param    notecolor            Pointer to the color of the notehead
    @param    curr_nt                The note (whose notehead we need to paint)
     @param    note_textbox_x        The x of the top-left corner of the textbox needed to write the notehead 
    @param    note_textbox_y        The y of the top-left corner of the textbox needed to write the notehead 
    @param    system_shift        The additional y shift due to the fact that the system is not the first one.
    @param  grace_ratio         The grace ratio factor
 */ 
void paint_notehead(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_jfont *jf, t_jrgba *notecolor, t_note *curr_nt, double note_textbox_x, 
                    double note_textbox_y, double system_shift, double grace_ratio);


/**    Paint the duration line of a note (and the duration tail). (For the time being only used by bach.roll
    This function will be abstracted for score soon, so it might be modified.)
    @ingroup                    notation_paint
    @param    r_ob                The notation object
    @param    view                The patcherview
    @param    g                    The graphic context
    @param    notecolor            The color of the duration line
    @param    tailcolor            The color of the duration tail
    @param    curr_nt                The note (whose duration line and tail we need to paint)
    @param    end_pos                The tail position in pixels
    @param    system_shift        The additional y shift due to the fact that the system is not the first one.
    @param    system_jump            Vertical space (in pixels) needed to jump from one system to the next one.
    @param    note_unselected        Leave non-zero if the chord containing the note is selected AND the note is preselected (thus about to be deleted from selection).
    @param    is_chord_selected    Leave non-zero if and only if the chord containing the note is selected
    @param    is_note_selected    Leave non-zero if and only if  the note is selected
    @param    is_durationline_selected    Leave non-zero if and only if the durationline is selected
    @param    is_note_played        Leave non-zero if and only if the note is being played
    @param    is_note_locked        Leave non-zero if and only if the note is locked
    @param    is_note_muted        Leave non-zero if and only if the note is muted
    @param    is_note_solo        Leave non-zero if and only if the note is "solo"
    @param    selected_breakpoint    Pointer which will be filled if needed with the last selected pitch breakpoint of the note (or with NULL if no note breakpoint was selected).
                                Leave NULL if unneeded
 */ 
void paint_duration_line(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_jrgba notecolor, t_jrgba tailcolor, t_note *curr_nt, 
                            double end_pos, double system_shift, double system_jump, char note_unselected, char is_chord_selected, 
                            char is_note_selected, char is_durationline_selected, char is_note_played, char is_note_locked,
                            char is_note_muted, char is_note_solo, t_bpt **selected_breakpoint);
    


/**    Paint the accidentals of a note (actually write them).
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    jf_acc                    The font for the accidentals
    @param    jf_text_fractiosn        The font for the fractions or cent representation of accidentals (if the user choose a non-classical #e_accidentals_display_type)
    @param    jf_acc_bogus            The font for the 'bogus' accidental 'Â°', used if the accidental to show is not supported with the current font. 
    @param    color                    The color of the accidentals
    @param    curr_nt                    The note (whose accidentals we need to paint)
    @param    clef                    The clef or clef combination of the note's voice (one of the #e_clefs)
    @param    note_y_real                The y pixel of the center of the notehead 
    @param    stem_x                    The x pixel of the chord stem
    @param    acc_top_uextension        Pointer which will be filled with the unscaled top extension of the accidental (see #e_accidentals_typo_preferences) 
                                    Leave NULL if you don't care for the information.
    @param    acc_bottom_uextension    Pointer which will be filled with the unscaled bottom extension of the accidental (see #e_accidentals_typo_preferences). 
                                    Leave NULL if you don't care for the information.
 */ 
void paint_noteaccidentals(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf_acc, t_jfont *jf_text_fractions, 
                           t_jfont *jf_acc_bogus, t_jrgba *color, t_note *curr_nt, long clef, 
                           double note_y_real, double stem_x, 
                           double *acc_top_uextension, double *acc_bottom_uextension);


/**    Paint an articulation
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    color                    The color of the articulation
    @param  art                     The articulation to be painted
    @param    articulation_owner      Pointer to the owner of the articulation (either a #t_note or a #t_chord)
    @param    stem_direction            Direction of the stem (see the <direction> field of #t_chord)
    @param    stem_x                    The x pixel of the chord stem
    @param    note_x_real                The x pixel of the center of the notehead 
    @param    note_y_real                The y pixel of the center of the notehead 
    @param    note_width                The notehead width
    @param    extension_end_x            The x pixel of the end of the (possible) articulation extension 
    @param  part_direction          0 if it's in a single-part voice, 1 if it's in a part with stems up, -1 if it's in a part with stems down
 */ 
void paint_articulation(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_articulation *art,
                        t_notation_item *articulation_owner,
                        char stem_direction, double stem_x, double note_x_real, double note_y_real, double note_width,
                        double extension_end_x, char part_direction);


/**    Paint the ruler and the grid (if needed) for [bach.roll] (don't use it for [bach.score]!)
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    graphic_rect            The view rectangle
 */ 
void paint_ruler_and_grid_for_roll(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect);


/**    Paint a single time-label for the ruler (both for [bach.roll] and for [bach.score])
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    milliseconds    The time (in ms) to be shown in the label
    @param    x_pos            The x pixel of the ruler tick to which the label is linked
    @param    y_pos            The y pixel of the center of the label box
    @param    v_alignment        Set 1 if this is aligned at the top of the object (top ruler), set -1 to align at the bottom (bottom ruler)
    @return                    The x pixel of the right end of the label textbox.
 */ 
double paint_label_for_ruler(t_notation_obj *r_ob, t_jgraphics* g, double milliseconds, double x_pos, double y_pos, char v_alignment);


/**    Paint the staff lines for a given voice (for a given staff or staff combination)
    @ingroup                    notation_paint
    @param    r_ob                The notation object
    @param    g                    The graphic context
    @param    x1                    The starting x pixel for the the staff lines
    @param    x2                    The ending x pixel for the the staff lines
    @param    width                Line width of each staff line
    @param    middleC_y            The y of the middle C of the staff whose staff lines have to be painted
    @param    clef                The clef or clef combination, as one of the #e_clefs
    @param    main_staff_color    The color for the main staves lines
    @param    aux_staff_color        The color for the auxiliary staves lines
    @param    num_staff_lines        Number of staff lines to be painted per staff
    @param    staff_lines            Array with customizable staff lines indices. Staff lines on the traditional 5-lines-staff are numbered
                                from 1 to 5 bottom-up (the middle one being the 3rd). You can choose a subset of these lines, or even use
                                (nontraditional) lines placed aboves or below, by properly setting these staff line values. E.g. if this
                                array is {1, 5, 6}, only the first and the last lines of each staff are painted, plus a line placed right
                                above the last one. You may leave <staff_lines> to null if the <num_staff_lines> lines to paint are the standard ones.
                                See the <num_staff_lines> and <staff_lines> fields in the #t_voice structure for more information;
                                these act exactly in the same way.
 */ 
void paint_staff_lines(t_notation_obj *r_ob, t_jgraphics* g, double x1, double x2, double width, double middleC_y, long clef, 
                       t_jrgba main_staff_color, t_jrgba aux_staff_color, long num_staff_lines, char *staff_lines);


// TBD
void paint_left_vertical_staffline(t_notation_obj *r_ob, t_jgraphics* g, t_voice *voice, t_jrgba color);



/**    Paint a time signature (actually write it) on each main staff of the specified voice (for a specified measure). This means that
    for every staff combination involving two main staves (e.g. #k_CLEF_FG or #k_CLEF_FFG...) the time signature will be painted twice,
    otherwise just once.
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    color            The time signature color
    @param    jf_ts            Font for the time signature
    @param    clef            The clef or clef combination, as one of the #e_clefs
    @param    staff_top        The topmost y pixel in the staff or staff combination
    @param    curr_meas        The measure of which we need to paint the time signature
    @param    big               Flag telling if the time signature is in "big" form (double size, e.g. above the staff)
 */ 
void paint_timesignature(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_jfont *jf_ts, long clef, double staff_top, t_measure *curr_meas, char big);


/**    Paint the semi-transparent selection rectangle. This is used also to paint the zooming rectangle (just by changing the color parameters).
    @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
     @param    bordercolor        The border color
    @param    fillcolor        The fill color
    @remark                    The positions for drawing are contained in the #t_notation_obj structure, namely they are the fields <j_mousedown_point> and <j_mousedrag_point> 
 */ 
void paint_selection_rectangle(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba bordercolor, t_jrgba fillcolor);


/**    Paint the semi-transparent dilation rectangle (to scale the rectangle content), with the 8 squares at the corners and middle-sides.
     @ingroup                notation_paint
    @param    r_ob            The notation object
    @param    g                The graphic context
    @remark                    The positions for drawing are contained in the #t_notation_obj structure, namely they are the field <dilation_rectangle> 
                            Used colors are automatical.
 */ 
void paint_dilation_rectangle(t_notation_obj *r_ob, t_jgraphics* g);


/**    Paint the part of background BEFORE the starting of the score domain. A small fade is achieved in #CONST_X_LEFT_START_FADE steps, from the background start position rightwards.
    Usually, all the score is painted, then the left background part is repainted (via this function) and then clefs and key signatures are painted 
    (over this left backgorund part)
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    graphic_rect            The current view rectangle
    @param    fade_left_x_pixel        X pixel of the point where fade starts (this is the left point delimiting fade horizontal zone)  
    @param    fade_right_x_pixel        X pixel of the point where fade ends (this is the right point delimiting fade horizontal zone)
*/ 
void repaint_left_background_part(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect, double fade_left_x_pixel, double fade_right_x_pixel);

/**    Paint the colored circles representing the note label families for a given notes
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    view                    The view
    @param    g                        The graphic context
    @param    curr_nt                    The note
    @param    label_family_chord_shape_radius    Pointer which will be possibly updated with the maximum radius reached by the colored circles around the note (plus a pad).
 */ 
void paint_note_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_note *curr_nt, double *label_family_chord_shape_radius);


/**    Paint the colored rectangles representing the chord label families for a given chord
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    view                    The view
    @param    g                        The graphic context
    @param    curr_ch                    The chord
    @param    start_label_family_chord_shape_radius    Starting pad (top, left, right and bottom) for the rectangle
 */ 
void paint_chord_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_chord *curr_ch, double start_label_family_chord_shape_radius);


/**    Paint the colored rectangles representing the measure label families for a given measure
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    view                    The view
    @param    g                        The graphic context
    @param    curr_meas                The measure
 */ 
void paint_measure_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g, t_measure *curr_meas);


/**    Paint the colored closed curves representing the label families in Venn-style
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    view                    The view
    @param    g                        The graphic context
 */
void paint_venn_label_families(t_notation_obj *r_ob, t_object *view, t_jgraphics* g);



/**    Obtain and paint the selection legend
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param  rect                    The drawing rectangle
    @param  jf_text_legend          The font
 */
void notationobj_paint_legend(t_notation_obj *r_ob, t_jgraphics *g, t_rect rect, t_jfont *jf_text_legend);


// Like paint_curve() inferring slope mapping type from the notation object
void notationobj_paint_curve(t_notation_obj *r_ob, t_jgraphics *g, t_jrgba color, double x1, double y1, double x2, double y2, double slope, double width);
void notationobj_paint_doublewidth_curve(t_notation_obj *r_ob, t_jgraphics *g, t_jrgba color, double x1, double y1, double x2, double y2, double slope, double width_start, double width_end);
void notationobj_paint_colorgradient_curve(t_notation_obj *r_ob, t_jgraphics *g, t_jrgba color_start, t_jrgba color_end, double x1, double y1, double x2, double y2, double slope, double width, long num_steps, char are_color_from_spectrum, double vel1, double vel2, double max_velocity);



#ifndef DOXYGEN_SHOULD_SKIP_THIS
// EXPERIMENTAL, UNDOCUMENTED, DON'T USE IT YET
void paint_slur(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba color, t_slur *slur, 
                char paint_control_points, t_jrgba linecolor, t_jrgba pointcolor, double point_radius, double line_width, double dash_length);

void delete_slur(t_notation_obj *x, t_slur *slur);

#endif

/**    Paint a small note (or sequence of notes, if the duration is not drawable singularly)
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    color                    The color
    @param    duration                The rational duration of the note. If the duration is not drawable (such as 5/16), the algorithm will
                                    take care of splitting it into a drawable ones, and draw all ties properly.
    @param    x_pos                    The x pixel for the painted note
    @param    y_pos                    The y pixel for the painted note
    @param    ratio                    Ratio determining 'how small' is the note: 1. = standard note (as the one painted at the current level of zoom).
                                    In principle, this function can be used thus to paint also "big notes", and not only small ones.
    @param    width                    Pointer filled with the width needed to draw the small notes.
    @remark    This is used for instance to draw tempi, or some tuplets ratii.
*/
void paint_small_note(t_notation_obj *r_ob,  t_jgraphics* g, t_jrgba color, t_rational duration, double x_pos, double y_pos, 
                        double ratio, double *width);


/**    Paint a small notehead, possibly with accidentals, given a pitch in midicents.
    This is different from paint_small_note() because this one does NOT paint flags or stems, only notehead with a given accidental.
    The screen midicents and the screen accidentals are automatically calculated from the given midicents (you can't set them up manually).
    @ingroup                        notation_paint
    @param    r_ob                    The notation object
    @param    view                    The patcherview
    @param    g                        The graphic context
    @param    notecolor                The notehead and accidentals color
    @param    midicents                The note midicents
    @param    notehead_center_x        The center x pixel of the notehead
    @param    note_attachment            Note to which this notehead is attached, e.g. because it represents graphically a pitch breakpoint of this note
    @param    system_shift        The additional y shift due to the fact that the system is not the first one.
    @param    small_note_ratio    Note size ratio (defaults to the grace note size)
    @remark    This is used for drawing breakpoints as notes.
*/
void paint_default_small_notehead_with_accidentals(t_notation_obj *r_ob, t_object *view, t_jgraphics *g, t_jrgba notecolor, double midicents, 
                                                double notehead_center_x, t_note *note_attachment, double system_shift, double small_note_ratio = CONST_GRACE_CHORD_SIZE);


// TBD
void paint_annotation_from_slot(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_notation_item *item,
                                double x_pos, long slot, t_jfont *jf_ann, double staff_top_y,
                                char *last_annotation_text, double *annotation_sequence_start_x_pos, double *annotation_sequence_end_x_pos,
                                double *annotation_line_y_pos);

double paint_dynamics_from_slot(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_notation_item *item,
                              double center_x, double duration_x, long slot, t_jfont *jf_dynamics, t_jfont *jf_dynamics_roman, double font_size, double roman_font_size, double staff_bottom_y, double *curr_hairpin_start_x, long *curr_hairpin_type, char paint_mode);
double paint_dynamics(t_notation_obj *r_ob, t_jgraphics* g, t_jrgba *color, t_notation_item *item,
                    double center_x, double duration_x, t_dynamics *dyn, t_jfont *jf_dynamics, t_jfont *jf_dynamics_roman, double font_size, double roman_font_size, double y_position, double *curr_hairpin_start_x, long *curr_hairpin_type, t_jrgba *prev_hairpin_color, char *prev_hairpin_dont_paint, char paint_mode, double min_hairpin_start_x, char force_show);






// -----------------------------------
// SLOT PAINTING
// -----------------------------------


/**    Paint the slot window relative to a given notation item.
    @remark                    This function rely on the values of t_notation_obj::slot_window_x1 and t_notation_obj::slot_window_x1, which you have to
                            set "manually" *before* entering this function 
    @ingroup                slot_graphic
    @param    r_ob            The notation object
    @param    g                The graphic context
    @param    graphic_rect    The current view rectangle
    @param    nitem            The notation item whose slot window needs to be painted
    @param    slot_number        The number of the slot that needs to be painted (0-based!!!)
 */ 
void paint_slot(t_notation_obj *r_ob, t_jgraphics* g, t_rect graphic_rect, t_notation_item *nitem, long slot_number);


/**    Paint in background the slot window relative to a given notation item. 
    Painting in background differ from standard slot painting (done via paint_slot()), because no slot window is displayed, only the slot content, 
    and in a more compact or transparent way, allowing the user to keep more than the note slot under each eyes at any time. Moreover, paint_background_slots() 
    differs from paint_slot() because ALL the slots kept in background with the <background_slots> field (and attribute) are displayed. 
    Number-slots content will be written UNDER the note duration line, text-slots content will be written ABOVE the note duration line, all other type of slot will be 
    displayed within the <bounding_rectangle>, as if it were an invisible slot window.
    @ingroup                slot_graphic
    @param    r_ob                The notation object
    @param    g                    The graphic context
    @param    slot_bgwindow_active_x1        The left pixel of the imaginary bounding rectangle of the background displayed slot
                                        (This is meaningful only for function or filter slots: other slots, when in background, are written linearly, not drawn in a rectangle.)
    @param    slot_bgwindow_active_y2        The bottom pixel of the imaginary bounding rectangle of the background displayed slot
                                        (This is meaningful only for function or filter slots: other slots, when in background, are written linearly, not drawn in a rectangle.)
    @param    duration_line_length        Length of the duration line of the note to which the slots refer, in pixels. (This is used only by temporal slots.)
    @param    jf_slottext            Font used to display text
    @param    jf_slotbold            Font used to display bold text and numbers
    @param  jf_slotdynamics     Font used to display dynamics
    @param    nitem                The notation item whose background slots needs to be background-painted  
    @param    pos_x_for_numbers    X pixel for the left side of the box (or series of boxes) containing the number-slot-content
    @param    pos_y_for_numbers    Y pixel for the top of the box (or series of boxes) containing the number-slot-content
    @param    pos_x_for_text        X pixel for the left side of the box (or series of boxes) containing the text-slot-content
    @param    pos_y_for_text        Y pixel for the top of the box (or series of boxes) containing the text-slot-content
    @param    dont_paint_this_slot    0-based index of a slot which will be not be painted even if in background. This is useful in some cases to prevent 
                                    background painting of the "foreground" slot. Leave this to -1 in order to ignore it (and to paint all background slots).
 */ 
void paint_background_slots(t_notation_obj *r_ob, t_jgraphics* g, double slot_bgwindow_active_x1, double slot_bgwindow_active_y2, double duration_line_length, 
                                t_jfont *jf_slottext, t_jfont *jf_slotbold, t_jfont *jf_slotdynamics, t_jfont *jf_slotdynamicsroman, t_notation_item *nitem, double pos_x_for_numbers, double pos_y_for_numbers,
                                double pos_x_for_text, double pos_y_for_text, long dont_paint_this_slot);


/**    Paint a function graph (as a breakpoint-curve) contained inside a note slot
    @ingroup                slot_graphic
    @param    r_ob                            The notation object
    @param    g                                The graphic context
    @param    function_bounding_rectangle        The bounding rectangle for the whole function
    @param    displayed_bounding_rectangle    The bounding rectangle for the portion of the function to be displayed
    @param    item                    The item whose background slots needs to be background-painted
    @param    slot_number                The slot number (0-based)
    @param    slot_color                The color associated to the <slot_number>
    @param    new_alpha                The new alpha value for lines and points, provided that <can_change_alpha> is non-0
    @param    show_points                If non-0, it also paints all the breakpoints as small white circles
    @param    can_change_luminosity    If non-0, it'll increase the luminosity of lines and points (usually non-0)
    @param    can_change_alpha        If non-0, it'll set the alpha value of lines and points to <new_alpha> (usually non-0)
    @param    mouse_hover                If non-0, it allows the displaying of additional bigger circles when the mouse is over a point 
    @param  slot_zoom                Additional zoom factor for slots, 100 being the default one (thus put 100 for default behavior). 
                                    This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                    or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)
    @param    highlight_selection        If non-0 it'll display the selected function points with the selection color
    @param    paint_point_labels        If non-0 it'll also paint some labels with the Y values of the slot points
    @param    jf_label_font            Font for the labels (only needed if #paint_point_labels is non-zero, leave NULL otherwise).
    @param    paint_lines_separately    If non-0, it paints the lines on a new surface, and not on the original one. The surface will be properly trimmed
                                    to match the #displayed_bounding_rectangle, and will be drawn upon it.
 
    @remark    This function is recalled both by paint_slot() and by paint_background_slots()
 */ 
void paint_function_in_slot_win(t_notation_obj *r_ob, t_jgraphics* g, t_rect function_bounding_rectangle, t_rect displayed_bounding_rectangle,
                                t_notation_item *item, long slot_number,
                                t_jrgba slot_color, double new_alpha, char show_points, char can_change_luminosity, 
                                char can_change_alpha, char mouse_hover, double slot_zoom, char highlight_selection,
                                char paint_point_labels, t_jfont *jf_label_font, char paint_lines_separately);
    

/**    Paint a 3d-function graph (as a breakpoint-curve) contained inside a slot
    @ingroup                        slot_graphic
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    function_bounding_rectangle        The bounding rectangle for the whole function
    @param    displayed_bounding_rectangle    The bounding rectangle for the portion of the function to be displayed
    @param    nitem                    The notation item whose background slots needs to be background-painted
    @param    slot_number                The slot number (0-based)
    @param    slot_color                The color associated to the <slot_number>
    @param    new_alpha                The new alpha value for lines and points, provided that <can_change_alpha> is non-0
    @param    show_points                If non-0, it also paints all the breakpoints as small white circles
    @param    can_change_luminosity    If non-0, it'll increase the luminosity of lines and points (usually non-0)
    @param    can_change_alpha        If non-0, it'll set the alpha value of lines and points to <new_alpha> (usually non-0)
    @param    mouse_hover                If non-0, it allows the displaying of additional bigger circles when the mouse is over a point 
    @param  slot_zoom                Additional zoom factor for slots, 100 being the default one (thus put 100 for default behavior). 
                                    This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                    or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)
    @param    paint_lines_separately    If non-0, it paints the lines on a new surface, and not on the original one. The surface will be properly trimmed
                                    to match the #displayed_bounding_rectangle, and will be drawn upon it.
    @param  trim_overflowing_lines    If non-0, the lines going out from the slot window are cropped

    @remark    This function is recalled both by paint_slot() and by paint_background_slots()
 */ 
void paint_3dfunction_in_slot_win(t_notation_obj *r_ob, t_jgraphics* g, t_rect function_bounding_rectangle, t_rect displayed_bounding_rectangle,
                                  t_notation_item *nitem, long slot_number,
                                    t_jrgba slot_color, double new_alpha, char show_points, char can_change_luminosity, char can_change_alpha, 
                                    char mouse_hover, double slot_zoom, char paint_lines_separately, char trim_overflowing_lines);


/**    Paint a function spatialization graph contained inside a slot
    @ingroup                            slot_graphic
    @param    r_ob                        The notation object
    @param    g                            The graphic context
    @param    function_bounding_rectangle        The bounding rectangle for the whole function
    @param    displayed_bounding_rectangle    The bounding rectangle for the portion of the function to be displayed
    @param    nitem                        The notation item whose background slots needs to be background-painted
    @param    slot_number                    The slot number (0-based)
    @param    slot_color                    The color associated to the <slot_number>
    @param    points_color                The color of the spat points
    @param    new_alpha                    The new alpha value for lines and points, provided that <can_change_alpha> is non-0
    @param    show_points                    If non-0, it also paints all the breakpoints as small white circles
    @param    can_change_line_luminosity    If non-0, it'll increase the luminosity of any line: both spatialization paths and point border or angle line (usually non-0)
    @param    can_change_point_luminosity    If non-0, it'll increase the luminosity of points filling (usually non-0)
    @param    can_change_alpha            If non-0, it'll set the alpha value of lines and points to <new_alpha> (usually non-0)
    @param    point_radius                Radius of each slot point
    @param  slot_zoom                    Additional zoom factor for slots, 100 being the default one (thus put 100 for default behavior). 
                                        This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                        or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)
    @param    paint_lines_separately        If non-0, it paints the lines on a new surface, and not on the original one. The surface will be properly trimmed
                                        to match the #displayed_bounding_rectangle, and will be drawn upon it.
    @param  trim_overflowing_lines        If non-0, the lines going out from the slot window are cropped

    @remark    This function is recalled both by paint_slot() and by paint_background_slots()
 */ 
void paint_spatfunction_in_slot_win(t_notation_obj *r_ob, t_jgraphics* g, t_rect function_bounding_rectangle, t_rect displayed_bounding_rectangle, t_notation_item *nitem, long slot_number,
                                    t_jrgba slot_color, t_jrgba points_color, double new_alpha, char show_points, char can_change_line_luminosity, 
                                    char can_change_point_luminosity, char can_change_alpha, double point_radius, double slot_zoom, char paint_lines_separately, char trim_overflowing_lines);


/**    Paint a filter amplitude response contained inside a slot
    @ingroup                        slot_graphic
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    bounding_rectangle        The bounding rectangle for the function
    @param    nitem                    The notation item whose background slots needs to be background-painted
    @param    slot_number                The slot number (0-based)
    @param    slot_color                The color associated to the <slot_number>
    @param    new_alpha                The new alpha value for lines and points, provided that <can_change_alpha> is non-0
    @param    can_change_luminosity    If non-0, it'll increase the luminosity of lines and points (usually non-0)
    @param    can_change_alpha        If non-0, it'll set the alpha value of lines and points to <new_alpha> (usually non-0)
    @param    paint_bandwidth            If non-0, it also paints the bandwidth rectangle
    @param    write_coefficients        If non-0, it also writes the biquad coefficient of the filter
    @param    paint_0db_line            If non-0, it also paints the horizontal line corresponding to a 0dB gain 
    @param  slot_zoom                Additional zoom factor for slots, 100 being the default one (thus put 100 for default behavior). 
                                    This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                    or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)

    @remark    This function is recalled both by paint_slot() and by paint_background_slots()
 */ 
void paint_filtergraph_in_slot_win(t_notation_obj *r_ob, t_jgraphics* g, t_rect bounding_rectangle, t_notation_item *nitem, long slot_number,
                                   t_jrgba slot_color, double new_alpha, char can_change_luminosity, char can_change_alpha, 
                                   char paint_bandwidth, char write_coefficients, char paint_0db_line, double slot_zoom);
    

/**    Paint a dynamic filter amplitude response contained inside a slot
    @ingroup                        slot_graphic
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    function_bounding_rectangle        The bounding rectangle for the whole dynfilter
    @param    displayed_bounding_rectangle    The bounding rectangle for the portion of the dynfilter to be displayed
    @param    nitem                    The notation item whose background slots needs to be background-painted
    @param    slot_number                The slot number (0-based)
    @param    slot_color                The color associated to the <slot_number>
    @param    new_alpha                The new alpha value for lines and points, provided that <can_change_alpha> is non-0
    @param    can_change_luminosity    If non-0, it'll increase the luminosity of lines and points (usually non-0)
    @param    can_change_alpha        If non-0, it'll set the alpha value of lines and points to <new_alpha> (usually non-0)
    @param    paint_markers            If non-0, it also paints the markers identifying the "breakpoint" filters
    @param  slot_zoom                Additional zoom factor for slots, 100 being the default one (thus put 100 for default behavior). 
                                    This is typically either t_notation_obj::slot_win_zoom (if the function is drawn inside a slot window)
                                    or t_notation_obj::bgslot_zoom (if the function is drawn in a background slot)

    @remark    This function is recalled both by paint_slot() and by paint_background_slots()
 */ 
void paint_dynfiltergraph_in_slot_win(t_notation_obj *r_ob, t_jgraphics* g, t_rect dynfilter_bounding_rectangle,
                                      t_rect displayed_bounding_rectangle, t_notation_item *nitem, long slot_number,
                                      t_jrgba slot_color, double new_alpha, char can_change_luminosity, char can_change_alpha, 
                                      char paint_markers, double slot_zoom);
    

/**    Paint a color palette (inside a slot window), under the form of a main palette + complete spectrum (red -> red)
    @ingroup                        slot_graphic
    @param    r_ob                    The notation object
    @param    g                        The graphic context
    @param    palette_rectangle        The bounding rectangle for the main palette
    @param    spectrum_x                X pixel for the spectrum to start 
    @param    spectrum_width            Width (in pixels) for the spectrum
    @param    selected_color            The currently selected color in the palette
    @param    top_right_corner_color    The color currently present in the top right corner of the main palette
    @param    show_circle                If non-0, it also shows a circle around the selected color
    @param    show_spectrum            If non-0, it shows the complete spectrum right bar, otherwise it only shows the main palette 
    @param    show_spectrum_arrow        If non-0, it also shows a rectangle (currently NOT an arrow...) around the selected color in the right spectrum bar 
    @param    show_coefficients        If non-0, it also shows, under the palette, the RGBA coefficients
    @param    coeff_font                If #show_coefficients is non-0, here you need to pass the font to write the coefficients. Leave NULL if unneeded.
    @param    coeff_color                Color for the coefficients writing (leave any value if you don't need them).
    @param    coeff_bg_color            Background color for the coefficients (leave any value if you don't need them).
    @param    zoom                    The zoom factor (1. = default). If the palette is painted inside the notation object, this usually coincides with the <r_ob->zoom_y> field 
    @remark    This function is by paint_slot(), but not by paint_background_slots()
 */ 
void paint_colorpalette(t_notation_obj *r_ob, t_jgraphics* g, t_rect palette_rectangle, double spectrum_x, double spectrum_width, t_jrgba selected_color, 
                        t_jrgba top_right_corner_color, char show_circle, char show_spectrum, char show_spectrum_arrow, char show_coefficients, 
                        t_jfont *coeff_font, t_jrgba coeff_color, t_jrgba coeff_bg_color, double zoom);


/**    Get the text string representing the content of a numeric slot 
    @ingroup                        slot_graphic
    @param    r_ob                    The notation object
    @param    firstslotitem            First #t_slotitem in the slot
    @param    num_elems                Numbers of slotitems in the slot
    @param    buf                        A pointer to an _uninitialized_ text buffer, which will be initialized and filled with the text content
    @param    slot_type                The type of the slot
    @param    slot_num                The 0-based number of the slot
    @param  numbers_only            Only get numbers, don't get any measurement unit nor enumeration elements
    @return                            The length of the text string.
 */ 
long number_slot_to_text_buf(t_notation_obj *r_ob, t_slotitem *firstslotitem, long num_elems, char **buf, char slot_type, long slot_num, char numbers_only = false);


/**    Obtain the default unscaled height of a slot window, depending on the slot type.
    @ingroup                slot_graphic
    @param    r_ob            The notation object
    @param    slot_num        The 0-based number of the slot
    @param    item            The item whose slot window unscaled height has to be retrieved 
    @param    get_active_uheight    If this is non-zero, the active unscaled height is returned (the height of the inner portion of the slot window).
                                If this is zero, the whole slot window height is returned. The former is used for background slots, the latter for ordinary open slot windows.
    @return                    The default unscaled height connected with the given slot type. 
 */ 
double get_default_slot_window_uheight(t_notation_obj *r_ob, long slot_num, t_notation_item *item, char get_active_uheight);


/**    Obtain the unscaled height of the top vertical inset of a slot window, depending on the slot type.
    @ingroup                slot_graphic
    @param    r_ob            The notation object
    @param    slot_num        The 0-based number of the slot
    @param    note            The note whose slot window unscaled height has to be retrieved 
    @return                    The default unscaled height of the top vertical inset of a slot window. 
 */ 
double get_slot_window_top_inset_uheight(t_notation_obj *r_ob, long slot_num);


/**    Obtain the unscaled height of the bottom vertical inset of a slot window, depending on the slot type.
    @ingroup                slot_graphic
    @param    r_ob            The notation object
    @param    slot_num        The 0-based number of the slot
    @param    note            The note whose slot window unscaled height has to be retrieved 
    @return                    The default unscaled height of the bottom vertical inset of a slot window. 
 */ 
double get_slot_window_bottom_inset_uheight(t_notation_obj *r_ob, long slot_num);


// -----------------------------------
// TEXT WRITING WRAPPERS
// -----------------------------------

#ifdef BACH_MAX

/**    Convenience wrapper for writing left-aligned single-lined non-ellipsed text, whereas the top-left corner (0, 0) also takes into account
    the horizontal inset, and the vertical inset (which is not user defined, but set to 0.5 to allow a good staff lines painting).
    @ingroup                notation_text
    @param    g                The graphic context
     @param    jf                The font for writing
     @param    textcolor        The text color
     @param    text            The text as a string
    @param    x1                The x of the top-left corner of the text box, considering that (0, 0) is already indented for x and y insets
    @param    y1                The y of the top-left corner of the text box, considering that (0, 0) is already indented for x and y insets
    @see                    write_text()
 */ 
void write_text_standard_account_for_insets(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);

void write_text_standard_account_for_insets_singleline(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);


/**    Convenience wrapper for writing left-aligned single-lined non-ellipsed text, whereas the top-left corner (0, 0) also takes into account
    the vertical inset only (which is not user defined, but set to 0.5 to allow a good staff lines painting).
    @ingroup                notation_text
    @param    g                The graphic context
     @param    jf                The font for writing
     @param    textcolor        The text color
     @param    text            The text as a string
    @param    x1                The x of the top-left corner of the text box
    @param    y1                The y of the top-left corner of the text box, considering that (0, 0) is already indented for vertical inset
    @see                    write_text()
 */ 
void write_text_standard_account_for_vinset(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);

void write_text_standard_account_for_vinset_singleline(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);

#endif

#ifdef BACH_JUCE
void write_text_standard_account_for_insets(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);
void write_text_standard_account_for_vinset(t_notation_obj *r_ob, t_jgraphics* g, t_jfont* jf, t_jrgba textcolor, const char * text, double x1, double y1);
#endif


/**    Paint a color palette (inside a slot window), under the form of a main palette + complete spectrum (red -> red)
    @ingroup        notation_text
    @ingroup        voice_attributes
    @param    r_ob    The notation object
    @param    g        The graphic context
    @param    jf        The font
    @param    y_pos    Y pixel of the top border of the writing box 
    @param    label    The text to write for the voicename
    @param    align    The alignment: 0 = left, 1 = centered, 2 = right
    @param    color    The text color
 */ 
void write_voicename(t_notation_obj *r_ob, t_jgraphics* g, t_jfont *jf, double y_pos, char *name, char align, t_jrgba color);


// DEPRECATED. Use notationobj_get_legend()
void get_legend(t_notation_obj *r_ob, t_note *curr_nt, t_bpt *selected_breakpoint, char *there_is_legend, char *legend_text);


/**    Get the upper legend.
    @ingroup        notation_text
    @param    r_ob                    The notation object
    @param    legend_text                A pointer which will be filled with the legend text, if there is any legend. IMPORTANT: IT MUST BE ALREADY BE CORRECTLY SIZED. TO be sure, size it as a char[256], since 255 is the maximum number of admissible characters for an upper legend.
 */
void notationobj_get_legend(t_notation_obj *r_ob, char *legend_text);



// -----------------------------------
// PAGE VIEW
// -----------------------------------

#ifndef DOXYGEN_SHOULD_SKIP_THIS

// UNDONE yet, unfinished, only sketched for bach.roll
long yposition_to_systemnumber(t_notation_obj *r_ob, double yposition);

// page view stuff, already done, but to be extended to bach.score
void recalculate_num_systems(t_notation_obj *r_ob);
double get_system_jump(t_notation_obj *r_ob);
long onset_to_system_index(t_notation_obj *r_ob, double onset);
double system_index_to_system_start_ms(t_notation_obj *r_ob, long index);
double system_index_to_system_end_ms(t_notation_obj *r_ob, long index);

void calculate_ms_on_a_line(t_notation_obj *r_ob);

#endif






// -----------------------------------
// EXTERNAL EDITOR
// -----------------------------------

/**    Close the editor, and properly update slot content.
    @ingroup        editor
    @param    r_ob    The notation object
    @param    ht        Pointer to the new text
    @param    size    The size of the new text
    @ingroup        editor
 */
void notation_obj_edclose(t_notation_obj *r_ob, char **ht, long size);






// -----------------------------------
// TEXTFIELD
// -----------------------------------

/**    Initialize the textfield.
    @ingroup        textfield
    @param    r_ob    The notation object
 */
void initialize_textfield(t_notation_obj *r_ob);


/**    Start to edit a voicename.
    @ingroup                textfield
    @param    r_ob            The notation object
    @param    patcherview        The patcher view
    @param    voice            The voice whose name has to be edited
 */
void start_editing_voicename(t_notation_obj *r_ob, t_object *patcherview, t_voice *voice);


// internal
t_max_err notationobj_set_fontname_safe(t_notation_obj *r_ob, t_symbol *ps);
t_max_err notationobj_set_fontsize_safe(t_notation_obj *r_ob, double d);
long notationobj_oksize_check(t_notation_obj *r_ob, t_rect *newrect);

/**    Start typing a text inside a #k_SLOT_TYPE_TEXT slot.
    @ingroup                    textfield
    @param    r_ob                The notation object
    @param    patcherview            The patcher view
    @param    nitem                The notation item whose slot we need to edit
    @param    slot_num            The 0-based index of the slot to edit
    @param    slot_text_textcolor    The textcolor
 */
void start_editing_textslot(t_notation_obj *r_ob, t_object *patcherview, t_notation_item *nitem, long slot_num, t_jrgba slot_text_textcolor);


/**    Start typing the number inside a #k_SLOT_TYPE_INT or #k_SLOT_TYPE_FLOAT slot.
    @ingroup                    textfield
    @param    r_ob                The notation object
    @param    patcherview            The patcher view
    @param    nitem                The notation item whose slot we need to edit
    @param    slot_num            The 0-based index of the slot to edit
    @param    slot_text_textcolor    The textcolor
 */
void start_editing_numberslot(t_notation_obj *r_ob, t_object *patcherview, t_notation_item *nitem, long slot_num, t_jrgba slot_text_textcolor);


/**    Start to edit a marker name.
    @ingroup                    textfield
    @ingroup                    markers
    @param    r_ob                The notation object
    @param    patcherview            The patcher view
    @param    marker                The marker whose name we need to edit
    @param    textfield_left_position    Horizontal pixel of the left boundary of the textfield 
 */
void start_editing_markername(t_notation_obj *r_ob, t_object *patcherview, t_marker *marker, double textfield_left_position);


/**    Start to edit a portion of lyrics.
    @ingroup                    textfield
    @param    r_ob                The notation object
    @param    patcherview            The patcher view
    @param    chord                The chord whose lyrics we need to edit
 */
void start_editing_lyrics(t_notation_obj *r_ob, t_object *patcherview, t_chord *chord);


/**    Start to edit a portion of dynamics.
    @ingroup                    textfield
    @param    r_ob                The notation object
    @param    patcherview            The patcher view
    @param    chord                The chord whose dynamics we need to edit
 */
void start_editing_dynamics(t_notation_obj *r_ob, t_object *patcherview, t_chord *chord);


/**    Stop editing, and hide the textfield (whatever the user was editing).
    @ingroup                    textfield
    @param    r_ob                The notation object
 */
void end_editing_textfield(t_notation_obj *r_ob);





// -----------------------------------
// MIDICHANNELS
// -----------------------------------


/**    Sets the midichannels from an llll
    @ingroup                midichannels
    @param    r_ob            The notation object
    @param    midichannels    The llll containing the midichannels. Use a long to set a midichannel for a voice, use by convention "nil" to skip changing a voice
 */
void set_midichannels_from_llll(t_notation_obj *r_ob, t_llll* midichannels);


/**    Change the midichannel of a specific voice
    @ingroup                midichannels
    @param    r_ob            The notation object
    @param    voice            The voice whose midichannel need to be changed
    @param    new_midichannel    The new midichannel
    @param    also_add_undo_tick    Also adds an undo tick before changing
 */
void change_single_midichannel(t_notation_obj *r_ob, t_voice *voice, long new_midichannel, char also_add_undo_tick);



// -----------------------------------
// BREAKPOINTS
// -----------------------------------

/**    Add a breakpoint to a note duration line.
    Each note already has by default two "special" breakpoints: one with <rel_x_pos> = 0 (corresponding to the note start) and the second with <rel_x_pos> = 1 
    (corresponding to the note tail). Those breakpoints are ALWAYS kept, and cannot be deleted. Any other breakpoint must lie strictly inside those two breakpoints. 
    @ingroup                breakpoints
    @param    r_ob            The notation object
    @param    note            The note to which the breakpoint has to be added
    @param    rel_x_pos        The breakpoint relative time position in the note duration (0 = note start, 1 = note tail)
    @oaram    delta_mc        The cents difference of the breakpoint pitch with respect to the note pitch 
    @oaram    slope            The slope of the curve segment ending with the breakpoint 
    @param    auto_mc_pos        If this is 1, the <delta_mc> argument is ignored, and the pitch of the newly added breakpoint 
                            is set exactly ON the existing duration line (by interpolating the already existing breakpoints).
    @param    velocity        The velocity of the newly added breakpoint (this only makes sense if the <breakpoints_have_velocity> flag is set
                            to 1 in the notation structure).
    @param    auto_velocity    If this is 1, the <velocity> argument is ignored, and the velocity is automatically set by linearly interpolating 
                            the already existing breakpoints' velocities. If <breakpoints_have_velocity> = 0, you are advised to set this to 1.
    @return                    The newly added breakpoint.
 */
t_bpt* add_breakpoint(t_notation_obj *r_ob, t_note *note, double rel_x_pos, double delta_mc, double slope, char auto_mc_pos, long velocity, char auto_velocity);


/**    Delete a given breakpoint.
    @ingroup            breakpoints
    @param    r_ob        The notation object
    @param    breakpoint    The breakpoint to delete
    @return                1 if something has changed, 0 otherwise.
    @remark                If the breakpoint was the first one (the note start), this won't be deleted.
                        If the breakpoint was the last one (the note tail), this won't be deleted, but its delta_mc and slope 
                        will be set to 0 (constant flat duration line).
 */
char delete_breakpoint(t_notation_obj *r_ob, t_bpt *breakpoint);


/**    Delete all the breakpoints in the notation object selection, in the sense of the delete_breakpoint() function (see its remark).
    @ingroup        breakpoints
    @param    r_ob    The notation object
    @return            1 if some breakpoint has been deleted, 0 otherwise
 */
char delete_breakpoints_in_selection(t_notation_obj *r_ob);


/**    Set the slope of all selected breakpoints in a notation object selection to 0 (linear).
    @ingroup        breakpoints
    @param    r_ob    The notation object
    @return            1 if something has changed, 0 otherwise
 */
char reset_selection_breakpoint_slope(t_notation_obj *r_ob);


/**    Delete all breakpoints of a note (as usual, keeping the first and the last one, but eventually setting their delta_mc and their slopes to 0). 
    @ingroup        breakpoints
    @param    r_ob    The notation object
    @param    note    The note whose breakpoints have to be deleted
    @return            1 if something has changed, 0 otherwise
 */
char note_delete_breakpoints(t_notation_obj *r_ob, t_note *note);


/**    Move a breakpoint horizontally and/or vertically
    @ingroup                breakpoints
    @param    r_ob            The notation object
    @param    breakpoint        The breakpoint to move
    @param    delta_rel_x_pos    Horizontal relative shift (1 being the whole note duration)
    @param    delta_mc_pos    Vertical shift (in midicents)
    @return                    1 if something has changed, 0 otherwise
 */
char move_breakpoint(t_notation_obj *r_ob, t_bpt *breakpoint, double delta_rel_x_pos, double delta_mc_pos);


/**    Snap the pitch of a breakpoint to the current microtonal grid.
    @ingroup        breakpoints
    @param    r_ob    The notation object
    @param    bpt        The breakpoint
    @remark            What is snapped is of course not the <delta_mc> field, but its absolute pitch position (so the note's mc plus the breakpoint delta_mc).
 */ 
void snap_pitch_to_grid_for_breakpoint(t_notation_obj *r_ob, t_bpt *bpt);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
// very private
void append_note_breakpoints_formatted_for_pwgl(t_notation_obj *r_ob, t_llll *this_note_llll, t_note *note);
#endif


/** Obtain the absolute onset (in milliseconds) of a given breakpoint. 
    @ingroup            breakpoints
    @param    r_ob        The notation object
    @param        bpt        The breakpoint
    @return                The absolute onset of the breakpoint in milliseconds.
*/
double breakpoint_get_absolute_onset(t_notation_obj *r_ob, t_bpt *bpt);

double note_get_spanning_width(t_notation_obj *r_ob, t_note *nt);


/** Obtain a part of duration line, as breakpoints llll.
    @ingroup            breakpoints
    @param    r_ob        The notation object
    @param    note        The note
    @param    start_rel_x_pos        The starting position of the partial section to be extrapolated (from 0 to 1, 0 being note start, 1 being note end).
    @param    end_rel_x_pos        The ending position of the partial section to be extrapolated (from 0 to 1, 0 being note start, 1 being note end).
    @param    new_start_midicents    Pointer which will be filled with the midicents value at the beginning of the extrapolated part, or NULL if not needed.
    @return                The partial breakpoints as llll
 */
t_llll* note_get_partial_breakpoint_values_as_llll(t_notation_obj *r_ob, t_note *note, double start_rel_x_pos, double end_rel_x_pos, double *new_start_midicents);





// -----------------------------------
// ARTICULATIONS
// -----------------------------------

/**    Convert a symbol represented an articulation (e.g. gensym("staccato")) to the articulation long ID as one of the #e_articulations (e.g. #k_ARTICULATION_STACCATO).
    @ingroup        articulations
    @param    atp    The articulations typo preferences structure
    @param    s        The articulation symbol
    @return            The articulation long ID (one of the #e_articulations)
 */ 
long articulation_symbol2id(const t_articulations_typo_preferences *atp, t_symbol *s);


/**    Convert an articulation long ID (one of the #e_articulations, e.g. #k_ARTICULATION_STACCATO) to the articulation symbol (e.g. gensym("staccato")).
    @ingroup        articulations
    @param    atp    The articulations typo preferences structure
    @param    ID        The articulation long ID (one of the #e_articulations)
    @return            The articulation symbol
 */ 
t_symbol* articulation_id2symbol(const t_articulations_typo_preferences *atp, long ID);


/**    Convert a symbol represented an articulation (e.g. gensym("staccato")) to the articulation long ID as one of the #e_articulations (e.g. #k_ARTICULATION_STACCATO).
    @ingroup        articulations
    @param    r_ob    The notation object
    @param    s        The articulation symbol
    @return            The articulation long ID (one of the #e_articulations)
 */
t_symbol* notationobj_articulation_id2symbol(t_notation_obj *r_ob, long ID);


/**    Convert an articulation long ID (one of the #e_articulations, e.g. #k_ARTICULATION_STACCATO) to the articulation symbol (e.g. gensym("staccato")).
    @ingroup        articulations
    @param    r_ob    The notation object
    @param    ID        The articulation long ID (one of the #e_articulations)
    @return            The articulation symbol
 */
long notationobj_articulation_symbol2id(t_notation_obj *r_ob, t_symbol *s);


/**    Convert an articulation ID (one of the #e_articulations, e.g. #k_ARTICULATION_STACCATO) into a text buffer, depending on the current
    #articulations_typo_preferences.
    @ingroup        articulations
    @param    atp     The articulations typo prefernces
    @param    ID        The articulation long ID (one of the #e_articulations)
    @return            The allocated buffer
 */
char *articulation_to_text_buf(t_articulations_typo_preferences *atp, long artic_ID);


/**    Free an articulation.
    @ingroup        articulations
    @param    art     The articulation
 */
void destroy_articulation(t_articulation *art);


/**    Allocate and initialize memory for an articulation
    @ingroup        articulations
    @param    r_ob    The notation object
    @param    articulation_ID        The articulation long ID (one of the #e_articulations)
    @param  owner   The notation item to which the articulation will be attached
    @param  parent  The slotitem containing the articulation, if any (new way), or NULL if none (old way)
    @param  original_name   The name with which the user has instantiated the articulation, if any
    @return            The allocated articulation
 */
t_articulation *build_articulation(t_notation_obj *r_ob, long articulation_ID, t_notation_item *owner, t_slotitem *parent, t_symbol *original_name);


/**    Delete a given articulation of a given notation item.
    @ingroup                        articulations
    @param    r_ob                    The notation object
    @param    owner                    The notation item owning the articulation (either a #k_CHORD or a #k_NOTE)
    @param    articulation_number        The 0-based index of the articulation (among all the owner's articulations). 
 */ 
void delete_articulation_from_notation_item(t_notation_obj *r_ob, t_notation_item *owner, long articulation_number);


/**    Delete all articulations of a given notation item.
    @ingroup                        articulations
    @param    r_ob                    The notation object
    @param    owner                    The notation item owning the articulation (either a #k_CHORD or a #k_NOTE)
 */ 
void delete_all_articulations_from_notation_item(t_notation_obj *r_ob, t_notation_item *owner);


/**    Delete all the articulations of the selected items
    @ingroup        articulations
    @param    r_ob    The notation object
    @return            1 if something has changed, 0 otherwise.
 */ 
char delete_articulations_in_selection(t_notation_obj *r_ob);


/**    Recompute the articulation painting parameters for all the articulations of a given chord.
    @ingroup        articulations
    @param    r_ob    The notation object
    @param    ch        The chord
 */ 
void reset_articulation_position_for_chord(t_notation_obj *r_ob, t_chord *ch);


/**    Reset all the positions of the articulations in the score.
    @ingroup        articulations
    @param    r_ob    The notation object
 */
void reset_all_articulations_positions(t_notation_obj *r_ob);


void erase_all_topmost_and_bottommost_y_infos(t_notation_obj *r_ob);
void erase_all_topmost_and_bottommost_y_noacc_infos(t_notation_obj *r_ob);


/**    Add a given articulation to a given notation item.
    @ingroup                    articulations
    @param    r_ob                The notation object
    @param    item                The notation item
    @param    articulation_ID        The ID of the articulation to add (one of the #e_articulations)
 */ 
void add_articulation_to_notation_item(t_notation_obj *r_ob, t_notation_item *item, long articulation_ID);


/**    Add a given articulation to all the selected items.
    @ingroup                    articulations
    @param    r_ob                The notation object
    @param    articulation_ID        The ID of the articulation to add (one of the #e_articulations)
    @return                        1 if something has changed, 0 otherwise
 */ 
char add_articulation_to_selected_elements(t_notation_obj *r_ob, long articulation_ID);


/**    Check if any articulation hotkey has been pressed, in which case it adds the articulation to the selected elements, 
    by calling add_articulation_to_selected_elements(). 
    @ingroup                    articulations
    @param    r_ob                The notation object
    @param    patcherview            The current view
    @param    keycode                The pressed keycode (as for the MaxAPI-standard _key() function) 
    @param    modifiers            The pressed modifiers (as for the MaxAPI-standard _key() function) 
    @param    textcharacter        The inserted text character (as for the MaxAPI-standard _key() function) 
    @return                        1 if an articulation hotkey was detected, 0 otherwise.
    @remark                        The standard usage is within the _key() method, with something like this (<x> could be a t_score or a t_roll): 
                                @code
                                if (handle_keys_for_articulations((t_notation_obj *) x, patcherview, keycode, modifiers, textcharacter)) {
                                    handle_change_if_there_are_free_undo_ticks((t_notation_obj *) x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, gensym("Add Articulation To Selection")); 
                                    return 1;
                                }
                                @endcode
 */ 
char handle_keys_for_articulations(t_notation_obj *r_ob, t_object *patcherview, long keycode, long modifiers, long textcharacter);



// TBD
void set_articulationinfo_from_llll(t_notation_obj *r_ob, t_articulations_typo_preferences *atp, t_llll* art_ll, char add_mode);
t_llll *get_articulationinfo_as_llll(t_notation_obj *r_ob);
void notation_obj_reset_articulationinfo(t_notation_obj *r_ob);



// -----------------------------------
// NOTEHEADS
// -----------------------------------

// TBD
t_symbol* notationobj_notehead_id2symbol(t_notation_obj *r_ob, long ID);
long notationobj_notehead_symbol2id(t_notation_obj *r_ob, t_symbol *s);
long notationobj_notehead_id2unicodechar(t_notation_obj *r_ob, long id, t_rational rdur);
long notehead_symbol2id(t_noteheads_typo_preferences *ntp, t_symbol *s);
t_symbol* notehead_id2symbol(t_noteheads_typo_preferences *ntp, long ID);
char *notehead_to_text_buf(t_notation_obj *r_ob, long artic_ID, t_rational rdur);

// TBD
void set_noteheadinfo_from_llll(t_notation_obj *r_ob, t_llll* nh_ll, char add_mode);
t_llll *get_noteheadinfo_as_llll(t_notation_obj *r_ob);
void notation_obj_reset_noteheadinfo(t_notation_obj *r_ob);



// -----------------------------------
// SELECTION HANDLING
// -----------------------------------

/**    Clear the preselection.
    @ingroup        selection
    @param    r_ob    The notation object
 */ 
void clear_preselection(t_notation_obj *r_ob);


/**    Clear the selection.
    @ingroup        selection
    @param    r_ob    The notation object
 */ 
void clear_selection(t_notation_obj *r_ob);

// private
void test_selection(t_notation_obj *r_ob);

/**    Obtain the common type of the selected items. For instance, if all selected items are #k_MEASURE, it returns #k_MEASURE;
    if all elements are either breakpoints or notetails, it returns #k_PITCH_BREAKPOINT_OR_DURATION_TAIL. If types do not
    coincide, it returns #k_MIXED.
    @ingroup        selection
    @param    r_ob    The notation object
    @return            The common type of the selected objects    
    @remark            This value is typically stored in the <selection_type> field of the notation object.
 */ 
long get_selected_items_common_type(t_notation_obj *r_ob);


/**    Remove from the selection all elements belonging to a given voice.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    voice_num    The 0-based index of the voice whose selected elements have to be unselected 
 */ 
void clear_voice_selection(t_notation_obj *r_ob, long voice_num);


/**    Append a notation item to the preselection.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        Pointer to the notation item to add.
    @return                The same item if everything was correct, NULL if something has gone wrong.
 */ 
t_notation_item* notation_item_add_to_preselection(t_notation_obj *r_ob, t_notation_item *item);


/**    Delete a notation item from the preselection linked list.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        Pointer to the notation item to delete.
    @remark                Should be extremely rarely used (we kind of never used it!), since
                        this task is usually replaced by the move_preselecteditems_to_selection() function.
 */ 
void notation_item_delete_from_preselection(t_notation_obj *r_ob, t_notation_item *item);


/**    Append a notation item to the selection.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        Pointer to the notation element to add.
    @return                The same item if everything was correct, NULL if something has gone wrong.
    @remark                Please be careful, since in many cases performing this direct operation might be deprecated.
                        More precisely: if the selection involves any preselection mechanism (click, drag...), or if you 
                        want to handle the different selection cases explained by the #e_selection_modes, consider using
                        notation_item_add_to_preselection() and move_preselecteditems_to_selection() instead!
                        A standard code looks like the following:
                        @code
                        notation_item_add_to_preselection(r_ob, (t_notation_item *)mychord);
                        move_preselecteditems_to_selection(r_ob, k_SELECTION_MODE_INVOLUTIVE, true);
                        @endcode
 */ 
t_notation_item* notation_item_add_to_selection(t_notation_obj *r_ob, t_notation_item *item);


/**    Delete a notation item from the selection linked list.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item_ptr    The pointer to the notation element to deleate from selection.
 */ 
void notation_item_delete_from_selection(t_notation_obj *r_ob, t_notation_item *item);


/**    Convert a symbol into the corresponding e_selection_modes
    @ingroup            selection
    @param    r_ob        The notation object
    @param    s           The symbol
 */
e_selection_modes symbol_to_mode(t_notation_obj *r_ob, t_symbol *s);


/**    Merge the preselection into the selection. This can be done in different ways, which handle the facts that a preselected item
    might already be selected. The different ways are set by the <mode> argument, which is one of the #e_selection_modes (see them for more info).
    After this call, the preselection will be completely empty.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    mode        One of the #e_selection_modes, handling the different ways to deal with the fact that some preselected elements might already be selected
    @param    use_groups    If this is 1, the function will check all preselected items, in order to perform the same type of selection not only on the preselected
                        item itsself, but to every item in their group.
    @param  add_all_tied_notes  If a note is selected, also add to the selection all the notes tied to/from it.
 */ 
void move_preselecteditems_to_selection(t_notation_obj *r_ob, e_selection_modes mode, char use_groups, char add_all_tied_notes);


/**    Sort all selection by onset. 
    This is usually only done before sending a dumpselection message
    @ingroup            selection
    @param    r_ob        The notation object
    @param  inverse_order   If non-zero, sorts from biggest to smallest
 */
void sort_selection(t_notation_obj *r_ob, char inverse_order);


/**    Tell if a given notation item is preselected (is in the preselection linked list).
    This is equivalent to directly query the item->preselected field. 
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item_ptr    The notation item
    @return                1 if the notation element is preselected, 0 otherwise.
    @see                notation_item_is_selected()
 */
long notation_item_is_preselected(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a given notation item is selected (is in the selection linked list).
    This is equivalent to directly query the item->selected field. 
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        The notation item
    @return                1 if the notation element is preselected, 0 otherwise.
    @see                notation_item_is_preselected()
 */
long notation_item_is_selected(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a notation item is globally selected, either because it is selected itsself (e.g. a note which is selected)
    or because some element that contains it is selected (e.g. the measure containing the note's chord is selected).
    @ingroup selection
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the notation item is globally selected, 0 otherwise.
*/
char notation_item_is_globally_selected(t_notation_obj *r_ob, t_notation_item *item);

// TBD
char chord_or_any_of_its_notes_are_selected(t_notation_obj *r_ob, t_chord *ch);


/**    Remove from the selection all notation elements of a given type.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    type        The type of the elements to be removed
 */
void delete_item_type_from_selection(t_notation_obj *r_ob, long type);


// TBD
long are_all_selecteditems_tied_to_chord(t_notation_obj *r_ob, t_chord *ch);
long are_all_selecteditems_tied_to_note(t_notation_obj *r_ob, t_note *nt);


/**    Dump the selection, as a gathered-syntax llll containing all selected elements info.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    outlet        The 0-based outlet number for dumping.
    @param    command_number    The command number of the command to be sent, or -1 if none (the default "note" "chord" routers will then be output).
    @param    delete_item_method    Pointer to the roll_sel_delete_item() or score_sel_delete_item() methods, or NULL if none
    @param  forced_routers   If non-NULL, a router (possibly different from "note", "chord" and "rest")
                                that will be forced to be put in case the command_number is -1
                                If more than one router is defined, then the first one will be for notes, the second one for chords, and the third one for rests
    @return                0 if nothing changed, 1 otherwise.
 */
char standard_dump_selection(t_notation_obj *r_ob, long outlet, long command_number, delete_item_fn delete_item_method, t_llll *forced_routers = NULL);


/**    Deletes all the breakpoints which are selected.
    @ingroup            selection
    @ingroup            breakpoints
    @ingroup            interface
    @param    r_ob        The notation object
    @return                1 if something has changed, 0 otherwise.
 */
char delete_breakpoints_in_selection(t_notation_obj *r_ob);


/**    Reset the slope of all selected breakpoints to 0.
    @ingroup            selection
    @ingroup            breakpoints
    @ingroup            interface
    @param    r_ob        The notation object
    @return                1 if something has changed, 0 otherwise.
 */
char reset_selection_breakpoint_slope(t_notation_obj *r_ob);


/**    Reset the slope of all selected note tails to 0, and their <delta_mc> field to 0 as well.
    @ingroup            selection
    @ingroup            breakpoints
    @ingroup            interface
    @param    r_ob        The notation object
    @return                1 if something has changed, 0 otherwise.
 */
char reset_selection_tail_gliss(t_notation_obj *x);


/**    Reset the <draggingvelocity> field to the <velocity> value, for all selected elements admitting them.
    @ingroup            interface
    @param    r_ob        The notation object
 */
void set_selection_dragging_velocity(t_notation_obj *r_ob);


/**    Set the <j_dragging_direction> field of a notation object to 1 or -1, depending if the point <pt> has moved
    more horizontally than vertically (1) or more vertically than horizontally (-1) with respect to the mousedown point.  
    This is usually performed at the first mousedrag() call after a mousedown(). In fact, the 
    mousedown will set the <j_mousedown_point> fields, and the <pt> argument will be the current
    mousedrag point.
    @ingroup            interface
    @param    r_ob        The notation object
    @param    pt            The current mouse position (after a mousedown)
 */
void decide_dragging_direction(t_notation_obj *r_ob, t_pt pt);


/**    Obtain the first chord appearing in the selection linked list
    @ingroup            selection
    @param    r_ob        The notation object
    @return                The first chord in the selection linked list
    @remark                Beware: this might not coincide with the first chord in temporal order!
 */
t_chord *chord_get_first_selected(t_notation_obj *r_ob);


/**    Obtain the first note appearing in the selection linked list
    @ingroup            selection
    @param    r_ob        The notation object
    @return                The first note in the selection linked list
    @remark                Beware: this might not coincide with the first chord in temporal order!
 */
t_note *note_get_first_selected(t_notation_obj *r_ob);


// TBD
t_dynamics *dynamics_get_first_selected(t_notation_obj *r_ob);
t_lyrics *lyrics_get_first_selected(t_notation_obj *r_ob);


/**    Tell if only note tails are selected. 
    @ingroup            selection
    @return                1 if only note-tails are selected, 0 otherwise
 */
char only_tails_are_selected(t_notation_obj *r_ob);


/**    A #fun_fn function to substitute symbols (the incoming hatom) such as "onset" or "cents" with a "$x" variable for lexpr.
    This is used to parse user-inserted conditional selections such as "sel if onset > 100":
    the expression is reduced to "$x1 > 100" and then plugged into a lexpr to find the corresponding matches
    among the existing notation data.
    @ingroup            selection
    @remark                This function is obsolete, use notation_obj_lexpr_new() instead
    @remark                The substitutions are as follows:
                        "onset" > $x1 
                        "cents" > $x2 
                        "duration" > $x3 
                        "velocity" > $x4
                        "symduration" > $x5 
                        "symonset" > $x6
    @remark                Must be only used inside llll_funall, such as
                        @code
                        t_llll *selectllll = llllobj_parse_llll((t_object *) x, LLLL_OBJ_UI, NULL, argc, argv, LLLL_PARSE_RETAIN);
                        if (...) { // << checking that the first two symbols are "sel if"
                            llll_destroyelem(selectllll->l_head);
                            llll_destroyelem(selectllll->l_head);
                            llll_funall(selectllll, (fun_fn) substitute_symbols_for_lexpr_fn, NULL, 1, -1, 0);
                            new_ac = llll_deparse(selectllll, &new_av, 0, LLLL_D_QUOTE);
                            x->r_ob.n_lexpr = lexpr_new(new_ac, new_av, 0, NULL);
                            ...
                        }
                        @endcode
 */
long substitute_symbols_for_lexpr_fn(void *data, t_hatom *a, const t_llll *address);


/**    Create a new lexpr object with already embedded substitutions for symbols used by notation objects.
    @ingroup            selection
    @remark                The substitutions are as follows:
    "onset" > $x1 
    "cents" > $x2 
    "duration" > $x3 
    "velocity" > $x4
    "symduration" > $x5 
    "symonset" > $x6
    "tail" > $x7
    "symtail" > $x8
    "voice" > $x9
    "measure" > $x10
    "tie" > $x11
 */
t_lexpr *notation_obj_lexpr_new(short ac, t_atom *av);



/** Add a notation item to the selection, after having cleared it (and also cleared the preselection).
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        The notation item
 */
void select_single_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/** Add a notation item to the selection, after having cleared it (and also cleared the preselection),
    and then force the item to be inside the screen by possibly changing the horizontalscrollbar position.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    item        The notation item
 */
void select_single_notation_item_and_force_inscreen(t_notation_obj *r_ob, t_notation_item *item);


/** Add all the markers lying inside a millisecond range to the preselection.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    ms1            The starting boundary of the range (in milliseconds)
    @param    ms2            The ending boundary of the range (in milliseconds)
 */
void preselect_markers_in_region(t_notation_obj *r_ob, double ms1, double ms2);



/** Add to the current preselection all the notes (or possibly note tails, or breakpoitns) lying inside a millisecond range times a pitch range times a voice range.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    ms_min        The starting boundary of the time range (in milliseconds)
    @param    ms_max        The ending boundary of the time range (in milliseconds)
    @param    mc_min        The starting boundary of the pitch range (in cents)
    @param    mc_max        The ending boundary of the pitch range (in cents)
    @param    voice_min    The starting boundary of the voice range (in 0-based voice numbers)
    @param    voice_max    The ending boundary of the voice range (in 0-based voice numbers)
    @param  also_preselect_tails    Allow the preselection of note tails
    @param  also_preselect_breakpoints    Allow the preselection of inner breakpoints
 */
void preselect_notes_in_region(t_notation_obj *r_ob, double ms_min, double ms_max, double mc_min, double mc_max, long voice_min, long voice_max,
                               char also_preselect_tails, char also_preselect_breakpoints);


/** Add all the notes of a chord to the preselection.
    @ingroup            selection
    @param    r_ob        The notation object
    @param    chord        The chord
 */
void add_all_chord_notes_to_preselection(t_notation_obj *r_ob, t_chord *chord);

    

// -----------------------------------
// NOTATION DATA SEND
// -----------------------------------


/**    Output the gathered syntax information about a given note from a given outlet of a notation object. 
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    note        The note
    @param    outlet        The outlet number
    @param    mode        The reason why you need to send the information: this is one of the #e_data_considering_types and 
                        will affect the output syntax accordingly.
    @param    command_number    The 0-based number of the command, if the sending is associated to a specific command; 
                            -1 otherwise (this should be the default and standard case: -1).
 */
void send_note_as_llll(t_notation_obj *r_ob, t_note *note, long outlet, e_data_considering_types mode, long command_number);


/**    Output the gathered syntax information about a given chord from a given outlet of a notation object. 
    @ingroup            notation_data_send
    @remark                If the notation object playmode is note-wise, lllls corresponding to each note will be output in sequence, one after the other.
                        Thus, this function in general does not output a SINGLE llll. 
    @param    r_ob        The notation object
    @param    note        The chord
    @param    outlet        The outlet number
    @param    mode        The reason why you need to send the information: this is one of the #e_data_considering_types and 
                        will affect the output syntax accordingly.
    @param    command_number    The 0-based number of the command, if the sending is associated to a specific command; 
                            -1 otherwise (this should be the default and standard case: -1).
    @param  forced_routers   If non-NULL, a router (possibly different from "note", "chord" and "rest")
                            that will be forced to be put in case the command_number is -1
                        If more than one router is defined, then the first one will be for notes, the second one for chords, and the third one for rests
 */
void send_chord_as_llll(t_notation_obj *r_ob, t_chord *chord, long outlet, e_data_considering_types mode, long command_number, t_llll *forced_routers = NULL);


/**    Auxiliary function used by the send_ functions, returning an llll containing a list of lllls to be output (indeed, for instance if the playmode is
    notewise, actually what will be output is each note data one by one: this function will return an llll containing at the base level sublllls associated
    to the data for each note â€“ if the playmode is chordwise, the llll will just contain a single subllll). 
    Also this functions returns the references to the notation items being played and a flag telling if the obtained llll is splitted note-wisely.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    note        The chord
    @param    mode        The reason why you need to send the information: this is one of the #e_data_considering_types and 
                        will affect the output syntax accordingly.
    @param    command_number    The 0-based number of the command, if the sending is associated to a specific command; 
                            -1 otherwise (this should be the default and standard case: -1).
    @param  forced_routers   If non-NULL, a router (possibly different from "note", "chord" and "rest") 
                                that will be forced to be put in case the command_number is -1
                                If more than one router is defined, then the first one will be for notes, the second one for chords, and the third one for rests
    @param    references    An llll which will be filled with pointers to notation items associated to each obtained sub-llll (e.g. if playmode is notewise, each note of the chord) 
                        You will have to free this llll later on.
    @param    is_notewise    Pointer that will be filled with 1 if the data retrieving is for chord being played notewisely, will be filled with 0 otherwise.
    @return    An llll containing at the root level a list of lllls to be supposely later output one after the other.
 */
t_llll *chord_get_as_llll_for_sending(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, long command_number, t_llll *forced_routers, t_llll **references, char *is_notewise);


/**    Obtain tempo as llll to be sent through the playout.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    note        The tempo
    @param    mode        The reason why you need to send the information: this is one of the #e_data_considering_types and
 will affect the output syntax accordingly.
    @return    An llll containing the tempo llll to be sent out.
 */
t_llll *get_tempo_as_llll_for_sending(t_notation_obj *r_ob, t_tempo *tempo, e_data_considering_types mode);


// Private
t_llll *get_single_tempo_values_as_llll(t_notation_obj *r_ob, t_tempo *tempo, e_data_considering_types mode);
t_llll *measure_get_as_llll_for_sending(t_notation_obj *r_ob, t_measure *measure, e_data_considering_types mode);


/**    Actually send some sublists one after each other through the playout (and also properly set the references for possible lambda loops).
    @ingroup            notation_data_send
    @remark                This function is usually used right after chord_get_as_llll_for_sending().
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    to_send        List of sublists to be sent
    @param    to_send_references    Plain list of references as H_OBJ (one for each sublist)
    @param    is_notewise    If this is non-zero, it means that the content sent through the playout is notewise.
 */
void send_sublists_through_playout_and_free(t_notation_obj *r_ob, long outlet, t_llll *to_send, t_llll *to_send_references, long is_notewise);


/**    Function internally scheduled by send_sublists_through_playout_and_free(). 
    This function need to be called inside a schedule_delay() function.
    @see                send_sublists_through_playout_and_free()
    @ingroup            notation_data_send
    @remark                This function is usually used right after chord_get_as_llll_for_sending().
    @param    r_ob        The notation object
    @param    s            Dummy symbol (ignored, leave NULL) 
    @param    ac            Number of atoms (should be 3)
    @param    av            Atoms: needed atoms are: a A_OBJ containing the pointer to the sublists llll, a A_OBJ containing the pointer
                        to the references llll, a A_LONG containing the <is_notewise> flag (see send_sublists_through_playout_and_free())
 */
void do_send_sublists_through_playout_and_free(t_notation_obj *r_ob, t_symbol *s, long ac, t_atom *av);


/**    Setup the lambda information for a given notation item, and send the corresponding element through a given outlet (supposedly the playout).
    @ingroup            notation_data_send
    @remark                This function is called internally in most of the previous functions.
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    llll        llll to be sent
    @param    related_item    Pointer to the notation item which has to be set as current lambda element.
 */
void setup_lambda_and_send_llll(t_notation_obj *r_ob, long outlet, t_llll *llll, t_notation_item *related_item);


/**    Setup the lambda information for some notation items, and send the corresponding sub-lllls through a given outlet (supposedly the playout).
    @ingroup            notation_data_send
    @remark                This function is called internally in most of the previous functions, especially inside do_send_sublists_through_playout_and_free().
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    to_send        List of sublists to be sent
    @param    to_send_references    Plain list of references as H_OBJ (one for each sublist)
    @param    is_notewise    If this is non-zero, it means that the content sent through the playout is notewise.
    @see                do_send_sublists_through_playout_and_free()
 */
void setup_sublists_lambda_and_send_llll(t_notation_obj *r_ob, long outlet, t_llll *to_send, t_llll *to_send_references, long is_notewise);


/**    If the "playoutfullpath" attribute is set to 0 (default), append the voice number of a given notation item to the incoming #playout_llll.
    If it is non-zero, append the full path of the notation item to the incoming #playout_llll.
    Depending on the #mode, if, in bach.score, the tied notes are played once and the item starts a tied sequence, the path of all the elements 
    in the tied sequence can be returned. 
    @ingroup                notation_data_send
    @param    r_ob            The notation object
    @param    playout_llll    The llll to which the data must be appended
    @param    item            The notation item
    @param    mode            One of the e_data_considering_types
 */
void append_voice_or_full_path_to_playout_syntax(t_notation_obj *r_ob, t_llll *playout_llll, t_notation_item *item, e_data_considering_types mode);


/**    Send the playhead position information through a given outlet. This will be in the form "cursor <ms>".
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
 */
void send_playhead_position(t_notation_obj *r_ob, long outlet);


/**    Send the moved playhead position information through a given outlet. This will be in the form "movedcursor <ms>".
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
 */
void send_moved_playhead_position(t_notation_obj *r_ob, long outlet);


/**    Send the loop region information through a given outlet. This will be in the form "loop <start_ms> <end_ms>" for bach.roll and
    "loop <start_ms> <end_ms> (<start_timepoint> <end_timepoint>)" where the timepoints are in the usual score timepoint syntax: 
    either (<measure>) or (<measure> <point_in_measure>) or (<measure> <point_in_measure> <voice>). 
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
 */
void send_loop_region(t_notation_obj *r_ob, long outlet);


/**    Send the loop region on/off information through a given outlet. This will be in the form "loop on" if and only if the loop is 
    visible and active ("showloop" and "useloop" attributes both being 1); otherwise a "loop off" message will be sent.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
 */
void send_loop_region_on_off(t_notation_obj *r_ob, long outlet);


/** Send a given marker information (or all markers information) through a given outlet.  
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker whose information has to be sent, or NULL if you need the information about all markers
    @param    namefirst    If this is 1, the usual (<position_ms> <name>) coupling is reversed for each marker, and becomes (<name> <position_ms>).
                        If this is 0, the syntax is the usual (<position_ms> <name>).
    @param    outlet        The outlet through which the llll containing the information will be sent (usually the play outlet)
    @param   command_number The command number, if any (or leave -1 otherwise)
    @param  forced_router   If non-NULL, a router that will be forced to be put instead of the standard "marker" one
    @see                get_single_marker_as_llll()
 */
void send_marker_as_llll(t_notation_obj *r_ob, t_marker *marker, char namefirst, long outlet, long command_number = -1, t_llll *forced_router = NULL);


/**    Send a "done" message through the playout. 
    @remark        This message is immediately sent except when the flag t_notation_obj::need_send_rebuild_done_after_paint is set,
                in which case the sending is inside a qelem.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
 */
void send_rebuild_done(t_notation_obj *r_ob);


/**    Function called inside the qelem for send_rebuild_done().
    @ingroup        notation_data_send
    @param    x        The notation object
 */
void do_send_rebuild_done(t_object *x);


/**    Send the vertical zoom information through the playout, in the form "vzoom <value>".
    The output value is a percentage (100% being normal zoom).
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    label        A possible query label to be appended after "vzoom" if needed (leave NULL if not wanted). 
 */
void send_vzoom(t_notation_obj *r_ob, long outlet, t_symbol *label);


/**    Send the horizontal zoom information through the playout, in the form "zoom <value>".
    The output value is a percentage (100% being normal zoom).
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    label        A possible query label to be appended after "zoom" if needed (leave NULL if not wanted). 
 */
void send_zoom(t_notation_obj *r_ob, long outlet, t_symbol *label);


/**    Send the vertical pixel position information of each voice, containing a sublist (<middleC_y_pos> <staff_bottom_y> <staff_top_y>) for each voice.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The outlet number
    @param    label        A possible query label to be appended after "vzoom" if needed (leave NULL if not wanted). 
 */
void send_voicepixelpos(t_notation_obj *r_ob, char obj_type, long num_voices, void *firstvoice, long outlet, t_symbol *label);



#ifndef DOXYGEN_SHOULD_SKIP_THIS
// these are unused undocumented functions. Essentially no one should use them.
void send_llll_through_playout(t_notation_obj *r_ob, t_llll *llll, long outlet, void *related_object, long related_type);
void send_llll_through_playout_and_free(t_notation_obj *r_ob, t_llll *llll, long outlet, void *related_object, long related_type);

void do_send_llll_through_playout(t_notation_obj *r_obj, t_symbol *s, long ac, t_atom *av);
void do_send_llll_through_playout_and_free(t_notation_obj *r_obj, t_symbol *s, long ac, t_atom *av);
#endif






// -----------------------------------
// NOTATION DATA GET/SET
// -----------------------------------


/**    Obtain an llll containing the timepoint data in the form <voice_number> <measure_number> <rational_onset_in_measure>,
    where the first two items are 1-based (if the #old_timepoint_syntax_bw_compatibility field of the notation item is set, the voice
    number is the last element, not the first one).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    tp            The timepoint
    @return                The timepoint information in llll form 
 */
t_llll *get_timepoint_as_llll(t_notation_obj *r_ob, t_timepoint tp);


/**    Obtain a llll containing the measure symbolic durations
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    measure        The measure
    @return                A plain llll of rationals, containing the measure symbolic durations 
 */
t_llll *measure_get_rhythm_as_llll(t_notation_obj *r_ob, t_measure *measure);


/**    Obtain a llll containing the sequence of chords in a measure (as #H_OBJ), each wrapped in a llll
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    measure        The measure
    @return                A llll of of lllls (one for each chord), each containing an #H_OBJ (the pointer to the chord)
 */
t_llll *measure_get_chords_wrapped_as_llll(t_notation_obj *r_ob, t_measure *measure);


/**    Set a specific graphic (= enharmonicity) representation to a given note.
    @ingroup                    notation_data
    @param    r_ob                The notation object
    @param    note                The note
    @param    screen_midicents    The displayed diatonic midicents
    @param    accidental            The displayed accidental (-1/2 = flat, +1/2 = sharp, and so on)
    @remark                        For instance, if you want to display a note as middle C double flat, you should put screen_midicents = 6000 and accidental = -1.
    @remark                        BEWARE: the graphic reperesentation you specify should hopefully match the note real midicents!
    @see                        set_graphic_values_to_note_from_llll()
 */
void set_graphic_values_to_note(t_notation_obj *r_ob, t_note *note, long screen_midicents, t_rational accidental);


/**    Set a specific graphic (= enharmonicity) representation to a given note, where the source is an llll of the form [screen_midicents accidentals].
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    note    The note
    @param    llll    An llll of the form [screen_midicents accidental] specifying the displayed diatonic midicents and the displayed accidantal
                    (-1/2 = flat, +1/2 = sharp, and so on)
    @see            set_graphic_values_to_note()
 */
void set_graphic_values_to_note_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* graphic);


/**    Set the time signature and the tempi for a given measure, starting from two different lllls (one for the time signature, and one for the tempo).
    Alo assign the measure barline type and possibly the measure parameters (such as fixed width, hide measure number etc.)
    @ingroup                notation_data
    @param    r_ob            The notation object
    @param    measure            The measure
    @param    time_signature    llll containing the time signature information for the measure, in the form (<num> <den>) or ((<num1> <num2> ...) <den>)
    @param    tempo            llll containing the tempi information for the measure, in the usual tempo syntax: either as a single TEMPO or as a tempi list
                            (TEMPO TEMPO TEMPO... ) where each TEMPO is either (<quarter_tempo>) or (<tempo_figure> <tempo>) or (<tempo_figure> <tempo> <rational_symbolic_position_in_measure>) or (<tempo_figure> <tempo> <rational_symbolic_position_in_measure> <interpolation_type>)
    @param    measure_barline    One of the #e_barline_modifier determining the measure ending barline type
    @param    parameters        A list of measure specifications in the form needed by the function set_measure_parameters()
    @param    when_no_ts_given_use_previous_or_nearest_measure_ts
                            If this is 1, when no time signature is specified (e.g. null, or nil, or wrong time signature is specified)
                            the algorithm will set as time signature the time signature of the previous measure (if any), or (if none) of
                            the following measure (if any).
    @see                    set_measure_parameters()
    @see                    get_timesignature_from_llll()
 */
void measure_set_ts_and_tempo_from_llll(t_notation_obj *r_ob, t_measure *measure, t_llll *time_signature, 
                                        t_llll *tempo, char measure_barline, t_llll *parameters, char when_no_ts_given_use_previous_or_nearest_measure_ts);


/**    Assign the further specification parameters to a given measures. These parameters involves width, 
    @ingroup                notation_data
    @param    r_ob            The notation object
    @param    measure            The measure
    @param    parameters        A list of measure specifications in the form [(<label> value) (<label> value)...], where label can be one of the followings:
                            _llllobj_sym_widthfactor, _llllobj_sym_width, _llllobj_sym_shownumber, _llllobj_sym_barline, setting respectively 
                            a width factor, a fixed width, a number to show instead of the default measure number (use _llllobj_sym_off as value to turn numbering off for the measure,
                            and use _llllobj_sym_default to revert to default numbering), and a barline type (one of the #e_barline_modifier).
 */
void set_measure_parameters(t_notation_obj *r_ob, t_measure *measure, t_llll *parameters);


/**    Convert a notation item flag into a symbol.
    @ingroup        notation_data
    @param  flag    The notation item flag as number (combination of #e_notation_item_flags)
    @return            The notation item flag as symbol
 */
t_symbol *notationitemflag2symbol(long flag);


/**    Convert a symbol into a numeric combination determining the notation item flag.
    @ingroup        notation_data
    @param   sym    The notation item flag as symbol
    @return         The notation item flag as number (combination of #e_notation_item_flags)
 */
long symbol2notationitemflag(t_symbol *sym);


/**    Set the flag field to a given notation item, starting from a llllelem which is supposed to be of type #H_LONG. 
    Flag accounts for mute/lock/solo/rhythmic tree lock.
    If the llllelem is not #H_LONG default flags are assigned (0).
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    elem    The notation element containing the flag information
    @param    item    The notation item
    @param    destroy_flag_llllelem    If this is 1, #elem is also destroyed
    @return            1 if flags were correctly assigned, 0 if default flags were assigned.
 */
char notation_item_set_flags_from_llllelem(t_notation_obj *r_ob, t_llllelem *elem, t_notation_item *item, char destroy_flag_llllelem);


/**    Get the flag of a given notation item. Flag accounts for mute/lock/solo/rhythmic tree lock.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            A combination of the #e_notation_item_flags representing the element flag.
    @see            get_element_global_flag()
 */
long get_element_flag(t_notation_obj *r_ob, t_notation_item *item);


/**    Get the flag of a given notation item as a symbol. Flag accounts for mute/lock/solo/rhythmic tree lock.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            A symbol representing the element flag.
    @see            get_element_flag()
 */
t_symbol *get_element_flag_as_symbol(t_notation_obj *r_ob, t_notation_item *item);


/**    Get the flag of a given notation item also depending on its "ancestors". 
    For instance, if a note is not muted but its chord is muted, this function will report the mute, 
    differently from get_element_flag().
    Flag accounts for mute/lock/solo/rhythmic tree lock.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            A combination of the #e_notation_item_flags representing the element flag.
    @see            get_element_flag()
 */
long get_element_global_flag(t_notation_obj *r_ob, t_notation_item *item);


/**    Get the flag of a given notation item also depending on its "ancestors", in symbolic form.
    For instance, if a note is not muted but its chord is muted, this function will report the mute,
    differently from get_element_flag_as_symbol().
    Flag accounts for mute/lock/solo/rhythmic tree lock.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            A symbol representing the element flag.
    @see            get_element_flag_as_symbol()
 */
t_symbol *get_element_global_flag_as_symbol(t_notation_obj *r_ob, t_notation_item *item);


/**    Append the notation item flags in llll form to a given <ll>.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param  ll      The llll
    @param  item    The notation item
 */
void llll_append_notationitem_flag(t_notation_obj *r_ob, t_llll *ll, t_notation_item *item);


/**    Append the notation item global flags (also accounting for the flags of its ancestors) in llll form to a given <ll>.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param  ll      The llll
    @param  item    The notation item
 */
void llll_append_notationitem_global_flag(t_notation_obj *r_ob, t_llll *ll, t_notation_item *item);


/**    Set the breakpoints to a note. 
    @ingroup            notation_data
    @ingroup            breakpoints
    @param    r_ob        The notation object
    @param    note        The note
    @param    breakpoints    An llll containing a (relative_x_position delta_mc slope) llll for each breakpoint to add.
 */
void note_set_breakpoints_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* breakpoints);


/**    Assign one or more articulations to a notation item. Deletes the already existing articulations.
    @ingroup                notation_data
    @ingroup                articulations
    @param    r_ob            The notation object
    @param    item            The notation item (either a #k_CHORD or a #k_NOTE).
    @param    articulations    An llll containing one or more elements, each being either a long (the articulation ID, one of the #e_articulations),
                            or a symbol specifying the articulation (e.g. "staccato"), which will be parsed to the long via the articulation_symbol2id() function
    @see                    set_articulations_to_element_from_hatom()
 */
void set_articulations_to_element_from_llll(t_notation_obj *r_ob, t_notation_item *item, t_llll* articulations);


/**    Assign one or more articulations to a notation item, starting from a hatom (either containing a single symbol/long, or containing a whole llll specifying articulations).
    Deletes the already existing articulations.
    @ingroup        notation_data
    @param    r_ob    The notation object
    @param    item    The notation item (either a #k_CHORD or a #k_NOTE).
    @param    hatom    A #t_hatom containing either a long (the articulation ID, one of the #e_articulations) or a symbol specifying the articulation (e.g. "staccato"), 
                    or a llll containing a sequence of longs/symbols (to specify multiple articulations)
    @see                    set_articulations_to_element_from_llll()
 */
void set_articulations_to_element_from_hatom(t_notation_obj *r_ob, t_notation_item *item, t_hatom* hatom);


/**    Assign parameters (and breakpoints, graphics, slots) to a note of a [bach.roll], starting from a llll.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    notevalues    llll containing the note information in the usual bach gathered syntax form
 */
void set_rollnote_values_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* notevalues);


/**    Assign parameters (and breakpoints, graphics, slots) to a chord of a [bach.roll], starting from a llll.
    @ingroup                        notation_data
    @param    r_ob                    The notation object
    @param    note                    The chord
    @param    chordvalues                llll containing the chord information in the usual bach gathered syntax form
    @param    onset_delta                A global shift in milliseconds to be applied to each one of the chords in chordvalues (handy when dealing with pasting to a given position on the roll - leave this to 0 for most usages).
    @param    always_from_scratch        If this is non-0, the chord is first emptied, and then rebuilt. Otherwise, the chord content is kept (so if you give as #chordvalues less notes than the previous number of notes, some older notes remain).
    @param    also_recompute_total_length    If this is non-0, the total length of the notation object is recalculated.
    @param  check_notes_order       Also check notes order
 */
void set_rollchord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll* chordvalues, double onset_delta, char always_from_scratch, char also_recompute_total_length, char check_notes_order);


/**    Assign parameters (and breakpoints, graphics, slots) to a note of a [bach.score], starting from a llll.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    notevalues    llll containing the note information in the usual bach gathered syntax form
    @param    always_from_scratch        If this is 1, the note is first emptied, and then rebuilt. Otherwise, the note content is kept (e.g. articulations are kept as they are).
 */
void set_scorenote_values_from_llll(t_notation_obj *r_ob, t_note *note, t_llll* notevalues, char always_from_scratch);


/**    Assign parameters (and breakpoints, graphics, slots) to a chord of a [bach.core], starting from a llll.
    @ingroup                        notation_data
    @param    r_ob                    The notation object
    @param    note                    The chord
    @param    chordvalues                llll containing the chord information in the usual bach gathered syntax form
    @param    always_from_scratch        If this is 1, the chord is first emptied, and then rebuilt. Otherwise, the chord content is kept (so if you give as #chordvalues less notes than the previous number of notes, some older notes remain).
    @param  check_notes_order       Also check notes order
 */
void set_scorechord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll* chordvalues, char always_from_scratch, char check_notes_order);


/**    Returns the 1-based position of the chord in the parent: either rollvoice or measure.
    @remark                We stress again that this is 1-based!
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The 1-based position of the chord inside the measure or rollvoice. 0 if chord could not be found in its voice or measure (which should never happen!).
 */
long chord_get_position(t_notation_obj *r_ob, t_chord *chord);


/**    Returns the 1-based position of the note in the parent chord.
    @remark                We stress again that this is 1-based!
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The note
    @return                The 1-based position of the note inside the parent chord. 0 if note could not be found in its parent (which should never happen!).
 */
long note_get_position(t_notation_obj *r_ob, t_note *nt);


/**    Returns the 1-based position of the tempo inside the linked list of tempi of the measure owning the tempo.
    @remark                We stress again that this is 1-based!
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    tp            The tempo
    @return                The 1-based position of the tempo inside the owning measure. 0 if tempo could not be found in its owner (which should never happen!).
 */
long get_tempo_position(t_notation_obj *r_ob, t_tempo *tp);


/**    Returns the 1-based position of the marker inside the linked list of markers of the notation object.
    @remark                We stress again that this is 1-based!
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    tp            The marker
    @return                The 1-based position of the marker in the notation object's marker; 0 if the marker is not found.
 */
long get_marker_position(t_notation_obj *r_ob, t_marker *mk);


/**    Returns the 1-based index of the pitch breakpoint inside the linked list of breakpoints.
    @remark                Beware: the NOTEHEAD counts as a breakpoint (as well as the note tail!), so the first non-trivial breakpoint is the *second* breakpoint.
                        Also, we stress again that this is 1-based!
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    bpt            The pitch breakpoint
    @return                The 1-based position of the pitch breakpoint in the note's sequence of breakpoints; 0 if the the pitch breakpoint is not found (which should never happen, if the breakpoint is correctly assigned to a note).
 */
long get_breakpoint_position(t_notation_obj *r_ob, t_bpt *bpt);


/**    Returns the path of a chord inside the notation object. This will be in the form (<voice_number> <measure_number> <chord_index_in_measure>) if the chord
    is inside a bach.score, or (<voice_number> <chord_index>) if it is inside a bach.roll. In both cases, ALL these numbers are 1-based.
    @remark                We stress again that all the number are 1-based!!! (differently from the usual inner representation which has voice_number and measure_number as 0-based).
                        This is due to the fact that this function is used by get_groups_for_dump_as_llll() which returns data visible for the user (and as a general rule
                        within the bach environment, all things visible for the user have to be 1-based).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The path in the notation object to get to the chord (in the form explained above).
 */
t_llll *chord_get_path_in_notationobj(t_notation_obj *r_ob, t_chord *chord);


/**    Returns the path of a note inside the notation object. This will be in the form (<voice_number> <measure_number> <chord_index_in_measure> <note_index_in_chord>) if the note
    is inside a bach.score, or (<voice_number> <chord_index> <note_index_in_chord>) if it is inside a bach.roll. In both cases, ALL these numbers are 1-based.
    @remark                We stress again that all the number are 1-based!!! (differently from the usual inner representation which has voice_number and measure_number as 0-based).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return                The path in the notation object to get to the note (in the form explained above).
 */
t_llll *note_get_path_in_notationobj(t_notation_obj *r_ob, t_note *note);


/**    Returns the path of a tempo inside the notation object. This will be in the form (<voice_number> <measure_number> <tempo_index_in_measure>).
    ALL these numbers are 1-based.
    @remark                We stress again that all the number are 1-based!!! (differently from the usual inner representation which has voice_number and measure_number as 0-based).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    tempo        The tempo
    @return                The path in the notation object to get to the tempo (in the form explained above).
 */
t_llll *get_tempo_path_in_notationobj(t_notation_obj *r_ob, t_tempo *tempo);


/**    Returns the path of a measure inside the notation object. This will be in the form (<voice_number> <measure_number>).
 ALL these numbers are 1-based.
    @remark                We stress again that all the number are 1-based!!! (differently from the usual inner representation which has voice_number and measure_number as 0-based).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    meas        The measure
    @return                The path in the notation object to get to the measure (in the form explained above).
 */
t_llll *measure_get_path_in_notationobj(t_notation_obj *r_ob, t_measure *meas);


/**    Returns the list of paths of all the notes belonging to a tied sequence of notes (given one note of the sequence).
    For each one of the tied notes, a sublist is returned, having the form of the llll returned by note_get_path_in_notationobj().
    If the given note is not tied to anything (nor has an incoming tie), then the result will be the llll given by note_get_path_in_notationobj()
    only with an additional external level of parentheses.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        A note
    @return                A list with the path of each note inside the sequence of tied notes to which the given note belongs.
    @seealso            note_get_path_in_notationobj()
 */
t_llll *get_tied_notes_sequence_path_in_notationobj(t_notation_obj *r_ob, t_note *note);


/**    Returns the list of paths of all the chord belonging to a completely-tied sequence of chord (given one chord of the sequence).
    For each one of the tied chords, a sublist is returned, having the form of the llll returned by chord_get_path_in_notationobj().
    If the given chord is not completely-tied to anything (nor the previous chord is completely tied to it), 
    then the result will be the llll given by chord_get_path_in_notationobj()
    only with an additional external level of parentheses.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        A chord
    @return                A list with the path of each chord inside the sequence of completely tied chords to which the given chord belongs.
    @seealso            chord_get_path_in_notationobj()
 */
t_llll *get_tied_chords_sequence_path_in_notationobj(t_notation_obj *r_ob, t_chord *chord);
t_llll *get_tied_chords_sequence(t_notation_obj *r_ob, t_chord *chord);



/**    Same as get_tied_chords_sequence_path_in_notationobj() but for sequences of consecutive rests.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        A rest
    @return                A list with the path of each rest inside the sequence of consecutive rests to which the given rest belongs.
    @seealso            get_tied_chords_sequence_path_in_notationobj()
 */
t_llll *get_rests_sequence_path_in_notationobj(t_notation_obj *r_ob, t_chord *chord);
t_llll *get_rests_sequence(t_notation_obj *r_ob, t_chord *chord);


/**    Obtain the information about the groups defined in the notation object in llll form. The form is: [GROUP1 GROUP2 GROUP3...],
    where each GROUP is an llll of the form (CHORD1 CHORD2 CHORD3...), featuring each chord included in the group; each CHORD
    is in the form of the chord adress (see chord_get_path_in_notationobj()), as an llll displaying (voice_number measure_number position_of_the_chord_in_measure)
    in case of score chords, or (voice_number position_of_the_chord_in_voice) in case of roll chords. All these numbers are 1-based.
    @remark                All the numbers in the chord path are 1-based! Indeed, this group information can be stored or output from the first outlet. Being this
                        visible to the user, it has to make sense, and be coherent with the bach protocol (everything visible for the user is 1-based).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    mode        If this is 1, only groups appearing #start_ms and #end_ms are considered.
    @param    start_ms    If mode == 1, the beginning of the portion of the score to be considered
    @param    end_ms        If mode == 1, the end of the portion of the score to be considered
    @return                The group information as an llll, in the form explained above.
 */
t_llll *get_groups_for_dump_as_llll(t_notation_obj *r_ob, char mode, double start_ms, double end_ms);


/**    Get the first tempo in a given scorevoice
    @ingroup            notation_data
    @param    voice        The scorevoice
    @return                The first tempo for the #voice, NULL if none.
 */
t_tempo* tempo_get_first(t_scorevoice *voice);


/**    Get the first tempo in a given scorevoice, after a given measure (included).
    @ingroup            notation_data
    @param    meas        The given measure
    @return                The first tempo in the measure's voice, happening inside the given measure or after it.
 */
t_tempo* tempo_get_first_after_measure(t_measure *meas);


/**    Get the last tempo in a given scorevoice
    @ingroup            notation_data
    @param    voice        The scorevoice
    @return                The last tempo for the #voice, NULL if none.
 */
t_tempo* tempo_get_last(t_scorevoice *voice);


/**    Get the previous tempo (for a given tempo)
    @ingroup            notation_data
    @param    tempo        The given tempo
    @return                The first tempo before #tempo.
 */
t_tempo* tempo_get_prev(t_tempo *tempo);


/**    Get the next tempo (for a given tempo)
    @ingroup            notation_data
    @param    tempo        The given tempo
    @return                The first tempo after #tempo.
 */
t_tempo* tempo_get_next(t_tempo *tempo);


/**    Get the previous measure (for a given measure)
    @ingroup            notation_data
    @param    tempo        The given measure
    @return                The measure before #measure (if any, or NULL if none).
 */
t_measure* measure_get_prev(t_measure *measure);


/**    Get the next measure (for a given measure)
    @ingroup            notation_data
    @param    tempo        The given measure
    @return                The measure after #measure (if any, or NULL if none).
 */
t_measure* measure_get_next(t_measure *measure);





/**    Get the #t_voice structure inside which a chord is (either directly, as for roll, or within a measure, as for score).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    ch            The chord
    @return                The voice in which the chord is
 */
t_voice *chord_get_voice(t_notation_obj *r_ob, t_chord *ch);


/**    Get the first #t_voice structure which is not hidden.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @return                The first voice which is visible (not hidden)
 */
t_voice *voice_get_first_visible(t_notation_obj *r_ob);


/**    Get the las #t_voice structure which is not hidden.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @return                The last voice which is visible (not hidden)
 */
t_voice *voice_get_last_visible(t_notation_obj *r_ob);


/**    Obtain an llll containing as symbols all the voice names  
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    prepend_router    If this is non-zero a "voicenames" symbol at the beginning is prepended
    @return                An llll containing all voice names (and possibly a "voicenames" symbol at the beginning)
 */
t_llll *get_voicenames_as_llll(t_notation_obj *r_ob, char prepend_router);

// TBD
t_llll *get_voicespacing_as_llll(t_notation_obj *r_ob, char prepend_router);
t_llll *get_hidevoices_as_llll(t_notation_obj *r_ob, char prepend_router);


/**    Obtain an llll containing all clefs as symbols 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    prepend_router    If this is non-zero a "clefs" symbol at the beginning is prepended
    @return                An llll containing all clefs (and possibly a "clefs" symbol at the beginning)
 */
t_llll *get_clefs_as_llll(t_notation_obj *r_ob, char prepend_router);


/**    Obtain an llll containing all keys as symbols 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    prepend_router    If this is non-zero a "keys" symbol at the beginning is prepended
    @return                An llll containing all keys (and possibly a "keys" symbol at the beginning)
 */
t_llll *get_keys_as_llll(t_notation_obj *r_ob, char prepend_router);


/**    Obtain an llll containing all midichannels as #H_LONG elements (plus a "midichannels" symbol at the beginning) 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    prepend_router    If this is non-zero a "midichannels" symbol at the beginning is prepended
    @return                An llll containing all midichannels (and possibly a "midichannels" symbol at the beginning)
 */
t_llll *get_midichannels_as_llll(t_notation_obj *r_ob, char prepend_router);


/**    Obtain the header of a notation object
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    dump_what    A combination of #e_header_elems specifying what elements should be returned
    @param    add_router_symbol    If this is 1, the symbol corresponding to the notation object itself ("roll", "score"...) is output at the beginning
    @param    explicitly_get_also_default_stuff    If this is 1 (and #k_HEADER_SLOTINFO is asked to be returned), the function returns all slotinfo attributes, even if they are irrelevant for the slot type, and 
                                                even if they coincide with the default slottype value (ex. the slot color). This is useful when dealing with undo,
                                                but should be kept to 0 for most other purposes.
    @param    also_get_fields_saved_in_max_inspector    If this is 1 (and #k_HEADER_SLOTINFO is asked to be returned), the function also returs the slotinfo fields which are already saved as Max attributes for the object
                                                    and saved in the Max inspector (for instance: popup, background... determining which slots have to appear in the
                                                    popup menu or have to be kept in background: if this flag is 1, for each slotinfo a specification (popup 1) or
                                                    (popup 0) is added, and similarly for all the alreday-saved-with-the-Max-inspector stuff).
    @param    for_what    One of the #e_data_considering_types, typically either #k_CONSIDER_FOR_DUMPING of #k_CONSIDER_FOR_UNDO.
    @param    selection_only    If non-zero, only selected markers are output
    @return                An llll containing all notation object's header
 */
t_llll *get_notation_obj_header_as_llll(t_notation_obj *r_ob, long dump_what, char add_router_symbol, 
                                        char explicitly_get_also_default_stuff, char also_get_fields_saved_in_max_inspector, e_data_considering_types for_what, bool selection_only);


/**    Obtain an llll containing all the stafflines information (one element for each voice).
    Each staffline element can either be a single number (simply specifying the number of stafflines) or a llll, inside of which one has
    the indices of all lines of the stafflines (1 being the bottommost line in the traditional 5-lines-staff, +1 lines above, -1 lines below) 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    prepend_router    If this is non-zero a "stafflines" symbol at the beginning is prepended
    @return                An llll containing all stafflines information (and possibly a "stafflines" symbol at the beginning)
 */
t_llll *get_stafflines_as_llll(t_notation_obj *r_ob, char prepend_router);


/**    Obtain an llllelem containing the stafflines information for a given voice. This element element can either be a single number 
    (simply specifying the number of stafflines) or a llll, inside of which one has
    the indices of all lines of the stafflines (1 being the bottommost line in the traditional 5-lines-staff, +1 lines above, -1 lines below) 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice
    @return                An llllelem containing the stafflines information for a given voice.
 */
t_llllelem *get_voice_stafflines_as_llllelem(t_notation_obj *r_ob, t_voice *voice);



/**    Set the stafflines to a given voice. The llllelem containing the stafflines information has the syntax explained in get_voice_stafflines_as_llllelem().
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice
    @param    elem        The llllelem containing the stafflines information
    @param    force_assign_if_elem_is_wrong    If this is non-zero and #elem has the wrong syntax, it is interpreted and modified. 
                                            BEWARE: if this is non-zero, the function can thus be destructive on #elem. 
    @param    list        If force_assign_if_elem_is_wrong is non-zero, here you can put the overall list of elements specifying ALL stafflines information
                        for the notation object (one for each voice). It'll be used to properly interpret the wrongly-syntaxed elems.
 */
void set_stafflines_to_voice_from_llllelem(t_notation_obj *r_ob, t_voice *voice, t_llllelem *elem, char force_assign_if_elem_is_wrong, t_llll *list);


/**    Set the stafflines information to all voices of a given notation object. 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    stafflines    A llll containing all the stafflines information, one element for each voice.
                        Each llllelem has the syntax explained in get_voice_stafflines_as_llllelem().
    @param    char also_update_notation_obj_stafflines_llll    If this is non-0 the t_notation_obj::stafflines_as_llll field is also updated.
                                                            Set this to 0 if stafflines is exactly that llll, otherwise it'll hang!
 */
void set_stafflines_from_llll(t_notation_obj *r_ob, t_llll* stafflines, char also_update_notation_obj_stafflines_llll);


/**    Change the number of voices of a notation object. 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    num_voices    The new number of voices.
    @remark                This is equivalent to changing the "numvoices" attribute.
 */
void set_numvoices(t_notation_obj *r_ob, long num_voices);


/**    Tell if a note's pitch breakpoints are different from the default ones (only head and tail, and the tail has the same pitch as the head).
    For instance, if so we will need to send a "(breakpoint ...)" specification while getting the note's gathered syntax.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return                1 if note's pitch breakpoints are nontrivial, 0 otherwise
 */
char note_breakpoints_are_nontrivial(t_notation_obj *r_ob, t_note *note);


/**    Retrive the unscaled horizontal shift of a notehead. This shift is an ADDITIONAL shift, which sums up to the ordinary graphic positioning.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return        The unscaled horizontal shift of the notehead.    
*/
double get_notehead_ux_shift(t_notation_obj *r_ob, t_note *note);


/**    Retrive the unscaled vertical shift of a notehead. This shift is an ADDITIONAL shift, which sums up to the ordinary graphic positioning.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    ignore_custom_noteheads   If non-zero, ignores custom noteheads
    @return        The unscaled horizontal shift of the notehead.    
*/
double get_notehead_uy_shift(t_notation_obj *r_ob, t_note *note, char ignore_custom_noteheads);

// TBD
double get_notehead_durationline_start_ux_shift(t_notation_obj *r_ob, t_note *note);


/**    Obtain the "graphic" (= enharmonicity) information of a given note as an llll.
    For instance as (graphic 6000 1/2) meaning that the diatonic shown note is 6000, and the accidental is sharp.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return        The graphic specification as an llll
*/
t_llll* note_get_graphic_values_as_llll(t_notation_obj *r_ob, t_note *note);


/**    Same as note_get_graphic_values_as_llll() but without the "graphic" symbol at the beginning of the returned list 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return        The graphic specification as an llll, without router symbol
*/
t_llll* note_get_graphic_values_no_router_as_llll(t_notation_obj *r_ob, t_note *note);


/**    Obtain the pitch breakpoint information of a given note as an llll.
    For instance this might be (breakpoints (0 0 0) (0.5 200 0) (1 300 0.5)), where each sublist has the form <rel_x> <delta_mc> <slope> (<rel_x> ranging from 0 = note start to 1 = note tail).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus behaving differently (for instance,
                        if needed, trimming the breakpoints for a portion of the note, and not for its entirety).
    @param    new_start_midicents        Pointer which will be filled with the starting midicent of the note. This trivially coincides with the note midicents 
                                    unless the mode was a PARTIAL_NOTE or SAMPLE mode, in which case the note might be asked only from a given point in time.
    @param    new_start_midicents        Pointer which will be filled with the starting velocity of the note. This trivially coincides with the note midicents 
                                    unless the mode was a PARTIAL_NOTE or SAMPLE mode, in which case the note might be asked only from a given point in time.
    @return                The pitch breakpoints specification as an llll
*/
t_llll* note_get_breakpoint_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode, 
                                           double *new_start_midicents, double *new_start_velocity);


/**    Same as note_get_breakpoint_values_as_llll() but without the "breakpoints" symbol at the beginning of the returned list 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return        The graphic specification as an llll, without router symbol
*/
t_llll* note_get_breakpoints_values_no_router_as_llll(t_notation_obj *r_ob, t_note *note);


/**    Obtain all the "extra" information of a of a given note as an llll (such as breakpoints, graphics, slots, articulations).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @return                The extras of the note as an llll
*/
t_llll* note_get_extras_values_as_llll(t_notation_obj *r_ob, t_note *note);


/**    Obtain the information about all the defined commands in llll form.
    This can be, for instance (commands <FIRST_CMD> <SECOND_CMD>...) where each <XXX_CMD> is a sublist such as
    (<num> <notesym> <chordsym> <key>), where <num> is a 1-based index of the commands (up to# CONST_MAX_COMMANDS),
    <notesym> and <chordsym> are two symbols which will be output when the command is "performed" on a note or a chord, and key
    is the key that need to be pressed in order to perform the command on the selection.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param  bw_compatible   Triggers backwards compatibility with bach 0.7.9 or previous versions (i.e. only gets 5 commands)
    @return                The commands as an llll
*/
t_llll* get_commands_values_as_llll(t_notation_obj *r_ob, char bw_compatible);


/**    Set the commands for the notation object starting from the given llll.
    @ingroup            notation_data_send
    @param    r_ob        The notation object
    @param    outlet        The commands in llll form (see get_commands_values_as_llll())
    @see                get_commands_values_as_llll()
 */
void set_commands_from_llll(t_notation_obj *r_ob, t_llll* commands);


/**    Obtain all the information about a bach.roll note, in gathered syntax.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The gathered syntax of the note, as an llll
*/
t_llll* get_rollnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode);


/** Obtain all the information about a bach.roll note, in gathered syntax, but considering it as a part of a chord containing just this note.
    This is useful at playtime, when even if the playmode is notewise, each note is output also with its onset and chord-flag.
    Apart from these two small things, the function is essentially the same as get_rollnote_values_as_llll().
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The llll gathered syntax of a chord containing the #note as a single note
*/
t_llll* get_single_rollnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode);


/**    Obtain all the information about a bach.roll chord, in gathered syntax.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @param   selection_only  If non-zero, only get selected notes
    @return                The gathered syntax of the chord, as an llll
*/
t_llll* get_rollchord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, bool selection_only);


/**    Obtain all the information about a bach.score note, in gathered syntax.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The gathered syntax of the chord, as an llll
*/
t_llll* get_scorenote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode); // used by score


/** Obtain all the information about a bach.score note, in gathered syntax, but considering it as a part of a chord containing just this note.
    This is useful at playtime, when even if the playmode is notewise, each note is output also with its chord-syntax-content (such as rational duration...)
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The llll gathered syntax of a chord containing the #note as a single note
*/
t_llll* get_single_scorenote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode);


// TBD
char should_play_tied_notes_separately(t_notation_obj *r_ob, t_chord *chord);
char should_play_tied_chords_separately(t_notation_obj *r_ob, t_chord *chord);


/**    Obtain all the information about a bach.score chord, in gathered syntax.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The gathered syntax of the chord, as an llll
*/
t_llll* get_scorechord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, char put_grace_chord_sym_duration_to_zero); // used by score


/**    Obtain all the information about a (dummy) bach.slot note, in gathered syntax (indeed, bach.slot is a set of slots associated to a dummy note).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The (dummy) note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @return                The gathered syntax of the note, as an llll
*/
t_llll* get_uislotnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode);


/**    Apply to a chord the information coming in the #chordvalues llll.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @param    chordvalues    The llll containing all the chord values to be applied, in gathered syntax.
    @param    always_from_scratch    If this is non-zero, the chord is always completely "erased" before applying the information (and thus rebuilding it).
                                If this is not the case, the information is only applied on the existing elements of the chord. For instance,
                                if the chord had 3 notes, and the #chordvalues information contained only 2 notes, the third remaining note is kept
                                if #always_from_scratch == 0 and dropped if #always_from_scratch == 1.
    @param    also_recompute_total_length    If this is non-zero, the total recompute_total_length() function is called at the end. 
    @param  check_notes_order   Also check notes order
*/
void set_chord_values_from_llll(t_notation_obj *r_ob, t_chord *chord, t_llll *chordvalues, char always_from_scratch, char also_recompute_total_length, char check_notes_order);


/**    Get the midicents corresponding to a given position inside the duration line of a note (so interpolating between note's midicents).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    point        The point inside the duration line, from 0. to 1. (0. = start, 1. = end)
    @param    *velocity    Pointer which will be filled with the (possibly interpolated) velocity corresponding to the given point of the duration line
    @return                The (possibly interpolated) midicents at the specified point of the specified note.
*/
double get_breakpoints_interpolated_mc(t_notation_obj *r_ob, t_note *note, double point, double *velocity);


/**    Obtain all the information about a specific part of a bach.roll chord, in gathered syntax.
    @remark                This is used to handle partial chord playing.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @param    start_ms    The starting position of the part, in milliseconds
    @param    end_ms        The ending position of the part, in milliseconds
    @return                The gathered syntax of the requested part of the chord, as an llll
    @remark                The input interval(#start_ms, #end_ms) must overlap at least a little bit with the chord temporal position, 
                        otherwise a chord with no notes will be output.
    @see                get_rollchord_values_as_llll()
*/
t_llll* get_rollpartialchord_values_as_llll(t_notation_obj *r_ob, t_chord *chord, e_data_considering_types mode, double start_ms, double end_ms);


/**    Obtain all the information about a specific part of a bach.roll note, in gathered syntax.
    @remark                This is used to handle partial note playing.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    note        The note
    @param    mode        One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @param    start_ms    The starting position of the part, in milliseconds
    @param    end_ms        The ending position of the part, in milliseconds
    @return                The gathered syntax of the requested part of the note, as an llll
    @remark                The input interval(#start_ms, #end_ms) must overlap at least a little bit with the temporal position of the note's duration line, 
                        otherwise a note with no duration will be output.
    @see                get_rollnote_values_as_llll()
*/
t_llll* get_rollpartialnote_values_as_llll(t_notation_obj *r_ob, t_note *note, e_data_considering_types mode, double ms_start, double ms_end);





/** Obtain the selected notation item with smallest onset.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @return                The selected notation item with smallest onset (or NULL if none) 
 */
t_notation_item *get_leftmost_selected_notation_item(t_notation_obj *r_ob);
t_note *get_leftmost_selected_note(t_notation_obj *r_ob);


/** Obtain the selected notation item with greatest onset.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @return                The selected notation item with greatest onset (or NULL if none) 
 */
t_notation_item *get_rightmost_selected_notation_item(t_notation_obj *r_ob);


/** Obtain the unscaled horizontal pixel corresponding to the chord's alignment point (the point which is geometrically aligned
    when more chords are to be aligned). This point is usually the barycenter of the principal noteheads (noteheads near the stem, at its main side).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The unscaled horizontal pixel of the chord's alignment point 
    @remark                This only works in bach.score. In bach.roll, you can easily get this the horizontal pixel by using onset_to_xposition_roll().
                        Also in bach roll, alignment depends whether stems are shown (in which case stems are the alignment reference) or not 
                        (in which case notehead center is the alignment reference).
 */
double chord_get_alignment_ux(t_notation_obj *r_ob, t_chord *chord);


/** Obtain the horizontal pixel corresponding to the chord's alignment point (the point which is geometrically aligned
    when more chords are to be aligned). This point is usually the barycenter of the principal noteheads (noteheads near the stem, at its main side).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The horizontal pixel of the chord's alignment point
 */
double chord_get_alignment_x(t_notation_obj *r_ob, t_chord *chord);


// TBD
double chord_get_stem_x(t_notation_obj *r_ob, t_chord *chord);
double tail_get_alignment_x(t_notation_obj *r_ob, t_note *note);
double tail_get_alignment_ux(t_notation_obj *r_ob, t_note *note);


/** Obtain the longest note of a chord
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The longest note of the chord
 */
t_note *chord_get_longest_note(t_notation_obj *r_ob, t_chord *chord);


/** Calculate the onset of a chord in milliseconds roughly. Use notation_item_get_onset_ms_accurate() for accurate computation.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The onset of the chord in milliseconds
    @remark                Both in bach.roll and in bach.score, this is also stored in the t_chord::onset field.
 */
double chord_get_onset_ms(t_notation_obj *r_ob, t_chord *chord);


double measure_get_onset_ms(t_notation_obj *r_ob, t_measure *meas);
double measure_get_duration_ms(t_notation_obj *r_ob, t_measure *meas);


/** Obtain the onset of a tempo in milliseconds. (Only for bach.score)
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    tempo        The tempo
    @return                The onset of the tempo in milliseconds
    @remark                This is also stored in the t_tempo::onset field.
 */
double get_tempo_onset_ms(t_notation_obj *r_ob, t_tempo *tempo);


/** Get the previous chord (in case the chord is a bach.score chord, the previous chord may not necessarily belong to the the same measure).
    @ingroup            notation_data
    @param    chord        The chord
    @return                The chord preceding the input one, of NULL if none.
    @see    chord_get_next()
*/
t_chord *chord_get_prev(t_chord *chord);


/** Get the next chord (in case the chord is a bach.score chord, the next chord may not necessarily belong to the the same measure).
    @ingroup            notation_data
    @param    chord        The chord
    @return                The chord following the input one, of NULL if none.
    @see    chord_get_prev()
*/
t_chord *chord_get_next(t_chord *chord); 


/** Get the next non-rest chord. (Only for bach.score)
    @ingroup            notation_data
    @param    chord        The chord
    @return                The first non-rest chord following the input one, or NULL if none.
    @see    chord_get_next()
*/
t_chord *chord_get_next_nonrest(t_chord *chord);


/** Get the previous non-rest chord. (Only for bach.score)
    @ingroup            notation_data
    @param    chord        The chord
    @return                The first non-rest chord preceding the input one, or NULL if none.
    @see    chord_get_prev()
*/
t_chord *chord_get_prev_nonrest(t_chord *chord);

// TBD
t_chord *chord_get_next_with_dynamics(t_notation_obj *r_ob, t_chord *chord, long *curr_hairpin_type, char return_last_one_in_any_case, char include_this_chord);


/** Get the notation item 'at left' with respect to the input one. The item 'at left' is the first item preceding the input one, 
    and of the same kind of the input one (for instance, the previous chord, or measure, or marker; in case of notes, the note of the 
    previous chord being at the same index in the chord as the input note).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    item        The item
    @param skip_rests   If non-zero, skips rests
    @return                The notation item 'at left' with respect to the input one.
*/
t_notation_item *notation_item_get_at_left(t_notation_obj *r_ob, t_notation_item *item, char skip_rests);


/** Get the notation item 'at right' with respect to the input one. The item 'at right' is the first item following the input one.
    See notation_item_get_at_left() for more information.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    item        The item
    @param skip_rests   If non-zero, skips rests
    @return                The notation item 'at right' with respect to the input one.
    @see    notation_item_get_at_left()
*/
t_notation_item *notation_item_get_at_right(t_notation_obj *r_ob, t_notation_item *item, char skip_rests);


/** Get the notation item 'at top' with respect to the input one. The item 'at top' is the first item following the input one 
    (for instance in the voice above). See notation_item_get_at_left() for more information.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    item        The item
    @param skip_rests   If non-zero, skips rests
    @return                The notation item 'at top' with respect to the input one.
    @see    notation_item_get_at_left()
*/
t_notation_item *notation_item_get_at_top(t_notation_obj *r_ob, t_notation_item *item, char skip_rests);


/** Get the notation item 'at bottom' with respect to the input one. The item 'at bottom' is the first item following the input one 
    (for instance in the voice below). See notation_item_get_at_left() for more information.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    item        The item
    @param skip_rests   If non-zero, skips rests
    @return                The notation item 'at bottom' with respect to the input one.
    @see    notation_item_get_at_left()
*/
t_notation_item *notation_item_get_at_bottom(t_notation_obj *r_ob, t_notation_item *item, char skip_rests);


/** Obtain the unscaled width needed for a key signature to be drawn.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice, whose key need to be drawn
    @return        The unscaled width in pixel needed for the key signature of the voice to be drawn.
*/
double get_key_uwidth(t_notation_obj *r_ob, t_voice *voice);


/** Obtain the vertical pixel position of the staff top line of a given voice.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice
    @param    ignore_nonstandard_stafflines    If this flag is non-zero, the voice is always supposed to have standar 5-lines stafflines.
                                            Otherwise, the proper stafflines of the voice are taken into account to determine the staff topmost vertical point.
    @return        The vertical pixel position of the topmost staff line of the input voice
*/
double get_staff_top_y(t_notation_obj *x, t_voice *voice, char ignore_nonstandard_stafflines);


/** Obtain the vertical pixel position of the staff bottom line of a given voice.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice
    @param    ignore_nonstandard_stafflines    If this flag is non-zero, the voice is always supposed to have standar 5-lines stafflines.
                                            Otherwise, the proper stafflines of the voice are taken into account to determine the staff bottommost vertical point.
    @return        The vertical pixel position of the bottommost staff line of the input voice
*/
double get_staff_bottom_y(t_notation_obj *x, t_voice *voice, char ignore_nonstandard_stafflines);


/** Obtain the number of steps between the bottommost staff line and the topmost staff line for a given voice.
    For instance, in a standard G clef 5-staff staffline, this is 8 (4 spaces, i.e. 4*2 steps). For an FG clef, 
    this is 20 (4+4 spaces, and 2 spaces in between, i.e. 10*2 steps).
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    voice        The voice
    @return                The number of steps contained in the staff of a given voice.
*/
long get_num_steps_in_staff(t_notation_obj *r_ob, t_voice *voice);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
// obsolete function, no more used
t_llll *measure_get_ties_as_llll(t_notation_obj *r_ob, t_measure *measure);
#endif


/** Obtain all the content of a measure in llll form.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    measure        The measure
    @param    for_what    One of the possible #e_data_considering_types specifying the reason why the llll is asked, and thus returning slightly different specifications depending on the usage.
    @param    tree        If this is non-zero, the information is output in the tree form (and also the grace notes are output with their own "g" levels), otherwise the information
                        is output in a chord-wise linear form (one llll for each chord..., and the grace notes are output as chords of duration 0).
    @param    also_get_level_information    If this is non-zero, the "leveltype" llll specifications are always added at the beginning of each level. This is of course accounted for only if
                                        the previous #tree is non-zero.
    @param   prepend_this_tempo Optional tempo that will be prepended to the tempo lists (leave NULL if not needed)
    @return    The llll representation of the entire measure
*/
t_llll* measure_get_values_as_llll(t_notation_obj *r_ob, t_measure *measure, e_data_considering_types for_what, char tree, char also_get_level_information, t_tempo *prepend_this_tempo = NULL);


/** Obtain the measureinfo (measure "header" information: time signature, tempi, barline types...) for a given measure in llll form. 
    This always contains time signature and tempi (a void llll, if there's no tempo inside the measure). Also it might contain "barline" specification (end barline type),
    "width" or "widthfactor" or "shownumber" or "boxes" specifications.
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    measure        The measure
    @param    prepend_this_tempo  Additional tempo to be included at the beginning if needed (leave NULL otherwise)
    @return    The llll containing all the measureinfo for the given measure.
*/
t_llll* measure_get_measureinfo_as_llll(t_notation_obj *r_ob, t_measure *measure, t_tempo *prepend_this_tempo = NULL);


/** Obtain the tempi information for a given measure in llll form. 
    @ingroup            notation_data
    @param    r_ob        The notation object
    @param    measure        The measure
    @param    prepend_this_tempo   Additional tempo to be included at the beginning, if needed
    @return    The llll containing all the tempi information for the given measure.
*/
t_llll* measure_get_tempi_as_llll(t_measure *measure, t_tempo *prepend_this_tempo = NULL);

// TBD
t_llll *measure_get_single_tempo_as_llll(t_tempo *tempo);


/** Obtain the number of staves that a given voice has (depending on the clef).
    @ingroup notation_utilities
    @param    r_ob                        The notation object
    @param        voice        The voice
    @return        The number of staves of the voice.
    @remark        For instance, if the voice has clef k_CLEF_FFG, the function will return 3.
*/
long get_num_staves_voice(t_notation_obj *r_ob, t_voice *voice);


/** Obtain the global number of staves of all voices.
    @ingroup notation_utilities
    @param    r_ob                        The notation object
    @param    dont_count_hidden_staves    If this is non-zero, staves corresponding to hidden voices are NOT counted. 
    @return                                The overall number of staves of all voices.
*/
long get_num_staves(t_notation_obj *r_ob, char dont_count_hidden_staves);


/** Obtain the clef of a voice. This takes into account the possible staffensemble gathering, and returns
    the clef of the staff ensemble
    @ingroup notation_utilities
    @param    r_ob                        The notation object
    @param  voice                       The voice
    @return                                The clef with which the voice is displayed
 */
long get_voice_clef(t_notation_obj *r_ob, t_voice *voice);



/** Obtain the number of octaves the clef has been "shifted" via a 8va/8vb/15ma/15mb sign.
    @ingroup notation_utilities
    @param  clef                       The clef as numeric value
    @return                                The number of shift octaves
 */
long get_clef_octave_shift(long clef);


/** Obtain the number to be written over or under the clef for clef octaviation.
    @ingroup notation_utilities
    @param  clef                        The clef as numeric value
    @return                                The string containing the number ("8", "15", "22" or "")
 */
const char *get_clef_octave_shift_for_clef_text(long clef);


/** Get the next voice. This is a small wrapper working both for bach.roll and for bach.score (allowing you to get always the next #t_voice structure).
    @ingroup notation_data
    @param    r_ob    The notation object
    @param    voice    The voice
    @return            The voice following the given one, or NULL if none.
*/
t_voice *voice_get_next(t_notation_obj *r_ob, t_voice *voice);


/** Get the previous voice. This is a small wrapper working both for bach.roll and for bach.score (allowing you to get always the previous #t_voice structure).
    @ingroup notation_data
    @param    r_ob    The notation object
    @param    voice    The voice
    @return            The voice preceding the given one, or NULL if none.
*/
t_voice *voice_get_prev(t_notation_obj *r_ob, t_voice *voice);


/** Obtain the loop region in llll form. 
    This is a simple (<start_ms> <end_ms>) for bach.roll, but a more complicate 
    ((<start_measurenumber> <start_pointinmeasure> <start_voicenumber>) (<end_measurenumber> <end_pointinmeasure> <end_voicenumber>)) for bach.score.
    @ingroup notation_data
    @param    r_ob        The notation object
    @param router_sym   0/1 flag to prepend "loop" symbol
    @return                The loop region in llll form
*/
t_llll *get_loop_region_as_llll(t_notation_obj *r_ob, char router_sym);


/// VOICE ENSEMBLES:


/** Get the first following voice starting a voiceensemble.
    @ingroup notation_data
    @param    r_ob    The notation object
    @param    voice    The voice
    @return            The first following voice belonging to a new voiceensemble
 */
t_voice *voiceensemble_get_next(t_notation_obj *r_ob, t_voice *voice);


/** Get the first previous voice starting a new voiceensemble.
    @ingroup notation_data
    @param    r_ob    The notation object
    @param    voice    The voice
    @return            The first previous voice starting a new voiceensemble
 */
t_voice *voiceensemble_get_prev(t_notation_obj *r_ob, t_voice *voice);

long notationobj_get_num_voiceensembles(t_notation_obj *r_ob);
char do_voices_belong_to_same_voiceensemble(t_notation_obj *r_ob, t_voice *v1, t_voice *v2);
long voiceensemble_get_numparts(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble);
t_llll *voiceensemble_get_voicenumbers(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble, char one_based);
t_voice *voiceensemble_get_firstvoice(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble);
t_voice *voiceensemble_get_lastvoice(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble);
void voiceensemble_break(t_notation_obj *r_ob, t_voice *any_voice_in_voicenensemble, char add_undo_tick);
void voiceensemble_create_from_selection(t_notation_obj *r_ob, char add_undo_tick);

void change_voiceensemble_key(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, t_symbol *new_key, char also_add_undo_tick);
void change_voiceensemble_midichannel(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, long new_midichannel, char also_add_undo_tick);
void change_voiceensemble_clef(t_notation_obj *r_ob, t_voice* any_voice_in_voiceensemble, long new_clef, char also_add_undo_tick);

t_llll *get_parts_as_llll(t_notation_obj *r_ob); // DEPRECATED
t_llll *get_numparts_as_llll(t_notation_obj *r_ob);



// TBD
void set_need_perform_analysis_and_change_flag(t_notation_obj *r_ob);



// -----------------------------------
// SCORE OPERATIONS
// -----------------------------------

/**    Insert a chord inside a measure.
    @ingroup            score_operations
    @param    r_ob        The notation object
    @param    measure        The measure
    @param    chord_to_insert        The chord to insert
    @param    after_this_chord    The chord after which the previous chord must be inserted (leave NULL if chord must be inserted at the beginning of the measure)
    @param    force_ID    An ID which will be assigned to the inserted chord (as notation item). Leave zero in order to have automatic ID assignment. 
 */
void chord_insert_in_measure(t_notation_obj *r_ob, t_measure *measure, t_chord *chord_to_insert, t_chord *after_this_chord, unsigned long force_ID);


/**    Build a timepoint.
    @ingroup                    score_operations
    @param    measure_num            The 0-based measure number
    @param    point_in_measure    The rational onset of the timepoint inside the measure
    @param    voice_num            The 0-based number of the voice
    @return                        The filled-in #t_timepoint structure.
 */
t_timepoint build_timepoint_with_voice(long measure_num, t_rational point_in_measure, long voice_num);


/**    Build a timepoint, ignoring the voice field.
    @ingroup                    score_operations
    @param    measure_num            The 0-based measure number
    @param    point_in_measure    The rational onset of the timepoint inside the measure
    @return                        The filled-in #t_timepoint structure (with dummy voice field).
 */
t_timepoint build_timepoint(long measure_num, t_rational point_in_measure);


/**    Build a tempo (allocate and fill the memory).
    @ingroup                    tempi_operations
    @param    changepoint            A timepoint in which tempo changes
    @param    figure_tempo_value    The tempo value referred to the tempo figure. If 1/8 = 60, tempo_figure = 1/8, figure_tempo_value = 60.
    @param    tempo_figure        The tempo figure (the symbolic unit at the left side of the = in the tempo assignments).
    @param    interpolation_type    If this is 1, the tempo starts an interpolation towards the next one.
                                This will be an accelerando or rallentando depending on the next tempo values.
    @return    Pointer to the built tempo.
 */
t_tempo *build_tempo(t_rational changepoint, t_rational figure_tempo_value, t_rational tempo_figure, char interpolation_type);


/**    Build a tempo starting from an llll containing the information, in one of the following forms:
    (<tempovalue>) will be interpreted as quarter = <tempovalue>
    (<tempofigure> <figuretempovalue>) will be interpreted as <tempofigure> = <figuretempovalue>
    (<tempofigure> <figuretempovalue> <pt_in_measure>) works as the previous, but the tempo doesn't change at the measure beginning, rather at a given symbolic onset inside the measure (<pt_in_measure>)
    (<tempofigure> <figuretempovalue> <pt_in_measure> <interpolation>) works as the previous, but if <interpolation> = 1 the tempo starts an interpolation towards the following one. 
    @ingroup            tempi_operations
    @param    r_ob        The llll containing the tempo information
    @param  tempo_approx_digits Number of approximation digits
    @return    Pointer to the build tempo.
 */
t_tempo *build_tempo_from_llll(t_llll *tempollll, long tempo_approx_digits);


/**    Insert a tempo inside a measure (position inside the tempi linked list will be automatically determined by tempo's onset)
    @ingroup            tempi_operations
    @param    r_ob        The notation object
    @param    measure        The measure
    @param    tempo_to_insert        The tempo to insert
 */
void insert_tempo(t_notation_obj *r_ob, t_measure *measure, t_tempo *tempo_to_insert);


/**    Delete a tempo (and properly frees the memory).
    @ingroup            tempi_operations
    @param    r_ob        The notation object
    @param    tempo        The tempo
 */
void delete_tempo(t_notation_obj *r_ob, t_tempo *tempo);


/**    Determine if two tempi have the same value and are in the same position (i.e. they completely coincide and are overlapped).
    @ingroup            tempi_operations
    @param    tempo1        The first tempo
    @param    tempo2        The second tempo
 */
char are_tempi_the_same_and_in_the_same_tp(t_tempo *tempo1, t_tempo *tempo2);

// TBD
char are_tempi_the_same_and_with_the_same_onset(t_notation_obj *r_ob, t_tempo *tempo1, t_tempo *tempo2);


/**    Delete all the tempi of a given (score)voice.
    @ingroup            tempi_operations
    @param    r_ob        The notation object
    @param    voice        The score voice.
 */
void clear_voice_tempi(t_notation_obj *r_ob, t_scorevoice *voice);


/**    Build an empty measure (allocate and fill memory).
    @ingroup            measure_operations
    @param    r_ob        The notation object
    @param    time_signature    The time signature in llll form, such as (4 4) or ((3 2 2) 8), but NOT (3 (4 8)).
    @return    Pointer to the build measure.
 */
t_measure *build_measure(t_notation_obj *r_ob, t_llll *time_signature);


/**    Build the structure corresponding to a measure's end barline (allocate and fill memory).
    @ingroup            measure_operations
    @param    r_ob        The notation object
    @param    measure_ref    The measure which will be owning the end barline.
    @return    Pointer to the build barline.
 */
t_measure_end_barline *build_measure_end_barline(t_notation_obj *r_ob, t_measure *measure_ref);


/**    Tell if two time signatures are equal.
    @ingroup            ts_operations
    @param    ts1        First time signature
    @param    ts2        Second time signature
    @return    1 if time signatures are the same, 0 otherwise.
 */
char ts_are_equal(t_timesignature *ts1, t_timesignature *ts2);


/**    Obtain the graphic unscaled horizontal width needed to draw a given time signature
    @ingroup        ts_operations
    @param    r_ob    The notation object
    @param    ts        The time signature
    @return    The unscaled width needed to draw the time signature.
 */
double ts_get_uwidth(t_notation_obj *r_ob, t_timesignature *ts);


// TBD
double ts_get_spacing_uwidth(t_notation_obj *r_ob, t_timesignature *ts);

void ts_adapt_to_symduration(t_timesignature *ts, t_rational new_measure_duration);


/**    Obtain default beaming boxes to be associated with a given time signature.
    Beaming boxes are a list of rationals determining the width of each "beaming region". For instance, in 4/4, beaming boxes are 
    usually (1/4 1/4 1/4 1/4), meaning that beamings will be probably broken by default after each 1/4. This will force, for instance,
    figures like (1/8 1/8 1/8 1/8 1/4 -1/4) to be beamed like ((1/8 1/8) (1/8 1/8) (1/4) (-1/4)), at least at a first step of the
    process_rhythmic_tree() function.
    Measure's beaming boxes can be changed, the ones that this function returns are the default ones, which are also used by bach.quantize
    as standard regularity boxes if no other boxes are defined.
    @ingroup        ts_operations
    @param    r_ob    The notation object or NULL if none
    @param    ts        The time signature
    @param    division_for_PWGL    Pointer which will be filled with a special division number meant to be used when exporting to PWGL. 
                                This is ALWAYS 1/<ts_denominator>, so it is not a "real" division (see below), but PWGL needs that like this.
                                Leave NULL if unneeded.
    @param    division            Pointer which will be filled with the measure's division. For instance, (6 8) = 6/8 yields a division = 3/8.
                                For complex time signatures, when this might be ambiguous (such as (3+2+2)/8 or 8/8 or 5/12), this is left by default 1/<ts_denominator> 
                                Leave NULL if unneeded.
    @return    The default beaming boxes for the time signature.
 */
t_llll *ts_to_beaming_boxes(t_notation_obj *r_ob, t_timesignature *ts, t_rational *division_for_PWGL, t_rational *division);


/**    Obtain the default division associated with a given time signature. For instance, 4/4 -> 1/4, or 9/8 -> 3/8.
    For complex time signatures, when this might be ambiguous (such as (3+2+2)/8 or 8/8 or 5/12), this is left by default 1/<ts_denominator>.
    @ingroup        ts_operations
    @param    r_ob    The notation object
    @param    ts        The time signature
    @return            The default division for the time signature.
 */
t_rational ts_to_division(t_notation_obj *r_ob, t_timesignature *ts);

#ifndef DOXYGEN_SHOULD_SKIP_THIS
// OBSOLETE FUNCTIONS
// THESE ALL REFER TO THE OLD BEAMING PARSING (with no beaming tree below)
void calculate_measure_beamings(t_notation_obj *r_ob, t_measure *measure, long flags, t_llll *garbage);
void properly_retranscribe_tuplets(t_notation_obj *r_ob, t_measure *measure, t_llll *garbage);
char get_num_dots_with_tuplet_info(t_notation_obj *r_ob, t_rational duration, t_rational tuplet_group_unit, t_rational tuplet_group_figure);
char is_duration_drawable_with_tuplet_info(t_notation_obj *r_ob, t_rational duration, t_rational *screen_duration, char *num_dots, t_rational tuplet_group_unit, t_rational tuplet_group_unit_figure);
void get_rhythm_drawable(t_notation_obj *r_ob, t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, 
                         t_llll **tuplets, long max_dots, long tuplet_group_offset, long *max_tuplet_group, char admit_dotted_tuplets, t_llll *garbage, t_llll *next_box_infos);
#endif

/**    Reparse and verify the ties inside a given measure. This will reassign the note <tie_from> fields if needed.
    More precisely: ties are defined (outside this function) by setting to WHITENULL the <tie_to> field of the note where the tie starts.
    This function parses this WHITENULL information into a proper #t_note structure (the note where the tie ends, if any), and 
    also set the <tie_from> field of the note where the tie ends to the address of the note where the tie begins, so that the two notes are now linked 
    one to each other.
    @ingroup        measure_operations
    @param    r_ob    The notation object
    @param    ts        The measure
    @param    ties_assign_pitches    If this is non-zero, when two notes can be tied, the midicents of the second note are perfectly set equal to the midicents of the first note.
                                Beware: this will NOT mean, for instance, that if you try to tie a C4 with a F#4 the second note will be set to C4 and a tie will be drawn:
                                Ties will ALWAYS only be drawn, provided that the two notes have the SAME t_note::screen_midicents and t_note::screen_accidental fields 
                                (thus represented in the same position on the screen), as it is the case for two C4, one being 6004 midicents, and the next one being 5999 midicents.
                                This latter, upon tying with #ties_assign_pitches = 1, will be set to 6004 midicents also.  
    @param    nullify_incorrect_ties_if_needed    If this is 2, wrongly assigned <tie_to> and <tie_from> fields are set to NULL (for instance because a note cannot tie to the next chord, if in the next chord there's no note having same screen_midicents and screen_accidental representation).
                                                If this is 1, this is only true IF the t_notation_obj::nullify_incorrect_ties_if_needed field of the notation object is non-zero.
                                                If this is 0, this is never true.
    @return            The default division for the time signature.
 */
void check_measure_ties(t_notation_obj *r_ob, t_measure *measure, long flags, char nullify_incorrect_ties_if_needed);


/**    Properly fill the <num_unicode>, <den_unicode>, <len_num> and <len_den> fields of a time signature for a given measure.
    These fields contains the information for writing later the time signature with via the writing wrappers.
    @ingroup        ts_operations
    @param    r_ob    The notation object
    @param    ts        Pointer to the time signature
 */
void compute_utf_timesignature(t_notation_obj *r_ob, t_timesignature *ts);


/**    Tell if, among the elements aligned in an alignement point, there are some measures (= starting barlines of measures)
    @ingroup        notation
    @param    r_ob    The notation object
    @param    ap        The alignement point
    @return            1 if #ap contains measures, 0 otherwise.
 */
char are_there_measures_in_alignmentpoint(t_alignmentpoint *ap);


/**    Tell if, among the elements aligned in an alignement point, there are ONLY measures (= starting barlines of measures)
    @ingroup        notation
    @param    r_ob    The notation object
    @param    ap        The alignement point
    @return            1 if #ap contains only measures, 0 otherwise.
 */
char are_there_only_measures_in_alignmentpoint(t_alignmentpoint *ap);


/**    Merge all subsequent rests and all subsequente all-tied-chord, no matter if the merged duration is drawable or not.
    For instance: will rewrite 1/4 t 1/16 -1/16 -1/8 as 5/16 -3/16.
    The rhythm is described as a plain list of rational durations, all their note-wise informations and all their ties. 
    This is useful for instance in bach.quantize or bach.beatbox. On the other hand, if you wish to act    directly on a measure, you should use
    merge_rests_and_alltied_chords_one_step() and merge_rests_and_alltied_chords_for_level_fn() instead.
    The function initializes and returns #new_rhythm, #new_infos and #new_ties. If #discarded_info and #discarded_durations are non-NULL,
    they are also initialized and filled with the discarded informations and durations (for instance because they have been tied to the previous ones).
    @ingroup        notation
    @param    rhythm    The rhythm as a plain sequence of rational durations
    @param    infos    All the information associated to each rhythmic duration (could be whatever you want: usually, it's a sublist for each note containing 
                    pitch, velocity, and then a list with breakpoints, graphics, slots).
    @param    ties    All the ties, one subllll for each rhythm element containing one long value for each note (1 or 0).
    @param    new_rhythm    The modified rhythm (initialized inside the function: don't initialize it, you'll always need to free it)
    @param    new_infos    The modified infos (initialized inside the function: don't initialize it, you'll always need to free it)
    @param    new_ties    The modified ties (initialized inside the function: don't initialize it, you'll always need to free it)
    @param    discarded_info    If this is not-NULL, this is initialized (and thus you'll need to free it) and the all the information elements
                            which has been discarded from the #infos is stored here. Leave it NULL if unneeded.
    @param    discarded_durations    If this is not-NULL, this is initialized (and thus you'll need to free it) and will contain the rhythm durations corresponding
                                to the #discarded_info llll.
 @param  merge_when  If 0 it doesn't perform any merging, only copying
 */
void merge_rests_and_alltied_chords_from_separate_parameters(t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, t_llll **discarded_info, t_llll **discarded_durations, e_merge_when merge_when);


/**    In-place merge al subsequent rests and all subsequente all-tied-chord, no matter if the merged duration is drawable or not.
    See merge_rests_and_alltied_chords_from_separate_parameters() for a description of inputs.
    @see            merge_rests_and_alltied_chords_from_separate_parameters()
    @ingroup        notation
    @param    rhythm    The rhythm as a plain sequence of rational durations
    @param    infos    All the information associated to each rhythmic duration (could be whatever you want: usually, it's a sublist for each note containing 
                    pitch, velocity, and then a list with breakpoints, graphics, slots).
    @param    ties    All the ties, one subllll for each rhythm element containing one long value for each note (1 or 0).
    @param    discarded_info    If this is not-NULL, this is initialized (and thus you'll need to free it) and the all the information elements
                            which has been discarded from the #infos is stored here. Leave it NULL if unneeded.
    @param    discarded_durations    If this is not-NULL, this is initialized (and thus you'll need to free it) and will contain the rhythm durations corresponding
                                to the #discarded_info llll.
    @param  merge_when  If 0 it doesn't perform any merging, only copying
 */
void merge_rests_and_alltied_chords_from_separate_parameters_inplace(t_llll **rhythm, t_llll **infos, t_llll **ties, t_llll **discarded_info, t_llll **discarded_durations, e_merge_when merge_when);


/**    From a given llllelem containing information about the ties of a chord, tell if the chord is completely tied to the next one.
    @ingroup        notation
    @param    tie_elem                The llllelem containing the information about the ties of each note of the chord (plain list of 1's or 0's).
                                    Also acceptable if tie_elem contains a single long value (0 or 1 for the whole chord) .
    @param    num_next_chord_notes    The number of the notes of the next chord, which we use to check that the next chord have exactly the same number of 
                                    notes of the current chord, otherwise they are not completely tied.
                                    If you don't know this value, you can leave to -1, and the check will be automatically performed on tie_elem->l_next. 
                                    If you don't want to perform this check, set this variable to the special value of -5.
    @return            1 if the chord to which tie_element correspond is completely tied to the next one (= each note is tied to something, and next
                    chord has no more notes than the one that ends a tie), 0 otherwise.
 */
char is_all_llllelem_tied(t_llllelem *tie_elem, long num_next_chord_notes);


/**    From a given llllelem containing information about the ties of a chord, tell if at least one note of the chord starts a tie.
    @ingroup        notation
    @param    tie_elem                The llllelem containing the information about the ties of each note of the chord (plain list of 1's or 0's).
                                    Also acceptable if tie_elem contains a single long value (0 or 1 for the whole chord) .
    @return            1 if the chord to which tie_element correspond has at least one of its notes that starts a tie, 0 otherwise.
 */
char is_at_least_a_note_tied_in_llllelem(t_llllelem *tie_elem);


/**    Box a given rhythm, from its separate parameters (durations, global information, ties). In other words, splits a given rhythm with respect 
    to a box pattern, possibly splitting also the infos information, which has to be a llll composed by lllls, one for each rhythm element,
    associated 1-to-1 with a rhythm element, that may contain whatever you want (e.g. cents, velocity, ties...).
    E.g. if rhythm = (1/8 2/4 -1/16 1/16), infos = ((a) (b) (c) (d)) and boxes = (1/4 2/4) it returns 
    new_rhythm = ((1/8 1/8) (3/8 -1/16 1/16)), new_infos = (((a) (b)) ((b) (c) (d))) and ties = (0 1 0 0 0)
    As another example, if rhythm is 1/16 1/4 -1/8 -1/4 1/16, and boxes are 1/4 1/4 1/4, then the algorithm will return (1/16 3/16 t) (1/16 -1/8 -1/16) (-3/16 1/16)
    See merge_rests_and_alltied_chords_from_separate_parameters() for a description of inputs.
    The function initializes and fills **new_rhythm, **new_infos, and **ties lllls.

    @ingroup        notation
    @param    rhythm    The rhythm as a plain sequence of rational durations
    @param    infos    All the information associated to each rhythmic duration (could be whatever you want: usually, it's a sublist for each note containing 
                    pitch, velocity, and then a list with breakpoints, graphics, slots).
    @param    ties    All the ties, one subllll for each rhythm element containing one long value for each note (1 or 0).
    @param    new_rhythm    The modified rhythm (initialized inside the function, you need to free it)
    @param    new_infos    The modified infos (initialized inside the function, you need to free it)
    @param    new_ties    The modified ties (initialized inside the function, you need to free it)
    @param    check_completeness If this is non-zero, the functions pads all boxes with rests if the content sums to less than the box dimension.
    @param  mark_created_info_upon_split    If non-zero, marks the llllelem in <new_info> created during split (the "tied" ones) with a WHITENULL l_thing field
    @return 0 if check_completeness is non-zero and some box aren't complete; 1 otherwise
 */
char split_rhythm_to_boxes(t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll *boxes, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, char check_completeness, char mark_created_info_upon_split, char ties_have_ids);


/**    Calls the note_compute_approximation() function on all the notes of a chord.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    also_put_show_accidental_to_false    If this is 1, all the t_note::show_accidental flag are set to false.
                                                in which case, you usually might want to call validate_accidentals_for_measure() after this
 */
void compute_note_approximations_for_chord(t_notation_obj *r_ob, t_chord *chord, char also_put_show_accidental_to_false);


/**    Calls the note_compute_approximation() function on all the notes of a measure.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
    @param    also_put_show_accidental_to_false    If this is 1, all the t_note::show_accidental flag are set to false.
                                                in which case, you usually might want to call validate_accidentals_for_measure() after this
 */
void compute_note_approximations_for_measure(t_notation_obj *r_ob, t_measure *measure, char also_put_show_accidental_to_false);        


/**    Parse or re-parse the accidentals for a given measure, and set all the t_note::show_accidental fields accordingly (depending on keys,
    accidental preferences, accidental patterns, clefs...).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
 */
void validate_accidentals_for_measure(t_notation_obj *r_ob, t_measure *measure);





#ifndef DOXYGEN_SHOULD_SKIP_THIS
// OBSOLETE
void check_tuplets(t_notation_obj *r_ob, t_llll *rhythm, t_llll *infos, t_llll *ties, t_llll **new_rhythm, t_llll **new_infos, t_llll **new_ties, t_llll **tuplets, long tuplet_group_offset, long *max_tuplet_group, char admit_dotted_tuplets, char max_dots);
#endif


/**    Tell if a chord is completely tied to the next one.
    @ingroup        notation
    @param    r_ob    The notation object (can be also NULL if no notation object is needed)
    @param    chord    The chord
    @param    within_measure    If this is non-zero, we only consider ties within the same measure (if the chord is completely tied to a chord in next measure, 0 is returned)
    @param    next_chord        If this is given, it'll be accounted for in case one of the chord's notes' tie_to fields was set to WHITENULL (= "tie to be defined").
                            In this case, we'll verify that there be a note in #next_chord which can be reached from the "WHITENULLed" note. Also, if #r_ob
                            is given and t_notation_obj::tie_assign_pitch field is nonzero, the #next_chord's note pitch will be corrected to be exactly
                            equal to the one of the note at the beginning of the tie.
                            If #next_chord is NULL, each WHITENULL in the t_note::tie_to field of the given chord will be accounted as a tie.
    @return            1 if the chord is completely tied to the next one, 0 otherwise
 */
char chord_is_all_tied_to(t_notation_obj *r_ob, t_chord *chord, char within_measure, t_chord *next_chord);


/**    Tell if a chord is completely tied to the previous one.
    @ingroup        notation
    @param    r_ob    The notation object (can be also NULL if no notation object is needed)
    @param    chord    The chord
    @param    within_measure    If this is non-zero, we only consider ties within the same measure (if the chord is completely tied to a chord in next measure, 0 is returned)
    @param    next_chord        If this is given, it'll be accounted for in case one of the chord's notes' tie_to fields was set to WHITENULL (= "tie to be defined").
                            In this case, we'll verify that there be a note in #next_chord which can be reached from the "WHITENULLed" note.
                            If #next_chord is NULL, each WHITENULL in the t_note::tie_to field of the given chord will be accounted as a tie.
    @return            1 if the chord is completely tied to the previous one, 0 otherwise
 */
char chord_is_all_tied_from(t_chord *chord, char within_measure);


/**    Tell if a chord is followed by a rest
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, we only consider chords within the same measure
    @return            1 if the chord is followed by a rest, 0 otherwise
 */
char is_chord_followed_by_rest(t_notation_obj *r_ob, t_chord *chord, char within_measure);


/**    Tell if a chord is preceded by a rest
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, we only consider chords within the same measure
    @return            1 if the chord is preceded by a rest, 0 otherwise
 */
char is_chord_preceded_by_rest(t_notation_obj *r_ob, t_chord *chord, char within_measure);


/**    Tell if a chord has at least one note starting a tie
    @ingroup        notation
    @param    chord    The chord
    @return            1 if the chord has at least one note starting a tie, 0 otherwise
 */
char chord_has_a_tie_to(t_chord *ch);


/**    Tell if a chord has at least one note ending a tie
    @ingroup        notation
    @param    chord    The chord
    @return            1 if the chord has at least one note ending a tie, 0 otherwise
 */
char chord_has_a_tie_from(t_chord *ch);


/** Tell if a chord bears dynamics sign
    @ingroup        notation
    @param    chord    The chord
    @return            1 if the chord has dynamics, 0 otherwise
 */
char chord_has_dynamics(t_chord *ch);


/**    Set the t_measure::need_check_ties fields for a given measure, as well as for the previous and next ones (if any).
    @ingroup        notation
    @param    measure    The measure
 */
void check_ties_around_measure(t_measure *measure);


/**    Get the first note of the sequence of tied notes containing a given note. If the given note has no ending ties, the note itself is returned.
    @ingroup        notation
    @param    note    The note
    @return    The first note tied to the given note.
 */
t_note *note_get_first_in_tieseq(t_note *note);


/**    Get the last note of the sequence of tied notes containing a given note. If the given note has no starting ties, the note itself is returned.
    @ingroup        notation
    @param    note    The note
    @return    The last note tied to the given note.
 */
t_note *note_get_last_in_tieseq(t_note *note);


/**    Get the symbolic duration of a sequence of completely tied notes (given any note in the sequence)
    @ingroup        notation
    @param    note    Any note in the sequence
    @return            The symbolic duration of the sequence of completely tied notes
 */
t_rational note_get_tieseq_symduration(t_note *note);


/**    Get the first selected note of the sequence of tied notes containing a given note. If the given note has no ending ties, the note itself is returned.
    @ingroup        notation
    @param  r_ob    The notation object
    @param    note    The note
    @return    The first selected note tied to the given note.
 */
t_note *note_get_first_selected_in_tieseq(t_notation_obj *r_ob, t_note *note);


/**    Get the last selected note of the sequence of tied notes containing a given note. If the given note has no starting ties, the note itself is returned.
    @ingroup        notation
 @param  r_ob    The notation object
    @param    note    The note
    @return    The last selected note tied to the given note.
 */
t_note *note_get_last_selected_in_tieseq(t_notation_obj *r_ob, t_note *note);


/**    Get the last chord of the sequence of completely-tied chords containing a given chord. If the given chord is not completely tied to the
    next one or to the previous one, the chord itself is returned.
     @ingroup        notation
    @param    chord    The chord
    @return            The last chord of the sequence of completely-tied chords (if any, the chord itself otherwise).
 */
t_chord *chord_get_last_in_tieseq(t_chord *chord);


/**    Get the first chord of the sequence of completely-tied chords containing a given chord. If the given chord is not completely tied to the
    next one or to the previous one, the chord itself is returned.
    @ingroup        notation
    @param    note    The chord
    @return            The first chord of the sequence of completely-tied chords (if any, the chord itself otherwise).
 */
t_chord *chord_get_first_in_tieseq(t_chord *chord);


/**    Get the symbolic duration of a sequence of completely tied chords (given any chord in the sequence)
    @ingroup        notation
    @param    note    Any chord in the sequence
    @return            The symbolic duration of the sequence of completely tied chords
 */
t_rational chord_get_tieseq_symduration(t_chord *chord);


/**    Get the last chord of the sequence of completely tied chords (i.e. whose notes are all completely tied to each other) 
    containing a given chord. If the given chord is not completely tied to the next one, the same chord is returned.
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return    The last chord completely tied to the given chord.
 */
t_chord *last_all_tied_chord(t_chord *chord, char within_measure);


/**    Get the first chord of the sequence of completely tied chords (i.e. whose notes are all completely tied to each other) 
    containing a given chord. If the given chord is not completely tied to the previous one, the same chord is returned.
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return    The first chord completely tied to the given chord.
 */
t_chord *first_all_tied_chord(t_chord *chord, char within_measure);


/**    Get the overall symbolic duration of a sequence of completely tied chords containing a given chord.
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return    The overall symbolic duration of the sequence of completely tied chords containing a given chord. This will
            coincide with the chord duration if such chord is neither completely tied to its next nor to its previous one.
 */
t_rational get_all_tied_chord_sequence_abs_r_duration(t_chord *chord, char within_measure);


/**    Get the overall duration (in milliseconds) of a sequence of completely tied chords containing a given chord.
    @ingroup        notation
    @param    chord    The chord
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return    The overall duration in milliseconds of the sequence of completely tied chords containing a given chord. This will
                coincide with the chord duration if such chord is neither completely tied to its next nor to its previous one.
 */
double get_all_tied_chord_sequence_duration_ms(t_chord *chord, char within_measure);


//TBD
double get_all_tied_note_sequence_duration_ms(t_note *nt);
t_rational get_all_tied_note_sequence_abs_r_duration(t_note *nt);

/**    Get the last rest in a sequence of rest containing #chord. If #chord is not a rest, NULL is returned
    @ingroup                notation
    @param    chord            The rest
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return                    The last rest of the sequence, or NULL if none.
 */
t_chord *rest_get_last_in_seq(t_chord *chord, char within_measure);


/**    Get the first rest in a sequence of rest containing #chord. If #chord is not a rest, NULL is returned
    @ingroup                notation
    @param    chord            The rest
    @param    within_measure    If this is non-zero, only chords within the same measure of the given chords are considered.
    @return                    The first rest of the sequence, or NULL if none.
 */
t_chord *rest_get_first_in_seq(t_chord *chord, char within_measure);

/**    Get the number of notes of a chord which have a starting tie.
    @ingroup        notation
    @param    chord    The chord
    @return    The number of notes in the chord which start a tie.
 */
long get_num_tied_to_notes(t_chord *chord);


/**    Get the number of notes of a chord which have an ending tie.
    @ingroup        notation
    @param    chord    The chord
    @return    The number of notes in the chord which end a tie.
 */
long get_num_tied_from_notes(t_chord *chord);


/**    Tell if a measure has no non-rest-chords (is empty).
    @ingroup        notation
    @param r_ob     The notation object
    @param    measure    The measure
    @param account_for_slots    If non-zero, the measure is NOT empty if some of the rests have non-empty slots
    @return            1 if the measure is empty, 0 otherwise.
 */
char is_measure_empty(t_notation_obj *r_ob, t_measure *measure, char account_for_slots = true);


/**    Tell if a measure is composed by a single centered whole-note rest (or is completely empty: no rests at all).
    @ingroup        notation
    @param    measure    The measure
    @return            1 if the measure is composed by a single whole-note rest (or is completely empty), 0 otherwise.
    @remark         If the t_notation_obj:whole_rests_in_empty_measures is not set to 1, this will return 0.
 */
char is_measure_single_whole_rest(t_notation_obj *r_ob, t_measure *measure);


/**    Get a given symbolic rational duration representable (drawable) on screen. For instance, converts a duration such as 5/16 into 1/4 + 1/16.
    The algorithm takes into account the onset of the duration to be represented inside the rhythmic level, so that it can choose the best representation.
    For instance, if 5/16 has an onset of 1/16, the best representation will be 3/16 + 2/16, instead.
    @ingroup        notation
    @param    duration    The duration to be represented
    @param    onset        The onset of the duration to be represented inside the rhythmic level.
    @param    box_length    The overall length of the rhythmic level
    @param    max_dots    The maximum number of allowed dots
    @param    depth    This is the depth of the stack when this function is called. You might probably want to always set it to 1: 
                    it is used then internally to avoid too long recursions.
    @param    irregular    If this flag is non-zero, a standard decomposition will be made for the duration, ignoring its onset. This decomposition does not 
                        require recursion, so that 5/16 will always be written as 1/4+1/16. Otherwise, the decomposition is recursive and takes into
                        account the onset of the element to be decomposed, so that, for instance, if 5/16 has an onset of 2/16, it'll be decomposed 
                        as 2/16+3/16 instead.
    @return            1 if the measure is composed by a single rest (or is completely empty), 0 otherwise.
 */
t_llll *get_duration_drawable(t_rational duration, t_rational onset, t_rational box_length, long max_dots, long depth, char irregular);


/**    Given a list of rational durations, gather as many as possible if their sum is still "drawable" as a single chord.
    For instance, given (1/4 1/8 1/32) and <max_dots> = 1, the result will be (3/8 1/32), since 3/8 can be represented by a single chord with a dot.
    @ingroup        notation
    @param    llll    The llll to be parsed and modified. BEWARE: this function is destructive: modifies the incoming llll. 
    @param    max_dots    The maximum allowe number of dots for the representation.
 */
void llll_gather_if_drawable(t_llll *ll, char max_dots);


/**    Convert a denominator into the most natural tuplet ratio of a tuplet representing a duration with such denominator.
    For instance, it converts the denominator 12 into 2/3, since 1/12 is representable as a 8th note with a 3:2 tuplet.
    @ingroup        notation
    @param    denominator    The denominator
    @return    The most natural tuplet ratio corresponding to the denominator.
 */
t_rational denominator_to_natural_tuplet_ratio(long denominator);


/**    Re-count the number of chords inside a measure, and then update the t_measure::num_chords field accordingly.
    @ingroup        notation
    @param    measure    The measure
    @remark        We STRONGLY DISCOURAGE you to use this function, which should be an "emergency function" for very few cases. 
                Any operation on a measure should, instead, be accurately synchronized with the t_measure::num_chords field. 
 */
void update_measure_chordnumbers(t_measure *measure);


/**    Set a time signature for a given measure.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
    @param    ts        The time signature
 */
void measure_set_ts(t_notation_obj *r_ob, t_measure *measure, t_timesignature *ts);


/**    Properly fills the t_measure::boxes field (which is an llll containing all the standard base-level subdivision boxes) according to the
    time signature (unless custom boxing for the measure is required, which is: if the t_measure::custom_boxing flag is set).
    In any case, the function verifies that the boxes properly and exactly cover the whole measure.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
 */
void synchronize_boxes_for_measure(t_notation_obj *r_ob, t_measure *measure);


/**    Calculate the graphical representation fields for the chord, namely the t_chord::num_dots and t_chord::figure fields.
    Those take into account, of course, the tuplet ratio of the chord, if previously stored inside the t_chord::overall_tuplet_ratio field. 
    @ingroup        notation
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    warn_when_weird    If this is non-zero, when non-drawable chords are introduced, a warning message is displayed in the Max window.
                            Non-drawable chords are chords whose duration cannot be represented with a single chord, but needs a tied sequence of chords.
 */
void compute_chord_figure(t_notation_obj *r_ob, t_chord *chord, char warn_when_weird);


/**    Compute the figures for all chords inside a measure, which is: call the compute_chord_figure() function for all such chords.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
    @see    compute_chord_figure()
 */
void compute_measure_chords_figure(t_notation_obj *r_ob, t_measure *measure);



/**    Find the nearest chord of a given measure with respect to an unscaled x pixel position.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
    @param    ux        The reference unscaled x pixel position.
    @return            The chord inside the <measure> which is graphically nearest to the reference ux position, or NULL if none.
 */
t_chord *find_ux_nearest_chord_in_measure(t_notation_obj *r_ob, t_measure *measure, double ux);


/**    Find the nearest chord of a given scorevoice with respect to an unscaled x pixel position.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    voice    The scorevoice
    @param    ux        The reference unscaled x pixel position.
    @return            The chord inside the <scorevoice> which is graphically nearest to the reference ux position, or NULL if none.
 */
t_chord *find_ux_nearest_chord_in_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, double ux);


/**    Find the nearest non-rest chord of a given scorevoice with respect to an unscaled x pixel position.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    voice    The scorevoice
    @param    ux        The reference unscaled x pixel position.
    @return            The non-rest chord inside the <scorevoice> which is graphically nearest to the reference ux position, or NULL if none.
 */
t_chord *find_ux_nearest_nonrest_chord_in_scorevoice(t_notation_obj *r_ob, t_scorevoice *voice, double ux);


/**    Find the chord of a given roll voice whose onset is nearest to a given milliseconds position.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    voice    The scorevoice
    @param    ms        The milliseconds position.
    @return            The chord inside the <rollvoice> which is nearest to the millisecond position, or NULL if none.
 */
t_chord *find_ms_nearest_chord_in_rollvoice(t_notation_obj *r_ob, t_rollvoice *voice, double ms);


/**    Get the first note (from lowest to highest) inside the chord which doesn't have a tie ending to it.
    @ingroup        notation
    @param    chord    The chord
    @return    The first note inside the chord which doesn't have a tie ending, or NULL if none.
 */
t_note* note_get_first_non_tiedfrom(t_chord *chord);


/**    Tell if the note corresponding to a given cents is tied, starting from a list of midicents and a list of ties.
    @ingroup            notation
    @param    ties        The list of ties
    @param    mc            The    list of midicents (in 1-to-1 correspondance with the list of ties)
    @param    this_mc        Cents of the note we want to know about
    @param    tolerance    Admitted tolerance in midicents for the note to be found.
    @param use_lthing_marking  1/0 flag to mark found notes in the l_thing field of the ties llllelem as WHITENULL, and to only consider unmarked elements
    @return                1 if a note having cents #this_mc (up to #tolerance) is found to have a starting tie; 0 otherwise. If the ties or midicents are empty it returns -1. 
 */
long get_tie_corresponding_to_mc(t_llll *ties, t_llll *mc, double this_mc, double tolerance, double use_lthing_marking);


/**    Get the tempo at a given time point. This takes into account tempo changes and tempo interpolations.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    voice        The reference scorevoice (since voices may have different tempi) 
    @param    tp            The timepoint in which the tempo has to be retrieven.
                            If the timepoint voice is not equal to the scorevoice #voice, then the timepoint is computed with respect to
                            another voice
    @param    figure_tempo_value        Pointer which will be filled with the tempo value with respect to the followingly retrieven tempo figure (e.g., in 3/8 = 72, this will be filled with 72)
    @param    tempo_figure            Pointer which will be filled with the tempo figure (the symbolic duration to which the tempo is referred, e.g. in 3/8 = 72 this will be filled with 3/8)
    @param    tempo_value                Pointer which will be filled with the tempo value with respect to 1/4 note (e.g. in 3/8 = 72 this will be filled with 108)
    @param    interpolation            Pointer which will be filled with 1 if a tempo interpolation is ongoing, 0 otherwise
    @remark    See #t_tempo to know more about tempo fields.
 */
void get_tempo_at_timepoint(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp, t_rational *figure_tempo_value, t_rational *tempo_figure, t_rational *tempo_value, char *interpolation);

// TBD
void get_timesig_at_timepoint(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp, t_timesignature *timesig);


/**    Tell if a chord is a whole-measure-rest (which means: it is a rest, and it is the only rest in the measure).
    @ingroup        notation
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if the chord is a rest and the only rest in the measure, 0 otherwise.
 */
char is_chord_a_whole_measure_rest(t_notation_obj *r_ob, t_chord *chord);


/**    Tell if a barline exists in the same position in all the voices of the score.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    barline    The barline
    @return            1 if the barline exists in the same position in all the voices of the score, 0 otherwise.
 */
char is_barline_tuttipoint(t_notation_obj *r_ob, t_measure_end_barline *barline);

//TBD
char is_barline_tuttipoint_with_same_ts(t_notation_obj *r_ob, t_measure_end_barline *barline);
char is_tuttipoint_with_same_ts(t_notation_obj *r_ob, t_tuttipoint *tpt);


/**    Obtain all the barlines falling together with a given barline.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    ref_barline    The reference barline
    @param    barline        Array of barlines which must be allocated of #CONST_MAX_VOICES barlines, and which will be filled with all the tuttipoint barlines
                        (one for each voice
    @return                1 if the barline is a tuttipoint barline, 0 otherwise.
    @remark                This function returns such barlines only if such barline is a tuttipoint, i.e. all the measure are together on that barline.
                        Otherwise 0 is returned
 */
char get_all_tuttipoint_barlines(t_notation_obj *r_ob, t_measure_end_barline *ref_barline, t_measure_end_barline **barline);

// TBD
t_llll *measure_get_aligned_measures_as_llll(t_notation_obj *r_ob, t_measure *meas);


/**    Set the t_chord::need_recompute_parameters flags for all the chords in a given measure, and also sets the t_notation_obj::need_perform_analysis_and_change flag.
    Those flags will force the chord graphic parameters to be recomputed at the next paint cycle.
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
 */
void recompute_all_measure_chord_parameters(t_notation_obj *r_ob, t_measure *measure);


/**    Sets the flag to recompute rhythmic tree and graphical parameters for a given measure.
    This function actually properly sets the recalculation flags, and then the actual recomputing will be done inside the next paint cycle.
    The function calls recompute_all_measure_chord_parameters() and check_ties_around_measure(), sets the t_tuttipoint::need_recompute_spacing flag
    to #k_SPACING_RECALCULATE, sets the t_notation_object::need_perform_analysis_and_change flag, recomputes the t_notation_objec::domain_ux.
    If #also_recompute_beamings is true, it also sets t_measure::need_recompute_beamings and t_measure::need_check_autocompletion; otherwise it just
    sets #t_measure::need_recompute_beams_positions.
    @ingroup                            notation
    @param    r_ob                        The notation object
    @param    meas                        The measure
    @param    also_recompute_beamings        If this is non-zero, the beamings and the measure autocompletion are also reparsed. Otherwise, the beamings are kept
                                        as they are, and only the notes positions are reparsed.
 */
void recompute_all_for_measure(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings);

// TBD
void recompute_all_for_measure_ext(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings, char also_check_autocompletion);


/**    As recompute_all_for_measure(), but also applies to all corresponding measures in the voice ensemble.
    @ingroup                            notation
    @param    r_ob                        The notation object
    @param    meas                        The measure
    @param    also_recompute_beamings        If this is non-zero, the beamings and the measure autocompletion are also reparsed. Otherwise, the beamings are kept
                                        as they are, and only the notes positions are reparsed.
 */
void recompute_all_for_measures_in_voiceensemble(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings);


/**    Apply recompute_all_for_measure() not only on the given measure, but also on the previous and next one (if any).
    @ingroup                            notation
    @param    r_ob                        The notation object
    @param    meas                        The measure
    @param    also_recompute_beamings        If this is non-zero, the beamings and the measure autocompletion are also reparsed. Otherwise, the beamings are kept
 as they are, and only the notes positions are reparsed.
 */
void recompute_all_for_measure_and_neighbor_measures(t_notation_obj *r_ob, t_measure *meas, char also_recompute_beamings);


/**    Recalculate the graphic parameters for a given tuttipoint region.
    This function calls recompute_all_for_measure() on all measures of a tuttipoint region
    @ingroup                            notation
    @param    r_ob                        The notation object
    @param    tpt                            The tuttipoint (starting the tuttipoint region)
    @param    also_recompute_beamings        If this is non-zero, the beamings and the measure autocompletion are also reparsed. Otherwise, the beamings are kept
                                        as they are, and only the notes positions are reparsed.
 */
void recompute_all_for_tuttipoint_region(t_notation_obj *r_ob, t_tuttipoint *tpt, char also_recompute_beamings);


/**    Quick'n'dirty way to recalculate all measure and chord graphic parameters (for bach.score) or chord graphic parameters (for bach.roll).
    For bach.roll: this sets the t_chord::need_recompute_parameters flags for all the chords in a given measure, 
    forcing the chord parameters to be recomputed at the next paint cycle.
    For bach.score: this calls recompute_all_for_measure() for all measures.
    In any case, the t_notation_obj::need_perform_analysis_and_change flag is set, then the notationobj_invalidate_notation_static_layer_and_redraw() function is called
    in order to repaint (all parameters will be actually calculated inside the paint cycle).
    @ingroup                                notation
    @param    r_ob                            The notation object
    @param    also_recompute_beamings            If this is set to 1, all beamings are also recalculated, i.e. the t_measure::need_recompute_beamings flag
                                            is set for all measures.
 */
void implicitely_recalculate_all(t_notation_obj *r_ob, char also_recompute_beamings);


/**    Tell if all chords inside a measure are selected (or the measure itself is selected).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    meas        The measure
    @return        1 if all chords inside the measure are selected, or the measure itself is selected; 0 otherwise.
 */
char are_all_chords_in_measure_selected(t_notation_obj *r_ob, t_measure *meas);    


/**    Properly fills the t_chord::r_sym_onset fields of each chord inside a given measure.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    meas        The measure
 */
void recompute_measure_r_onsets(t_notation_obj *r_ob, t_measure *measure);


/**    Tell if a given notation item is an "ancestor" of another notation item (which means: if it's its father, grand-father, great-grand-father...)
    @ingroup            notation
    @param    r_ob        The notation object
    @param    dad            The possible "father" (or grand-father, or great-grand-father...)
    @param    son            The possible "son" (or grand-son, or great-grand-son...)
 */
char notation_item_is_ancestor_of(t_notation_obj *r_ob, t_notation_item *dad, t_notation_item *son);

// TBD
t_notation_item *notation_item_get_ancestor_of_at_least_a_certain_type(t_notation_obj *r_ob, t_notation_item *item, long parent_type);


/**    Delete a chord from a given voice (for bach.roll only).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    chord        The chord
    @param    update_chord_play_cursor_to_this_chord_if_needed    Chord to which the chord play cursor should be set if the current cursor is on the chord to be deleted
    @param    also_recompute_total_length                            Flag to tell if we need to also recalculate the total length of the bach.roll
    @return                1 if the function check_correct_scheduling() should be called, because the scheduling is now invalid; 0 otherwise
 */
char chord_delete(t_notation_obj *r_ob, t_chord *chord, t_chord *update_chord_play_cursor_to_this_chord_if_needed, char also_recompute_total_length);


/**    Fill the t_measure::r_total_duration_sec and t_measure::total_duration_ms fields for a measure (for bach.score only).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    meas        The measure.
 */
void calculate_rat_measure_durations_ms(t_notation_obj *r_ob, t_measure *meas);


/**    Fill the t_measure::r_total_duration_sec and t_measure::total_duration_ms fields for all measure of a given scorevoice (for bach.score only).
    @ingroup            notation
    @param    r_ob        The notation object
    @param    voice        The scorevoice.
 */
void calculate_rat_measure_durations_ms_for_voice(t_notation_obj *r_ob, t_scorevoice *voice);


/**    Calculate the rational duration (in seconds) between two timepoints.
    @ingroup            notation
    @param    r_ob        The notation object
    @param    voice        The scorevoice.
    @param    tp1            The first timepoint
    @param    tp2            The second timepoint
    @remark    The t_timepoint::voice_num fields of the timepoints are ignored, since the #voice is given explicitely as previous input parameter.
    @return    The distance between the two timepoints, in seconds (as a rational number)
 */
t_rational get_rat_durations_sec_between_timepoints(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp1, t_timepoint tp2);

double get_duration_ms_between_timepoints(t_notation_obj *r_ob, t_scorevoice *voice, t_timepoint tp1, t_timepoint tp2);

/**    Calculate the symbolic rational duration between two timepoints.
    @ingroup            notation
    @param    voice        The scorevoice.
    @param    tp1            The first timepoint
    @param    tp2            The second timepoint
    @remark    The t_timepoint::voice_num fields of the timepoints are ignored, since the #voice is given explicitely as previous input parameter.
    @return    The distance between the two timepoints, in musical units (symbolic rational duration).
 */
t_rational get_sym_durations_between_timepoints(t_scorevoice *voice, t_timepoint tp1, t_timepoint tp2);


/**    Obtain the global symbolic duration of a measure
    @ingroup            notation
    @param    meas        The measure.
    @remark    This duration is the duration defined by the measure time signature, and NOT the overall duration of the chords contained in the measure (this could be
            in general different!). See measure_get_content_sym_duration(). For instance, a 6/8 measure has symbolic duration of 3/4, even if it might contain just 
            a single 1/8 chord.
 */
t_rational measure_get_sym_duration(t_measure *meas);


/**    Obtain the global symbolic duration of a measure, given the time signature
    @ingroup            notation
    @param    ts          The time signature
    @seealso            measure_get_sym_duration()
 */
t_rational ts_to_sym_duration(t_timesignature *ts);


/**    Obtain the overall symbolic duration of all the chords contained in a measure
    @ingroup            notation
    @param    meas        The measure.
    @remark    This duration is the duration defined by the measure content, and NOT by the time signature. See measure_get_sym_duration().
            A measure is completed only if measure_get_content_sym_duration() and measure_get_sym_duration() coincide. 
 */
t_rational measure_get_content_sym_duration(t_measure *measure);


/**    Get the timepoint corresponding to the beginning of the score, for the first voice.
    @ingroup    notation_utilities
    @return        The "zero-timepoint" (corresponding to the beginning of the score, for the first voice).
 */
t_timepoint get_zero_timepoint();


/**    Tell if at least one note in a chord starts a tie
    @ingroup        notation
    @param    ch        The chord
    @return            1 if at least one note in the chord starts a tie, 0 otherwise.
 */
char has_chord_at_least_one_tie(t_chord *ch);



/** Obtain the (interpolated) tempo between two tempi, at a given timepoint of a scorevoice.
    @remark     Beware: this is different than a linear interpolation: it is linear with respect to 1/tempo, 
                due to reasons exposed in the bach algorithms documentation, chapter "Tempo functions: absolute and symbolic time"
    @ingroup    tempi_operations
    @param    voice        The scorevoice
    @param    tp            The timepoint where the tempo must be found. The voice field is ignored, since the given #voice is used instead.
    @param    tempo_L        The tempo at left of #tp
    @param    tempo_R        The tempo at right of #tp
    @return                The interpolated tempo at the position #tp, referred to the standard 1/4 tempo figure
    @remark                The result might be approximated if the interpolation yields too big numbers
    @see                get_intermediate_tempo_double()
 */
t_rational get_intermediate_tempo(t_scorevoice *voice, t_timepoint tp, t_tempo *tempo_L, t_tempo *tempo_R);


/** Obtain the double-precision (interpolated) tempo between two tempi, given a parameter ranging from 0 to 1.
    @remark     Beware: this is different than a linear interpolation: it is linear with respect to 1/tempo, 
                due to reasons exposed in the bach algorithms documentation, chapter "Tempo functions: absolute and symbolic time"
    @ingroup    tempi_operations
    @param    D            A parameter from 0 to 1, determining the interpolation (0 being the left tempo, 1 being the right one).
    @param    tempo_L        The tempo at left of #tp
    @param    tempo_R        The tempo at right of #tp
    @return                The double-precision interpolated tempo corresponding to the parameter #D
    @see                get_intermediate_tempo()
 */
double get_intermediate_tempo_double(double D, t_tempo *tempo_L, t_tempo *tempo_R);


/** Obtain the amount of time spent from the position at which a given tempo is to the position at which another tempo is (just considering the two tempi, ignoring
    any other tempo which might be in between). This corresponds to the (trapece) integration of the linear segment going from one tempo to the other.
    @ingroup    tempi_operations
    @param    voice                The scorevoice
    @param    tempo_L_value        The value of the left tempo, referred to the standard 1/4 tempo figure
    @param    tempo_L_tp            The timepoint of the left tempo
    @param    tempo_R_value        The value of the right tempo, referred to the standard 1/4 tempo figure
    @param    tempo_R_tp            The timepoint of the right tempo
    @return                        The amount of time (in seconds) spent from the #tempo_L_tp timepoint to the #tempo_R_tp timepoint 
 */
t_rational get_tempo_trapece_sec(t_scorevoice *voice, t_rational tempo_L_value, t_timepoint tempo_L_tp, t_rational tempo_R_value, t_timepoint tempo_R_tp);


/** Get the header from a gathered-syntax representation of a roll or a score.
    @ingroup    notation_utilities
    @param    whole_content    The gathered syntax representation of the roll or score
    @param    keep_notation_obj_router    Toggles the preservation of the "roll" or "score" symbol, or any other routing symbol
    @return        The header of the gathered syntax representation    
    @remark        This function clones the header, and hence does not destroy the header in the #ll, which remains untouched.
    @see    get_body()
*/
t_llll *get_header(t_llll *whole_content, char keep_notation_obj_router);


/** Get the body from a gathered-syntax representation of a roll or a score (all the representation, ignoring the header)
    @ingroup    notation_utilities
    @param    ll    The gathered syntax representation of the roll or score
    @return        The body of the gathered syntax representation    
    @remark        This function clones the header, and hence does not destroy the header in the #ll, which remains untouched.
    @see    get_header()
*/
t_llll *get_body(t_llll *ll);


/** Find the first llllelem of the body of a gathered-syntax representation of roll or score (which is: the first element which does not belong to the header).
    @ingroup    notation_utilities
    @param    ll    The gathered syntax representation of the roll or score
    @return        The first llllelem representing the body of the score
    @see    get_header()
    @see    get_body()
    @see    header_offset()
*/
t_llllelem *get_first_nonheader_elem(t_llll *ll);


/** Take as argument the first llllelem of a gathered syntax representation of a roll or score, and change it with the first llllelem corresponding to the body.
    It returns the number of llllelems belonging to the header.
    @ingroup                        notation_utilities
    @param    first_nonheader_elem    A pointer which must be given filled with the HEAD of the gathered syntax representation of a roll or score, and which will be then
                                    filled with the first llllelem in that representation corresponding to the object body (or NULL if none).
    @return        The number of llllelems in the header of the gathered syntax representation
    @see    get_header()
    @see    get_body()
    @see    get_first_nonheader_elem()
*/
long header_offset(t_llllelem **first_nonheader_elem); 


/** Fill the t_chord::r_measure_onset_sec and t_tempo::r_measure_onset_sec fields for all chords and tempi of a given measure. Those fields represent the 
    rational onsets (in seconds) of the chords and tempi with respect to the beginning of the measure
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
*/
void calculate_chords_and_tempi_measure_onsets(t_notation_obj *r_ob, t_measure *measure);


/** Set the t_chord::float_steps field to zero for all chords inside the measure. (This correspond to resetting to zero all the number of floating steps of the rests.) 
    @ingroup        notation
    @param    r_ob    The notation object
    @param    measure    The measure
*/
void reset_floatsteps(t_notation_obj *r_ob, t_measure *measure);


/** Obtain the length of a given portion of roll from its gathered-syntax.
    The function expects to have a plain list of voices, with a plain list of chords (as for bach.roll), without any header.
    @ingroup                            notation_utilities
    @param    chords_in_gathered_syntax    The chords represented in llll syntax.
    @return                                The length of the portion of score with the chords.
*/
double get_max_rhythm_length(t_llll *chords_in_gathered_syntax);


/** Obtain the maximum duration of all the notes of a chord, in milliseconds.
    @ingroup notation
    @param  r_ob             The notation object
    @param  chord           The chord
    @param  accurate     Accurate processing
    @return                The duration of the longest note of the chord, in milliseconds
*/
double chord_get_max_duration(t_notation_obj *r_ob, t_chord *chord, bool accurate = false);


/** Obtain the maximum velocity of all the notes of a chord.
    @ingroup notation
    @param    r_ob        The notation object
    @param    chord        The chord
    @return                The velocity of the loudest note in the chord
 */
long chord_get_max_velocity(t_notation_obj *r_ob, t_chord *chord);


// -----------------------------------
// PLAY AND SCHEDULING
// -----------------------------------

/** Make sure that the next scheduled event is the one which should be scheduled. If it's not the case, change the scheduled event, rescheduling another one properly.
    This function is called during playtime at any time a new stuff is added or moved or changed: e.g. if we add a note between the current playhead position and the next
    scheduled chord, the algorithm will do its best to reschedule this note and to play it properly before the next one.
    @ingroup play
    @param    r_ob        The notation object
    @param    lock_general_mutex    If this is non-zero, the t_notation_obj::c_general_mutex mutex is locked and unlocked before checking and changing
*/
void check_correct_scheduling(t_notation_obj *r_ob, char also_lock_general_mutex);


/** Update the t_notation_obj::playhead_cant_trespass_loop_end field, telling us if the playhead can or cannot be AFTER the end of the loop.
    This is performed before starting playing: via this, we know for instance that if the playhead start is BEFORE the end of the (visible) loop, 
    the loop end will never be trespassed; otherwise if it is AFTER the end of the loop, the play will continue linearly to the end of the roll or score. 
    @ingroup play
    @param    r_ob        The notation object
*/
void update_playhead_cant_trespass_loop_end(t_notation_obj *r_ob);


/** Obtain the next notation item which is supposed to be played.
    @ingroup play
    @param    r_ob        The notation object
    @param    current_ms    The last scheduled time or the "current" time (in milliseconds), in any case: a time limit BEFORE WHICH everything
                        is supposed to have been already properly scheduled, or ignored.
    @return                The next notation item which should be played
*/
t_notation_item *get_next_item_to_play(t_notation_obj *r_ob, double current_ms);


/** Check if some of the notes and chords which were played (i.e. had their t_chord::played and t_note::played fields set) have ended playing, and should be
    marked as non-played, in order to be represented as standard notes and not as "green" notes at paint time.
    @ingroup play
    @param    r_ob        The notation object
    @param    current_ms    The "current" time (in milliseconds).
*/
void check_unplayed_notes(t_notation_obj *r_ob, double current_ms);





// -----------------------------------
// INTERFACE CHANGES
// -----------------------------------

/**    Change the clef of a specific voice
    @ingroup                voice_attributes
    @param    r_ob            The notation object
    @param    voice            The voice
    @param    new_clef        The new clef as a #e_clefs element
    @param    also_add_undo_tick    If this is non-zero, an undo tick is properly added.
 */
void change_single_clef(t_notation_obj *r_ob, t_voice* voice, long new_clef, char also_add_undo_tick);


/**    Change the cents of a note, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new cents of the note (as a single element).
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_cents        The llll containing the new cents, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_note_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_cents);


/**    Change the cents of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain one element for each note. If less are given, the last one is padded.
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_cents        The llll containing the new cents, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_cents);

// TBD, Same, with pitches
char change_chord_pitch_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_pitch);
char change_note_pitch_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_pitch);

// TBD, Same, with pitches/or/cents
char change_chord_poc_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_poc);
char change_note_poc_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_poc);


/**    Change the cents of a pitch breakpoint, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    @ingroup interface
    @param    r_ob            The notation object
    @param    bpt            The pitch breakpoint
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_cents        The llll containing the new cents, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_breakpoint_cents_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_cents);


/**    Change the duration of a note, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new note duration (as a single element).
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_duration    The llll containing the new duration, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_note_duration_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *chord, t_lexpr *lexpr, t_llll *new_duration);


/**    Change the duration of the notes of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain one element for each note. If less are given, the last one is padded.
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_duration    The llll containing the new durations, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_duration_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_duration);

/**    Change the symbolic duration of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_duration    The llll containing the new symbolic duration, or NULL if none
    @param    autoadapt_ts      If non-zero, the time signature of the measure will be adapted according to the duration change
                                If it is 1, the time signature is adapted when it needs to be increased, if it is 2 when it needs to be decreased, if it is 3, in both cases
    @param    autoadapt_scope   Sets the scope for adapting the time signatures: 0 = this measure only, 1 = all synchronous measures
    @param    autoadapt_simplify If non-zero, will allow simplifying numerator and denominator of new time signature (only meaningful if #adapt_measureinfo is non-zero)
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_symduration_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_duration, char autoadapt_ts, char autoadapt_scope, char autoadapt_simplify);


/**    Change the position of a note tail, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new note tail position in milliseconds (as a single element).
    The "legato", "legatotrim", "legatoextend", "glissando", "glissandotrim", "glissandoextend" symbols are also allowed.
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_tail        The llll containing the new tail position in milliseconds, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_note_tail_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_tail);


/**    Change the position of the tails of the notes of a chord,based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain one element for each note (if less are given, the last one is padded) or a single "legato" symbol.
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_tail        The llll containing the new tail positions in milliseconds, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_tail_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_tail);


/**    Change the midicents of the tail of a given note in order to have it matching the midicents of the following note (i.e. obtain a glissando)
    @param    r_ob            The notation object
    @param    note            The note
    @param  slope           The slope of the glissando (-1. to 1., 0, being linear)
 */
void note_change_tail_for_glissando_till_next(t_notation_obj *r_ob, t_note *note, double slope);


/**    Change the onset of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new chord onset in milliseconds (as a single element).
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_onset        The llll containing the new onset position in milliseconds, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_onset_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_onset);


// Undocumented, troublesome!!!!
// Among other things, it depends on selected chords order, which is usually undefined!
char change_chord_ioi_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_ioi);


/**    Change the onset of a pitch breakpoint, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    @ingroup interface
    @param    r_ob            The notation object
    @param    bpt             The pitch breakpoint
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_onset        The llll containing the new onset position in milliseconds, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_breakpoint_onset_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_onset);

char change_breakpoint_onset(t_notation_obj *r_ob, t_bpt *bpt, double new_onset);


/**    Change the velocity of a note, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new note velocity (as a single element).
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_velocity    The llll containing the new velocity, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_note_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_velocity);


/**    Change the velocity of a breakpoint, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new note velocity (as a single element).
    @ingroup interface
    @param    r_ob            The notation object
    @param    bpt             The breakpoint
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_velocity    The llll containing the new velocity, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_breakpoint_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_bpt *bpt, t_lexpr *lexpr, t_llll *new_velocity);


/**    Change the velocities of the notes of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain one element for each note (if less are given, the last one is padded)
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_velocity    The llll containing the new velocities, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_velocity_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_velocity);


/**    Change the velocity of all the selected elements of a certain amount (given as difference with the existing velocities).
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    delta_velocity    The velocity difference to be added to existing elements' velocities.
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_selection_velocity(t_notation_obj *r_ob, double delta_velocity);


/**    Convert the tie parameter of a note into a numeric parameter: 0 = no tie, 1 = starting tie, 2 = ending tie, 3 = both.
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @return                    The tie as an integer (0 = no tie, 1 = starting tie, 2 = ending tie, 3 = both)
 */
long tie_to_long(t_notation_obj *r_ob, t_note *note);


/**    Assign the ties to a note starting from an integer value (0 = no tie, 1 = starting tie, 2 = ending tie, 3 = both)
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    new_tie         The new ties as integer value
 */
void assign_tie_from_long(t_notation_obj *r_ob, t_note *note, long new_tie);


/**    Change the tie of a note, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain only the new note tie (as a single element).
    Ties are 0 = no tie, 1 = starting tie, 2 = ending tie, 3 = both.
    @ingroup interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_tie         The llll containing the new velocity, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_note_tie_from_lexpr_or_llll(t_notation_obj *r_ob, t_note *note, t_lexpr *lexpr, t_llll *new_tie);


/**    Change the ties of the notes of a chord, based on a valid lexpr or (if such lexpr is NULL) on the content of an llll.
    The llll is supposed to contain one element for each note (if less are given, the last one is padded).
    Ties are 0 = no tie, 1 = starting tie, 2 = ending tie, 3 = both.
    @ingroup interface
    @param    r_ob            The notation object
    @param    chord            The chord
    @param    lexpr            The lexpr object, or NULL if none
    @param    new_tie         The llll containing the new ties, or NULL if none
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_chord_tie_from_lexpr_or_llll(t_notation_obj *r_ob, t_chord *chord, t_lexpr *lexpr, t_llll *new_tie);



/**    Change the slope of all the selected breakpoints (note tails included) of a certain amount (given as difference with the existing slopes).
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    delta_slope_abs    The absolute value of the slope to add or substract    
    @param    direction        The GRAPHICAL direction of the curve shifting: 1 being UPWARDS, -1 being DOWNWARDS (0 being no change at all).
    @return                    1 if something has been changed, 0 otherwise.
    @remark                    We stress that the quantity #delta_slope_abs â€¢ #direction is NOT the real amount of the slope which is added but only the graphical one.
                            This function, indeed handles the fact that (depending on the breakpoints' positions) while dragging UP the curve, the slope might DECREASE, and vice versa.
                            This is why the arguments are separated into an absolute value of the amount of the slope to add, and then a GRAPHICAL direction ("up" or "down") 
                            in which this addition must be performed.
 */
char change_selection_breakpoint_slope(t_notation_obj *r_ob, double delta_slope_abs, char direction);



/**    Change the slope of a single breakpoint of a certain amount (given as difference with the existing slopes).
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    bpt             The breakpoint
    @param    delta_slope_abs    The absolute value of the slope to add or substract
    @param    direction        The GRAPHICAL direction of the curve shifting: 1 being UPWARDS, -1 being DOWNWARDS (0 being no change at all).
    @return                    1 if something has been changed, 0 otherwise.
    @remark                    We stress that the quantity #delta_slope_abs â€¢ #direction is NOT the real amount of the slope which is added but only the graphical one.
                            This function, indeed handles the fact that (depending on the breakpoints' positions) while dragging UP the curve, the slope might DECREASE, and vice versa.
                            This is why the arguments are separated into an absolute value of the amount of the slope to add, and then a GRAPHICAL direction ("up" or "down")
                            in which this addition must be performed.
 */
char change_breakpoint_slope(t_notation_obj *r_ob, t_bpt *bpt, double delta_slope_abs, char direction);


/**    Change the pitch of all the selected breakpoints (note tails included) of a certain amount (given as difference with the existing pitches).
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    delta_mc        The midicent difference to be added to existing breakpoints' midicents
    @return                    1 if something has been changed, 0 otherwise.
 */
char change_selection_breakpoint_pitch(t_notation_obj *r_ob, double delta_mc);


/**    Change the position of the note tail preserving the absolute position of all breakpoints and temporal slot elements.
    Only usable in bach.roll.
    @ingroup interface
    @param    r_ob            The notation object
    @param    nt                The note
    @param    delta_ms        The time to be added to existing durations, in milliseconds.
 */
void trim_note_end(t_notation_obj *r_ob, t_note *nt, double delta_ms);

// TBD
void trim_note_slots(t_notation_obj *r_ob, t_note *nt, double delta_ms, char trim_absolute_slots_only);

/**    Change the position of the note heads preserving the absolute position of all breakpoints and temporal slot elements.
    Only usable in bach.roll.
    @ingroup interface
    @param    r_ob            The notation object
    @param    ch                The chord
    @param    delta_ms        The time to be added to the note onset, in milliseconds.
 */
void trim_chord_start(t_notation_obj *r_ob, t_chord *ch, double delta_ms);


// Private
void add_amount_to_all_trimlinked_slots(t_notation_obj *r_ob, t_notation_item *nitem, double howmuch);



/**    Change the duration of the selected notes, trimming their tails, but preserving the absolute temporal position of the breakpoints. Only usable in bach.roll.
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    delta_ms        The time to be added to existing durations, in milliseconds.
    @return                    1 if something has been changed, 0 otherwise.
 */
char trim_selection_end(t_notation_obj *r_ob, double delta_ms);


/**    Change the duration of the selected notes, moving their heads, but preserving the absolute temporal position of the breakpoints. Only usable in bach.roll.
    @ingroup selection_changes
    @param    r_ob            The notation object
    @param    delta_ms        The time to be added to existing onsets, in milliseconds.
    @return                    1 if something has been changed, 0 otherwise.
 */
char trim_selection_start(t_notation_obj *r_ob, double delta_ms);


/**    Change the key for a single given voice
    @ingroup voice_attributes
    @param    r_ob            The notation object
    @param    voice            The voice
    @param    new_key            The new key as symbol
    @param    also_add_undo_tick    If this is non-zero, an undo tick is properly added
 */
void change_single_key(t_notation_obj *r_ob, t_voice* voice, t_symbol *new_key, char also_add_undo_tick);



/**    Set or unset the "keep in background" flag for a given slot.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    slot_num        The 0-based slot number.
    @param    new_flag        1 if the slot has to be kept in background, 0 if the slot does NOT have to be kept in background.
 */
void change_background_slot_flag(t_notation_obj *r_ob, long slot_num, char new_flag);


/**    Set or unset the "appears in popup menu" flag for a given slot.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    slot_num        The 0-based slot number.
    @param    new_flag        1 if the slot has to appear in the contextual menu, popped up when a note is right-clicked, 0 otherwise.
 */
void change_popupmenu_slot_flag(t_notation_obj *r_ob, long slot_num, char new_flag);


/**    Change the slot linkage for a given slot. Slot linkage is a mechanism to assign graphical parameters to slot values (e.g. lyrics, notehead colors, notehead sizes...).
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    slot_num        The 0-based slot number.
    @param    new_flag        The new link type, one of the #e_slot_linkages.
 */
void change_linkto_slot_flag(t_notation_obj *r_ob, long slot_num, char link_to_what);


/**    Obtain the interpolated y value corresponding to a given x value in a #k_SLOT_TYPE_FUNCTION type of slot of a give note.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    slot_num        The 0-based slot number.
    @param    x                The x value according to which the y value must be computed.
    @return                    The corresponding y value. 0 if the slot is not of type function, or is empty.
    @remark                    This takes correctly into account the slopes, by using the function rescale_with_slope()
    @see    get_function_slot_sampling()
 */
double get_function_slot_interp(t_notation_obj *r_ob, t_note *note, long slot_num, double x);


/**    Obtain a sampling of a given #k_SLOT_TYPE_FUNCTION type of slot of a give note.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    slot_num        The 0-based slot number.
    @param    num_pts            The number of points in which the function has to be sampled
    @return                    The function sampling, as an llll of the form ((<x1> <x2> ... <x_n>) (<y1> <y2> ... <y_n)). NULL if slot is not of type function.
    @remark                    The domain is sampled accoring to its slope parameter (only if the domain slope is 0 the sampling is uniform).
    @see    get_function_slot_interp()
 */
t_llll* get_function_slot_sampling(t_notation_obj *r_ob, t_note *note, long slot_num, long num_pts);


/**    Obtain a sampling of a given #k_SLOT_TYPE_FUNCTION type of slot of a give note, starting from a distance between x points.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    note            The note
    @param    slot_num        The 0-based slot number.
    @param    delta            The distance between domain points to be sampled
    @return                    The function sampling, as an llll of the form ((<x1> <x2> ... <x_n>) (<y1> <y2> ... <y_n)). NULL if slot is not of type function.
    @see    get_function_slot_sampling()
 */
t_llll* get_function_slot_sampling_delta(t_notation_obj *r_ob, t_note *note, long slot_num, double delta);



/**    Paste slot items from an llll (currently this only works for function slots).
    The function inserts the slot items at the appropriate places inside the llll.
    @ingroup slot_interface
    @param    r_ob            The notation object
    @param    nitem            The notation item
    @param    slotnum            The 0-based slot number.
    @param    newitems        The llll containing the new items in (x y slope) form
    @param    active_slot_window    Active slot window rectangle
    @param    x_offset        An horizontal offset in pixels
    @param    delete_intermediate_points    If non-zero, it also deletes all the intermediate original points which would fall inside the pasted region 
 */
void paste_slotitems(t_notation_obj *r_ob, t_notation_item *nitem, long slotnum, t_llll *newitems, t_rect active_slot_window, double offset, char delete_intermediate_points);

// TBD
t_llll *slots_develop_ranges(t_notation_obj *r_ob, t_llll *ll);
double slot_get_max_x(t_notation_obj *r_ob, t_slot *slot, long slot_num);
double notationobj_get_slot_max_x(t_notation_obj *r_ob, long slot_num);
double slot_get_domain_min(t_notation_obj *r_ob, long slot_num);
double slot_get_domain_max(t_notation_obj *r_ob, long slot_num, t_notation_item *nitem);
double slot_get_domain_max_force_default_duration(t_notation_obj *r_ob, long slot_num, double default_duration);





// -----------------------------------
// QUANTIZATION TOOLS
// -----------------------------------

/**    Approximate a list of rational durations inside a box so that their numerators be less than #CONST_RAT_MAX_NUM_SAFETY and their
    denominators be less than #CONST_RAT_MAX_DEN_SAFETY.
    @ingroup                quantization_tools
    @param    box_durations    llll containing the plain list of durations, whose elements will be changed.
    @param    box_width        The overall width of the box (supposedly, the sum of the absolute values of all the box durations).
                            You are assured that the overall sum of the approximated durations will be still #box_width.
    @remark                    BEWARE: This function is destructive, since the elements in the llll are changed.
 */
void approximate_for_too_high_rationals(t_llll *box_durations, t_rational box_width);


/**    Approximate a list of rational durations inside a box so that their denominator be a given number (up to fraction simplifications).
    @ingroup                quantization_tools
    @param    box_durations    llll containing the plain list of durations, whose elements will be changed.
    @param    box_width        The overall width of the box (supposedly, the sum of the absolute values of all the box durations).
                            You are assured that the overall sum of the approximated durations will be still #box_width.
    @param    fixed_den        The fixed denominator for the approximation
    @remark                    BEWARE: This function is destructive, since the elements in the llll are changed.
    @see    approx_rat_with_rat_fixed_den()
 */
void approximate_for_too_high_rationals_fixed_den(t_llll *box_durations, t_rational box_width, long fixed_den);


/**    Convert (quantize) a list of durations in milliseconds into a list of rational symbolic durations.
    @ingroup                                quantization_tools
    @param    measure_symduration                A plain list containing the symbolic duration of each measure
    @param    tempi                            A plain llll containing a list of H_OBJ, each containing a (properly allocated) tempo.
                                            The tempi inside the llll are also allowed NOT to have an owner (so you can allocate them without inserting them in a measure), 
                                            provided that their t_tempo::hack_measure_number be defined, containing the measure number in which the tempo change
                                            (this "surrogate" of the owner is everything this function needs to work). The t_tempo::changepoint must be ALWAYS properly defined.
    @param    durations                        The plain list of durations (in milliseconds)
    @param    how_many_measures_to_append        Pointer to a number which will be filled with the number of additional measures to append (considering as "existing" the measures
                                            defined by the #measure_symduration input parameter)
    @param    const_approx_double_with_rat_fixed_den    The greatest allowed denominator for the approximation of each duration.
    @param    fixed_approximations            If this is non-zero, the approximate_for_too_high_rationals_fixed_den() will be called on all the outgoing list, 
                                            having #const_approx_double_with_rat_fixed_den as fixed approximation
    @return                                    The list of rational symbolic duration quantizing the incoming millisecond durations.
 */
t_llll *ms_to_rat_durations(t_llll *measure_symdurations, t_llll *tempi, t_llll *durations, long *how_many_measures_to_append, long const_approx_double_with_rat_fixed_den, char fixed_approximations);


/**    Convert a tempo and a symbolic duration into the corresponding duration in milliseconds.
    For instance, a tempo of 3/8 = 60 and a sym_duration of 9/8 will be converted into 3000 ms.
    @ingroup                    quantization_tools
    @param    figure_tempo_value    The tempo value referred to the following defined tempo figure (see #t_tempo for more information)
    @param    tempo_figure        The tempo figure (see #t_tempo for more information)
    @param    sym_duration        The symbolic duration of which you want to know the milliseconds duration
    @return                        The duration in milliseconds of the input symbolic duration at the given tempo
 */
double tempo_and_sym_duration_to_duration_ms(double figure_tempo_value, t_rational tempo_figure, t_rational sym_duration);


/** Convert an onset difference into a symbolic difference (given the tempi directly at right or at left of a given onset).
    @ingroup                quantization_tools
    @param    onset_ms        The given onset in milliseconds
    @param    tempo_L_ms        The absolute time position of the tempo directly on the left side of the onset_ms
    @param    tempo_L_value    The value of the tempo tempo directly on the left side of the onset_ms, referred to the standard 1/4 tempo figure
    @param    tempo_R_ms        The absolute time position of the tempo directly on the right side of the onset_ms
    @param    tempo_R_value    The value of the tempo tempo directly on the right side of the onset_ms, referred to the standard 1/4 tempo figure
    @param    delta_sym_tempi    The distance between the left and the right tempo in (rational) symbolic units.
    @return                    The (double-precision) symbolic distance corresponding to the absolute time lapse between #tempo_L_ms and #onset_ms. In other word, it returns
                            the distance of the given onset with respect to the first tempo position, in (double-precision) symbolic units.

    @remark                    For instance, if #tempo_L_value = 60, #tempo_R_value = 120, #tempo_L_ms = 2000, #tempo_R_ms = 3000, delta_sym_tempi = 1/2,
                            we have two tempi whose distance is 1000ms or 1/2 symbolic units (one half), and whose values (referred to the quarter figure) are 60 and 120.
                            If we choose #onset_ms = 2500, the function returns the symbolic distance corresponding to the absolute time lapse [2000ms -> 2500ms].
                            To do so, it uses the quadratic formula documented in section 2.3 "Uniformly accelerating tempo" of the function documentation, where 
                            the start speed is 240/60 = 4, end speed is 240/120 = 2 (notice that speed decrease!!! since we choose the 1/tempo linear reference frame),
                            acceleration is thus (2-4)/(1/2) = -2/0.5 = -4, Î”t_abs will be our 2500-2000 = 500ms = 0.5s, and thus we can find our Î”t_sym by solving that 
                            quadratic equation, 0.5 = 4*x - 2x^2, thus 4x^2-8x+1 = 0, whose delta is 64-16 = 48, yielding as solutions x = 1 Â± sqrt(3)/2. 
                            Only the solution corresponding to the negative sign is acceptable (the other one is even bigger than #delta_sym_tempi!), 
                            and thus the symbolic distance corresponding to the lapse [2000ms -> 2500ms] is 0,133974...,  a little more than 1/8 (a quaver).

    @remark                    This function is used by ms_to_rat_durations()
 */
double get_sym_diff_from_onset_ms(double onset_ms, double tempo_L_ms, double tempo_L_value, double tempo_R_ms, double tempo_R_value, t_rational delta_sym_tempi);



// -----------------------------------
// LOCK, SOLO, MUTE
// -----------------------------------

/**    Update the t_notation_obj::are_there_solo field properly.
    @ingroup                lock_solo_mute
    @param    r_ob            The notation object
 */
void update_solos(t_notation_obj *r_ob);


/**    Tell if a notation item is globally locked, either because it is locked itsself (e.g. a note which is locked)
    or because some element that contains it is locked (e.g. the measure containing the note's chord is locked).
    @ingroup                lock_solo_mute
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the element is globally locked, 0 otherwise.
*/
char notation_item_is_globally_locked(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a notation item is globally muted, either because it is muted itsself (e.g. a note which is muted)
    or because some element that contains it is muted (e.g. the measure containing the note's chord is muted).
    @ingroup                lock_solo_mute
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the element is globally muted, 0 otherwise.
*/
char notation_item_is_globally_muted(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a notation item is globally solo, either because it is locked itsself (e.g. a note which is solo)
    or because some element that contains it is solo (e.g. the measure containing the note's chord is solo).
    @ingroup lock_solo_mute
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the element is globally solo, 0 otherwise.
*/
char notation_item_is_globally_solo(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a notation item is solo, or if any of its progeny is solo (e.g. tells if a chord or any of its notes are solo.
    @ingroup lock_solo_mute
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the element or any of its progeny is solo, 0 otherwise.
 */
char is_solo_with_progeny(t_notation_obj *r_ob, t_notation_item *item);


/**    Tell if a given notation item is to be played, depending on the overall mute/solo configuration
    @ingroup    lock_solo_mute
    @ingroup    play
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                    1 if the element is to be played, 0 otherwise.
*/
char should_element_be_played(t_notation_obj *r_ob, t_notation_item *item);


/**    Lock a chord.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
*/
char lock_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Unlock a chord.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
*/
char unlock_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Lock a chord (if it was unlocked) or unlock it (if it was locked).
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            Always 1
*/
char lock_unlock_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Lock a note.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
*/
char lock_note(t_notation_obj *r_ob, t_note *note);


/**    Unlock a note.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
*/
char unlock_note(t_notation_obj *r_ob, t_note *note);


/**    Lock a note (if it was unlocked) or unlock it (if it was locked).
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            Always 1
*/
char lock_unlock_note(t_notation_obj *r_ob, t_note *note);


/**    Lock a measure.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
*/
char lock_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Unlock a measure.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
*/
char unlock_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Lock a voice.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
*/
char lock_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Unlock a voice.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
*/
char unlock_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Lock a notation item.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char lock_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Unlock a notation item.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char unlock_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Lock the selection
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
*/
char lock_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Unlock the selection
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
*/
char unlock_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Lock the unlocked selected elements, and unlock the locked selected elements.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            Always 1
 */
char lock_unlock_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Tell if all the selected elements are locked.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are locked
 */
char is_all_selection_locked(t_notation_obj *r_ob);


/**    Tell if all the selected elements are unlocked.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are unlocked
 */
char is_all_selection_unlocked(t_notation_obj *r_ob);


/**    Mute a chord.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
 */
char mute_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Unmute a chord.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
 */
char unmute_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Mute a chord (if it was NOT muted) or unmute it (if it was muted)
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            Always 1
 */
char mute_unmute_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Mute a note.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
 */
char mute_note(t_notation_obj *r_ob, t_note *note);


/**    Unmute a note.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
 */
char unmute_note(t_notation_obj *r_ob, t_note *note);


/**    Mute a measure.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
 */
char mute_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Unmute a measure.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
 */
char unmute_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Mute a voice.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
 */
char mute_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Unmute a voice.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
 */
char unmute_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Mute a note (if it was NOT muted) or unmute it (if it was muted)
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The note
    @return            Always 1
 */
char mute_unmute_note(t_notation_obj *r_ob, t_note *note);


/**    Mute a notation item.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char mute_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Unmute a notation item.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char unmute_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Mute the selection
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, mutes across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
 */
char mute_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Unmute the selection
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, mutes across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
 */
char unmute_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Mute the non-muted selected elements, and unmute the muted selected elements.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, mutes across whole voice ensembles
    @return            Always 1
 */
char mute_unmute_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Tell if all the selected elements are muted.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are muted
 */
char is_all_selection_muted(t_notation_obj *r_ob);


/**    Tell if all the selected elements are NOT muted.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are NOT muted
 */
char is_all_selection_unmuted(t_notation_obj *r_ob);


/**    Unmute ALL the muted elements.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @return            1 if something has changed, 0 otherwise.
 */
char no_muted(t_notation_obj *r_ob);


/**    Set a chord as solo
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Remove the solo flag to a chord 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char unsolo_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Set a chord as solo (if it was NOT solo) or remove the solo flag to the chord (if it was solo) 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    chord    The chord
    @return            Always 1
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_unsolo_chord(t_notation_obj *r_ob, t_chord *chord);


/**    Set a note as solo
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_note(t_notation_obj *r_ob, t_note *note);


/**    Remove the solo flag to a note 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char unsolo_note(t_notation_obj *r_ob, t_note *note);


/**    Set a measure as solo
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Remove the solo flag to a measure 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The measure
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char unsolo_measure(t_notation_obj *r_ob, t_measure *meas);


/**    Set a voice as solo
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Remove the solo flag to a voice 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The voice
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char unsolo_voice(t_notation_obj *r_ob, t_voice *voice);


/**    Set a note as solo (if it was NOT solo) or remove the solo flag to the note (if it was solo) 
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    note    The note
    @return            Always 1
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_unsolo_note(t_notation_obj *r_ob, t_note *note);


/**    Set a notation item as solo.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char solo_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Remove the solo flag to a notation item.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    item    The notation item
    @return            1 if something has changed, 0 otherwise
*/
char unsolo_notation_item(t_notation_obj *r_ob, t_notation_item *item);


/**    Set all selected elements as solo 
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Remove the solo flag to the selected elements 
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            1 if something has changed, 0 otherwise.
    @remark            Also properly update the r_ob->are_there_solos field
 */
char unsolo_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Set to solo all the non-solo selected elements, and remove the solo flag to all the solo selected elements.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @param  whole_voiceensembles    If non-zero, locks across whole voice ensembles
    @return            Always 1
    @remark            Also properly update the r_ob->are_there_solos field
 */
char solo_unsolo_selection(t_notation_obj *r_ob, char whole_voiceensembles);


/**    Tell if all elements in the selection have the solo flag set.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are "solo", 0 otherwise
 */
char is_all_selection_solo(t_notation_obj *r_ob);


/**    Tell if all elements in the selection have the solo flag unset.
    @ingroup        lock_solo_mute
    @ingroup        selection
    @param    r_ob    The notation object
    @return            1 if all selected elements are NOT "solo", 0 otherwise
 */
char is_all_selection_unsolo(t_notation_obj *r_ob);


/**    Remove the solo flag to ALL the solo elements.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @return            1 if something has changed, 0 otherwise.
 */
char no_solo(t_notation_obj *r_ob);


/**    Tell if there is any solo element in the notation object.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @return            1 if there is at least a solo element in the notation object, 0 otherwise
    @remark            This function is crucial, since, in order for the solo mechanism to work properly, it has to be kept up to date with the
                    <are_there_solos> field in the notation object structure. This field, indeed, keeps track of the presence of solos elements in the score,
                    in order to avoid checking its value at each play event. This update is usually done simply by setting
                    @code
                    r_ob->are_there_solos = are_there_solos(r_ob);
                    @endcode
 */
char are_there_solos(t_notation_obj *r_ob);


/**    Remove all solo or mute flags set to rests.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
 */
void check_mute_solo_flags_for_rests(t_notation_obj *r_ob);



/**    Check the compatibility between chord flags and its notes', possibly modifying the lock/solo/mute status accordingly.
    @ingroup        lock_solo_mute
    @param    r_ob    The notation object
    @param    ch        The chord
    @return            1 if something had to be modified, 0 otherwise
 */
char check_lock_mute_solo_compatibilities_for_chord_and_notes(t_notation_obj *r_ob, t_chord *ch);



// -----------------------------------
// IDs
// -----------------------------------


/**    Retrieve a notation item's ID as an llll containing the "ID" symbol and then the item's id.
    @ingroup        ids
    @param    it        The notation item
    @return            A llll containing (ID <number>), where <number> is the item's ID.
 */
t_llll *get_ID_as_llll(t_notation_item *it);


/**    Search the tail of an llll in order to find any subllll of the type (ID <number>). If this specification is found,
    the ID is returned, and the element is destroyed. 
    @remark            Beware: this is destructive, since the incoming llll could be changed.
    @ingroup        ids
    @param    llll    The llll to be searched for ID specification.
    @return            The ID if found, 0 otherwise.
 */
unsigned long notation_item_get_ID_from_llll(t_llll *llll);





// -----------------------------------
// UNDO AND CHANGE
// -----------------------------------

/** Send the "done" message through the playout after the object has been rebuilt, or if the field #send_rebuild_done_only_after_paint_method of the notation object is set,
    prepare things, such that next paint method will send the "done" message.
    @ingroup                interface
    @param    r_ob            The notation object
*/
void handle_rebuild_done(t_notation_obj *r_ob);


/** Routine to perform some standard operation, as a consequence of some specific change in the score.
    @ingroup                interface
    @param    r_ob            The notation object
    @param    change_type        A combination of #e_actions_upon_change specifying the change actions to be performed.
                            Namely, the routine can perform: @n
                            - Redraw the static layer of the object (if #k_CHANGED_REDRAW_STATIC_LAYER is set) @n
                            - Create an undo step marker (if #k_CHANGED_CREATE_UNDO_STEP_MARKER is set) @n
                            - Check correct scheduling if during play (if #k_CHANGED_CHECK_CORRECT_SCHEDULING is set) @n
                            - Set a flag, so that after next painting the usual bang will be sent - meaning that something has been changed via the interface (if #k_CHANGED_SEND_BANG is set) @n
                            - Set a flag, so that after next painting the automessage, if any, will be sent to the object itself (if #k_CHANGED_SEND_AUTOMESSAGE is set) @n
                            Some useful combinations for the wrapper are #k_CHANGED_STANDARD_SEND_BANG, #k_CHANGED_STANDARD_UNDO_MARKER, #k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG.
    @param    undo_op            One of the #e_undo_operations, if the change has to imply the creation of an undo marker (also see the Undo module), or 0 if no undo marker is required.
    @remark                    For instance, after some change in the slot has been performed (and all its undo ticks have been added), one should call:
    @code
    handle_change(r_ob, k_UNDO_MODIFICATION_CHANGE, k_UNDO_OP_CHANGE_SLOT);
    @endcode
 */
void handle_change(t_notation_obj *r_ob, int change_actions, e_undo_operations undo_op);


/** If one of the fields <need_send_changed_bang> and <need_send_automessage> of the notation object is non-zero, the corresponding action is performed (or also both, of course).
    If <need_send_changed_bang> is nonzero, the usual bang will be sent - meaning that something has been changed via the interface.
    If <need_send_automessage> is nonzero, the automessage, if any, will be sent to the object itself.
    @ingroup                interface
    @remark                    Both actions should be called after painting, so this function is typically called at the end of the paint methods 
    @param    r_ob            The notation object
*/
void send_changed_bang_and_automessage_if_needed(t_notation_obj *r_ob);


/** Send a notification about the current opened slot, in the form "openslot <number>", where the number is 1-based (as everything which goes out to the user or comes in from the user).
    The <number> is indeed t_notation_obj::active_slot_num + 1. Thus if no slot is open, one will have "openslot 0".
    This is only used by [bach.slot], for which incidentally some slot should ALWAYS be open (otherwise it's a bug!).
    @ingroup                interface
    @param    r_ob            The notation object
    @param    outlet_num        The 0-based number of the outlet
*/
void send_changed_open_slot_notification(t_notation_obj *r_ob, long outlet_num);


/** Convenience wrapper for handle_change, to handle the events when the only changed thing is WHICH notation items are selected (and NO modification
    whatsoever is done to the items). This is the case, for instance, when a note is clicked, or a new selection rectangle is drawn. In all this cases,
    this function has to be called.
    @ingroup                interface
    @param    r_ob            The notation object
    @see    handle_change()
 */
void handle_change_selection(t_notation_obj *r_ob);


/** Convenience wrapper for handle_change, which actually calls for the function only if some "free" undo ticks have been found. A "free" undo tick, is an #t_undo_redo_information
    stored in a #H_OBJ at the beginning of the undo llll, which is NOT precedeed by any #H_SYM undo marker. These ticks are prepended when interface operations are performed,
    and then the undo step is finalized by prepending the marker, and thus usually calling this function, which will prepend the marker ONLY if there are undo ticks.
    @ingroup                interface
    @param    r_ob            The notation object
    @param    change_type        A combination of #e_actions_upon_change specifying the change actions to be performed (see handle_change())
    @param    undo_op            One of the #e_undo_operations, if the change has to imply the creation of an undo marker (also see the Undo module), or 0 if no undo marker is required.
    @see    handle_change()
    @remark    This is completely equivalent to
    @code
    if (are_there_free_undo_ticks(r_ob, true))
        handle_change(r_ob, change_type, undo_op);
    @endcode
 */
void handle_change_if_there_are_free_undo_ticks(t_notation_obj *r_ob, int change_type, e_undo_operations undo_op);


/** Tell if there are free undo ticks (see handle_change_if_there_are_free_undo_ticks() for more information)
    @ingroup        undo
    @param    r_ob    The notation object
    @param    also_return_true_if_undo_is_empty    If this is non-zero, function returns 1 also if undo llll is empty
    @return            1 if there are free undo ticks, 0 otherwise.
 */
char are_there_free_undo_ticks(t_notation_obj *r_ob, char also_return_true_if_undo_is_empty);


/** Delete and properly free all the free undo ticks (see handle_change_if_there_are_free_undo_ticks() for more information)
    @ingroup        undo
    @param    r_ob    The notation object
    @param    also_clear_ticks_flags    Also clear the flag for the free ticks â€“ this is strongly advised to be 1.
 */
void remove_all_free_undo_ticks(t_notation_obj *r_ob, char also_clear_ticks_flags);


/** Unset the #k_FLAG_MODIF_UNDO, #k_FLAG_MODIF_FLAG_UNDO, #k_FLAG_MODIF_CHECK_ORDER_UNDO and #k_FLAG_MODIF_NAME_UNDO flags from any element in the r_ob->undo_notation_items_under_tick
    llll. This is automatically called by handle_change() when a new undo marker is added. Those flags are usually set by 
    create_simple_selected_notation_item_undo_tick(), and are useful when dealing with selection to avoid saving the content of the same item multiple times.
    @ingroup        undo
    @param    r_ob    The notation object
 */
void remove_modif_undo_flag_to_last_undo_ticks(t_notation_obj *r_ob);


/** Convert the current selection into the set of notation items that describe it. This is thought for then adding undo ticks and steps to each item, and
    it is minimal with respect to this perspective;    so for instance, if a measure appears among the returned items, no chord or notes inside the measure will appear. 
    Moreover, if a note is selected, its chord will appear, and not the note itself, since currently the minimum undoable item is a chord.
    @ingroup            undo
    @param    r_ob        The notation object
    @param    undo_items    Pointer which will be filled with an array of (t_notation_item *), specifying the selected notation items whose information has to be saved for
                        undo, if we want to save a change on the current selection.
    @remark                The returned pointer must then be properly freed.
 */
void selection_to_undo_notation_item(t_notation_obj *r_ob, t_notation_item **undo_items);


/** Convert an interface operation, represented as a long (one of the #e_undo_operations), into a string characterizing the operation.
    This string, for instance, is the one displayed in the Max window if the undo is verbose.
    @ingroup    undo
    @param        undo_op        One of the #e_undo_operations identifying the performed operation.
    @return        A string containing the string describing the operation.
    @remark        The returned pointer must then be properly freed.
 */
char *undo_op_to_string(long undo_op); // convert an undo operation into the string for the max window, allocates memory


/**    Set the flag fields to a notation item for some undo operation. If the item is of type chord, a list in the
    form [chord_flag (note1_flag note2_flag...)] is expected, where all flags are #H_LONG elements, a combination of the
    #e_notation_item_flags. In all other cases, a list containing a single #H_LONG is expected.
    @ingroup        undo
    @param    r_ob    The notation object
    @param    ll        The llll containing the flag information in the form explained above.
    @param    father_item        The notation item to which the flags must be assigned (if this is a chord, flags will be assigned to its notes as well).
    @see get_multiple_flags_for_undo
 */
void set_multiple_flags_from_llll_for_undo(t_notation_obj *r_ob, t_llll *ll, t_notation_item *father_item);


/**    Get the flag fields to be stored for undo. If the item is of type chord, a list in the
    form [chord_flag (note1_flag note2_flag...)] will be returned, where all flags are #H_LONG elements, a combination of the
    #e_notation_item_flags. In all other cases, a list containing a single #H_LONG will be returned.
    @ingroup        undo
    @param    r_ob    The notation object
    @param    father_item        The notation item of which we want to retrieve the flag in llll form (if this is a chord, we'll retrieve also all its notes' flags).
    @return            A llll containing the flags, in the form explained above.
    @see set_multiple_flags_from_llll_for_undo
 */
t_llll *get_multiple_flags_for_undo(t_notation_obj *r_ob, t_notation_item *father_item);


/**    Allocate the memory for a #t_undo_redo_information structure, representing some undo information linked with a specific notation item (or with the whole
    notation object, or with some header content) and initialize it with the parameters given in input.
    @ingroup            undo
    @param    ID            The ID of the notation item whose information need to be saved, or 0 if header whole notation item are being saved.
    @param    type        The type of the item whose information need to be saved (one of the #e_element_types)
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
                        We stress the fact that this operation is NOT the operation performed by the user, but rather the inverse operation. For instance, if the user
                        adds a chord, the modification type stored here will be #k_UNDO_MODIFICATION_DELETE.
    @param    voice_num    The voice number of the notation item (or 0 if irrelevant)
    @param    meas_num    The measure number of the notation item (or 0 if irrelevant)
    @param    header_info    The header information (as a combination of the #e_header_elems) that need to be saved, if type = #k_HEADER_DATA. 0 otherwise.
    @param    content        An llll specifying the content of the notation item before the user-performed operation. Could be nil if irrelevant (e.g. when a chord was added, and
                        thus modif_type = #k_UNDO_MODIFICATION_DELETE).
 */
t_undo_redo_information *build_undo_redo_information(long ID, e_element_types type, e_undo_modification_types modif_type, long voice_num, long meas_num, e_header_elems header_info, t_llll *content);


/**    Free the memory for a #t_undo_redo_information structure, correctly freeing also the llll possibily contained in the
    t_undo_redo_information::n_it_content field.
    @ingroup    undo
    @param        operation    The undo/redo information to be freed.
 */
void free_undo_redo_information(t_undo_redo_information *operation);


/**    Create a undo/redo tick and properly prepend it to the undo or redo llll. 
    @ingroup            undo
    @param    r_ob        The notation object
    @param    what        One of the #e_undo_redo (k_UNDO or k_REDO) specifying if the operation is for an undo or a redo.
    @param    from_what    Leave this to 0 if the tick is placed because some interface operation occurred; set this to 1 if the tick is placed because some
                        undo or redo command has been performed (and thus the corresponding inverse redo or undo ticks are being created).
    @param    operation    Pointer to an already allocated #t_undo_redo_information structure, which describes the tick and which will be prepended as an #H_OBJ to the undo or redo llll.
    @param    lock_undo_mutex    If this is non-zero, the function also locks the undo mutex
    @return                0 if the undo tick has properly been created, 1 if it could not be created, due to the fact that the undo is inactive or to a generic error.
    @remark                VERY IMPORTANT: If for any reason the undo tick could not be created (and then 1 is returned), the #operation information is properly freed
                        (along with its possible llll content field)
 */
long create_undo_redo_tick(t_notation_obj *r_ob, char what, char from_what, t_undo_redo_information *operation, char lock_undo_mutex);


/**    Create a undo/redo step marker ("closing" a sequence of undo ticks) and properly prepend it to the undo or redo llll. 
    @ingroup            undo
    @param    r_ob        The notation object
    @param    what        One of the #e_undo_redo (k_UNDO or k_REDO) specifying if the operation is for an undo or a redo.
    @param    from_what    Leave this to 0 if the tick is placed because some interface operation occurred; set this to 1 if the tick is placed because some
                        undo or redo command has been performed (and thus the corresponding inverse redo or undo ticks are being created).
    @param    undo_op        The operation which was performed, as one of the #e_undo_operations.
    @param    lock_undo_mutex    If this is non-zero, the function also locks the undo mutex
    @return                Return the llllelem corresponding to the positioned step marker (or NULL if none)
 */
t_llllelem *create_undo_redo_step_marker(t_notation_obj *r_ob, char what, char from_what, long undo_op, char lock_undo_mutex);


/**    Create a undo tick associated with some header change. 
    @ingroup            undo
    @param    r_ob        The notation object
    @param    what        A combination of #e_header_elems, representing the header elements which have been changed
*/
void create_header_undo_tick(t_notation_obj *r_ob, e_header_elems what);


/**    Clear the undo llll or the redo llll. This means that all the ticks (#H_OBJ elements) are properly freed, and their <content> llll field is properly freed as well. 
    @ingroup            undo
    @param    r_ob        The notation object
    @param    what        One of the #e_undo_redo (k_UNDO or k_REDO) specifying if the operation is for an undo or a redo.
    @remark                To avoid memory leaks, never call llll_free() on the undo/redo lllls, but always use this function.
 */
void clear_undo_redo_llll(t_notation_obj *r_ob, char what);


/**    Create a simple undo tick, containing the information about the modification of a given notation item.
    @ingroup            undo
    @param    r_ob        The notation object
    @param    item        The notation item being modified
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
                        We stress the fact that this operation is NOT the operation performed by the user, but rather the inverse operation. For instance, if the user
                        adds a chord, the modification type stored here will be #k_UNDO_MODIFICATION_DELETE.
    @remark                This function has to be called BEFORE the item is modified (so that it can retrieve the correct content for undo), except if the
                        notation item has just been created, in which case it should be called afterwards, with #modif_type = #k_UNDO_MODIFICATION_DELETE.
    @see                create_undo_redo_tick()
 */
void create_simple_notation_item_undo_tick(t_notation_obj *r_ob, t_notation_item *item, e_undo_modification_types modif_type);


/**    Create undo ticks for a sequence of notation items.
    @ingroup            undo
    @param    r_ob        The notation object
    @param    num_items    The number of notation items for which ticks need to be created
    @param    item        Pointer to the first element of the array of notation items (the algorithm expects #num_items items).
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
                        This must be common to all notation items in the array, otherwise single create_simple_notation_item_undo_tick() functions must be called for.
    @remark                This function has to be called BEFORE the items are modified (so that it can retrieve the correct content for undo), except if the
                        notation items have just been created, in which case it should be called afterwards, with #modif_type = #k_UNDO_MODIFICATION_DELETE.
    @see                create_simple_notation_item_undo_tick()
    @see                create_undo_redo_tick()
 */
void create_multiple_notation_items_undo_ticks(t_notation_obj *r_ob, long num_items, t_notation_item **item, e_undo_modification_types modif_type, long *undo_op);


/**    Works just like create_simple_notation_item_undo_tick(), but when the item is selected. This also accepts a #smallest_undoable_element specification,
    specifying the minimum structure for which the undo information has to be store. For instance, if #item is a note, and #smallest_undoable_element is #k_MEASURE,
    the undo tick will actually involve the whole measure containing the note. Also, this function has the advantage to automatically set 
    the flags #k_FLAG_MODIF_FLAG_UNDO, #k_FLAG_MODIF_UNDO, #k_FLAG_MODIF_CHECK_ORDER_UNDO and #k_FLAG_MODIF_NAME_UNDO if needed. Those flags are assigned, respectively, when the flag information
    of the item is already stored as an undo tick, when the whole information of the item is already stored as an undo tick, and when the whole information of the item
    is stored as an undo tick and also this undo operation will require a new checking of the chords order. Those flags are set for selected item in order to avoid
    repeatedly storing undo ticks on the same thing. For instance, once we've stored an undo tick for a chord, because one of its notes has changed while dragging, we don't need to add
    a new tick if another note has changed.  
    @ingroup            undo
    @param    r_ob        The notation object
    @param    item        The notation item being modified
    @param    smallest_undoable_element    One of the #e_element_types determining the smallest element of which we want to save the undo information. For instance,
                                        usually in bach we don't save undo information for notes, so #smallest_undoable_element is usually #k_CHORD or #k_MEASURE.
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
                        We stress the fact that this operation is NOT the operation performed by the user, but rather the inverse operation. For instance, if the user
                        adds a chord, the modification type stored here will be #k_UNDO_MODIFICATION_DELETE.
    @remark                This function has to be called BEFORE the item is modified (so that it can retrieve the correct content for undo), except if the
                        notation item has just been created, in which case it should be called afterwards, with #modif_type = #k_UNDO_MODIFICATION_DELETE.
    @see                create_simple_notation_item_undo_tick()
 */
void create_simple_selected_notation_item_undo_tick(t_notation_obj *r_ob, t_notation_item *item, e_element_types smallest_undoable_element, e_undo_modification_types modif_type);

/**    (DEPRECATED) Create undo ticks for all selected items.
    @ingroup            undo
    @param    r_ob        The notation object
    @param    num_items    The number of notation items for which ticks need to be created
    @param    item        Pointer to the first element of the array of notation items (the algorithm expects #num_items items).
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
                        This must be common to all notation items in the array, otherwise single create_simple_notation_item_undo_tick() functions must be called for.
    @remark                This function has to be called BEFORE the items are modified (so that it can retrieve the correct content for undo), except if the
                        notation items have just been created, in which case it should be called afterwards, with #modif_type = #k_UNDO_MODIFICATION_DELETE.
    @remark                This function is DEPRECATED. The standard way to handle undo in bach is to add ticks individually to each it when it is modified. For instance
                        if we're changing the velocity to the selection, instead of using this function, we should add single ticks at the points of the code where
                        we actually change the velocity for each given chord (via create_simple_selected_notation_item_undo_tick()) and then add a marker directly with the
                        handle_change() function when the operation is performed.
    @see                create_simple_selected_notation_item_undo_tick()
 */
long create_selection_notation_item_undo_tick(t_notation_obj *r_ob, e_element_types smallest_undoable_element, e_undo_modification_types modif_type);


/**    Obtain, starting from a modification performed on a single notation item, the operation performed by the user as one of the #e_undo_operations.
    @ingroup            undo
    @param    r_ob        The notation object
    @param    item        The notation item
    @param    modif_type    The type of the modification (as one of the #e_undo_modification_types) that need to be performed, in order to revert the item state to the previous state.
    @return                The operation performed by the user, as one of the #e_undo_operations.
    @remark                For instance, if #item is a measure and #modif_type is #k_UNDO_MODIFICATION_DELETE, then the operation returned will be #k_UNDO_OP_ADD_MEASURE.
 */
long notation_item_get_undo_op(t_notation_obj *r_ob, t_notation_item *item, char modif_type);


/**    Obtain, starting from a combination of #e_header_elems, the name of the operation performed by the user when changing the specified header information.
    @ingroup                undo
    @param    header_types    The header elements being changed, as a combination of #e_header_elems
    @return                    The operation, as one of the #e_undo_operations, performed by the user when changing the specified header elements.
    @remark                    For instance, if #header_types = #k_HEADER_KEYS, then the operation returned will be #k_UNDO_OP_CHANGE_KEYS.
 */
long header_types_to_undo_op(long header_types);


/**    Get the inverse undo operation (e.g. from #k_UNDO_OP_ADD_MEASURE to #k_UNDO_OP_DELETE_MEASURE)
    @ingroup                undo
    @param    undo_operation    The given undo operation
    @return                    The inverse undo operation
    @remark                    This only works with adding/deleting operations on chords, measures, voices, markers.
 */
long reverse_undo_op(long undo_operation);


/**    Make an undo operation plural (e.g. from #k_UNDO_OP_CHANGE_MEASURE to #k_UNDO_OP_CHANGE_MEASURES)
    @ingroup                undo
    @param    undo_operation    The given undo operation
    @return                    The plural undo operation
 */
long make_undo_op_plural_for_undo(long undo_operation);


/**    Post on the max window (verbosely) a given undo/redo tick. 
    @ingroup                undo
    @param    r_ob            The notation object
    @param    what            One of the #e_undo_redo specifying if it is a #k_UNDO or a #k_REDO tick.
    @param    info            The tick as a pointer to a #t_undo_redo_information structure.
 */
void post_undo_redo_tick(t_notation_obj *r_ob, long what, t_undo_redo_information *info);


/**    Prune the last undo step, by merging its undo ticks (undo information) into the previous undo step.
    @ingroup                undo
    @param    r_ob            The notation object
    @param    lock_undo_mutex    Flag telling if the function has also to lock/unlock the #c_undo_mutex mutex of the #t_notation_obj.
 */
void prune_last_undo_step(t_notation_obj *r_ob, char lock_undo_mutex);


/**    Tell if a given notation item is under undo tick.
    @ingroup                undo
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                 1 if the notation item is under undo tick, 0 otherwise
 */
char notation_item_is_under_undo_tick(t_notation_obj *r_ob, t_notation_item *item);


/**    Given a notation item, retrieve the corresponding element in the undo tick list (if any), or NULL if none.
    @ingroup                undo
    @param    r_ob            The notation object
    @param    item            The notation item
    @return                 The llllelem containing the item in the items under undo tick llll, or NULL if none
 */
t_llllelem *notation_item_to_undo_tick(t_notation_obj *r_ob, t_notation_item *item);








    
// -----------------------------------
// POPUP MENUS
// -----------------------------------

/** Destroy all popup menus.
    @ingroup    popup_menus
    @param        r_ob        The notation object
 */
void destroy_popup_menus(t_notation_obj *r_ob);


/** Properly build the contextual menu associated with a right click on the background of the object.
    @ingroup    popup_menus
    @param        r_ob            The notation object
    @param      clipboard_type  The current clipboard element type
 */
void build_popup_background_menu(t_notation_obj *r_ob, e_element_types clipboard_type = k_NONE);


/** Properly build the contextual menu associated with a right click on a voice.
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        voice        The voice
 */
void build_popup_voice_menu(t_notation_obj *r_ob, t_voice *voice);


/** Properly build the contextual menu associated with a right click on a notehead.
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        note        The note
    @param      clipboard_type  The current clipboard element type
 */
void build_popup_note_menu(t_notation_obj *r_ob, t_note *note, e_element_types clipboard_type = k_NONE);


/** Properly build the contextual menu associated with a right click on a measure.
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        measure        The measure
 */
void build_popup_measure_menu(t_notation_obj *r_ob, t_measure *measure);


/** Properly build the contextual menu associated with a right click on a measure ending barline.
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        measure        The measure (whose ending barline has been clicked)
 */
void build_popup_barline_menu(t_notation_obj *r_ob, t_measure *measure);


/** Properly build the contextual menu associated with a right click on a biquad filter inside a filter slot
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        clickeditem    The slotitem being clicked (of type filter)
 */
void build_popup_filters_menu(t_notation_obj *r_ob, t_slotitem *clickeditem);


/** Properly build the contextual menu associated with a right click on an articulation.
    @ingroup    popup_menus
    @param        r_ob        The notation object
 */
void build_popup_articulations_menu(t_notation_obj *r_ob);


/** Translate the chosen item ID in the menu into the corresponding clef ID (one of the #e_clefs). 
    For instance, number 1 is translated to k_CLEF_G, number 2 to k_CLEF_F and so on. 
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        result        The chosen item ID in the popup menu
    @return                    The corresponding clef ID (one of the #e_clefs).
 */
long popup_menu_result_to_clef(t_notation_obj *r_ob, long result);


/** Translate the chosen item ID in the menu into the corresponding key signature symbol. 
    For instance, number 101 is translated to "CM", number 102 to "C#M" and so on. 
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        result        The chosen item ID in the popup menu
    @return                    The symbol corresponding to the chosen key signature.
 */
t_symbol* popup_menu_result_to_keysymbol(t_notation_obj *r_ob, long result);


/** Translate the chosen item ID in the menu into the corresponding time signature. 
    For instance, number 501 is translated to 2/2, number 502 to 4/4 and so on. 
    @ingroup    popup_menus
    @param        r_ob        The notation object
    @param        result        The chosen item ID in the popup menu
    @return                    The time signature corresponding to the chosen item ID.
 */
t_timesignature popup_menu_result_to_timesignature(t_notation_obj *r_ob, long result);


/** Handle the process of right clicking on a notehead: builds the menu and intercept the chosen ID.
    Also process the required actions (unless special cases, see "return" to know more).
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob        The notation object
    @param        note        The clicked note
    @param        modifiers    The key modifiers
    @param      clipboard_type  The current clipboard element type
    @return                    One of the #e_actions_upon_change, determining the action to be passed to handle_change() or handle_change_if_there_are_free_undo_ticks(), or
                            the chosen item ID (only in case this is 473, 474, 475, and from 600 to 605), which are values linked
                            with object-specific actions, and thus need to be passed to the specific objects.
                            Specifically, these values correspond to:
                            - 473: Align in time ([bach.roll] only)
                            - 474: Evenly distribute in time ([bach.roll] only)
                            - 475: Legato
                            - 600: Apply Auto Rhythmic Tree Keeping Existing Tuplets ([bach.score] only)
                            - 605: Apply Auto Rhythmic Tree Ignoring Existing Tuplets ([bach.score] only)
                            - 601: Stick Rhythmic Tree ([bach.score] only)
                            - 602: Destroy Rhythmic Tree ([bach.score] only)
                            - 603: Add Level (in Rhythmic Tree, [bach.score] only)
                            - 604: Destroy Level (in Rhythmic Tree, [bach.score] only)
    @remark        The handle_change() functions are a family of function specifying what should be done upon any interface change
                (where the change type is specified in an input as a combination of #e_actions_upon_change longs.
    @remark        A sample code usage is the following, where x is a t_score object.
    @code
     long res;
     res = handle_note_popup((t_notation_obj *) x, curr_nt, modifiers);
     if (res == 475) {
        score_legato(x);
        res = k_CHANGED_DO_NOTHING; // undo ticks, undo markers and bang already done in roll_legato
     } else if (res == 600){
        rebeam_levels_of_selected_tree_nodes(x, false);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_AUTO_RHYTHMIC_TREE_KEEPING_EXISTING_TUPLETS);
     } else if (res == 601){
        fix_levels_of_selected_tree_nodes_as_original(x);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_STICK_RHYTHMIC_TREE);
     } else if (res == 602){
        destroy_selected_tree_nodes(x, true, true, true);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_DESTROY_RHYTHMIC_TREE);
     } else if (res == 603){
        create_level_for_selected_tree_nodes(x);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_ADD_RHYTHMIC_TREE_LEVEL);
     } else if (res == 604){
        splatter_selected_tree_nodes(x, true, true, true);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_DESTROY_RHYTHMIC_TREE_LEVEL);
     } else if (res == 605){
        rebeam_levels_of_selected_tree_nodes(x, true);
        handle_change_if_there_are_free_undo_ticks((t_notation_obj *)x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, k_UNDO_OP_AUTO_RHYTHMIC_TREE_IGNORING_EXISTING_TUPLETS);
     } else if (res != k_CHANGED_DO_NOTHING)
        handle_change((t_notation_obj *)x, res, 0);
 @endcode
 @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_note_popup(t_notation_obj *r_ob, t_note *note, long modifiers, e_element_types clipboard_type = k_NONE);


// TBD
long handle_durationline_popup(t_notation_obj *r_ob, t_duration_line *dl, long modifiers);


/** Handle the process of right clicking on a measure: builds the menu and intercept the chosen ID.
    Also process the required actions (unless special cases, see "return" to know more).
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob        The notation object
    @param        measure        The clicked measure
    @param        modifiers    The key modifiers
    @return                    One of the #e_actions_upon_change, determining the action to be passed to changed_bang() or to handle_change_if_there_are_free_undo_ticks(), or 
                            the chosen item ID (only in case this from 600 to 605), which are values linked
                            with object-specific actions, and thus need to be passed to the specific objects.
                            Specifically, these values correspond to:
                            - 600: Apply Auto Rhythmic Tree Keeping Existing Tuplets ([bach.score] only)
                            - 605: Apply Auto Rhythmic Tree Ignoring Existing Tuplets ([bach.score] only)
                            - 601: Stick Rhythmic Tree ([bach.score] only)
                            - 602: Destroy Rhythmic Tree ([bach.score] only)
                            - 603: Add Level (in Rhythmic Tree, [bach.score] only)
                            - 604: Destroy Level (in Rhythmic Tree, [bach.score] only)
    @see        handle_note_popup()
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_measure_popup(t_notation_obj *r_ob, t_measure *measure, long modifiers);


/** Handle the process of right clicking on a measure barline: builds the menu and intercept the chosen ID.
    Also process the required barline change.
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob        The notation object
    @param        measure        The measure whose right barline has been clicked
    @param        modifiers    The key modifiers
    @return                    One of the #e_actions_upon_change, determining the action to be passed to handle_change() or to handle_change_if_there_are_free_undo_ticks().
    @see        handle_note_popup()
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_barline_popup(t_notation_obj *r_ob, t_measure *measure, long modifiers);


/** Handle the process of right clicking on a voice (at the beginning of its staff): builds the menu and intercept the chosen ID.
    Also process the required actions. If the action involves changing clefs, keys, or midichannels, k_CHANGED_DO_NOTHING is 
    returned and the <chosenelement> pointer is filled with the resulting menu choice, that should be parsed as shown in the sample code. 
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob            The notation object
    @param        voice            The clicked voice
    @param        modifiers        The key modifiers
    @param        chosenelement    Pointer to an integer to be filled with the chosen element ID, actually meaningful only when
                                k_CHANGED_DO_NOTHING is returned, in order to perform object-specific operations
    @return                        One of the #e_actions_upon_change, determining the action to be passed to changed_bang() or handle_change_if_there_are_free_undo_ticks().
    @see        handle_note_popup()
    @remark        Sample code should be like this:
                @code
                int chosenelem;
                char res = handle_voice_popup((t_notation_obj *)x, (t_voice *)voice, modifiers, &chosenelem);
                
                if (res != k_CHANGED_DO_NOTHING) {
                    handle_change((t_notation_obj *)x, res, NULL);
                } else {
                    // clefs ?
                    chosenclef = popup_menu_result_to_clef((t_notation_obj *) x, chosenelem);
                    if (chosenclef != k_CLEF_WRONG) {
                        t_atom av[CONST_MAX_VOICES];
                        long i; t_scorevoice *tmpvoice;
                        create_header_undo_tick((t_notation_obj *)x, k_HEADER_CLEFS);
                        for (i = 0, tmpvoice = x->firstvoice; i < x->r_ob.num_voices && tmpvoice; i++, tmpvoice = tmpvoice->next) {
                            if (tmpvoice == voice)
                                atom_setsym(av+i, clef_number_to_clef_symbol((t_notation_obj *) x, chosenclef));
                            else
                                atom_setsym(av+i, x->r_ob.clefs_as_symlist[i]);
                        }
                        score_setattr_clefs(x, NULL, x->r_ob.num_voices, av);
                        handle_change_if_there_are_free_undo_ticks((t_notation_obj *) x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, gensym("Change Clefs"));
                    } 
                    
                    // keys?
                    chosenkeysym = popup_menu_result_to_keysymbol((t_notation_obj *) x, chosenelem);
                    if (chosenkeysym) {
                        t_atom av[CONST_MAX_VOICES];
                        long i; t_scorevoice *tmpvoice;
                        create_header_undo_tick((t_notation_obj *)x, k_HEADER_KEYS);
                        for (i = 0, tmpvoice = x->firstvoice; i < x->r_ob.num_voices && tmpvoice; i++, tmpvoice = tmpvoice->next) {
                            if (tmpvoice == voice)
                                atom_setsym(av+i, chosenkeysym);
                            else
                                atom_setsym(av+i, x->r_ob.keys_as_symlist[i]);
                        }
                        score_setattr_keys(x, NULL, x->r_ob.num_voices, av);
                        handle_change_if_there_are_free_undo_ticks((t_notation_obj *) x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, gensym("Change Keys"));
                    }
                    
                    // midichannels?
                    if (chosenelem > 150 && chosenelem <= 166){
                        create_header_undo_tick((t_notation_obj *)x, k_HEADER_MIDICHANNELS);
                        change_single_midichannel((t_notation_obj *) x, (t_voice *)voice, chosenelem - 150);
                        handle_change_if_there_are_free_undo_ticks((t_notation_obj *) x, k_CHANGED_STANDARD_UNDO_MARKER_AND_BANG, gensym("Change Midichannels"));
                    } 
                }
                @endcode
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_voice_popup(t_notation_obj *r_ob, t_voice *voice, long modifiers, int *chosenelement);


/** Handle the process of right clicking on the background of a notation objects: build the menu, intercept the chosen ID,
    and process the required changes.
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob        The notation object
    @param        modifiers    The key modifiers
    @param      clipboard_type  The current clipboard element type
    @return                    One of the #e_actions_upon_change, determining the action to be passed to changed_bang() or handle_change_if_there_are_free_undo_ticks().
    @see        handle_note_popup()
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_background_popup(t_notation_obj *r_ob, long modifiers, e_element_types clipboard_type = k_NONE);


/** Handle the process of right clicking on the slotwindow of a filter-typed slot: build the menu, intercept the chosen ID,
    and process the required changes to the filter in the window.
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob            The notation object
    @param        modifiers        The key modifiers
    @param        clicked_item    The slotitem in the window which was clicked (for slots of type #k_SLOT_TYPE_DYNFILTER)
                                Leave it NULL for trivial (for #k_SLOT_TYPE_FILTER).
    @return                        One of the #e_actions_upon_change, determining the action to be passed to changed_bang() or handle_change_if_there_are_free_undo_ticks().
    @see        handle_note_popup()
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_filters_popup(t_notation_obj *r_ob, long modifiers, t_slotitem *clicked_item);



/** Handle the process of right clicking on an articulation: build the menu, intercept the chosen ID,
    and process the required changes.
    @ingroup    popup_menus
    @ingroup    interface
    @param        r_ob            The notation object
    @param        art             The articulation
    @param        modifiers        The key modifiers
    @see        handle_note_popup()
    @see        handle_change()
    @see        handle_change_if_there_are_free_undo_ticks()
 */
long handle_articulations_popup(t_notation_obj *r_ob, t_articulation *art, long modifiers);



// -----------------------------------
// LOCAL SPACING FOR [bach.score]
// -----------------------------------

/** Properly assign a local spacing width multiplier (gamma^x) to a tuttipoint region.
    A local spacing width multiplier is a multiplicative constant which stretches the default width by a certain amount (e.g. 
    it enlarges/shrinks measures); by default this is 1 (no stretch). 
    It is handled by the fields <local_spacing_width_multiplier> of #t_tuttipoint AND #t_measure structures, so you should
    always use this function to assign multipliers, in order for all the values to be synchronized (all measures in a same
    tuttipoint region MUST have the same gamma^x value).
    @ingroup    spacing
    @param        r_ob        The notation object
    @param        tpt            The tuttipoint identifying the tuttipoint region
    @param        new_value    The new value for the local spacing width multiplier
    @remark        This function does not trigger the spacing recalculation, only changes the fields value. You need to explicitely 
                change the recomputations flag, and then perform_analysis_and_change() (or the redraw, if the calculation can
                be done at paint time) in order to have all done. For instance
    
                @code
                assign_local_spacing_width_multiplier(r_ob, tpt, 2.);
                recompute_all_for_tuttipoint_region(r_ob, tpt);
                notationobj_invalidate_notation_static_layer_and_redraw(r_ob);    // or perform_analysis_and_change(...)
                @endcode
    
 */
void assign_local_spacing_width_multiplier(t_notation_obj *r_ob, t_tuttipoint *tpt, double new_value);


/** Properly assign a fixed value for the unscaled width of a tuttipoint region. Similarly to assign_local_spacing_width_multiplier()
    this function automatically sets the <fixed_spacing_uwidth> flag both for the tuttipoint and its measure, and also sets
    their <is_spacing_fixed> flag. Again, use this function to fix spacing width for a tuttipoint, in order to have all sync up.
    @ingroup    spacing
    @param        r_ob        The notation object
    @param        tpt            The tuttipoint identifying the tuttipoint region
    @param        new_value    The new fixed unscaled width for the tuttipoint region.
    @remark        As for assign_local_spacing_width_multiplier(), this function does not change recomputation flags, nor perform the
                changes, so call recompute_all_for_tuttipoint_region() to change the recomputation flags, and then redraw or 
                perform_analysis_and_change() to have changes accounted for.
    @see        remove_fixed_spacing_uwidth()
 */
void assign_fixed_spacing_uwidth(t_notation_obj *r_ob, t_tuttipoint *tpt, double new_value);


/** Remove the fixed spacing for a tuttipoint region, and revert it to the default one. 
    As for the previous functions, this does not change recomputation flags nor
    it perform the changes. Do that explicitely afterwards (see assign_fixed_spacing_uwidth())
    @ingroup    spacing
    @param        r_ob        The notation object
    @param        tpt            The tuttipoint identifying the tuttipoint region
    @see        assign_local_spacing_width_multiplier
    @see        assign_fixed_spacing_uwidth()
 */
void remove_fixed_spacing_uwidth(t_notation_obj *r_ob, t_tuttipoint *tpt);


/** Fix or unfix the measure width for a measure (and also for its whole tuttipoint region).
    If the measure width was fixed (measure->is_spacing_fixed = 1), then it removes the flag, so that the spacing of the 
    measure will float to the default bach-computed spacing. If the measure width was NOT fixed, then it assigns the fixed 
    spacing for the tuttipoint region via assign_fixed_spacing_uwidth(), and also sets the local multiplier to 1.
    @ingroup    spacing
    @param        r_ob        The notation object
    @param        measure        The measure which is being fixed/unfixed
    @remark        It ALSO set to 1 the recompuations flags for the measures and tuttipoint regions affected.
                Yet it does NOT call the perform_analysis_and_change() function, so either you do that explicitely, or
                you call a repaint.
    @see        assign_local_spacing_width_multiplier()
    @see        fix_unfix_barlines_in_selection()
 */
char fix_unfix_measure_width(t_notation_obj *r_ob, t_measure *measure);


/** Fix or unfix the measure width for all the measures whose barline were selected.
    @ingroup    spacing
    @param        r_ob        The notation object
    @remark        It ALSO set to 1 the recompuations flags for the measures and tuttipoint regions affected.
                Yet it does NOT call the perform_analysis_and_change() function, so either you do that explicitely, or
                you call a repaint.
    @see        fix_unfix_measure_width()
 */
char fix_unfix_barlines_in_selection(t_notation_obj *r_ob);


/** Reset the local spacing width multiplier to 1 for all the selected measures (and all their tuttipoint regions).
    @ingroup    spacing
    @param        r_ob        The notation object
    @remark        It ALSO set to 1 the recompuations flags for the measures and tuttipoint regions affected.
                Yet it does NOT call the perform_analysis_and_change() function, so either you do that explicitely, or
                you call a repaint.
    @see        assign_local_spacing_width_multiplier()
 */
char reset_selected_measures_local_spacing_width_multiplier(t_notation_obj *r_ob);





// -----------------------------------
// RHYTHMIC TREES IN [bach.score]
// -----------------------------------

/** Analyze the rhythmic tree of a given measure, and make all the requested changes to analyze/process/rebuild it properly.
    Also identify the correct beamings, and the correct tuplet levels, so that at the end of the function, all levels in the
    measure rhythmic tree contains in their <l_thing> field a perfectly filled #t_rhythm_level_properties structure.
    This function specifically recalls a lot of functions listed below. 
    @ingroup    rhythmic_trees
    @param        r_ob                            The notation object
    @param        measure                            The measure
    @param        char beaming_calculation_flags    One of the #e_beaming_calculation_flags, specifying if some steps must be avoided. Leave #k_BEAMING_CALCULATION_DO = 0 to perform all steps.
    @see        build_beams_structures()
 */
void process_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure, long beaming_calculation_flags);


/** Starting from the information contained in the <l_thing> fields of a measure rhythmic tree, build the actual #t_beam 
    structures to represent beams and tuplets. This function specifically recalls some of the functions listed below.
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        measure            The measure
    @see        process_rhythmic_tree()
 */
void build_beams_structures(t_notation_obj *r_ob, t_measure *measure);


/** Convert a leveltype symbol into an integer, combination of #e_rhythm_level_types.
    @ingroup    rhythmic_trees
    @param      sym The level type as symbol (combination of letters)
    @return     The level type as integer number (combination of #e_rhythm_level_types)
 */
long symbol2leveltype(t_symbol *sym);


/** Convert a leveltype number (combination of #e_rhythm_level_types) into a more user-friendly symbol.
    @ingroup    rhythmic_trees
    @param      leveltype       The level type as integer number (combination of #e_rhythm_level_types)
    @return     The level type as symbol (combination of letters)
 */
t_symbol *leveltype2symbol(long leveltype);


/** A #fun_fn function which flattens any level (incoming hatom) if its level type is k_RHYTHM_LEVEL_IGNORE.
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, flatten_ignore_levels_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long flatten_ignore_levels_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function which analyze if a level (incoming hatom) is a grace level, and in this case it destroys all possible nested grace levels,
    so that at the end we don't have grace levels inside grace levels. Also, if requested by the <try_to_beam_grace_sequences> field of the
    notation object, the algorithm tries to beam together consecutive grace notes.
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, tidy_up_grace_levels_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long tidy_up_grace_levels_fn(void *data, t_hatom *a, const t_llll *address);


/** Set a chord to be grace or not grace (but does not set the recalculation parameter for the measure).
    @ingroup        rhythmic_trees
    @param    r_ob    The notation object
    @param    chord    The chord
    @param    grace    1 if the chord needs to be set as grace chord, 0 if it needs to be set as normal chord 
 */
void toggle_grace_for_chord(t_notation_obj *r_ob, t_chord *chord, char grace);


/** A #fun_fn function which analyze if a level (incoming hatom) has a NULL <l_thing> field, and in this case fills it with a default #t_rhythm_level_properties 
    structure, where the level type is k_RHYTHM_LEVEL_ORIGINAL.
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, mark_levels_with_no_lthing_as_original_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long mark_levels_with_no_lthing_as_original_fn(void *data, t_hatom *a, const t_llll *address);


/** Make a measure rhythmic tree compatible with a certain boxing pattern, typically due to the time signature divisions.
    Elements in the original rhythmic tree can thus be split in correspondance with the end of a box in the boxing pattern.
    For instance, if the boxes are [1/4 1/4 1/4 1/4], as for a 4/4 time signature, the tree
    [(1/4 1/8) 1/4 (1/8 1/4)] will be changed into [(1/4) ((1/8) 1/8) (1/8 (1/8)) (1/4)].
    Please notice that it is up to the programmer to perform later a reduction of the singleton (which is necessary to
    stick with the bach standards for rhythmic trees), for instance by using flatten_singleton_levels(). 
    @ingroup    rhythmic_trees
    @param        r_ob                        The notation object
    @param        measure                        The measure
    @param        boxes                        The boxes (typically coming from a ts_to_beaming_boxes() function)
    @param        only_wrap_ignore_levels        If this is set to 1, the algorithm only is operative on beaming boxes 
                                            having #k_RHYTHM_LEVEL_IGNORE levels inside them. Leave it to 0 for default behaviour.
    @param        cant_split_chords            If this is set to 1, the algorithm will only add the time signature levels when there's no chord to be splitted in between.
    @see        process_rhythmic_tree()
    @see        ts_to_beaming_boxes()
    @remark        This function is essentially equivalent to merge_rests_and_alltied_chords_for_level_fn(), except that it 
                does not need to be called inside llll_funall.
 */
void split_first_level_according_to_boxes(t_notation_obj *r_ob, t_measure *measure, t_llll *boxes, char only_wrap_ignore_levels, char cant_split_chords);


/** A #fun_fn function which for any level (incoming hatom) merges all the sequences of all-tied-chords into a single chord, and
    all the rest-sequences into a single rest. More practically: if it sees N chords in a row, all tied, they are replaced with a 
    single chord whose duration is the sum of the original chords' durations - and similarly with the rests sequences.
    @ingroup    rhythmic_trees
    @param        data                Must be an array of pointers:
                                    - data[0] is the notation object
                                    - data[1] is the measure of the incoming level
                                    - data[2] is a pointer to a char which will be filled to 1 if something has been changed in the box
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, mark_levels_with_no_lthing_as_original_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
    @see        merge_rests_and_alltied_chords_one_step()
 */
 long merge_rests_and_alltied_chords_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Merge all chords lying in the same level and being either completely tied, or being two or more rests in a row.
    Does not merge chords across levels.
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        meas            The measure to which the level <box> belongs
    @param        changed            Pointer to a char which will contain 1 if something has been merged, 0 otherwise
    @param        box                The level whose chords will be possibly merged
    @param        ref_chord        A pointer to a reference (t_chord *) structure, which will be changed if the pointed chord will be merged.
                                This might be handy for chord tracking: if the pointed chord will be merged, the address will be changed 
                                to the one of the newly created bigger chord. Leave this to NULL if you don't need to track any chord.
    @param      merge_when      One of the #e_merge_when flags
    @see        process_rhythmic_tree()
    @see        merge_rests_and_alltied_chords_one_step()
    @remark        This function is essentially equivalent to merge_rests_and_alltied_chords_for_level_fn(), except that it
                does not need to be called inside llll_funall.
 */
void merge_rests_and_alltied_chords_one_step(t_notation_obj *r_ob, t_measure *meas, char *changed, t_llll *box, t_chord **ref_chord, e_merge_when merge_when);


/** A #fun_fn function to find the tuplets inside a specific level (the incoming hatom). 
    Must be used inside funall, for instance
    
    @code
    llll_funall(measure->rhythmic_tree, find_tuplets_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    @endcode 

    @param        data                Must be an array of pointers, containing: @n
                                    data[0] -> (t_notation_obj *) -> The notation object @n
                                    data[1] -> (t_measure *) -> The measure containing the level @n
                                    data[2] -> (char *) ->    Pointer to a char containing an "only_correct_existing_inner_tuplets" information
                                                            If this information is 1, it does not search for new tuplets, but only reparse the 
                                                            existing ones by checking if their tupletinfo parameters are correct. You should
                                                            almost always let this to 0, unless you know what you are doing. @n
                                    data[3] -> (char *) -> Pointer to the desired flag of the #e_beaming_calculation_flags.
    
    @see        process_rhythmic_tree()
    @ingroup    tuplets
 */
long find_tuplets_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Retranscribe a rhythmic tree level, by having all its durations "drawable".
    A "drawable" duration is a duration which can be represented with a single chord. For instance 3/8 is a drawable duration, 
    since it can be represented with a dotted quarter chord; conversely 5/16 is no drawable duration, since it cannot be represented
    via a single duration, but it must rather be split into, say, [1/4 t 1/16].
    The "drawability" also depends on the <max_dots> field of the notation object structure: for instance, if <max_dots> = 1, 
    7/16 is NOT drawable, but if <max_dots> >= 2, 7/16 is perfectly drawable as a double dotted eight note.
    The function splits all the non-drawable chords (or rests) in the level <box> into perfectly drawable tied chords (or rests).
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        box                The level to be retranscribed
    @param        only_compute_chord_figures    If this is 1, the algorithm takes the incoming chords for granted, and only compute their figure via the compute_chord_figure() function.
    @see        process_rhythmic_tree()
 */
void get_rhythm_drawable_one_step(t_notation_obj *r_ob, t_llll *box, char only_compute_chord_figures);


/** A #fun_fn function to get the rhythm drawable inside a given level (the incoming hatom).
    See #get_rhythm_drawable_one_step() to know more about getting rhythms drawable.
    Must be used inside funall, e.g.
    
    @code
    llll_funall(measure->rhythmic_tree, get_rhythm_drawable_for_level_fn, data, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
    @endcode

    @param        data                data[0] -> The notation object (t_notation_obj *) @n
                                    data[3] -> (char *) -> Pointer to the desired flag of the #e_beaming_calculation_flags. @n
                                    All the middle data fields are ignored.
                                    
    @see        process_rhythmic_tree()
    @ingroup    rhythmic_trees
 */
long get_rhythm_drawable_for_level_fn(void *data, t_hatom *beam_tree, const t_llll *address);


// TBD
long fix_level_type_flag_for_level_as_ignore_fn(void *data, t_hatom *a, const t_llll *address);
char rebeam_level(t_notation_obj *r_ob, t_measure *meas, t_llllelem *level, char also_destroy_tuplets, char force_autoparse, long flags);


/** A #fun_fn function to reset all the three beam number parameters to -1 for a level (the incoming hatom).
    The three beam parameters are: beam number, maximum supported beam number and maximum supported beam number if
    the level is inside a level which has a beam. Setting these to -1 will force a recomputation the next time assign_default_beam_numbers_and_refine_beams() is
    performed.
    @ingroup    rhythmic_trees
    @param        data                NULL
    @see        process_rhythmic_tree()
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, reset_beam_number_for_level_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
 */
long reset_beam_number_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Assign default beaming numbers and refine existing beams, by setting the beam number fields for each already existing level
    (if those numbers were negative, meaning they need to be recomputed), and then by trying to find
    inside each existing levels other possible beaming or tuplet levels.
    @ingroup    rhythmic_trees
    @param        r_ob                The notation object
    @param        measure                The measure containing the box to be refined
    @param        box                    The box whose levels need to be refined
    @param        only_assign_default_beams    If this is non-zero the beams are not refined, but only standard beaming values are assigned.
    @param        only_if_beams_are_not_defined    If this is non-zero the default beams are assigned only if they were not already previously assigned (i.e. only if their value is negative, or there's no lthing)
    @see        process_rhythmic_tree()
 */
void assign_default_beam_numbers_and_refine_beams(t_notation_obj *r_ob, t_measure *measure, t_llll *box, char only_assign_default_beams, char only_if_beams_are_not_defined);


/** Possibly automatically add further levels of brackets, by wrapping the elements of a given level (only at the ground depth! that's why it's called "once").
    @ingroup    rhythmic_trees
    @param        r_ob                The notation object
    @param        box                    The level
    @param        for_sublllls_use_max_beam_number_if_under_beam    If this is 1, the algorithm will consider as beaming number of the inner lllls not the actual <beam_number>
                                                                field (stored in the #t_rhythm_level_properties structure in the l_thing field) but the <max_beam_number_if_under_beam> field of the same structure.
    @param        strictly_forbid_noninternal_rests                If this is 1, the algorithm will NOT create levels having a rest at first or last place
    @param        only_additional_refining                        If this is 1, the algorithm will NOT create level spanning all the elements of the level (so no wrapped llll)
                                                                and at the same time it will NOT consider as beamable the inner lllls having only 1 beam more than the number of beams of the level.
                                                                For instance, if the rhythm is [(1/32 1/32) 1/16 (1/24 1/24 1/24)], and the number of beams of the whole level is set to 1,
                                                                the algorithm will wrap the first two elements, but not the third one: [((1/32 1/32) 1/16) (1/24 1/24 1/24)]
                                                                Indeed, the first llll can have a number of beamings up to 3, (3 > 1 + 1), whilst the last llll can have up to 2 beaming (and 2 is not greater than 1 + 1)
                                                                In other words, if this is 1, existing level-to-beam correspondances WILL NOT BE LOST, meaning that all existing level having beams
                                                                will continue to be indentifiable by their beaming: for instance (1/32 1/32) is still identifiable, since it has one more beaming than ((1/32 1/32) 1/16).
    @param        max_number_of_beams_for_refined_lllls            Maximum number of beams that refined lllls will have in the <beam_number> field of their #t_rhythm_level_properties (stored in their <l_thing> field).
                                                                Leave 0 for no limit (should be the default). Notice that the usage of this flag makes sense only for additional refinings; otherwise the <beam_number> would then be
                                                                overwritten by the function check_correct_beaming(), called later on.
    @param        recursively_refine_added_levels                    If this flag is 1, as soon as a new refined level (of type ADDED) is created, it is *immediately* refined in turn.
    @see        process_rhythmic_tree()
    @see        assign_default_beam_numbers_and_refine_beams()
    @remark        This function is called inside assign_default_beam_numbers_and_refine_beams() with #only_additional_refining = 0, and then called repeatedly when some heavy tree operation are performed 
                (such as check_correct_beaming() or correct_tuplets()) with #only_additional_refining = 1, in order to keep the already identified beamed levels visible in the beaming. 
 */
char refine_beams_for_level_once(t_notation_obj *r_ob, t_llll *box, char for_sublllls_use_max_beam_number_if_under_beam, 
                                    char strictly_forbid_noninternal_rests, char only_additional_refining, 
                                    char max_number_of_beams_for_refined_lllls, char recursively_refine_added_levels);


/** Flatten, in the measure rhythmic tree, all redundant singleton levels, i.e. all levels containing a single element, either as #H_OBJ 
    or as nested #H_LLLL. All representation as [((1/4) 1/8 1/8) ((1/4))] are reduced to [(1/4 1/8 1/8) 1/4].
    This is a common process which is by default ALWAYS done over the rhythmic tree. 
    This function also properly calls compatibilize_rhythm_level_properties_before_flatting(), which is in charge to 
    compatibilize the #t_rhythm_level_properties information between the "flattened" level andÂ its dad (for instance, 
    if we flatten a tuplet level onto a non-tuplet level, this latter should be transformed into a tuplet level).
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        measure            The measure whose beaming tree need to be analyzed
    @param        except_for_these_levels        A combination of #e_rhythm_level_types which should NOT be splattered when found.
                                            (but can be flattened and compatibilized). For instance if (a) is such a level,
                                            ((a)) will be flattened and compatibilized to (a), whilst ((b) (a)) will be kept as it is.  
    @see        flatten_level_if_singleton()
    @see        compatibilize_rhythm_level_properties_before_flatting()
    @see        process_rhythmic_tree()
*/
void flatten_singleton_levels(t_notation_obj *r_ob, t_measure *measure, long except_for_these_levels);


/** Properly flatten (repeatedly, if needed) a level, as long as it contains only another single element.
    For instance, levels such as [((1/4))] are flattened to [1/4]. This function is called in flatten_singleton_levels()
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        box                The level
    @param        measure            The measure where the level is
    @param        except_for_these_levels        A combination of #e_rhythm_level_types which should NOT be splattered when found.
                                            (but can be flattened and compatibilized). For instance if (a) is such a level,
                                            ((a)) will be flattened and compatibilized to (a), whilst ((b) (a)) will be kept as it is.  
    @see        flatten_singleton_levels()
    @see        process_rhythmic_tree()
*/
void flatten_level_if_singleton(t_notation_obj *r_ob, t_llll *box, t_measure *measure, long except_for_these_levels);


/** Make compatible the #t_rhythm_level_properties of a dad level and a son level. Usually the dad level has size 1, and thus
    only contains the son level; and usually this compatibilization is needed as soon as the son level has to be splattered, 
    but its properties (such as holding a tuplet!) must be preserved.
    This function tries to merge the dad and son properties, when possible, or otherwise to find possible compromises. 
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        external        The external level
    @param        internal        The internal level
    @see        flatten_singleton_levels()
    @see        process_rhythmic_tree()
*/
void compatibilize_rhythm_level_properties_before_flatting(t_notation_obj *r_ob, t_llll *external, t_llll *internal);


/** Perform additional correction of the tuplets, namely:
    - Verification of the correctness of the tuplet unit with respect to the inner lllls. For instance, if we had as level
      [1/12 (1/24 1/24) 1/12] and the tuplet unit is 1/12, this latter is set to 1/24, and the tuplet multiplier is increased to 2
    - Verification of the possibility to group tuplets, i.e. incorporate more identical tuplets in a row into a single larger-multiplier-tuplet.
      For instance, if we have [(1/24 1/24 1/24) (1/24 1/24 1/24)] we can join the two triplets to have a single 6-plet (multiplier
      = 2) having the same unit and the sum of complete durations: [1/24 1/24 1/24 1/24 1/24 1/24]
    - Verification of the possibility to simplify tuplets, i.e. splattering tree levels only in order to achieve a higher simpler 
      representation of the tuplet. For instance [(1/6 1/12 t) (1/12 1/6)] will be regrouped into [1/6 1/6 1/6].
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        r_ob                        The notation object
    @param        measure                        The measure in which we want to correct the tuplets
    @param        beaming_calculation_flags    One of the #e_beaming_calculation_flags telling if levels or chords must be left untouched  
    @see        process_rhythmic_tree()
*/
void correct_tuplets(t_notation_obj *r_ob, t_measure *measure, char beaming_calculation_flags);


/** Assure that all the level of a measure's beaming tree contain in their <beam_number> field of their #t_rhythm_level_properties
    the correct beaming number. This function follows the following spirit: analyze with the maximum allowed beaming numbers 
    (<max_beam_number> and <max_beam_number_if_under_beam> fields) and then fill the <beam_number> fields in order for them to
    be "coherent" (all inclusion and under-beam-conditions must be respected!) and "maximal" (if we can go up to beaming N, and there's
    no particular coherence reason to stop at a lower beaming, then we'll choose as <beam_number> N).
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        r_ob            The notation object
    @param        meas            The measure in which we want to check the beaming numbers
    @see        process_rhythmic_tree()
*/
void check_correct_beaming(t_notation_obj *r_ob, t_measure *meas);


/** Analyze the possibilities to splatter some levels, if this would help improving the writing. For instance, the tree
    [(1/4 1/4 t) (1/4 1/4)] could be modified into [1/4 1/2 1/4], with a middle syncopation. The opportunity of the modification
    depends on the notation object syncopation parameters, and from the tree handling type. (Of course if the tree is locked
    no such processing is done). 
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        measure            The measure in which we want to check the syncopations
    @see        process_rhythmic_tree()
*/
void handle_tree_syncopations(t_notation_obj *r_ob, t_measure *measure);


/** A #fun_fn function which turns any level (incoming hatom) which is of type #k_RHYTHM_LEVEL_IGNORE or #k_RHYTHM_LEVEL_KEEP into 
    a level of type #k_RHYTHM_LEVEL_ORIGINAL (all other flags are preserved, only the ignore and keep flags are erased).
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, convert_ignore_and_keep_levels, r_ob, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long convert_ignore_and_keep_levels(void *data, t_hatom *a, const t_llll *address);
 

/** A #fun_fn function which sets to 1 or 0 the <is_grace_chord> flag to all chords within a given level (the incoming hatom), depending 
    if the level is a grace level or not.
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, set_is_grace_flag_to_chords_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long set_is_grace_flag_to_chords_fn(void *data, t_hatom *a, const t_llll *address);


/** Decide all the direction for the beaming inside a measure.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        measure        The measure
    @see        process_rhythmic_tree()
 */
void decide_beaming_direction(t_notation_obj *r_ob, t_measure *measure);


/** A #fun_fn function for deciding and setting the direction of a tuplet level (incoming hatom). 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        data                Pointer to a char telling if the measure is in a voice ensemble or in a single voice.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, decide_tuplet_direction_for_level_fn, &is_in_voiceensemble, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
    @see        process_rhythmic_tree()
 */
long decide_tuplet_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Assign to all chords inside a measure the <beam_depth> field, accordingly to the <beam_number> field of the rhythmic tree level 
    they have as parent. So for instance, if a chord is inside a level whose beaming number is 3, the <beam_depth> field will be 
    filled with 3. It's essentially a synchronization function, between the tree analysis information and the chord field.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        measure        The measure
    @see        process_rhythmic_tree()
 */
void set_beams_depth_to_chords(t_notation_obj *r_ob, t_measure *measure);


/** Reset the <stemtip_stafftop_uy>, <topmost_stafftop_uy>, <topmost_stafftop_uy_noacc> and <bottommost_stafftop_uy> fields
    of any chord in the measure to default values. This is used before calculating beam positions.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        measure        The measure
    @see        build_beams_structures()
 */
void reset_stemtip_topmost_bottommost_stafftop_uy_positions(t_notation_obj *r_ob, t_measure *measure);


/** Starting from the <beam_number> fields of the #t_rhythm_level_properties properties contained in the <l_thing> fields
    of the rhythmic tree of a given measure, this function builds the proper #t_beam structures (one for each beam line), 
    and associates them to the proper chords.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        measure        The measure
    @see        build_beams_structures()
    @see        build_measure_tuplet_beams()
 */
void build_measure_beams(t_notation_obj *r_ob, t_measure *measure);


/** Starting from the <tupletinfo> structure of the #t_rhythm_level_properties properties contained in the <l_thing> fields
    of the rhythmic tree of a given measure, this function builds the proper #t_beam structures (one for each tuplet),
    which will be a "false-beam", meaning that its <has_beam_line> field will be 0, and will represent the graphical structures
    needed to propery paint the tuplet instead. 
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        measure        The measure
    @see        build_beams_structures()
    @see        build_measure_beams()
 */
void build_measure_tuplet_beams(t_notation_obj *r_ob, t_measure *measure);


/** A #fun_fn function to flat any level (incoming hatom) which has as level_type #k_RHYTHM_LEVEL_DISPLAY_ONLY.
    This function is performed after all the beam structures have been created in build_beams_structures(),
    so that the purely display levels will not be kept in the tree structure.
    @ingroup    rhythmic_trees
    @param        data                NULL
    @see        build_beams_structures()
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(measure->rhythmic_tree, flatten_level_if_graphical_fn, NULL, 1, one_but_last_level(measure->rhythmic_tree), FUNALL_SKIP_ATOMS);
                @endcode
 */
long flatten_level_if_graphical_fn(void *data, t_hatom *a, const t_llll *address);



/** Reset the local spacing width multiplier to 1 for all the selected measures (and all their tuttipoint regions).
    @ingroup    rhythmic_trees
    @param        r_ob                            The notation object
    @param        rhythmic_tree                    The rhythmic tree
    @param        clone_rhythm_level_properties    Set to 1 if you want to preserve on the duration list the t_rhythm_level_properties information in the l_thing fields
    @param        use_ties_hack                    Very very private parameter. You should always set it to 0. Setting it to 1 will force bach to
                                                make a real bad hack and reverse signs both of numerator and denominator for chords which are all tied to the next one
                                                This is something you should NOT in general do, since reversing signs of numerators and denominators leads to a 
                                                non-bach-standard rational. 
 */
t_llll *rhythmic_tree_to_duration_tree(t_notation_obj *r_ob, t_llll *rhythmic_tree, char clone_rhythm_level_properties, char use_ties_hack);


/** A #fun_fn function for substituting a H_OBJ chord with its H_RAT symbolic duration, in a tree.
    @ingroup    rhythmic_trees
    @param        data                This should be an array of pointers containing
                                    data[0] -> the notation object r_ob
                                    data[1] -> a pointer to a char containing the use_ties_hack flag (see rhythmic_tree_to_duration_tree)
 */
long substitute_chords_with_rduration_fn(void *data, t_hatom *a, const t_llll *address);


/** Build a default #t_rhythm_level_properties structure.
    @ingroup    rhythmic_trees
    @return        The default #t_rhythm_level_properties structure 
 */
t_rhythm_level_properties *build_rhythm_level_properties();


/** Set a level type in the t_rhythm_level_properties of a tree level
    @ingroup    rhythmic_trees
    @param        box            The level
    @param        level_type    The level type, a combination of #e_rhythm_level_types
 */
void set_level_type_flag_for_level(t_llll *box, long level_type);


/** Add a level type in the t_rhythm_level_properties of a tree level
    @ingroup    rhythmic_trees
    @param        box            The level
    @param        level_type    The level type to be added, a combination of #e_rhythm_level_types
 */
void add_level_type_flag_for_level(t_llll *box, long level_type);


/** Sets a beam number in the t_rhythm_level_properties of a tree level
    @ingroup    rhythmic_trees
    @param        box            The level
    @param        beam_number    The beam number for the level (1 = 8ths, 2 = 16ths, and so on)
 */
void set_beam_number_for_level(t_llll *box, char beam_number);


/** Sets a maximum beam number in the t_rhythm_level_properties of a tree level
    @ingroup    rhythmic_trees
    @param        box                The level
    @param        max_beam_number    The maximum beam number the level can support
 */
void set_max_beam_number_for_level(t_llll *box, char max_beam_number);


/** Sets a maximum beam number (if under beam) in the t_rhythm_level_properties of a tree level
    @ingroup    rhythmic_trees
    @param        box                                The level
    @param        max_beam_number_if_under_beam    The maximum beam number the level can support in case the level
                                                is inside another level which has a beam.
 */
void set_max_beam_number_if_under_beam_for_level(t_llll *box, char max_beam_number_if_under_beam);


/** Automatically assign the three beam numbers fields of the #t_rhythm_level_properties structure of a given level.
    @ingroup    rhythmic_trees
    @param        r_ob                The notation object
    @param        level                The level
    @param        only_if_undefined    If this is 1, the beam values are assigned only if they are negative (= undefined).
 */
void set_all_default_beam_numbers(t_notation_obj *r_ob, t_llll *level, char only_if_undefined);


/** A #text_buf_fn used by llll_post_named and llll_print_named as a rule to print H_OBJs and l_thing fields of lllls.
    This function consider the H_OBJs to be #t_chord structures, and the l_things to be #t_rhythm_level_properties, so
    it is designed to be used with rhythmic tree posting/printing. This is useful for debugging (to the tree content, 
    if the tree - as the rhythmic tree - is made of H_OBJs and has l_thing information).
    @ingroup    rhythmic_trees
    @param        h                    The hatom to be translated into string
    @param        verbosity_level        A verbosity level (0 to 3) to tell how much do we want to know of the t_rhythm_level_properties.
    @return        The string corresponding to the hatom.
 */
char* get_strings_for_rhythmic_tree_elements_options(t_hatom *h, char verbosity_level);


/** Quick wrapper for get_strings_for_rhythmic_tree_elements_options(h, 0);
    @ingroup    rhythmic_trees
    @param        h            The hatom to be translated into string
    @param      maxdecimals The maximum number of decimals
    @return        The string corresponding to the hatom
    @see        get_strings_for_rhythmic_tree_elements_options()
 */
char* get_strings_for_rhythmic_tree_elements_verbosity0(t_hatom *h, long maxdecimals);


/** Quick wrapper for get_strings_for_rhythmic_tree_elements_options(h, 1);
    @ingroup    rhythmic_trees
    @param        h            The hatom to be translated into string
    @param      maxdecimals The maximum number of decimals
    @return        The string corresponding to the hatom
    @see        get_strings_for_rhythmic_tree_elements_options()
 */
char* get_strings_for_rhythmic_tree_elements_verbosity1(t_hatom *h, long maxdecimals);


/** Quick wrapper for get_strings_for_rhythmic_tree_elements_options(h, 2);
    @ingroup    rhythmic_trees
    @param        h            The hatom to be translated into string
    @param      maxdecimals The maximum number of decimals
    @return        The string corresponding to the hatom
    @see        get_strings_for_rhythmic_tree_elements_options()
 */
char* get_strings_for_rhythmic_tree_elements_verbosity2(t_hatom *h, long maxdecimals);


/** Quick wrapper for get_strings_for_rhythmic_tree_elements_options(h, 3);
    @ingroup    rhythmic_trees
    @param        h            The hatom to be translated into string
    @param      maxdecimals The maximum number of decimals
    @return        The string corresponding to the hatom
    @see        get_strings_for_rhythmic_tree_elements_options()
 */
char* get_strings_for_rhythmic_tree_elements_verbosity3(t_hatom *h, long maxdecimals);


/** Post in the max window the rhythmic tree (for debug)
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        measure            The measure whose rhythmic tree need to be posted
    @param        frontsymbol        A symbol to be displayed in the left part of the max window
    @param        verbosity_level    A verbosity level (0 to 3, see get_strings_for_rhythmic_tree_elements_options())
 */
void post_rhythmic_tree(t_notation_obj *r_ob, t_measure *measure, t_symbol *frontsymbol, char verbosity_level);


/** A #llll_clone_fn function chiefly used inside the llll_clone and llll_reshape calls to tell the functions to not only clone/reshape 
    the lllls, but also to clone the #t_rhythm_level_properties structures contained in the non-null l_thing fields.
    @ingroup    rhythmic_trees
 */
void* clone_rhythm_level_properties_fn(void *x);


/** A #llll_clone_fn function chiefly used inside the llll_clone and llll_reshape calls to tell the functions to ignore any
    <l_thing> field while cloning.
    @ingroup    rhythmic_trees
 */
void* ignore_l_thing_fn(void *x);


/** Retrieve the depth of a given level ignoring all inner grace levels
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        box                The level
    @return                        The depth of #box, ignoring all grace levels inside it.
 */
long get_depth_ignoring_grace_levels(t_notation_obj *r_ob, t_llll *box);


/** Retrieve the number of chords in a given level, ignoring all inner grace levels
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @param        box                The level
    @return                        The number of chords in #box, ignoring all grace levels inside it.
 */
long get_num_chords_ignoring_grace_levels(t_notation_obj *r_ob, t_llll *box);


/** Sets a beaming slope in the t_rhythm_level_properties of a tree level.
    @ingroup    rhythmic_trees
    @param        box            The level
    @param        slope        The slope value
 */
void set_beam_slope_for_level(t_llll *box, double slope);


/** A #fun_fn function for settinga beaming slope in the t_rhythm_level_properties of a tree level and sublevels.
    @ingroup    rhythmic_trees
    @param        data                This should a (double *) pointer to the slope.
 */
long set_beam_slope_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Sets a beaming direction in the t_rhythm_level_properties of a tree level.
    @ingroup    rhythmic_trees
    @param        box            The level
    @param        direction    The beaming direction (1 = up, -1 = down, 0 = undefined) 
 */
void set_direction_for_level(t_llll *box, char direction);


/** A #fun_fn function for settinga beaming direction in the t_rhythm_level_properties of a tree level and sublevels.
    @ingroup    rhythmic_trees
    @param        data                This should a (char *) pointer to the direction.
 */
long set_direction_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** Obtain the overall symbolic duration of a rhythmic tree level
    @ingroup    rhythmic_trees
    @param        r_ob                    The notation object
    @param        level_rhythmic_tree        The level
    @param        return_0_if_grace        Set this flag to 1 if you want the algorithm to return 0 when the original level is a grace level
    @param        ignore_internal_grace_levels    Set to 1 if you want to ignore the symbolic durations of internal grace levels 
    @param        change_force_tuplet_levels_to_sum    Set to 1 if you want to force to substitute the #k_RHYTHM_LEVEL_FORCE_TUPLET levels with their overall duration 
    @param        level_is_durations        Set to 1 if the <level_rhythmic_tree> is not a rhythmic tree, but instead a tree of durations 
                                        (still with proper #t_rhythm_level_properties in the l_thing fields), as the one obtained via  
                                        rhythmic_tree_to_duration_tree()
    @return        The overall symbolic duration of the <level_rhythmic_tree> level
 */
t_rational get_level_rduration(t_notation_obj *r_ob, t_llll *level_rhythmic_tree, char return_0_if_grace, char ignore_internal_grace_levels, char change_force_tuplet_levels_to_sum, char level_is_durations);


/** Obtain the symbolic duration of the part of a rhythmic tree level preceding a given element
    @ingroup    rhythmic_trees
    @param        level                    The level
    @param        before_this_elem        The element up to which (but NOT included which) the symbolic tree duration must be computed
    @param        ignore_grace_levels        Set to 1 if you want to ignore the symbolic durations of grace elements 
    @return        The overall symbolic duration of the <level_rhythmic_tree> level but only BEFORE the <before_this_elem> element
 */
t_rational get_rduration_before_beaming_element(t_llll *level, t_llllelem *before_this_elem, char ignore_grace_levels);


/** Obtain the first #t_chord structure of a given level
    @ingroup    rhythmic_trees
    @param        level                    The level
    @param        ignore_grace_levels        Set to 1 if you want to ignore the grace elements 
    @return        The first chord in the <level>
    @see        get_leaf_start_chord()
 */
t_chord *get_level_start_chord(t_llll *level, char ignore_grace_levels);


/** Obtain the last #t_chord structure of a given level
    @ingroup    rhythmic_trees
    @param        level                    The level
    @param        ignore_grace_levels        Set to 1 if you want to ignore the grace elements 
    @return        The last chord in the <level>
    @see        get_leaf_end_chord()
 */
t_chord *get_level_end_chord(t_llll *level, char ignore_grace_levels);


/** Obtain the first #t_chord structure of a given beaming tree leaf. If a leaf is a H_LLLL,
    this essentially works as get_level_start_chord(), but if the leaf is an H_OBJ, this returns
    the (t_chord *) H_OBJ itsself.
    @ingroup    rhythmic_trees
    @param        leaf                    The beaming tree leaf
    @param        ignore_grace_levels        Set to 1 if you want to ignore the grace elements 
    @return        The last chord in the <leaf>
    @see        get_level_start_chord()
 */
t_chord *get_leaf_start_chord(t_llllelem *leaf, char ignore_grace_levels);


/** Obtain the last #t_chord structure of a given beaming tree leaf. If a leaf is a H_LLLL,
    this essentially works as get_level_end_chord(), but if the leaf is an H_OBJ, this returns
    the (t_chord *) H_OBJ itsself.
    @ingroup    rhythmic_trees
    @param        leaf                    The beaming tree leaf
    @param        ignore_grace_levels        Set to 1 if you want to ignore the grace elements 
    @return        The last chord in the <leaf>
    @see        get_level_end_chord()
 */
t_chord *get_leaf_end_chord(t_llllelem *leaf, char ignore_grace_levels);


/** Take the selected measures of a notation object, and lock their rhythmic tree (if it was unlocked) or unlock it (if it was locked).
    @ingroup    rhythmic_trees
    @param        r_ob            The notation object
    @return        1 if something has changed, 0 otherwise.
 */
char lock_unlock_rhythmic_trees_in_selection(t_notation_obj *r_ob);


/** Obtain the maximum beam numbers contained in the level properties of all levels INSIDE a given reference level (which is ALSO accounted) 
    @ingroup    rhythmic_trees
    @param        level                The reference level (which is also accounted in the maximum finding process)
    @return        The highest beam number of all levels inside <level> (and included <level>).
 */
char get_max_beam_depth_inside_level(t_llll *level);


/** Obtain the maximum beam numbers contained in the level properties of all levels OUTSIDE a given reference level 
    (which is ALSO accounted). These outside-levels are elsewhere referred to as "ancestors" of the reference level.
    @ingroup    rhythmic_trees
    @param        level                The reference level (which is also accounted in the maximum finding process)
    @return        The highest beam number of all levels outside <level> (and included <level>).
 */
char get_max_depth_outside_level(t_llll *level);


/** Obtain the maximum beam numbers contained in the level properties of all levels OUTSIDE or INSIDE a given reference level 
    (which is ALSO accounted). So, the maximum search is performed through all ancestors of levels, and through all the sons,
    grand-sons, grand-grand-sons... of the level.
    @ingroup    rhythmic_trees
    @param        level                The reference level (which is also accounted in the maximum finding process)
    @return        The highest beam number of all levels outside or inside <level> (and included <level>).
 */
char get_max_depth_for_level(t_llll *level);


/** Tell if a level is locked. A level is "locked" when it cannot be modified, and this can only be when two things happen:
    1. the measure->lock_rhythmic_tree flag is set (the rhythmic tree in the measure is locked), and 2. the level is not
    an #k_RHYTHM_LEVEL_IGNORE or #k_RHYTHM_LEVEL_KEEP level (which are the level type set when users forces the automatic recalculation
    of rhythmic tree).
    @ingroup    rhythmic_trees
    @param        measure        The measure
    @param        level        The level
    @return        1 if the level is locked
 */
char is_level_locked(t_measure *measure, t_llll *level);


/** Tell if a level is of type #k_RHYTHM_LEVEL_ORIGINAL.
    @ingroup    rhythmic_trees
    @param        box        The level
    @return        1 if the level is an original level
 */
char is_level_original(t_llll *box);


/** Tell if a level is a grace level.
    @ingroup    rhythmic_trees
    @param        box        The level
    @return        1 if the level is a grace level
 */
char is_level_grace(t_llll *box);


/** Tell if a level is a grace level or is inside a grace level.
    @ingroup    rhythmic_trees
    @param        box        The level
    @return        1 if the level is a grace level or is inside a grace level
 */
char is_level_grace_or_inside_grace(t_llll *box);


/** Tell if a level is a tuplet level.
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box        The level
    @return        1 if the level is a tuplet
 */
char is_level_tuplet(t_llll *box);


/** Tell if a level contains a tuplet level (which can also be the level itself).
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box        The level
    @return        1 if the level contains a tuplet level (which can also be the level itself)
 */
char level_contains_tuplet(t_llll *box);


/** Delete all the grace sub-levels from a level 
    @ingroup    rhythmic_trees
    @param        box        The level
 */
void delete_grace_levels(t_llll *box);


/** Flatten a list, but preserve all levels starting with the "g" symbol.
    Also flatten the "g" levels completely. So for instance, from ((1/12 1/12 1/12) 1/8 (g 1/8 (1/16 1/16)) -1/4)
    one has (1/12 1/12 1/12 1/8 (g 1/8 1/16 1/16) -1/4)
    @ingroup    rhythmic_trees
    @param        box        The list
    @remark        It does NOT free the l_things: no llll having filled l_thing fields should be passed to this function. 
 */
void flat_up_to_level_starting_with_g(t_llll *box);


/** Tell if inside a given level there is any tuplet level
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box        The level
    @return        1 if there is a tuplet level inside <box>, 0 otherwise
 */
char are_there_tuplets_inside_level(t_llll *box);


/** Add the #k_RHYTHM_LEVEL_KEEP flag to the level_type of the t_rhythm_level_properties of all tuplet sub-levels of a level
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box        The level
 */
void set_tuplet_levels_as_keep_levels(t_llll *tree);


/** Completely flatten a level, but preserving its inner levels of a certain type (or type combinations). Those inner levels are kept, but flatten in turn, until
    other levels of the requested type(s) are found.
    @ingroup    rhythmic_trees
    @param        box            The level to be flattened
    @param        mindepth    The mindepth for flattening
    @param        maxdepth    The maxdepth for flattening
    @param        leveltypes    The type or types of levels that need to be kept (as a combination of #e_rhythm_level_types)
    @param        freething    One of the #e_freething_modes, handling the way the l_thing of lllls is freed while flattening.
    @param        data        Unused, dummy
 */
void flat_preserving_leveltypes(t_llll *box, long mindepth, long maxdepth, e_rhythm_level_types leveltypes, e_freething_modes freething, void *data);


/** A #fun_fn function for removing the INTERNAL grace flags in a tree level (it does not remove the level itself, if it is grace). 
    This will convert the levels into normal levels.
    @ingroup    rhythmic_trees
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(level, clear_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
                @endcode
 */
long clear_grace_levels_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function for removing the #k_RHYTHM_LEVEL_FORCE_TUPLET flag on all levels which had it. 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        data                NULL pointer, no data needed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(meas->rhythmic_tree, remove_force_tuplet_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
                @endcode
 */
long remove_force_tuplet_levels_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function to fill the <tuplet_local_ratio> field of the chords (the incoming hatoms) of the beaming tree. 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        data                Must be an pointer to the overall chord tuplet ratio (= product of the pregressed ratio and the tuplet ratio)
    @remark        Must be used inside funall, e.g.
                @code
                t_rhythm_level_properties *prop = ...;
                t_rational overall_ratio = rat_rat_prod(prop->tupletinfo.tuplet_local_ratio, prop->tupletinfo.tuplet_pregressed_ratio);
                llll_funall(your_level, set_tuplet_overall_ratio_for_level_chords_fn, &overall_ratio, 1, -1, 0);
                @endcode
 */
long set_tuplet_overall_ratio_for_level_chords_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function to multiply the <tuplet_local_ratio> field of the chords (the incoming hatoms) of the beaming tree by a certain ratio. 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        data                Must be an pointer to the multiplier ratio (= product of the pregressed ratio and the tuplet ratio)
    @remark        Must be used inside funall
    @see        set_tuplet_overall_ratio_for_level_chords_fn()
 */
long multiply_tuplet_overall_ratio_for_level_chords_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function to compute the proper figures for the chords (the incoming hatoms) of the beaming tree. 
    @ingroup    rhythmic_trees
    @param        data                The notation object (t_notation_obj *)
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(your_level, compute_chord_figure_for_level_fn, r_ob, 1, -1, 0);
                @endcode
 */
long compute_chord_figure_for_level_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function to set the <level_type> flag of a level (the incoming hatom) as #k_RHYTHM_LEVEL_ORIGINAL.
    @ingroup    rhythmic_trees
    @param        data                Must be a pointer to a char, which will be filled with 1 if some level type has been changed.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(your_level, fix_level_type_flag_for_level_as_original_fn, &this_changed, 1, -1, FUNALL_SKIP_ATOMS);
                @endcode
 */
long fix_level_type_flag_for_level_as_original_fn(void *data, t_hatom *a, const t_llll *address);


/** Get the size of a level, ignoring all the grace sublevels
    @ingroup    rhythmic_trees
    @param        box            The level
    @return        The number of elements in <box> except for the elements corresponding to grace sublevels.
 */
long level_size_except_for_grace(t_llll *box);


/** Get the cumulated tuplet ratio of the stricly outer levels with respect to a reference level. 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box            The reference level
    @return        The cumulated tuplet ratio of the levels strictly outside <box>.
    @remark        For instance, if "tr" indicates a tuplet ratio, and we represent as {...} the l_thing fields, in a tree 
                such as {tr 2/3}(.... {tr 3/4}(.... {tr 7/8}(*****  {tr 3/4}(....))))
                the **** level has get_overall_tuplet_ratio_for_outer_levels = (2/3) * (3/4)
 */
t_rational get_overall_tuplet_ratio_for_outer_levels(t_llll *box);


/** Get the cumulated tuplet ratio of the outer levels of a reference level, and of the reference level itself. 
    @ingroup    rhythmic_trees
    @ingroup    tuplets
    @param        box            The reference level
    @return        The cumulated tuplet ratio of the levels outside <box> and <box> itsself.
    @remark        For instance, if "tr" indicates a tuplet ratio, and we represent as {...} the l_thing fields, in a tree 
                such as {tr 2/3}(.... {tr 3/4}(.... {tr 7/8}(*****  {tr 3/4}(....))))
                the **** level has get_overall_tuplet_ratio_for_outer_levels = (2/3) * (3/4) * (7/8)
 */
t_rational get_overall_tuplet_ratio_for_outer_levels_and_this_level(t_llll *box);


/** Tell if, inside a given llll (root level included), there is a sublevel having a given <level_type> (a combination of the #e_rhythm_level_types).
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        ll            The root level
    @param        level_type    The level type to match, as a combination of the #e_rhythm_level_types
    @return        1 if a sublist having as type <level_type> is found in the specified <ll> (included the root level); 0 otherwise
    @remark        The <level_type> match is positive when any of the levels specified by the <level_type> is found.
 */
char there_is_level_type_inside_llll(t_notation_obj *r_ob, t_llll *ll, long level_type);


/** Tell if, in a given level, there is a sublevel having at least some portion of it situated between a starting and ending duration (with respect to the given level),
    whose type include level_type (type & level_type is nonzero), <level_type> being a combination of the #e_rhythm_level_types.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        ll            The level
    @param        start_dur    The starting onset (0 = beginning of <ll> level) for the search of sublevels
    @param        end_dur        The ending onset for the search of sublevels
    @param        level_type    The level type to match, as a combination of the #e_rhythm_level_types
    @param        only_across_range    If this flag is 1, this only accounts for levels which are settled ACROSS the range borders, and not for levels completely inside the specified range
    @return        1 if a sublist including <level_type> is found in the specified range of the level <ll>; 0 otherwise
    @remark        The <level_type> match is positive when any of the levels specified by the <level_type> is found.
 */
char there_is_level_in_llll_range(t_notation_obj *r_ob, t_llll *ll, t_rational start_dur, t_rational end_dur, long level_type, char only_across_range);


/** Check again if the beaming inclusions are correct for the level <dad> in the measure meas.
    This function can be called when you perform some changes on levels that for some reasons might destroy the correctness of beamings.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @param        meas        The measure
    @param        dad            The level to be checked
 */
void re_check_beams_for_lower_levels(t_notation_obj *r_ob, t_measure *meas, t_llll *dad);


/** Lock the rhythmic trees of the selected measures.
    @ingroup    rhythmic_trees
    @param        r_ob        The notation object
    @return        1 if something has changed, 0 otherwise
 */
char lock_rhythmic_trees_in_selection(t_notation_obj *r_ob);


/** Unlock the rhythmic trees of the selected measures.
    @param        r_ob        The notation object
    @return        1 if something has changed, 0 otherwise
    @ingroup    rhythmic_trees
 */
char unlock_rhythmic_trees_in_selection(t_notation_obj *r_ob); 


/** Properly fill all the tupletinfo fields, starting from:
    - the tuplet unit (ignoring the pregressed ratio)
    - the pregressed ratio
    - the tuplet complete symbolic duration
    @remark        See the function documentation, section Tuplets.
    @param        r_ob                                The notation object
    @param        tupletinfo                            Pointer to the #t_tupletinfo structure to be filled
    @param        tuplet_local_unit        The tuplet unit ignoring the pregressed ratio
    @param        pregressed_ratio                    The pregresse ratio (ratio of the outer levels of the current level)
    @param        tuplet_sym_duration                    The complete symbolic duration of the tuplet
    @ingroup    tuplets
 */
void fill_tupletinfo_fields(t_notation_obj *r_ob, t_tupletinfo *tupletinfo, t_rational tuplet_local_unit, t_rational pregressed_ratio, t_rational tuplet_sym_duration);


/** Properly fill all the tupletinfo fields, starting from:
    - the local tuplet ratio (ignoring previous ratios)
    - the tuplet graphical unit
    - the pregressed ratio
    - the tuplet multiplier
    @remark        See the function documentation, section Tuplets.
    @param        r_ob                                The notation object
    @param        tupletinfo                            Pointer to the #t_tupletinfo structure to be filled
    @param        tuplet_local_ratio                        The local tuplet ratio (ignoring outer levels)
    @param        tuplet_graphical_unit                The graphical figure used to paint the tuplet unit
    @param        pregressed_ratio                    The pregresse ratio (ratio of the outer levels of the current level)
    @param        tuplet_multiplier                    The tuplet multiplier (see #t_tupletinfo for more information about all these)
    @ingroup    tuplets
 */
void fill_tupletinfo_fields2(t_notation_obj *r_ob, t_tupletinfo *tupletinfo, t_rational tuplet_local_ratio, t_rational tuplet_graphical_unit, t_rational pregressed_ratio, t_rational tuplet_multiplier);


/** Correct the tupletinfo fields for a given box, depending on the box durations
    @remark        This is usually used in combination right after one of the fill_tupletinfo_fields() function, for instance:
    @code
                fill_tupletinfo_fields(r_ob, &prop->tupletinfo, forced_local_unit, pregresse_ratio, forced_duration);
                correct_tuplets_units_and_multiplier_for_level(r_ob, meas, box, true);
    @endcode
    @param        r_ob                The notation object
    @param        measure                The measure
    @param        box                    The box in which we want to correct the tuplets
    @param        just_take_sublllls_as_their_full_duration    If this is true, when sublllls are found, they are accounted only with their full duration.
    @ingroup    tuplets
 */
void correct_tuplets_units_and_multiplier_for_level(t_notation_obj *r_ob, t_measure *measure, t_llll *box, char just_take_sublllls_as_their_full_duration);


/** Find the rational greatest common divisors of all rationals contained in a llll, but ignoring al sub-lllls which are tuplets.
    When a tuplet sub-llll is found in the depth iteration, only the tuplet complete duration (and not the tuplet single elements)
    are accounted for in the gcd calculation.
    @param        r_ob            The notation object
    @param        rationals        A llll containing rational values (chiefly the rational durations of a level, obtained for 
                                instance from the rhythmic tree via rhythmic_tree_to_duration_tree())
    @return        The greatest common divisors of all rationals in the llll, but considering tuplet levels only with
                their overall duration.
    @ingroup    rhythmic_trees
*/
t_rational llll_gcd_of_rat_llll_until_tuplet(t_notation_obj *r_ob, t_llll *rationals);


/** Find the sum of all absolute values of rationals contained in a llll, but ignoring al sub-lllls which are grace levels.
    @param        r_ob            The notation object
    @param        rationals        A llll containing rational values (chiefly the rational durations of a level, obtained for 
                                instance from the rhythmic tree via rhythmic_tree_to_duration_tree())
    @param        consider_forcetuplets_with_their_total_duration        If this is 1, the levels whose type is #k_RHYTHM_LEVEL_FORCE_TUPLET are considered in their tuplet complete symbolic duration contained in the #tupletinfo field of the #t_rhythm_level_properties structure
    @return        The sum of absolute values of all rationals in the llll, but ignoring grace levels.
    @ingroup    rhythmic_trees
*/
t_rational llll_sum_abs_of_rat_llll_until_grace(t_llll *rationals, char consider_forcetuplets_with_their_total_duration);


/** Find the correct screen figure for a given tuplet unit (ignoring the pregressed ratio).
    For instance, the screen figure associated with the tuplet unit 1/12 is 1/8. 
    @param        r_ob                                The notation object
    @param        tuplet_local_unit        The tuplet unit, ignoring the pregressed ratio (see #t_tupletinfo)
    @param        allow_dotted_tuplets                Set to 1 if you allow to have dotted tuplets, 0 if you forbid it
    @return        The correct screen figure complete duration (e.g. including dots, if any).
    @remark        If you apply this function to nested tuplets, be sure to use as tuplet unit the 
                <tuplet_local_unit> field, and NOT the real tuplet unit. For instance, if a 1/12 triplet is split in
                3 again, yielding a tuplet unit of 1/36 for the inner tuplet, the corresponding tuplet unit ignoring the pregressed ratio 
                is 1/24: indeed we're putting 3 notes in a 1/12, which has a graphical representation of 1/8 (this is the representation
                which matters if we ignore the pregresse ratio, i.e. we ignore the fact that this eight note is under a triplet). And
                1/8 divided into 3 yields 1/24 (for more information, see the Tuplets section in the function documentation). 
    @ingroup    tuplets
*/
t_rational tuplet_unit_to_tuplet_graphical_unit(t_notation_obj *r_ob, t_rational tuplet_local_unit, char allow_dotted_tuplets);


/** Find the greatest common divisor of all elements at the base level of an llll containing rationals. If at the base levels are
    found lllls, their overall sum is accounted for as a single rational (instead of the llll itsself). 
    @param        rationals        A llll containing rational values (chiefly the rational durations of a level, obtained for 
                                instance from the rhythmic tree via rhythmic_tree_to_duration_tree())
    @param        consider_forcetuplets_with_their_total_duration        If this is 1, the levels whose type is #k_RHYTHM_LEVEL_FORCE_TUPLET are considered in their tuplet complete symbolic duration contained in the #tupletinfo field of the #t_rhythm_level_properties structure
    @return        The greatest common divisor of all durations on first level in <rationals> (if lllls are found, their overall
                duration is accounted for).
    @ingroup    rhythmic_trees
*/
t_rational llll_gcd_on_first_level_in_rdurations_rhythmic_tree(t_llll *rationals, char consider_forcetuplets_with_their_total_duration);


/** Tell if a rhythmic tree node is "good" for tuplet processing, i.e. it allows its brackets to be splattered, in order to 
    create a larger or simpler upper tuplet level. If this function returns 0, this node won't be considered when trying to 
    process tuplets, and will be kept as it is. This function depends essentially on the tree level types and the tree handling modes.
    The tuplet processing is essentially done in the correct_tuplets() function. 
    @param        r_ob                    The notation object
    @param        boxelem                    The llllelem (leaf or node of the rhythmic tree)
    @param        no_good_level_types        A combination of #e_rhythm_level_types which will be alwyas treated as `no good' levels.
    @param        orig_and_keep_together_is_good    If this is 1, if the level is both #k_RHYTHM_LEVEL_ORIGINAL and (#k_RHYTHM_LEVEL_KEEP or #k_RHYTHM_LEVEL_IGNORE), it will be considered good.
    @return        1 if node is good for tuplet processing, 0 otherwise.
    @ingroup    tuplets
*/
char node_is_good_for_processing_tuplets(t_notation_obj *r_ob, t_llllelem *boxelem, long no_good_level_types, char orig_and_keep_or_ignore_together_is_good);


/** Append a beam to the measure.
    @param        measure            The measure
    @param        beam            The beam
    @ingroup    rhythmic_trees
 */
void append_beam(t_measure *measure, t_beam *beam);


/** Build a single beam structure.
    @param        startchord            The starting chord of the beam
    @param        endchord            The ending chord of the beam
    @return                            The built beam
    @ingroup    rhythmic_trees
 */
t_beam *build_beam(t_chord *startchord, t_chord *endchord);


/** Delete a beam from a measure
    @param        r_ob            The notation object
    @param        measure            The measure
    @param        beam            The beam
    @ingroup    rhythmic_trees
 */
void delete_beam(t_notation_obj *r_ob, t_measure *measure, t_beam *beam);


/** Delete all beams from a measure
    @param        r_ob            The notation object
    @param        measure            The measure
    @ingroup    rhythmic_trees
 */
void clear_measure_beams(t_notation_obj *r_ob, t_measure *meas);


/** Convert a multi-chord or -measure selection into a set of selected tree nodes.
    The conversion is done as follows: 
    - for any selected measure, all chords are selected; 
    - all the chords are terminal leafs of the tree, and thus they are all selected at the beginning;
    - if the chords (leafs) of an entire tree level are selected, the leafs are removed from selection, and their dad-llll node 
      is put into the selection instead;
    - this process is iterated as long as there are tree levels whose nodes are completely selected.
    Extremely important remark: since whole measures correspond to the global measure llll, who has no llllelem owning it,
    in order to tell that the whole measure rhythmic tree is selected the #WHITENULL_llllelem llllelem is used. 
    Any algorithm using results should thus take care of this possibility!
    @param        r_ob            The notation object
    @param        num_nodes        Pointer which will be filled with the number of selected nodes
    @param        nodes            Pointer to an array of (#t_llllelem *), which will be filled with an array of <num_nodes> nodes.
    @param        node_measures    Pointer to an array of (#t_measure *), which will be filled with an array of <num_nodes> measure, 
                                each representing the measure where it is situated the corresponding node in the <nodes> array.
    @remark        Of course, the <nodes> and <node_measures> pointers must be manually freed after usage.
    @ingroup    rhythmic_trees
 */
void selected_chords_and_measures_to_selected_rhythmic_tree_nodes(t_notation_obj *r_ob, long *num_nodes, t_llllelem ***nodes, t_measure ***node_measures);


/** Obtain the closest "ancestor" (parent or grand-parent or grand-grand-parent etc.) of an llllelem, whose
    associated #t_rhythm_level_properties have a beam, and have more than one chord inside the level (except for grace ones).
    @param        r_ob            The notation object
    @param        elem            The llllelem
    @return                        The first ancestor of #elem having a beam.
    @ingroup    rhythmic_trees
 */
t_llll *get_first_ancestor_having_a_beam(t_notation_obj *r_ob, t_llllelem *elem);


/** Obtain the highest beam number among all the "ancestors" (parent or grand-parent or grand-grand-parent etc.) of 
    a given llllelem. The beam number of each ancestor (which is indeed an llll) is stored in the <beam_number> field of the
    #t_rhythm_level_properties structure contained in the llll <l_thing> field.
    @param        elem                    The llllelem
    @param        stop_to_grace_levels    Set this to 1 if you want to stop the ancestor backward search when a grace level
                                        was achieved, and avoid considering anything outside this level (= any former ancestor).
    @return        The highest beam number among all the ancestors of <elem>; 0 if all ancestors are unbeamed. 
    @ingroup    rhythmic_trees
 */
char get_highest_ancestor_beam_number(t_llllelem *elem, char stop_to_grace_levels);


/** Tell if the rhythmic tree of any selected measure is locked
    @param        r_ob            The notation object
    @return        1 if all the selected measures have a locked rhythmic tree, 0 otherwise.
    @ingroup    rhythmic_trees
    @ingroup    selection
 */
char is_all_selection_rhythmic_tree_locked(t_notation_obj *r_ob);


/** Tell if the rhythmic tree of any selected measure is unlocked
    @param        r_ob            The notation object
    @return        1 if all the selected measures have an unlocked rhythmic tree, 0 otherwise.
    @ingroup    rhythmic_trees
    @ingroup    selection
 */
char is_all_selection_rhythmic_tree_unlocked(t_notation_obj *r_ob);


/** A #fun_fn function to wrap grace levels inside a (g ...) list.
    @ingroup    rhythmic_trees
    @param        data                NULL, unneeded.
    @remark        Must be used inside funall, e.g.
                @code
                llll_funall(llll, add_g_in_front_of_grace_levels_fn, NULL, 1, -1, FUNALL_SKIP_ATOMS);
                @endcode
 */
long add_g_in_front_of_grace_levels_fn(void *data, t_hatom *a, const t_llll *address);


/** A #fun_fn function to add a "t" symbol between all the completely tied chords 
    @ingroup    rhythmic_trees
    @param        data                Must be an array having @n
                                    data[0] -> the (#t_notation_obj *) structure
                                    data[1] -> the lists itself used to funall
    @remark        Must be used inside funall, e.g.
                @code
                void *data[2]
                t_llll *model = llll_clone_extended(measure->rhythmic_tree, WHITENULL_llll, 0, clone_rhythm_level_properties_fn);
                data[0] = (t_notation_obj *)x;
                data[1] = model;
                llll_funall(model, add_t_after_all_tied_chords_fn, data, 1, -1, 0);
                @endcode
 */
long add_t_after_all_tied_chords_fn(void *data, t_hatom *a, const t_llll *address);


/** Get the first tuplet-ancestor of a given notation element; in other words: it finds the innermost level
    of parenthesis (around a given llllelem) representing a tuplet.
    @param        leaf        The llllelem
    @return        The innermost level of parenthesis (around #leaf) representing a tuplet. NULL if none.
    @see        get_innermost_tuplet_level_for_chord()
 */
t_llll *get_innermost_tuplet_level(t_llllelem *leaf);


/** Get the innermost tuplet including a given chord.
    @param        chord    The chord
    @return        The innermost rhythmic level representing a tuplet and wrapped around the chord. NULL if none.
    @see        get_innermost_tuplet_level()
 */
t_llll *get_innermost_tuplet_level_for_chord(t_chord *chord);


/** Get the starting chord of a tuplet.
    @param        generic_chord_inside_the_tuplet     Any of the chords inside the tuplet
    @return        The starting chord of the tuplet containing #generic_chord_inside_the_tuplet.
    @see        get_tuplet_end_chord()
 */
t_chord *get_tuplet_start_chord(t_chord *generic_chord_inside_the_tuplet);


/** Get the ending chord of a tuplet.
    @param        generic_chord_inside_the_tuplet     Any of the chords inside the tuplet
    @return        The ending chord of the tuplet containing #generic_chord_inside_the_tuplet.
    @see        get_tuplet_start_chord()
 */
t_chord *get_tuplet_end_chord(t_chord *generic_chord_inside_the_tuplet);


/** Properly set the <is_grace_chord> field of all chords inside a given rhythmic tree, depending if they are inside
    a grace level or not.
    @param        r_ob    The notation object
    @param        tree    The rhythmic tree
 */
void set_grace_flag_to_chords_from_rhythmic_tree(t_notation_obj *r_ob, t_llll *tree);



// -----------------------------------
// ATTRIBUTES ADDING
// -----------------------------------

/** Add to a class all the common attributes for notation objects. This recalls all the other
    notation_class_add_*() functions.
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_notation_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning object behavior.
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_behavior_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning object editing.
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_edit_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning things to show or hide.
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_showhide_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning fonds
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_font_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning pitches
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_pitches_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning object settings
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_settings_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning colors
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_color_attributes(t_class *c, char obj_type);


/** Add to a class all the common attributes concerning object appearance
    @ingroup    attributes
    @param        c            The class
    @param        obj_type    The object type (one of the #e_notation_objects)
 */
void notation_class_add_appearance_attributes(t_class *c, char obj_type);



// -----------------------------------
// SETTERS
// -----------------------------------

/** \addtogroup attributes 
 *  @{
 */
t_max_err notation_obj_setattr_showvscrollbar(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_bgcolor(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_inset(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_jitmatrix(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_show_voicenames(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_voicenames(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_voicenames_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_voicenames_font(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_nonantialiasedstaff(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_numvoices(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_clefs(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_keys(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_midichannels(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_voicespacing(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_hidevoices(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_markers_font(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_markers_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_rulermode(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_stafflines(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_lyrics_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_dynamics_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_dynamics_roman_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_annotation_font_size(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_lyrics_alignment(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linklyricstoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linknotecolortoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linkarticulationstoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linknoteheadtoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linknoteheadfonttoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linknoteheadadjusttoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linknoteheadsizetoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linkannotationtoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linkdynamicstoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linkdlcolortoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_linklyricstoslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_showlyrics(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_onseteqthresh(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_ruler(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_showmeasurenumbers(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_showvelocity(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_labelfamilies(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_samplingrate(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_highlightplay(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_showloop(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_useloop(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_backgroundslots(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_popupmenuslots(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_rightclickdirectlypopsoutslot(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_set_clefs(t_notation_obj *r_ob, t_symbol **newstaff, long *must_recompute_all);
t_max_err notation_obj_set_keys(t_notation_obj *r_ob, t_symbol **keys);
t_max_err notation_obj_set_hidevoices(t_notation_obj *r_ob, char *hide);
t_max_err notation_obj_set_voicespacing(t_notation_obj *r_ob, long ac, double *value);
t_max_err notation_obj_setattr_preventedit(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_maxundosteps(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_showaccidentalspreferences(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_lyrics_font(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_annotations_font(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_setattr_numparts(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);
t_max_err notation_obj_voice_part_getattr(t_notation_obj *r_ob, t_object *attr, long *ac, t_atom **av);
t_max_err notation_obj_set_numparts_from_llll(t_notation_obj *r_ob, t_llll *ll);
t_max_err notation_obj_set_parts_from_llll(t_notation_obj *r_ob, t_llll *ll);
t_max_err notation_obj_set_parts(t_notation_obj *r_ob, long *part);
t_max_err notation_obj_setattr_dumpplaycmd(t_notation_obj *r_ob, t_object *attr, long ac, t_atom *av);

// GETTERS

t_max_err notation_obj_getattr_voicenames(t_notation_obj *x, t_object *attrname, long *ac, t_atom **av);
t_max_err notation_obj_getattr_stafflines(t_notation_obj *x, t_object *attrname, long *ac, t_atom **av);
t_max_err notation_obj_getattr_dumpplaycmd(t_notation_obj *x, t_object *attr, long *ac, t_atom **av);
/** @}*/


// -----------------------------------
// MARKERS
// -----------------------------------

/** Build a new marker. This function allocate the memory and set fields to the correct values (depending from the arguments)
    @ingroup        markers
    @param    r_ob    The notation object
    @param    names    The name(s) of the marker (as llll)
    @param    ms        The position in milliseconds of the marker
    @param    tp        The timepoint of the marker (only makes sense with [bach.score])
    @param    attach_to    One of the #e_marker_attach, deciding to what the marker should be attached. By default, it should be #k_MARKER_ATTACH_TO_MS.
    @param    role        One of the #e_marker_roles, possibly specifying the special role of the marker
    @param    content        If the role is NOT #k_MARKER_ROLE_NONE, this is the content associated with the marker role (e.g. tempo or time signature). See the <content> field of the #t_marker structure.
    @return            The newly built marker
 */
t_marker *build_marker(t_notation_obj *r_ob, t_llll *names, double ms, t_timepoint tp, char attach_to, e_marker_roles role, t_llll *content);


/** Clear all the markers in the score
    @ingroup        markers
    @param    r_ob    The notation object
 */
void clear_all_markers(t_notation_obj *r_ob);


/** Properly insert an already built marker in the score.
    Markers are always kept ordered by the <position_ms> field. If you need to check ordering, use check_markers_order()
    @ingroup        markers
    @param    r_ob    The notation object
    @param    marker    The marker to insert
    @param    force_ID    If this is > 0, it'll be the ID that the marker will be forced to have.
 */
void insert_marker(t_notation_obj *r_ob, t_marker *marker, unsigned long force_ID);


/** Convenience wrapper for build_marker and insert_marker. Builds and insert a marker inside the score.
    @ingroup        markers
    @param    r_ob    The notation object
    @param    names    The name(s) of the marker (as llll)
    @param    ms        The position in milliseconds of the marker
    @param    tp        The timepoint of the marker (only makes sense with [bach.score])
    @param    attach_to    One of the #e_marker_attach, deciding to what the marker should be attached. By default, it should be #k_MARKER_ATTACH_TO_MS.
    @param    role        One of the #e_marker_roles, possibly specifying the special role of the marker
    @param    content        If the role is NOT #k_MARKER_ROLE_NONE, this is the content associated with the marker role (e.g. tempo or time signature). See the <content> field of the #t_marker structure.
    @param    force_ID    If this is > 0, it'll be the ID that the marker will be forced to have.
    @return            The newly built marker
 */
t_marker *add_marker(t_notation_obj *r_ob, t_llll *names, double ms, t_timepoint tp, char attach_to, e_marker_roles role, t_llll *content, unsigned long force_ID);


/** Verify if the ordering of the markers is correct, with respect to the ascending <position_ms> fields.
    If not, corrects the ordering.
    @ingroup        markers
    @param    r_ob    The notation object
    @return            1 if something has changed, 0 otherwise
 */
char check_markers_order(t_notation_obj *r_ob);


/** Delete a marker from the score (and properly free its memory).
    @ingroup        markers
    @param    r_ob    The notation object
    @param    marker    The marker to delete
 */
void delete_marker(t_notation_obj *r_ob, t_marker *marker);


/** Search for a marker having a given name (among its possible multiple names), and delete it from the score (and properly free its memory).
    @ingroup        markers
    @param    r_ob    The notation object
    @param    names    The llll of names to be matched for the marker to delete
    @remark            Only the first occurrence of the name is searched and deleted!
    @return            1 if something has been deleted, 0 otherwise.
 */
char delete_marker_by_name(t_notation_obj *r_ob, t_llll *names);


/** Find the first marker having a set of given names (among its possible names)
    @ingroup        markers
    @param    r_ob    The notation object
    @param    names    The llll of names to be matched for the marker
    @return            The first marker having <name> as name; NULL if none.
 */
t_marker *markername2marker(t_notation_obj *r_ob, t_llll *names);


/** Select all the markers
    @ingroup        markers
    @ingroup        selection
    @param    r_ob    The notation object
    @param mode      The selection mode (one of the #e_selection_modes)
    @param only_this_marker_role    One of the e_marker_roles, or -1 if ALL markers should be selected
 */
void select_all_markers(t_notation_obj *r_ob, e_selection_modes mode, long only_this_marker_role);


/** Select all the voices
    @ingroup        voices
    @ingroup        selection
    @param    r_ob    The notation object
    @param mode      The selection mode (one of the #e_selection_modes)
 */
void select_all_voices(t_notation_obj *r_ob, e_selection_modes mode);


/** Select all the chords
    @ingroup        selection
    @param    r_ob    The notation object
    @param mode     The selection mode (one of the #e_selection_modes)
 */
void select_all_chords(t_notation_obj *r_ob, e_selection_modes mode);


/** Select all the notes
    @ingroup        selection
    @param    r_ob    The notation object
 @param mode     The selection mode (one of the #e_selection_modes)
 */
void select_all_notes(t_notation_obj *r_ob, e_selection_modes mode);


/** Select all the rests
    @ingroup        selection
    @param    r_ob    The notation object
 @param mode     The selection mode (one of the #e_selection_modes)
 */
void select_all_rests(t_notation_obj *r_ob, e_selection_modes mode);


/** Select all the pitch breakpoints
    @ingroup        selection
    @param    r_ob    The notation object
    @param mode     The selection mode (one of the #e_selection_modes)
 */
void select_all_breakpoints(t_notation_obj *r_ob, e_selection_modes mode, char tails_only);


/** Select all the measures
    @ingroup        selection
    @param    r_ob    The notation object
 @param mode     The selection mode (one of the #e_selection_modes)
 */
void select_all_measures(t_notation_obj *r_ob, e_selection_modes mode);


/** Delete all the pitch breakpoints
    @ingroup        notation
    @param    r_ob            The notation object
    @param voice_number     The voice number, or set a negative number (e.g. -1) for all voices.
 */
char delete_all_breakpoints(t_notation_obj *r_ob, long voice_number);


/** Change a marker name (and recompute also the <name_uwidth> flag accordingly).
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker
    @param    new_names    The new marker's name as an llll
    @see                recalculate_marker_name_uwidth()
    @return                1 if the new name is different from the old one, 0 otherwise
 */
long change_marker_names(t_notation_obj *r_ob, t_marker *marker, t_llll *new_names);


/** Properly fill the <name_uwidth> field of a marker, contaning the unscaled width of the marker name label
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker
 */
void recalculate_marker_name_uwidth(t_notation_obj *r_ob, t_marker *marker);


/** Change a marker position in milliseconds.
    @ingroup                    markers
    @param    r_ob                The notation object
    @param    marker                The marker
    @param    new_ms                The new marker's position in ms
    @param    delta_mode            If this is 1, the <new_ms> value will be added to the marker's milliseconds. Otherwise they'll be replaced.
    @param    also_check_sorting    If this is 1, also the algorithm checks the correct ordering of all markers, increasing with respect to the <position_ms> field.
 */
void change_marker_ms(t_notation_obj *r_ob, t_marker *marker, double new_ms, char delta_mode, char also_check_sorting);


/** Change a marker role.
    @ingroup                    markers
    @param    r_ob                The notation object
    @param    marker                The marker
    @param    new_role            The new marker's role, as one of the #e_marker_roles
 */
void change_marker_role(t_notation_obj *r_ob, t_marker *marker, e_marker_roles new_role);

/** Interpret a symbol as a marker role (one of the #e_marker_roles).
    For gensym("timesig") is interpreted as #k_MARKER_ROLE_TIME_SIGNATURE.
    @ingroup            markers
    @param    s            The symbol
    @return                The element of #e_marker_roles corresponding to the symbol
 */
e_marker_roles sym_to_marker_role(t_symbol *s);


/** Convert a marker role into a symbol. 
    For instance #k_MARKER_ROLE_TIME_SIGNATURE is translated into _llllobj_sym_tempo = gensym("timesig").
    @ingroup            markers
    @param    marker_role    One of the #e_marker_roles
    @return                The symbol corresponding to the marker role.
 */
t_symbol *marker_role_to_sym(e_marker_roles marker_role);


/** (Internal) Shifts the selected markers depending on the current mousedown marker
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker_with_mousedown_ux    The ux position of the marker currently having the mousedown
    @param    magnetic    If non-zero, snaps to the nearest chord
    @param    delta_ms    If non-NULL, will be filled with the actual movement in milliseconds 
    @return                1 if something has changed, 0 otherwise
 */
char move_selected_ms_attached_markers(t_notation_obj *r_ob, double marker_with_mousedown_ux, char magnetic, double *delta_ms);


/** Shift the selected markers by an amount (in milliseconds)
    @ingroup            markers
    @param    r_ob        The notation object
    @param    delta_ms    The amount of the shift (in milliseconds)
    @param    magnetic    If non-zero, snaps to the nearest chord
    @return                1 if something has changed, 0 otherwise
 */
char move_selected_ms_attached_markers_delta(t_notation_obj *r_ob, double delta_ms);


/** Find the first incremental numbered unused marker name similar to a given name.
    For instance, if the given name is "foo", he'll try to search for "foo 1", "foo 2"... up to "foo 100000",
    and if any of these is NOT used, it returns the corresponding atom array (usually with length 2, unless the introduced 
    marker name was a long atom, in this case the output length will be 1, since the number will be tried to be incremented).
    If no incremental free names could be found, the original name be copied. 
    @ingroup                    markers
    @param    r_ob                The notation object
    @param    default_name        The base atom for building the incremental numbered sequence
    @param    ignore_this_marker    A marker which can be ignored while searching for an unused name.
                                For instance, when trying to make a given marker's name unique, one can ignore the marker itself. 
                                Leave it to NULL for standard behavior.
    @return                        The llll of unused incrementally numbered name found.
    @remark                        To avoid confusions, you might want to be sure that the <default_name> has no numbers at the end.
                                If you want to make a name unique, use make_marker_name_unique().
 */
t_llll *find_unused_marker_names(t_notation_obj *r_ob, t_hatom *default_name, t_marker *ignore_this_marker);


/** Make a marker name unique, by changing its numerical suffix.
    For instance, it might change "foo2" to "foo5", if all "foo2", "foo3" and "foo4" are already taken
    @ingroup        markers
    @param    r_ob    The notation object
    @param    names    The original names
    @return            The first unused incrementally numered name found as llll.
    @param    num_found_names        Pointer filled with the number of names found (length of #found_names)
 */
t_llll *make_marker_name_unique(t_notation_obj *r_ob, t_llll *names);


/** Change the name of the selected markers to a new name.
    @ingroup            selection_changes
    @param    r_ob        The notation object
    @param    new_names    The new marker names as llll
    @param    incremental    If this is 1, every name will be made unique by incrementing its numerical suffix
    @return                1 if something has changed, 0 otherwise.
 */
char change_selected_markers_name(t_notation_obj *r_ob, t_llll *new_names, char incremental);


/** Get the unscaled x position of the marker.
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker      The marker
    @return                The unscaled x position of the marker
 */
double get_marker_ux_position(t_notation_obj *r_ob, t_marker *marker);


/** Get the marker onset in milliseconds.
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker      The marker
    @return                The marker onset in milliseconds
 */
double get_marker_ms_position(t_notation_obj *r_ob, t_marker *marker);


/** Obtain all the markers as an llll containing (<position_ms> <name>) for each marker.
    @ingroup            markers
    @param    r_ob        The notation object
    @param    mode        If this is 1, the algorithm only returns the markers within a given "temporal window" (specified by the following paramters)
                        If this is 0, all the markers are given.
    @param    start_ms    If <mode> = 1, this is the starting position of the window in milliseconds (otherwise ignored)
    @param    end_ms        If <mode> = 1, this is the ending position of the window in milliseconds (otherwise ignored)
    @param    namefirst    If this is non-zero, the llll for each marker will be (<name> <position_ms>) 
    @param    for_what    This should be usually one of #k_CONSIDER_FOR_DUMPING, #k_CONSIDER_FOR_SUBDUMPING, #k_CONSIDER_FOR_UNDO or #k_CONSIDER_FOR_SCORE2ROLL.
    @param    start_meas_num    If <for_what> is #k_CONSIDER_FOR_SUBDUMPING and <r_ob> is a bach.score, this is the starting measure number for clipping (so that the dumped
                            information will be with respect to this measure as the starting one).
    @return                The markers' positions and names as llll.
    @see                get_single_marker_as_llll()
 */
t_llll *get_markers_as_llll(t_notation_obj *r_ob, char mode, double start_ms, double end_ms, char namefirst, char for_what, long start_meas_num);


/** Get an llll containing the information about a specific marker (or about all the markers)
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker whose information has to be got, or NULL if you need the information about all markers
    @param    command_number    Command number, if any (if no command is to be sent, use -1)
    @param    namefirst    If this is 1, the usual (<position_ms> <name>) coupling is reversed for each marker, and becomes (<name> <position_ms>).
                        If this is 0, the syntax is the usual (<position_ms> <name>).
    @return                A list containing the information about a single marker or all markers.
    @remark                Differntly from get_markers_as_llll(), the information we get can have names first and can concern a single marker
                        (but cannot concern a temporal window).
    @see                get_markers_as_llll()
 */
t_llll *get_single_marker_as_llll(t_notation_obj *r_ob, t_marker *marker, long command_number, char namefirst);


/** Set all markers of a given notation objet from a list of markers in the usual syntax (<position_ms> <name>) (<position_ms> <name>) ...
    @ingroup            markers
    @remark                Beware: this function does NOT free the markers llll, but might DELETE some parts of it!!!
    @param    r_ob        The notation object
    @param    markers        The llll determining the markers, in the above explained syntax
    @param    add_mode    If this is 1, the markers will be added to the existing ones, otherwise the existing ones will be removed
    @param    select      If this is 1, the markers will be added to the current selection
    @see                get_single_marker_as_llll()
 */
void set_markers_from_llll(t_notation_obj *r_ob, t_llll* markers, char add_mode, char select);


/** Retrieve the timepoint of a measure-attached-marker (for [bach.score]).
    @remark                Indeed the marker structure only contains the ID of the measure to which it is attached, and the symbolic offset inside the measure,
                        but it does not contain the precise timepoint.
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker
    @return                The timepoint of the marker
 */
t_timepoint measure_attached_marker_to_timepoint(t_notation_obj *r_ob, t_marker *marker);


/** Change the onset of a marker (and possibly its attachment type) either from a lexpr
    containing the new milliseconds position or (if this latter is NULL), from a llllelem containing either the milliseconds position, or the new
    timepoint (measure_number point_in_measure) or (measure_number point_in_measure voice_number) 
    @remark                Does NOT check the correct markers order, need to do it later via check_markers_order()
    @ingroup            markers
    @param    r_ob        The notation object
    @param    marker        The marker
    @param    lexpr        The lexpr
    @param    elem        The llllelem
 */
void change_marker_onset_from_lexpr_or_llllelem(t_notation_obj *r_ob, t_marker *marker, t_lexpr *lexpr, t_llllelem *elem);




// -----------------------------------
// GROUPS
// -----------------------------------

// Groups are larger structures gathering multiple notation elements. Up to now, they're used to allow common editing (moving) of the whole elements
// in the group at once in [bach.roll] (so they're unused - yet? - in [bach.score]).
// Each notation object has a linked list of groups, heads and tails being the <firstgroup> and <lastgroup> fields (by default NULL), specifying the
// groups "acting" on the elements.

/** Build a new group. This function allocate the memory and set fields to the default values.
    @ingroup    groups
    @return        The newly built group
    @see        build_and_append_group_from_selection()
 */
t_group *build_group();


/** Build a new group, and already fills it with all selected elements.
    @ingroup        groups
    @param    r_ob    The notation object
    @return            The newly built group
    @see            build_group()
 */
t_group *build_and_append_group_from_selection(t_notation_obj *r_ob);


/** Append a group to the linked list of groups of a notation object.
    @ingroup        groups
    @param    r_ob    The notation object
    @param    group    The group to append
 */
void append_group(t_notation_obj *r_ob, t_group *group);


/** Delete a group from the linked list of groups of a notation object.
    Also frees the group memory.
    @ingroup        groups
    @param    r_ob    The notation object
    @param    group    The group to delete
 */
void delete_group(t_notation_obj *r_ob, t_group *group);


/** Delete all groups of a given notation object (and free their memory)
    @ingroup        groups
    @param    r_ob    The notation object
 */
void clear_all_groups(t_notation_obj *r_ob);


/** Add a certain notation item to a given group.
    @ingroup    groups
    @param        r_ob        The notation object
    @param        group        The group
    @param        element        The notation item
 */
void append_element_in_group(t_notation_obj *r_ob, t_group *group, t_notation_item *element);


/** Remove a certain notation item to a given group.
    @ingroup    groups
    @param        r_ob        The notation object
    @param        group        The group
    @param        element        The pointer to the notation item to be removed. 
 */
void remove_element_from_group(t_notation_obj *r_ob, t_group *group, t_notation_item *element);


/** Tell if all selected elements belong to the same group.
    @ingroup    groups
    @param        r_ob        The notation object
    @param        whichgroup    Pointer to a (t_group *) pointer which will be filled with the address of the common group to all elements 
                            (or with NULL if a common group could not be found)
    @return        1 if all the selected elements belong to the same group, 0 otherwise
 */
char is_all_selection_in_one_group(t_notation_obj *r_ob, t_group **whichgroup);

char is_all_group_selected(t_notation_obj *r_ob, t_group *gr); // TBD
t_notation_item *group_get_leftmost_item(t_notation_obj *r_ob, t_group *gr);
t_notation_item *group_get_rightmost_item(t_notation_obj *r_ob, t_group *gr);



// -----------------------------------
// BACH ATTRIBUTES
// -----------------------------------

/** Initialize an attribute manager. An attribute managare is a structure taking care of bach-attributes handling for all elements of a given notation object. 
    @ingroup    attributes
    @param        man        The attribute manager
 */
void initialize_attr_manager(t_bach_attr_manager *man);


/** Standard macro used to declare a bach-attribute. It communicates to the notation manager of the notation object the standard set of parameters requested
    to deal with the attribute. A bach-attribute is always associated to a given field of a given C structure.
    @ingroup    attributes
    @param    man                    The    attribute manager
    @param    forced_position        A 0-based integer specifying the position of the attribute in the bach inspector. Leave this to -1 to append attributes at the end (standard usage).
    @param    name                A symbol specifying the name of the attribute
    @param    displayed_label        A string which will be used in the bach inspector as a label for the attribute
    @param    owner_type            The element type to which the attribute apply: one of the #e_element_types
    @param    struct_name            The name of the C structure owning the field associated with the attribute.
    @param    struct_member        The name of the field in the #struct_name structure, to which the attribute is associated
    @param    attr_type            The data type of the #struct_member field, as one of the #e_bach_attr_types
    @param    attr_size            If #attr_type is an array, the length of the array; otherwise leave to 1. 
                                If #attr_type is a VARSIZE array, then this is the *maximum* possible number of elements in the array. 
                                Be careful, in this case, to also define #ADD_BACH_ATTR_VARSIZE_FIELD. 
    @param    display_type        The type of interface handling of the attribute in the inspector, as one of the #e_bach_attr_display_types
    @param    preprocess_flags    Unused (maybe supported in the future), leave to 0
    @param    postprocess_flags    Unused (maybe supported in the future), leave to 0
 */
#define DECLARE_BACH_ATTR(man, forced_position, name, displayed_label, owner_type, struct_name, struct_member, attr_type, attr_size, display_type, preprocess_flags, postprocess_flags)  \
    bach_attribute_declare(man, forced_position, name, displayed_label, owner_type, calcoffset(struct_name, struct_member), attr_type, attr_size, display_type, preprocess_flags, postprocess_flags) 


/** Function called underlying the #DECLARE_BACH_ATTR macro. You should NEVER call this function directly, but use the #DECLARE_BACH_ATTR macro instead!!!
    @ingroup    attributes
    @param    man                    The    attribute manager
    @param    forced_position        A 0-based integer specifying the position of the attribute in the bach inspector. Leave this to -1 to append attributes at the end (standard usage).
    @param    name                A symbol specifying the name of the attribute
    @param    displayed_label        A string which will be used in the bach inspector as a label for the attribute
    @param    owner_type            The element type to which the attribute apply: one of the #e_element_types
    @param    field_position        Byte offset of the field corresponding to the attribute with respect to the beginning of the C structure. The macro #DECLARE_BACH_ATTR automatically calculates this via the Max #calcoffset macro
    @param    attr_type            The data type of the #struct_member field, as one of the #e_bach_attr_types
    @param    attr_size            If #attr_type is an array, the length of the array; otherwise leave to 1
    @param    display_type        The type of interface handling of the attribute in the inspector, as one of the #e_bach_attr_display_types
    @param    preprocess_flags    Unused (maybe supported in the future), leave to 0
    @param    postprocess_flags    Unused (maybe supported in the future), leave to 0
*/
void bach_attribute_declare(t_bach_attr_manager *man, char forced_position, t_symbol *name, const char *displayed_label, long owner_type, long field_position, long attr_type, long attr_size, char display_type, long preprocess_flags, long postprocess_flags);


/** Retrieve a bach attribute from its name and the owner type.
    @ingroup    attributes
    @param    man            The    attribute manager
    @param    owner_type    One of the #e_element_types corresponding to the type of element of the attribute owner
    @param    name        The name of the attribute
    @return                The corresponding #t_bach_attribute structure representing the bach attribute
 */
t_bach_attribute *bach_attribute_get(t_bach_attr_manager *man, long owner_type, t_symbol *name);


/** Add some 'lambda' function to deal with attributes. All attributes might have setters, getters, preprocess functions (function performed BEFORE the attribute is set) or postprocess functions (function performed AFTER the attribute has been set).
    This is useful to deal with all the complex notation interface. Typically, the preprocess functions deals with placing an undo tick, while the postprocess function deals with recalculating graphical stuff (if needed) and/or placing the undo marker.
    bach has default setters/getters/preprocess/postprocess/inactive functions which will be used if these functions are not defined (which is the case, by default, unless you define them by calling this routine.
    Also you can add an "inactive" function, telling if the attribute must be inactive in the inspector (returning 1 if this is the case, 0 otherwise).
    @ingroup    attributes
    @param    r_ob            The    notation object
    @param    attr            The bach-attribute to which the functions must be added (you can retrieve it via bach_attribute_get() if you don't have it directly)
    @param    getter            The getter function for the bach-attribute
    @param    setter            The setter function for the bach-attribute
    @param    preprocess        The preprocess function for the bach-attribute
    @param    postprocess        The postprocess function for the bach-attribute
    @param    inactive        The inactive function for the bach-attribute (returning 1 if the attribute must be inactive in the bach-inspector)
*/
void bach_attribute_add_functions(t_bach_attribute *attr, bach_getter_fn getter, bach_setter_fn setter, bach_attr_process_fn preprocess, bach_attr_process_fn postprocess, bach_inactive_fn inactive);


/** Standard macro used to set the field inside the structure which contains the information about the size of the attribute. 
    This is needed for attributes of the kind #k_BACH_ATTR_ATOM_ARRAY_VARSIZE, which behave like the standard VARSIZE Max attributes.
    Via this function you tag a field of the structure, stating that it contains the current size of the attribute, and you can update it directly when needed. 
    This function it is a wrapper for bach_attribute_add_var_size_offset().
    @ingroup    attributes
    @param    r_ob                The    notation object
    @param    name                The name of the attribute
    @param    owner_type            The element type to which the attribute apply: one of the #e_element_types
    @param    struct_name            The name of the C structure owning the field associated with the attribute.
    @param    struct_member        The name of the field in the #struct_name structure, which contains the size of the attribtue
 */

#define ADD_BACH_ATTR_VARSIZE_FIELD(attr_manager, name, owner_type, struct_name, struct_member)  \
    bach_attribute_add_var_size_offset(bach_attribute_get(attr_manager, owner_type, name), calcoffset(struct_name, struct_member));
    

/** Sets the t_bach_attribute::field_position_for_var_attr_size field for a given attribute. This field contains the information about the offset of the
    field containing the current size of the attribute (if the attribute has a variable size).
    @ingroup    attributes
    @param    attr    The bach attribute
    @param    offset    The offset of the field containing the current size of the attribute inside the attribute structure
 */
void bach_attribute_add_var_size_offset(t_bach_attribute *attr, long offset);


/** Sets the elements of the enumindex menu (scrolldown menu) for a given attribute
    @ingroup    attributes
    @param    attr        The bach attribute
    @param    num_items    Number of items in the scrolldown menu
    @param    items        Pointer to an array of #num_items symbols containing the list of symbols to be displayed in the menu
 */
void bach_attribute_add_enumindex(t_bach_attribute *attr, long num_items, t_symbol **items);


/** Declare the standard attributes for any notation object.
    These include almost all slotinfo/note/voice/markers attributes, and some chord attributes. 
    @ingroup    attributes
    @param    r_ob                The    notation object
 */
void notation_obj_bach_attribute_declares(t_notation_obj *r_ob);





/** Setter for a bach attribute (from an A_GIMME signature). If a custom setter is defined, it uses it, otherwise it uses the default bach_default_set_bach_attr() .
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @param    ac        The number of atoms in the A_GIMME signature
    @param    av        The atoms of the A_GIMME signature
 */
void bach_set_attr(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long ac, t_atom *av);


/** Getter for a bach attribute (from an A_GIMME signature). If a custom getter is defined, it uses it, otherwise it uses the default bach_default_get_bach_attr() .
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @param    ac        Pointer which will be filled with the number of atoms in the A_GIMME signature
    @param    av        Pointer which will be filled with the atoms of the A_GIMME signature (you'll need to free it later).
 */
void bach_get_attr(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long *ac, t_atom **av);


/** Inactivity determiner for a bach attribute. This function is called when the bach inspector is painted, in order to determine if a 
    given attribute is currently active or not. If a custom inactivity determiner is defined, it calls it,
    otherwise it calls the default bach_default_attr_inactive().
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
long bach_attr_inactive(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


/** Preprocessor for a bach attribute. This function is called BEFORE the attribute is set. 
    If a custom preprocess function is defined, it calls it, otherwise it uses the default bach_default_preprocess().
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
void bach_preprocess_attr(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


/** Postprocessor for a bach attribute. This function is called AFTER the attribute has been set. 
    If a custom postprocess function is defined, it calls it, otherwise it uses the default bach_default_postprocess().
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
void bach_postprocess_attr(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);





/** Standard setter for a bach attribute (from an A_GIMME signature). It handles most of the usual notation cases.
    This function is used by default, unless another setter is defined via bach_attribute_add_functions(). 
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @param    ac        The number of atoms in the A_GIMME signature
    @param    av        The atoms of the A_GIMME signature
 */
void bach_default_set_bach_attr(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr, long ac, t_atom *av);


/** Standard getter for a bach attribute (from an A_GIMME signature). It handles most of the usual notation cases. 
    This function is used by default, unless another getter is defined via bach_attribute_add_functions(). 
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @param    ac        Pointer which will be filled with the number of atoms in the A_GIMME signature
    @param    av        Pointer which will be filled with the atoms of the A_GIMME signature (you'll need to free it later).
 */
void bach_default_get_bach_attr(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr, long *ac, t_atom **av);


/** Standard inactivity determiner, handling the most common cases.
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
long bach_default_attr_inactive(t_notation_obj *r_ob, void *elem, t_bach_attribute *attr);


/** Standard preprocessor for a bach attribute. This function handles the most common cases.
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
void bach_default_preprocess(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr);


/** Standard postprocessor for a bach attribute. This function handles the most common cases.
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
void bach_default_postprocess(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr);


/** Properly set an attribute from an A_GIMME signature. This function properly calls the preprocessing function,
    sets the attribute (via the setter) and then calls the postprocessing function.
    @ingroup    attributes
    @param    man     The    inspector manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @param    ac        The number of atoms in the A_GIMME signature
    @param    av        The atoms of the A_GIMME signature
    @param    force_undo_step    If this is non-zero, the function handle_change_if_there_are_free_undo_ticks() is called in order to set the undo marker.
                            This is usually set to 1 (we put the undo marker).
 */
void set_bach_attr_and_process_from_ac_av(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long ac, t_atom *av, char force_undo_step);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
/** OBSOLETE or DEPRECATED */
t_rect bach_chord_miniature_fn(t_notation_obj *r_ob, void *elem, long elem_type, char *show_line);
t_rect bach_note_miniature_fn(t_notation_obj *r_ob, void *elem, long elem_type, char *show_line);
t_rect bach_voice_miniature_fn(t_notation_obj *r_ob, void *elem, long elem_type, char *show_line);
long get_field_position(void *field, void *structure); // DEPRECATED!!! use calcoffset instead
#endif


// To be documented
void bach_default_inspector_header_fn(t_notation_obj *r_ob, t_bach_inspector_manager *inspector_manager, void *elem, long elem_type, char *txt);
t_jsurface *bach_get_icon_surface_fn(t_notation_obj *r_ob, t_bach_inspector_manager *inspector_manager, void *obj, long elem_type);


/** Obtain the content of a bach attribute as a string containing a single character (for compatibility with bach_attribute_get_as_string()).
    Notice that a char array is thus allocated, and you need to free it when it is no longer needed. This is usually used for #k_BACH_ATTR_DISPLAY_CHAR
    attributes.
    @ingroup    attributes
    @param    man     The attribute manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
    @return            The string containing a single character representing the attribute.
 */
char *bach_attribute_get_as_character(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


/** Obtain the content of a bach attribute as a string. A char array is allocated and returned, and you need to free it when it is no longer needed.
    @ingroup    attributes
    @param    man     The attribute manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
char *bach_attribute_get_as_string(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


/** Obtain the content of a bach attribute as a #t_jrgba color structure. This makes only sense for #k_BACH_ATTR_COLOR.
    @ingroup    attributes
    @param    man     The attribute manager
    @param    obj        Pointer to the object being inspected
    @param    attr    The bach attribute
 */
t_jrgba bach_attribute_get_as_color(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


/** Set the voicename for the inspected voice from an A_GIMME signature.
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object (voice) being inspected
    @param    attr    The bach attribute (corresponding to the voicename)
    @param    ac        The number of atoms in the A_GIMME signature
    @param    av        The atoms of the A_GIMME signature.
 */
void bach_attr_set_single_voicename(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr, long ac, t_atom *av);


/** Get the voicename for the inspected voice as an A_GIMME signature.
    @ingroup    attributes
    @param    r_ob    The    notation object
    @param    obj        Pointer to the object (voice) being inspected
    @param    attr    The bach attribute (corresponding to the voicename)
    @param    ac        Pointer which will be filled with the number of atoms in the A_GIMME signature
    @param    av        Pointer which will be filled with the atoms of the A_GIMME signature (you'll need to free it later).
 */
void bach_attr_get_single_voicename(t_notation_obj *r_ob, void *obj, t_bach_attribute *attr, long *ac, t_atom **av);



/** A bach-attributes setter which can be used for notation items for attributes linked with notation item's flags (one of the #e_notation_item_flags).
    @ingroup    attributes
    @param      man     The inspector manager
    @param        obj        The element to which the attribute refers
    @param        attr    The attribute
    @param        ac        The number of atoms in the A_GIMME signature
    @param        av        The atoms in the A_GIMME signature
    @remark        For instance, while declaring the "locked" attribute for the note element, we do
    @code
    bach_attribute_add_functions(bach_attribute_get(r_ob, k_NOTE, _llllobj_sym_lock), NULL, (bach_setter_fn)bach_set_flags_fn, NULL, (bach_attr_process_fn)check_correct_scheduling_fn, NULL);
    @endcode
 */
void bach_set_flags_fn(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long ac, t_atom *av);



/** A bach-attributes setter which can be used to set notation item's names.
    @ingroup    attributes
    @param      man     The inspector manager
    @param        obj        The element to which the attribute refers
    @param        attr    The attribute
    @param        ac        The number of atoms in the A_GIMME signature
    @param        av        The atoms in the A_GIMME signature
 */
void bach_set_name_fn(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long ac, t_atom *av);


/** A bach-attributes setter which can be used for the following slotinfo attributes: "background", "popup", "rightclick" and "linkto".
    This setter takes the effort to change all the depending stuff in order to set all those elements properly (for instance, when "rightclick" is set,
    and thus the current slot is opened upon rightclick, the function set all the other slots' "rightclick" attributes to false). 
    @ingroup    attributes
    @param        man     The inspector manager
    @param        obj        The element to which the attribute refers
    @param        attr    The attribute
    @param        ac        The number of atoms in the A_GIMME signature
    @param        av        The atoms in the A_GIMME signature
 */
void set_bach_attr_slotinfo_flags(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr, long ac, t_atom *av);


/** A #bach_attr_process_fn function which just checks the correct scheduling, by calling check_correct_scheduling()
    @ingroup    attributes
    @param        man     The inspector manager
    @param        obj        The element to which the attribute refers
    @param        attr    The attribute
    @remark        Should be usually used as post-process function when declaring an attribute
 */
void check_correct_scheduling_fn(t_bach_inspector_manager *man, void *obj, t_bach_attribute *attr);


// Utilities
char *field2string(void *field, char type, long size, long max_decimals);




// -----------------------------------
// BACH INSPECTOR
// -----------------------------------


/** Paint the bach inspector.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man            The    inspector manager
    @param    view            The current view
    @param    g                The graphic context
    @param    graphic_rect    The current painting rectangle 
    @param    obj                Pointer to the notation item for which we need to paint the inspector â€“ or to a given element inside the t_notation_obj::slotinfo array. 
    @param    obj_type        One of the #e_element_types corresponding to the type of the object
    @param    zoom            A zoom factor. Default is #CONST_BACH_INSPECTOR_DEFAULT_ZOOM.
    @remark    This is usually used as
    @code
    open_bach_inspector(r_ob, obj, obj_type);
    paint_bach_inspector(r_ob, patcherview, g, rect, x->notation_obj->active_bach_inspector_item, x->notation_obj->active_bach_inspector_obj_type, CONST_BACH_INSPECTOR_DEFAULT_ZOOM);
    @endcode
 */
void paint_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *view, t_jgraphics* g, t_rect graphic_rect, void *obj, long obj_type, double zoom);


/** Function called when the textfield of the bach inspector sends the 'enter' notification; that is: this function handles
    all the cases of an attribute having been changed. It calls set_bach_attr_and_process_from_ac_av().
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man            The    inspector manager
 */
void bach_inspector_enter(t_notation_obj *r_ob, t_bach_inspector_manager *man);


/** Convert a graphic point into the corresponding attribute being clicked in the bach inspector.
    @ingroup    bach_inspector
    @param    man            The    inspector manager
    @param    view        The current view
    @param    pt            The point to be converted
    @return            The bach attribute situated under the point #pt
 */
t_bach_attribute *pt_to_attribute_to_edit(t_bach_inspector_manager *man, t_object *view, t_pt pt);


/** Set the bach inspector textfield properly so that a given attribute will begin to be edited.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man            The    inspector manager
    @param    patcherview        The current view
    @param    attr            The bach attribute
 */
void start_editing_bach_attribute(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_bach_attribute *attr);


/** Close the bach inspector.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man            The    inspector manager
 */
void close_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man);


/** Open the bach inspector for a given element
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man                The inspector manager
    @param    obj                Pointer to the notation item for which we need to paint the inspector â€“ or to a given element inside the t_notation_obj::slotinfo array. 
    @param    obj_type        One of the #e_element_types corresponding to the type of the object
 */
void open_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, void *obj, long obj_type);


/** Open the bach inspector for a given notation item.
    @ingroup    bach_inspector
    @remark    This is more specific than open_bach_inspector() since the bach inspector can be also opened for slotinfo.
    @param    r_ob    The    notation object
    @param    it        The notation item
 */
void open_bach_inspector_for_notation_item(t_notation_obj *r_ob, t_notation_item *it);


/** Change the inspected element in the bach inspector.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man                The inspector manager
    @param    obj                Pointer to the notation item for which we need to paint the inspector, or to a given element inside the t_notation_obj::slotinfo array. 
    @param    obj_type        One of the #e_element_types corresponding to the type of the object
 */
void switch_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, void *obj, long obj_type);


/** Change the inspected element in the bach inspector to a notation item.
    @ingroup    bach_inspector
    @remark    This is more specific than switch_bach_inspector() since the bach inspector can be also opened for slotinfo.
    @param    r_ob    The    notation object
    @param    it        The notation item
 */
void switch_bach_inspector_for_notation_item(t_notation_obj *r_ob, t_notation_item *it); 


/** Bring the bach inspector window to the front.
    @ingroup    bach_inspector
    @param    man                The inspector manager
 */
void bring_external_inspector_to_front(t_bach_inspector_manager *man);


/** Handle the mousedrag in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    rect        The drawing rectangle
    @param    pt            The mousedrag point
    @param    modifiers    The modifiers
    @return                As for any Max mousedrag function.
 */
long handle_mousedrag_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_rect rect, t_pt pt, long modifiers);


/** Handle the mouseup in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    pt            The mouseup point
    @return                As for any Max mouseup function.
 */
long handle_mouseup_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_pt pt);


/** Handle the mousemove in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    pt            The mousemove point
    @return                As for any Max mousemove function.
 */
long handle_mousemove_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_pt pt);


/** Handle the doubleclick in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    pt            The doubleclick point
    @return                1 if an attribute has been clicked, 0 otherwise.
 */
long handle_doubleclick_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_pt pt);


/** Handle the mousedown in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    rect        The drawing rectangle
    @param    pt            The mousedown point
    @param    modifiers    The modifiers
    @return                As for any Max mousedown function.
 */
long handle_mousedown_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_rect rect, t_pt pt, long modifiers);


/** Handle the mousewheel in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob        The    notation object
    @param    man                The inspector manager
    @param    patcherview    The current view
    @param    pt            The mousewheel point
    @param    x_inc        The horizontal pixel increment
    @param    y_inc        The vertical pixel increment
    @return                As for any Max mousewheel function.
 */
long handle_mousewheel_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, t_pt pt, double x_inc, double y_inc);


/** Handle the mousewheel in the bach inspector
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
    @param    man                The inspector manager
    @param    patcherview        The current view
    @param    keycode            The keycode of the key being pressed
    @param    modifiers        The modifiers
    @param    textcharacter    The actual character being pressed
    @return                    As for any Max key function.
 */
long handle_key_in_bach_inspector(t_notation_obj *r_ob, t_bach_inspector_manager *man, t_object *patcherview, long keycode, long modifiers, long textcharacter);


/** Set (synchronize) the bach inspector according to the current selection.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
 */
void resync_bach_inspector_with_selection(t_notation_obj *r_ob);


/** Set (synchronize) the selection according to the current inspected element in the bach inspector.
    @ingroup    bach_inspector
    @param    r_ob            The    notation object
 */
void resync_selection_with_bach_inspector(t_notation_obj *r_ob);


void slotinfo_copy(t_notation_obj *r_ob, long slotnum);
void slotinfo_paste(t_notation_obj *r_ob, long slotnum);



// -----------------------------------
// EXTERNAL BACH INSPECTOR OBJECT
// -----------------------------------

void bach_inspector_ui_classinit(void);
void bach_inspector_ui_paint(t_bach_inspector_ui *x, t_object *patcherview);
void bach_inspector_ui_mousedown(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers);
void bach_inspector_ui_mousedrag(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers);
void bach_inspector_ui_mousemove(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers);
void bach_inspector_ui_mouseup(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers);
void bach_inspector_ui_mousewheel(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers, double x_inc, double y_inc);
void bach_inspector_ui_mousedoubleclick(t_bach_inspector_ui *x, t_object *patcherview, t_pt pt, long modifiers);
long bach_inspector_ui_key(t_bach_inspector_ui *x, t_object *patcherview, long keycode, long modifiers, long textcharacter);
void bach_inspector_ui_free(t_bach_inspector_ui *x);
void *bach_inspector_ui_new(t_symbol *s, long argc, t_atom *argv);
void bach_inspector_ui_enter(t_bach_inspector_ui *x);
t_max_err bach_inspector_ui_notify(t_bach_inspector_ui *x, t_symbol *s, t_symbol *msg, void *sender, void *data);




// -----------------------------------
// MISCELLANEA
// -----------------------------------

/** Post the "unknown message" error in the max window, depending on the incoming llll. Usually this is used in the anything object's method,
    after having parsed the GIMME signature with llllobj_parse_llll(), and having dealt with all the cases in which the llll is properly understood by the algorithm.
    The incoming llll could also be null, in which case a generic unknown message will be posted.
    @ingroup    miscellanea
    @param        x                The object
    @param        incoming_llll    The incoming llll
 */
void post_unknown_message(t_object *x, t_llll *incoming_llll);


/** Eliminate the spaces before open brackets "(" inside a string.
    @remark        For instance, converts "sin ( $x1 + 2 )" into "sin( $x1 + 2)".
    @ingroup    miscellanea
    @param    buf    The string
 */
void eliminate_spaces_before_open_bracket_symbol(char *buf);


/** A #fun_fn function which simply transpose the incoming lists.
    @ingroup    llll_utilities
    @param        data                Must be left NULL
    @remark        Must be used inside llll_funall(), typically in the form
    @code
    llll_funall(ll, (fun_fn) trans_mode2_fn, NULL, 1, 1, FUNALL_PROCESS_SUBLISTS_ONLY_AT_MAXDEPTH);
    @endcode
 */
long trans_mode2_fn(void *data, t_hatom *a, const t_llll *address);


/** Lock the notation object's general mutex, corresponding to the field t_notation_obj::c_general_mutex.
    @ingroup    miscellanea
    @param        r_ob            The notation object
 */
void lock_general_mutex(t_notation_obj *r_ob);


/** Unlock the notation object's general mutex, corresponding to the field t_notation_obj::c_general_mutex.
    @ingroup    miscellanea
    @param        r_ob            The notation object
 */
void unlock_general_mutex(t_notation_obj *r_ob);


/** Try to lock the notation object's general mutex, corresponding to the field t_notation_obj::c_general_mutex.
    Returns non-zero if cannot enter the code
    @ingroup    miscellanea
    @param        r_ob            The notation object
    @return            Returns non-zero if there was a problem entering.
 */
long trylock_general_mutex(t_notation_obj *r_ob);


// Internal
void lock_deparse_mutex(t_notation_obj *r_ob);
void unlock_deparse_mutex(t_notation_obj *r_ob);

/** Lock the notation object's marker mutex, corresponding to the field t_notation_obj::c_markers_mutex.
    @ingroup    miscellanea
    @param        r_ob            The notation object
 */
void lock_markers_mutex(t_notation_obj *r_ob);


/** Unlock the notation object's marker mutex, corresponding to the field t_notation_obj::c_markers_mutex.
    @ingroup    miscellanea
    @param        r_ob            The notation object
 */
void unlock_markers_mutex(t_notation_obj *r_ob);


/** Verify that a chord has the correct stored number of notes, and that all the parenting works fine.
    @ingroup    miscellanea
    @param        r_ob            The notation object
    @param        ch                The chord
    @return        1 if error, 0 otherwise.
 */
long check_chord(t_notation_obj *r_ob, t_chord *ch);


/** Verify that a note's parenting works fine.
    @ingroup    miscellanea
    @param        r_ob            The notation object
    @param        nt                The note
    @return        1 if error, 0 otherwise.
 */
long check_note(t_notation_obj *r_ob, t_note *nt);


/** Dummy function to throw an issue. Always returns 1.
     @ingroup    miscellanea
    @param        r_ob            The notation object
    @return        Always 1.
 */
long notationobj_throw_issue(t_notation_obj *r_ob);



// -----------------------------------
// ITERATORS
// -----------------------------------

/** Apply the #fn function on all selected notation items.
    @ingroup    iterators
    @param        r_ob                The notation object
    @param        fn                    The function to be applied to each notation item (it might want to treat differently different types of notation items). 
                                    This function can change the notation items' parameters, but is NOT allowed to delete notation items.
    @param        data                Additional data to be passed to the function
    @param        create_undo_ticks    If non-0 also creates undo modification ticks. We stress that those ticks are k_UNDO_MODIFICATION_CHANGE ticks.
                                    So one is not allowed to delete structures.
    @param        smallest_undoable_element    Smallest element whose content will be stored in the undo tick. This is only used if #create_undo_ticks is non-zero.
    @return        1 if something has changed, 0 otherwise
 */
char iterate_changes_on_selection(t_notation_obj *r_ob, notation_obj_notation_item_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem);


/** Apply the #fn function on all selected notes.
    @ingroup    iterators
    @param        r_ob                The notation object
    @param        fn                    The function to be applied to each note. 
                                    This function can change the note's parameters, but is NOT allowed to delete the note.
    @param        data                Additional data to be passed to the function
    @param        create_undo_ticks    If non-0 also creates undo modification ticks. We stress that those ticks are k_UNDO_MODIFICATION_CHANGE ticks.
                                    So one is not allowed to delete structures.
    @param        smallest_undoable_element    Smallest element whose content will be stored in the undo tick. This is only used if #create_undo_ticks is non-zero.
    @return        1 if something has changed, 0 otherwise
*/
char iterate_notewise_changes_on_selection(t_notation_obj *r_ob, notation_obj_note_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem, char also_apply_on_notetails);


/** Apply the #fn function on all selected chords. 
    N.B.: This function is unused and untested at 08/08/2012
    @ingroup    iterators
    @param        r_ob                The notation object
    @param        fn                    The function to be applied to each note. 
                                    This function can change the chord's parameters, but is NOT allowed to delete the note.
    @param        data                Additional data to be passed to the function
    @param        create_undo_ticks    If non-0 also creates undo modification ticks. We stress that those ticks are k_UNDO_MODIFICATION_CHANGE ticks.
                                    So one is not allowed to delete structures.
    @param        smallest_undoable_element    Smallest element whose content will be stored in the undo tick. This is only used if #create_undo_ticks is non-zero.
    @param        also_apply_if_single_note_selected    If this is non-zero, the function will be applied also if only a note of the chord is selected, and not the chord itself.
                                                    (Also, of course this function makes sure that the function is not applied twice to the same chord, by using the #k_FLAG_MODIFIED flag for the chords, 
                                                    so you cannot trust the value of this flag before and after calling this function.)
    @return        1 if something has changed, 0 otherwise
 */
char iterate_chordwise_changes_on_selection(t_notation_obj *r_ob, notation_obj_chord_fn fn, void *data, char create_undo_ticks, e_element_types smallest_undoable_elem, char also_apply_if_single_note_selected); 




// -----------------------------------
// NAMES
// -----------------------------------
// object names


/** Tells if a name is used in the notation object
    @ingroup    names
    @param    r_ob        The notation object
    @param    name        The given name
    @return   1 if used, 0 otherwise
*/
long notationobj_name_is_used(t_notation_obj *r_ob, t_hatom *name);

/** Find all notation items matching one or more given names.
    @ingroup    names
    @param    r_ob        The notation object
    @param    names        The given names (as an llll)
    @return    An llll containing as H_OBJs all the notation items matching all the names.
 */
t_llll *notationobj_names_to_notation_items(t_notation_obj *r_ob, t_llll *names);


/** Retrieve the "first" notation item matching certain name(s). 
    @ingroup            names
    @param    r_ob        The notation object
    @param    names        The names to be matched
    @return                The "first" notation item matching the name(s), or NULL if none.
    @remark                The order of search should be straightforward voicewise, then measure-wise, then chord-wise, then note-wise, yet the user
                        should NOT really rely on it, and use this function only when a (random) item matching the name(s) is needed.
                        In order to retrieve all notation items matching certain names, use notationobj_names_to_notation_items()
 */
t_notation_item *names_to_single_notation_item(t_notation_obj *r_ob, t_llll *names);


/** Preselect all the notation items matching certain name(s).
    @ingroup    names
    @param    r_ob        The notation object
    @param    names        The given names (as an llll)
    @return    The number of notation items matching all the given names.
 */
long preselect_notation_items_by_name(t_notation_obj *r_ob, t_llll *names);


/** Get the name(s) of a notation item in llll form.
    @ingroup    names
    @param    it    The notation item
    @param    prepend_name_symbol    If this is non-zero, a "name" symbol is prepended to the list of names in the output llll.
    @return    The name(s) of the notation item in llll form.
 */
t_llll *get_names_as_llll(t_notation_item *it, char prepend_name_symbol);


/** Change the name(s) for a notation item.
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item
    @param    newnames    The new names (as an llll)
    @param    create_undo_tick    If this is non-zero, an undo tick is created.
    @return    1 if the name(s) has been changed, 0 if not (e.g. they were exactly the same as the previous names).
 */
char change_notation_item_names(t_notation_obj *r_ob, t_notation_item *it, t_llll *newname, char create_undo_tick);


/** Change the name(s) for all the current selection.
    @ingroup        selection_changes
    @param    r_ob    The notation object
    @param    newnames        The new names 
    @param    only_change_this_elems    If this is not NULL, it can contain a list of symbols identifying the elements whose name has to be changed.
                                    This list can contain symbols like "chord", "voice", "note", "measure", "marker".
    @param    incremental                If this flag is non-zero, markers are assigned incremental names (if such names were already used).
    @param    append_names            If this flag is non-zero, the new names are appended to the existing ones
    @param    also_assign_to_progeny_for_chords    If non-zero, if a chord is selected, the name is assigned BOTH to the chord and to each one of its notes
    @return    1 if something has been changed, 0 otherwise.
 */
char change_selection_name(t_notation_obj *r_ob, t_llll *newnames, t_llll *only_change_this_elems, 
                           char incremental, char append_names, char also_assign_to_progeny_for_chords, char lambda = 0);


/** Tell if two name-lllls are exactly the same
    @ingroup        names
    @param    names1        The first llll of names 
    @param    names2        The second llll of names
    @return    1 if the two llll of names coincide, 0 otherwise.
 */
char are_names_equal(t_llll *names1, t_llll *names2);


/** Find the name specification from an llll (if any), which might (or might not) contain a sub-llll in the (name <name1> <name2>...).
    If such sub-llll is found, names are applied to the given notation items, and such sub-llll is deleted. Otherwise, nothing happens
    @remark            BEWARE: The function also deletes the name specification llll, if found, hence it modifies the incoming llll (without freeing it).
 You still will need to free it later.
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item to which the names must be applied
    @param    llll    The llll possibly containing a sub-llll with names specification, of the kind (name <name1> <name2> ...)  
 */
void notation_item_find_and_set_names(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll);


// TBD
void notation_item_find_and_set_flags(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll);


/** Find the name specification from an llll (if any), which might (or might not) contain a sub-llll in the (name <name1> <name2>...) or 
    (flags <flags_as_symbol_or_number>)
    If such sub-llll is found, names and flags are applied to the given notation items, and such sub-llll is deleted. Otherwise, nothing happens
    @remark            BEWARE: The function also deletes the name specification llll, if found, hence it modifies the incoming llll (without freeing it).
                    You still will need to free it later.
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item to which the names must be applied
    @param    llll    The llll possibly containing a sub-llll with names specification, of the kind (name <name1> <name2> ...) and/or (flags <flags>)
 */
void notation_item_find_and_set_names_and_flags(t_notation_obj *r_ob, t_notation_item *it, t_llll *llll);


/** Obtain the name(s) array starting from an llll containing them as plain sequence. 
    @ingroup        names
    @param    r_ob    The notation object
    @param    ll        The llll containing the name(s)
    @return    The names
    @see    notation_item_set_names_from_llllelem()
 */
t_llll *get_names_from_llll(t_notation_obj *r_ob, t_llll *ll);


/** Obtain the name(s) llll starting from an llllelem containing them. If the llllelem is an #H_LLLL, it is expected
    to contain all the names in list form; if it is a single number or symbol, it'll be the only name.
    @ingroup        names
    @param    r_ob    The notation object
    @param    llelem    The llllelem containing the name(s)
    @return    The names
    @see    notation_item_set_names_from_llllelem()
 */
t_llll* get_names_from_llllelem(t_notation_obj *r_ob, t_llllelem *llelem);


/** Set the name(s) to a notation item starting from an llll containing them as plain sequence.
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item to which the names must be applied
    @param    llll    The llll containing the plain sequence of names 
 */
void notation_item_set_names_from_llll(t_notation_obj *r_ob, t_notation_item *it, t_llll *ll);


/** Set the name(s) to a notation item starting from an llllelem containing them. If the llllelem is an #H_LLLL, it is expected
    to contain all the names in list form; if it is a single number or symbol, it'll be the only name.
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item to which the names must be applied
    @param    llelem    The llllelem containing the name(s)
 */
void notation_item_set_names_from_llllelem(t_notation_obj *r_ob, t_notation_item *it, t_llllelem *llelem);


/** Tell if an array of names correspond to the single name "none"
    @ingroup        names
    @param    names    The llll of names
    @return    1 if the array contain the single symbol "none", 0 otherwise
 */
char name_is_none(t_llll *names);


/** Tell if an array of names correspond to the single name "<none>"
    @ingroup        names
    @param    names    The llll of names
    @return    1 if the array contain the single symbol "<none>", 0 otherwise
 */
char name_is_abr_none_abr(t_llll *names);


/** Convert an llll of names into text form.
    @ingroup        names
    @param    names    The llll of names
    @param    buf        The buffer which will be filled with the textual representation of the array of names. It must be already allocated with <buf_size> size
    @param    buf_size    The size of the allocated <buf> buffer
    @return Text size
 */
int get_names_as_text(t_llll *ll, char *buf, long buf_size);


/** Obtain voicenames as text (also including multiline names in case of voice ensemble
    @ingroup        names
    @param    r_ob    The notation object
    @param    voice   The voice
    @param    buf        The buffer which will be filled with the textual representation of the array of names. It must be already allocated with <buf_size> size
    @param    buf_size    The size of the allocated <buf> buffer
 */
void get_voicenames_as_text(t_notation_obj *r_ob, t_voice *voice, char *buf, long buf_size);


/** Tell if a given name is contained inside an array of names.
    @ingroup        names
    @param    contained    The name to be checked
    @param    container    The llll of names
    @return    1 if the given name is contained inside the names, 0 otherwise.
 */
char is_name_contained(t_hatom *contained, t_llll *container);


/** Tell if each name of a given array is contained inside an array of names.
    @ingroup        names
    @param    names        The names to be checked if contained
    @param    container    The possibly "container" names
    @return    1 if all the names in the llll to be checked are contained inside the "container" llll, 0 otherwise.
 */
char are_all_names_contained(t_llll *names, t_llll *container);


/** Append to a given llll all the names of a given notation item in llll form.
    @ingroup        names
    @param    ll        The original ll
    @param    it        The notation item
    @return The llllelem owning to the appended llll containing the names.
    @remark            For instance, if the original llll is (foo fee) and the notation item has names (pippo pluto), the llll will be altered
                    to (foo fee (pippo pluto)). If on the other hand the notation item has a single name, say "baah", a simple atom is appended, yielding 
                    (foo fee baah).
 */
t_llllelem *llll_append_notation_item_name(t_llll *ll, t_notation_item *it);


/** General method to change names to the selection of a notation object from a generic A_GIMME signature.
    This method parses the input A_GIMME signature and then properly calls change_selection_name().
    @ingroup        names
    @param    r_ob    The notation object
    @param    s        The router symbol in the A_GIMME signature
    @param    argc    The number of atoms of the A_GIMME signature
    @param    argv    The array of atoms of the A_GIMME signature
 */
void notation_obj_name(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


/** General method to clear names of all selected items. GIMME signature is ignored.
    @ingroup        names
    @param    r_ob    The notation object
    @param    s        The router symbol in the A_GIMME signature
    @param    argc    The number of atoms of the A_GIMME signature
    @param    argv    The array of atoms of the A_GIMME signature
 */
void notation_obj_clearnames(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


/** General method to append names to the selection of a notation object from a generic A_GIMME signature.
    This method parses the input A_GIMME signature and then properly calls change_selection_name().
    @ingroup        names
    @param    r_ob    The notation object
    @param    s        The router symbol in the A_GIMME signature
    @param    argc    The number of atoms of the A_GIMME signature
    @param    argv    The array of atoms of the A_GIMME signature
 */
void notation_obj_nameappend(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


// TBD
void notation_obj_nametoslot(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);
void notation_obj_slottoname(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);
void notation_obj_dltoslot(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);

/** Clear the names of all notation items in the score
    @ingroup        names
    @param    r_ob    The notation object
    @param    voice    If non-zero, clears all voice names
    @param    measures    If non-zero, clears all measure names
    @param    chords    If non-zero, clears all chord names
    @param    notes    If non-zero, clears all note names
    @param    markers    If non-zero, clears all marker names
 */
void notation_obj_clear_names(t_notation_obj *r_ob, long voices, long measures, long chords, long notes, long markers);


/** General method to change roles to the selection of a notation object from a generic A_GIMME signature.
    This method parses the input A_GIMME signature and then properly calls change_selection_role().
    @ingroup        names
    @param    r_ob    The notation object
    @param    s        The router symbol in the A_GIMME signature
    @param    argc    The number of atoms of the A_GIMME signature
    @param    argv    The array of atoms of the A_GIMME signature
 */
void notation_obj_role(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


/** Parse and fill the t_notation_obj::m_label structure properly.
    @ingroup        names
    @param    r_ob    The notation object
 */
void parse_label_families(t_notation_obj *r_ob);


/** Get the default color for a given label family
    @ingroup        names
    @param    fam        The bach label family
 */
t_jrgba label_family_to_color(t_notation_obj *r_ob, t_bach_label_family *fam);


/** Free the memory of a bach label manager.
    @ingroup        names
    @param    man    The bach label manager
 */
void free_all_label_families(t_bach_label_manager *man);

/** Free the memory of a single bach label family
    @ingroup        names
    @param    fam        The bach label family
 */
void free_label_family(t_bach_label_family *fam);


/** Check if a given notation item belongs to a certain label family
    @ingroup        names
    @param    item    The notation itemm
    @param    fam        The label family
    @return            1 if item belongs to family, 0 otherwise
 */
char notation_item_is_in_label_family(t_notation_item *item, t_bach_label_family *fam);


/** Update the contour information for a given label family
    @ingroup        names
    @param    r_ob    The notation object
    @param    fam        The label family
    @param  g        For debug purposes only
 */
void update_label_family_contour(t_notation_obj *r_ob, t_bach_label_family *fam, t_jgraphics* g);


/** Update the contour information for all the label families
    @ingroup        names
    @param    r_ob    The notation object
 */
void update_all_label_families_contour(t_notation_obj *r_ob);


/** Sets the t_bach_label_family::need_update_contour flag for all the elements
    which have been modified (and thus are under undo ticks).
    @ingroup        names
    @param    r_ob    The notation object
    @param    lock_general_mutex    Toggles the ability to also lock the general mutex
 */
void set_label_families_update_contour_flag_from_undo_ticks(t_notation_obj *r_ob, char lock_general_mutex);


/** Sets the t_bach_label_family::need_update_contour flag for all the label families
    @ingroup        names
    @param    r_ob    The notation object
 */
void set_all_label_families_update_contour(t_notation_obj *r_ob);


/** Remove all the label family data corresponding to a given notation item
    @ingroup        names
    @param    it        The notation item
 */
void remove_label_families_data_for_notation_item(t_notation_item *it);


/** Add the label family data corresponding to a given notation item
    @ingroup        names
    @param    r_ob    The notation object
    @param    it        The notation item
 */
void add_label_families_data_for_notation_item(t_notation_obj *r_ob, t_notation_item *r_it);


void verbose_post_label_families(t_notation_obj *r_ob);
double note_get_center_ux(t_notation_obj *r_ob, t_note *nt);



/**    Change the value of a long according to a given lexpr or on a given llllelem indication. 
    If the lexpr is non-NULL, such lexpr is used and the modify element is ignored. If lexpr is NULL, the #modify element is used.
    If the #t_llllelem <modify> contains a number, it will be understood as a long and the <number> will be changed to this long value.
    If it contains an llll, it can be of the form 
    - (<x>): which will simply see <x> as long, and plug its value into <number>
    - (plus <x>): which will sum <x> to <number>, and plug it back into <number>
    - (minus <x>): which will subtract <x> from <number>, and plug it back into <number>
    - (times <x>): which will multiply <x> by <number>, and plug it back into <number>
    - (div <x>): which will divide <x> by <number>, and plug it back into <number>
 
    @param    r_ob            The notation object
    @param number            Pointer to the number to be modified
    @param lexpr            The lexpr to modify the number (lexpr will accept also standard substitutions of a notation item parameters, set by #lexpr_argument)
    @param modify            A #t_llllelem containing eithing the new number (as #H_LONG, also works with #H_DOUBLE or #H_RAT) or the instruction to modify the number (as #H_LLLL, see above)
    @param convert_deg2rad    Flag to trigger an additional conversion from degrees to radiants. Should be always 0, except in very special cases 
                            (if you want to perform a change, you might want to use the change_double() function).
    @param lexpr_argument    The notation item whose elements parameter have to be used in lexpr 
    @remark                    This is used in the slot content modifications.
    @ingroup                math
 */
void change_long(t_notation_obj *r_ob, long *number, t_lexpr *lexpr, t_llllelem *modify, char convert_deg2rad, void *lexpr_argument);


/**    Change the value of a double according to a given lexpr or to a given llllelem indication. Possibilities are the same as the change_long() function.
    If the lexpr is non-NULL, such lexpr is used and the modify element is ignored. If lexpr is NULL, the #modify element is used.
 
    @param    r_ob            The notation object
    @param number            Pointer to the number to be modified
    @param lexpr            The lexpr to modify the number (lexpr will accept also standard substitutions of a notation item parameters, set by #lexpr_argument)
    @param modify            A #t_llllelem containing eithing the new number (as #H_DOUBLE, #H_LONG or #H_RAT) or the instruction to modify the number (as #H_LLLL, see change_long() for all possibilities)
    @param convert_deg2rad    Flag to trigger an additional conversion from degrees to radiants (leave it 0 if you don't need it)
    @param lexpr_argument    The notation item whose elements parameter have to be used in lexpr 
    @see                    change_long()
    @ingroup                math
 */
void change_double(t_notation_obj *r_ob, double *number, t_lexpr *lexpr, t_llllelem *modify, char convert_deg2rad, void *lexpr_argument);


/**    Change the value of a rational according to a given lexpr or to a given llllelem indication. Possibilities are the same as the change_long() function.
 If the lexpr is non-NULL, such lexpr is used and the modify element is ignored. If lexpr is NULL, the #modify element is used.
 
 @param    r_ob            The notation object
 @param number            Pointer to the number to be modified
 @param lexpr            The lexpr to modify the number (lexpr will accept also standard substitutions of a notation item parameters, set by #lexpr_argument)
 @param modify            A #t_llllelem containing eithing the new number (as #H_DOUBLE, #H_LONG or #H_RAT) or the instruction to modify the number (as #H_LLLL, see change_long() for all possibilities)
 @param lexpr_argument    The notation item whose elements parameter have to be used in lexpr
 @see                    change_long()
 @ingroup                math
 */
void change_rational(t_notation_obj *r_ob, t_rational *number, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument);


/**    Change the value of a pitch according to a given lexpr or to a given llllelem indication. Possibilities are the same as the change_long() function. IMPORTANT: according to the result of the expression, either the <pitch> or the <cents> are changed. In the first case, 0 is
    returned, while in the second case 1 is returned.
    If the lexpr is non-NULL, such lexpr is used and the modify element is ignored. If lexpr is NULL, the #modify element is used.
 
    @param    r_ob            The notation object
    @param pitch            Pointer to the pitch to be modified
    @param cents            Pointer to the midicents to be modified
    @param lexpr            The lexpr to modify the number (lexpr will accept also standard substitutions of a notation item parameters, set by #lexpr_argument)
    @param modify            A #t_llllelem containing eithing the new number (as #H_DOUBLE, #H_LONG or #H_RAT) or the instruction to modify the number (as #H_LLLL, see change_long() for all possibilities)
    @param lexpr_argument    The notation item whose elements parameter have to be used in lexpr
    @return                 0 if result was a pitch (put inside <pitch>), 1 if result was a number (put inside <cents>)
    @see                    change_long()
    @ingroup                math
 */
long change_pitch(t_notation_obj *r_ob, t_pitch *pitch, double *cents, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument);


void change_poc(t_notation_obj *r_ob, t_hatom *poc, t_lexpr *lexpr, t_llllelem *modify, void *lexpr_argument);

/**    Get the current threshold for equality of onsets (in ms).
    @param    r_ob            The notation object
    @return            Onset equality threshold in milliseconds
 */
double notationobj_get_onset_equality_threshold(t_notation_obj *r_ob);

/// SLOPE functions for notation objects (see corresponding abstract function in bach_math_utilitites.h
/// The slope type is inferred from the notation object attributes
double notationobj_rescale_with_slope(t_notation_obj *r_ob, double value, double min, double max, double new_min, double new_max, double slope);
double notationobj_rescale_with_slope_and_get_derivative(t_notation_obj *r_ob, double value, double min, double max, double new_min, double new_max, double slope, double *derivative);
double notationobj_rescale_with_slope_inv(t_notation_obj *r_ob, double value, double min, double max, double new_min, double new_max, double slope);



// internal
t_hatom *lexpr_eval_for_notation_item(t_notation_obj *r_ob, t_notation_item *it, t_lexpr *lexpr);
void notationobj_build_notation_item_surfaces(t_notation_obj *r_ob, t_object *view, t_rect rect);
void notationobj_build_clef_gradient_surface(t_notation_obj *r_ob);
char change_pitch_must_actually_snap_to_grid(t_notation_obj *r_ob, char mode, char snap_pitch_to_grid);
void notationobj_handle_change_cursors_on_mousemove(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers, t_rect rect);
void notationobj_handle_change_cursors_on_mousedrag(t_notation_obj *r_ob, t_object *patcherview, t_pt pt, long modifiers);

long notationobj_get_notification_outlet(t_notation_obj *r_ob);
double notationobj_get_supposed_standard_uheight(t_notation_obj *r_ob);
void notationobj_reset_size_related_stuff(t_notation_obj *r_ob);
void notationobj_set_vzoom_depending_on_height(t_notation_obj *r_ob, double height);


// to be documented
t_chord *chord_get_first(t_notation_obj *r_ob, t_voice *voice);
t_chord *chord_get_last(t_notation_obj *r_ob, t_voice *voice);
t_chord *chord_get_first_nongrace(t_notation_obj *r_ob, t_measure *meas);

t_llll *notationobj_get_interp(t_notation_obj *r_ob, double ms);
t_llll *notationobj_get_interp_tempo(t_notation_obj *r_ob, t_timepoint tp);
t_llll *notationobj_get_interp_timesig(t_notation_obj *r_ob, t_timepoint tp);
t_llll *notationobj_get_sampling(t_notation_obj *r_ob, long num_points);
t_llll *notationobj_get_sampling_ms(t_notation_obj *r_ob, double delta_ms);
void notation_obj_copy_slot(t_notation_obj *r_ob, t_clipboard *clipboard, t_notation_item *nitem, long slot_num, char cut);
void notation_obj_copy_slot_selection(t_notation_obj *r_ob, t_clipboard *clipboard, t_notation_item *nitem, long slot_num, char cut);
void notation_obj_paste_slot(t_notation_obj *r_ob, t_clipboard *clipboard, long paste_to_this_slot, char also_paste_to_rests = true);
void notation_obj_paste_slot_selection_to_open_slot_window(t_notation_obj *r_ob, t_clipboard *clipboard, char delete_intermediate_points);

void notation_obj_copy_durationline(t_notation_obj *r_ob, t_clipboard *clipboard, t_note *note, char cut);
void notation_obj_paste_durationline(t_notation_obj *r_ob, t_clipboard *clipboard);

void notationobj_parse_play_arguments(t_notation_obj *r_ob, long argc, t_atom *argv, char *selection, char *offline, char *preschedule, char *deferlow);


void notationobj_pixel_to_element(t_notation_obj *r_ob, t_pt pix, void **clicked_elem_ptr, long *clicked_elem_type);
void notationobj_toggle_realtime_mode(t_notation_obj *r_ob, char realtime);
void notationobj_setnotationcolors(t_notation_obj *r_ob, t_llll *ll);
void notationobj_set_voicespacing_from_llll(t_notation_obj *r_ob, t_llll* voicespacing);
void notationobj_set_hidevoices_from_llll(t_notation_obj *r_ob, t_llll* hidevoices);
void tempo_to_char_buf(t_tempo *tempo, char *buf, long buf_size, long max_decimals);
void time_to_char_buf(t_notation_obj *r_ob, double time_ms, char *buf, long buf_size);

//// LEXPR-BASED SELECTION
void select_voices_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_measures_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_chords_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_rests_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_notes_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_markers_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode);
void select_breakpoints_with_lexpr(t_notation_obj *r_ob, e_selection_modes mode, char tails_only);
void preselect_notation_item_with_lexpr(t_notation_obj *r_ob, t_notation_item *it);



/// UTILITIES
t_chord *chord_get_first_before_ms(t_notation_obj *r_ob, t_voice *voice, double ms);
t_chord *chord_get_first_after_ms(t_notation_obj *r_ob, t_voice *voice, double ms);
t_chord *chord_get_first_before_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset);
t_chord *chord_get_first_after_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset);
t_chord *chord_get_first_strictly_before_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset);
t_chord *chord_get_first_strictly_after_symonset(t_notation_obj *r_ob, t_measure *meas, t_rational r_sym_onset);
void move_linear_edit_cursor_depending_on_edit_ranges(t_notation_obj *r_ob, char num_steps, long modifiers);
char is_in_linear_edit_mode(t_notation_obj *r_ob);
void markers_check_update_name_uwidth(t_notation_obj *r_ob);
t_measure *tuttipoint_get_first_measure(t_notation_obj *r_ob, t_tuttipoint *tpt);
void note_stretch_portion_of_duration_line_and_temporal_slots(t_notation_obj *r_ob, t_note *nt, double from_rel_pos, double to_rel_pos, double stretch_factor, char direction, double old_note_duration, double new_note_duration);

t_max_err notationobj_handle_attr_modified_notify(t_notation_obj *r_ob, t_symbol *s, t_symbol *msg, void *sender, void *data);
t_atom_long notationobj_acceptsdrag(t_notation_obj *r_ob, t_object *drag, t_object *view);

// DYNAMICS
t_dynamics *dynamics_from_llll(t_notation_obj *r_ob, t_notation_item *owner, t_llll *ll);
t_symbol *dynamics_to_symbol(t_notation_obj *r_ob, t_dynamics *dyn);
long dynamics_to_textbuf(t_notation_obj *r_ob, t_dynamics *dyn, char **buf);
t_dynamics *dynamics_from_textbuf(t_notation_obj *r_ob, t_notation_item *owner, char *buf);
t_llll *dynamics_to_llll_full(t_notation_obj *r_ob, t_dynamics *dyn);
t_llll *dynamics_to_llll_detailed(t_notation_obj *r_ob, t_dynamics *dyn);
t_llll *dynamics_to_llll_plain(t_notation_obj *r_ob, t_dynamics *dyn);
t_llll *dynamics_to_llll(t_notation_obj *r_ob, t_dynamics *dyn, e_data_considering_types mode);

void dynamics_mark_measure(t_dynamics_mark *mark, t_jfont *jf_dynamics_nozoom, t_jfont *jf_dynamics_roman_nozoom, double *w, double *h);
void dynamics_mark_to_textbuf(t_dynamics_mark *mark, char *buf, long buf_size);

t_symbol *dynamics_mark_attachment_value_to_symbol(char val);
char dynamics_mark_attachment_symbol_to_value(t_symbol *s);

void deparse_dynamics_to_string_once(t_notation_obj *r_ob, char *dynamics, char *buf);
void dynamics_string_to_energy(t_notation_obj *r_ob, char *buf, short *start_energy, short *end_energy);
t_symbol *dynamics_energy_to_symbol(t_notation_obj *r_ob, long start_energy, long end_energy);
t_symbol *dynamics_mark_parse_string_to_typographic_text(t_notation_obj *r_ob, char *buf);
double dynamics_change_sel_energy_delta(t_notation_obj *r_ob, long delta_energy, char only_for_standard_range);

t_dynamics_mark *build_dynamics_mark(long num_words);
t_dynamics *dynamics_clone(t_dynamics *dyn, t_notation_item *newowner);
long dynamics_get_ending_hairpin(t_dynamics *dyn);
char dynamics_extend_till_next_chord(t_dynamics *dyn);
t_dynamics *chord_get_dynamics(t_chord *ch, t_slotitem **slotitem = NULL);
t_rational dynamics_get_symduration(t_notation_obj *r_ob, t_dynamics *dyn);
double dynamics_mark_get_relative_position(t_dynamics *dyn, t_dynamics_mark *mark);
double dynamics_mark_get_hshift(t_notation_obj *r_ob, t_dynamics *dyn, t_dynamics_mark *mark);


void dynamics_free_marks(t_dynamics *dyn);

long notationobj_check_dynamics(t_notation_obj *r_ob, long slot_num, char check_inconsistent, char check_unnecessary, char fix_inconsistent, char fix_unnecessary, char selection_only, char verbose);
long notationobj_dynamics2velocities(t_notation_obj *r_ob, long slot_num, t_llll *dyn_to_vel_associations, char selection_only, long dynamics_spectrum_halfwidth, double a_exp, char bptmode);
long notationobj_velocities2dynamics(t_notation_obj *r_ob, long slot_num, t_llll *dyn_vel_associations, char selection_only, long dynamics_spectrum_halfwidth, double a_exp, char delete_unnecessary, double approx_thresh, t_symbol *mindyn, t_symbol *maxdyn);
long dynamic_mark_cmp_fromtext(char *mark1, char *mark2);
long dynamic_mark_end_start_cmp(t_dynamics_mark *s1, t_dynamics_mark *s2);

t_bpt *dynamics_mark_get_breakpoint(t_dynamics *dyn, t_dynamics_mark *mark);

char dynamics_span_ties(t_notation_obj *r_ob);
double dynamics_get_spanning_width(t_notation_obj *r_ob, t_dynamics *dyn);
void dynamics_get_rect(t_notation_obj *r_ob, t_dynamics *dyn, t_rect *enclosure);
double dynamics_get_left_extension_from_chord_alignment_point(t_notation_obj *r_ob, t_dynamics *dyn);
double dynamics_get_left_extension_from_chord_stem(t_notation_obj *r_ob, t_dynamics *dyn);

// autospell
void notationobj_autospell_parseargs(t_notation_obj *r_ob, t_llll *args);


// export image
t_max_err notationobj_dowriteimage(t_notation_obj *r_ob, t_symbol *s, long ac, t_atom *av);

// mira multitouch
void notationobj_mt(t_notation_obj *r_ob, t_symbol *s, long argc, t_atom *argv);


#ifndef DOXYGEN_SHOULD_SKIP_THIS
END_CHECK_LINKAGE
#endif

#endif // _NOTATION_H_
