<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.quantize" module="bach">

	<digest>
		Perform quantization tasks
	</digest>

	<description>
		In its simplest usage, <o>bach.quantize</o> converts a <o>bach.roll</o> into a bach.score, by using specific time signatures
		and tempi, or by handling the information about the position of barlines. In its most extensive usage, it
		performs a general quantization of incoming data.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach objects</metadata>
		<metadata name="tag">bach notation</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Measureinfo or bang
			</digest>
			<description>
				Measureinfo is the information about time signature and tempo, plus some other optional specifications concerning the measure itself.
				This can be a single <b><m>TIME_SIGNATURE</m> <m>TEMPO</m></b> valid for all voices and all measures, or a llll containing for each measure and each voice
				an llll in the form <b>[<m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				All elements except for the <m>TIME_SIGNATURE</m> are optional. <br /> <br />
				The <m>TIME_SIGNATURE</m> is an llll containing the measure time signature, in one of the following forms: <br />
				- <b>[<m>numerator</m> <m>denominator</m>]</b> for standard time signatures. For instance, <b>[4 4]</b> corresponds to a 4/4 time signature. <br />
				- <b>[[<m>numerator1</m> <m>numerator2</m> <m>numerator3</m>...] <m>denominator</m>]</b> for time
				signatures where the numerator is a sum of numbers.For instance <b>[[3 2 3] 8]</b>
				corresponds to a (3+2+3)/8 time signature. <br /> <br />
				The <m>TEMPO_OR_LIST_OF_TEMPI</m> represent in its simplest form, a single tempo. <br />
				A tempo, defined for a measure of a <o>bach.score</o> has one of the following syntaxes: <br />
				- <b>[<m>tempo_value</m>]</b> will assign a quarter tempo at the beginning of the measure. For instance <b>[60]</b> will set a 1/4 = 60 tempo. <br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m>]</b> will assign the tempo value to the specified symbolic unit (at the beginning of the measure).
				The <m>tempo_figure</m> is indeed the tempo symbolic unit: for instance <b>[3/8 40]</b> will set a tempo of a dotted quarter = 40.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m>]</b> will assign the tempo value to the specified symbolic unit and will put the
				tempo at the point inside the measure specified by the <m>tempo_sym_onset</m>. For instance <b>[3/8 40 1/4]</b> will set a tempo of a dotted quarter = 40
				but not at the beginning of the measure, rather after 1/4 from the beginning.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m> <m>interpolation_to_next?</m>]</b> will do exactly as the previous case
				but if <m>interpolation_to_next?</m> is non-zero it will also toggle the interpolation from this tempo to the following one,
				yielding an accelerando or rallentando (depending if the next tempo is faster or slower). For instance <b>[3/8 40 1/4 1]</b>
				will set a tempo of a dotted quarter = 40, after 1/4 from the beginning, and will toggle the tempo interpolation to next tempo.<br />
				If more than one tempo need to be assigned to a given measure, one needs to use the general syntax for <m>TEMPO_OR_LIST_OF_TEMPI</m>, which is
				<b>[<m>TEMPO1</m> <m>TEMPO2</m> <m>TEMPO3</m>...]</b>, where each tempo must be in one the forms explained above. As an example, consider
				<b>[[60] [1/4 70 1/16] [1/8 60 1/8 1] [1/8 80 3/8]]</b>, where four tempi have been defined. The order of tempi is irrelevant,
				only their onset is accounted for. <br />
				Also, one might add an integer number at the beginning of each measure llll to indicate that the given measureinfo reference is valid for a
				certain number of measures, such as <b>[<m>how_many_measures</m> <m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				For instance <b>[5 [4 4] [[80] [1/4 160 1/2]]]</b> creates 5 measures of 4/4, each one starting with quarter = 80, and then each one accelerating
				until 1/4 = 160 exactly at half of the measure. For instance
				<b> [[[4 4] [1/8 60]] [[2 4] [1/4 50 1/4 1]] [4 [4 4]] [nil [180]]]</b> means that we start a bar 1 in 4/4 and octave note = 60, then we
				pass at 2/4 and quarter = 50 after 1/4 of measure 2, and at that moment, an accelerando starts. The accelerando lasts during 4 4/4-measures,
				and then ends at the following measure on a new tempo of quarter = 180. <br /> <br />
				Each <m>SPECIFICATION</m> is an optional llll representing a given measure parameter, in the form <b>[<m>parameter_name</m> <m>parameter_value</m>]</b>.
				The <m>parameter_name</m> is a symbol identifying the parameter. The complete list of parameters symbols and their corresponding
				values is the following one: <br />
				- <b>width</b>: assigns a fixed width to a measure. It expects as value a fixed width in pixels that the measure will have (referred to the default
				vertical and horizontal zoom of 100%, and modified accordingly to those). Assigning a <m>width</m> parameter will also lock the measure barline,
				so that the width will remain the same, no matter how many chords and notes the measure does and will contain. Use the "auto" symbol
				instead of the fixed width to revert to the automatic measure width assignment (depending on the measure content). <br />
				- <b>widthfactor</b>: assigns a local factor for the spacing. It expects as value a multiplier factor, which will be applied to the whole measure
				spacing, and which will compress (for values less than 1) or expand (for values
				greater than 1) the width of the measure and the spacing of its chords accordingly. In this case, the measure barline is not locked, only the
				width factor is changed. <br />
				- <b>barline</b>: assigns a specific ending barline to a given measure. It expects a specific letter, representing the barline type. This letter
				can be one of the following ones: 'a' = automatic barline (defaul), 'n' = normal barline, 'd' = dashed barline, 'p' = dotted barline (p = "points"),
				't' = double barline (t = "two"), 's' = solid barline, 'f' = final barline, 'h' = hidden barline, 'k' = tick,
				'i' = intervoice barline only (barline is only between voice staves, not over staves). <br />.
				- <b>shownumber</b>: deals with measure numbers. If an "off" symbol is given as value, it means that the measure number of the current measure will
				not be displayed. If a specific number is given, it will be assigned as a forced measure number to be displayed, for instance <b>[shownumber -4]</b> will
				show -4 as measure number (also see the attribute <m>measurenumberoffset</m>). If an "auto" symbol is given, it will show the measure's automatically
				assigned measure number (default). <br />
				- <b>boxes</b>: assign custom beaming boxes. It expects custom beaming boxes for the measure, as a plain list of rational numbers.
				Custom boxing allows you to handle beam grouping inside the measure differently than beat-wise.
				Each number of the expected list is the symbolic width of each beaming box inside the measure.
				If the given boxes don't fill the whole measure, the last one is padded. For instance, in a 4/4 measure,
				<b>[boxes 1/8]</b> will simply use eight 1/8-wide boxes to beam elements inside the measure, instead of the default 1/4 wide ones (beats).
				This is equivalent to <b>[boxes 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8]</b>.
				Analogously, <b>[boxes 1/2 1/8 1/4 1/8]</b> is a more exotic boxing for the same time signature. <br />
				As a final example, (((4 4) (60) (widthfactor 0.5) (barline h) (shownumber off))) for a given measure sets a 4/4 time signature, a quarter = 60 tempo,
				compresses the measure by a factor of two, hides its final barline and its number.
				<br /> <br />
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				The llll output by bach.roll's or bach.score's first outlet after a <m>quantize</m> message – or in <m>separate</m> mode: Pitches or MIDIcents
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				The Regularity Boxes for the quantization – or in <m>separate</m> mode: Durations
			</digest>
			<description>
				Regularity boxes are a concept that helps bach.quantize quantizing properly by preserving untouched important beat positions.
				Indeed, bach.quantize's algorithm is a box-based algorithm: bach.quantize first cuts a measure into different boxes (for instance having widths of 1/4 each, but the default boxes depend
				on the time signature in general), and then performs the quantization in each box. This allows things falling almost exactly on box boundaries to be kept exactly on the box boundaries,
				so that they may not float due to quantization errors. You can assign custom boxes by explicitely saying which boxes you want.
				You have to give a llll for each voice (in our case, just one), containing for each measure: either a rational number, which represents the
				width of each box (e.g. <b>1/8</b>] and which will be repeated; or a list, containing explicitely the box width for each box, e.g. <b>[1/4 3/4]</b>.
				This has to be done for each voice, so that for instance a list like <b>[1/8 2/4] [] [[1/4 3/4] 1/8]</b> sets to 1/8 the boxes for firt measure of first voice,
				to 2/4 the boxes for second measure of first voice (and all the possibly following ones); leaves by default the boxes of second voice; sets explicitely to <b>[1/4 3/4]</b> the boxes for
				the first measure of the third voice and then to 1/8 for all the following ones.
				<br /> <br />
			</description>
		</inlet>
		<inlet id="3" type="INLET_TYPE">
			<digest>
				Velocities (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="4" type="INLET_TYPE">
			<digest>
				Ties (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="5" type="INLET_TYPE">
			<digest>
				Extras (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="6" type="INLET_TYPE">
			<digest>
				Regularity Boxes (in <m>separate</m> mode only)
			</digest>
			<description>
				Regularity boxes are a concept that helps bach.quantize quantizing properly by preserving untouched important beat positions.
				Indeed, bach.quantize's algorithm is a box-based algorithm: bach.quantize first cuts a measure into different boxes (for instance having widths of 1/4 each, but the default boxes depend
				on the time signature in general), and then performs the quantization in each box. This allows things falling almost exactly on box boundaries to be kept exactly on the box boundaries,
				so that they may not float due to quantization errors. You can assign custom boxes by explicitely saying which boxes you want.
				You have to give a llll for each voice (in our case, just one), containing for each measure: either a rational number, which represents the
				width of each box (e.g. <b>1/8</b>] and which will be repeated; or a list, containing explicitely the box width for each box, e.g. <b>[1/4 3/4]</b>.
				This has to be done for each voice, so that for instance a list like <b>[1/8 2/4] [] [[1/4 3/4] 1/8]</b> sets to 1/8 the boxes for firt measure of first voice,
				to 2/4 the boxes for second measure of first voice (and all the possibly following ones); leaves by default the boxes of second voice; sets explicitely to <b>[1/4 3/4]</b> the boxes for
				the first measure of the third voice and then to 1/8 for all the following ones.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Messages for bach.score
			</digest>
			<description>
				Unless the <m>separate</m> argument is set, this sends
				the score gathered-syntax which construct the quantized score.
				If the <m>separate</m> attribute is set, this sends messages to score (such as "clear"
				if <m>autoclear</m> is active) and a bang to properly build the score from
				the separate parameters
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Notifications (in standard mode), or Measureinfo (in <m>separate</m> mode)
			</digest>
			<description>
				Unless the <m>separate</m> attribute is set, this sends out the notifications obtained
				from marker quantization (such as the pickup added time).
				If the <m>separate</m> argument is set, this sends out the Measureinfo (in <m>separate</m> mode only)
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				The quantized Pitches or cents (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="3" type="INLET_TYPE">
			<digest>
				The quantized Durations (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="4" type="INLET_TYPE">
			<digest>
				The quantized Velocities (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="5" type="INLET_TYPE">
			<digest>
				The quantized Ties (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="6" type="INLET_TYPE">
			<digest>
				The quantized Extras (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="7" type="INLET_TYPE">
			<digest>
				Notifications (in <m>separate</m> mode only)
			</digest>
			<description>
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="separate" optional="1" type="symbol">
			<digest>
				Separate parameters mode
			</digest>
			<description>
				Put a "separate" symbol as argument if you want to input and output the separate parameters (and not the bach.score gathered syntax).
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="allow">
			<arg name="allowed_configurations" optional="1" type="llll" />
			<digest>
				Only allow some rhythmic configurations
			</digest>
			<description>
				Syntax: <b>allow <m>[&lt;llll: allowed_configurations&gt;]</m> </b><br />
				Examples:<br />
				• <b>allow [1/16 1/16 1/8] [1/8 1/16 1/16] [1/4]</b>   <i>→ only allow some patterns</i><br />
				• <b>allow [[1/16 1/16 1/8] [1/8 1/16 1/16] [1/4]] [[1/16 1/8 1/16] [1/8 1/8]]</b>   <i>→ allow differen patterns for different voices</i><br />
				<br />
				Via an <m>allow</m> message one can allow the output of each box to be only in one of a given list of rhythmic configurations (thus forbidding any other option).
				For instance "allow (1/16 1/16 1/16 1/16) (1/16 1/16 1/8) (1/8 1/8) (1/4)" only allows each box to have one of the four given possibilities (one for each sublist).
				Just use "allow" with no further arguments in order to allow any option (default).
				If an <m>allow</m> list has one more level of parenthesis, such as "allow ((1/16 1/16 1/16 1/16) (1/16 1/16 1/8) (1/8 1/8) (1/4)) ((1/12 1/12 1/12) (1/6 1/12) (1/12 1/6) (1/4))"
				bach considers that different <m>allow</m> specification will apply to the different voices (possibly looping the last one, if needed).
			</description>
		</method>
		<method name="auto">
			<arglist />
			<digest>
				Quantize data based on markers
			</digest>
			<description>
				The word <m>auto</m> can substitute the measureinfo specification, when the quantized bach.roll
				contains markers carrying information about tempi, time signatures, barlines, divisions (i.e. markers having a
				role). In this case, those markers are parsed to identify automatically the proper measureinfo for quantization. <br />
				In <o>bach.roll</o>, one can assign a role for each marker, so that they can represent elements such as
				time signatures, tempi, barline, measure divisions. Time signature markers and tempi markers
				also require a "content", i.e. an llll specifying the time signature or the tempo.
				When adding a marker via the <m>addmarker</m> message, the role can be specified as third parameter,
				and the content as fourth parameter. Alternatively, roles and content can be set via the marker inspector.
				Roles can be: <br />
				<m>Time Signature</m>: set by the symbol "timesig", it represents a time signature, and expects the time signature llll as content.
				For instance, a message to add such a marker could be <b>addmarker 0 foo timesig [4 4]</b>.<br />
				<m>Tempo</m>: set by the symbol "tempo", it represents a time signature, and expects the tempo llll as content (tempo figure and tempo
				value). For instance, a message to add such a marker could be <b>addmarker 0 foo tempo [1/8 50]</b>, meaning
				that the tempo is 1/8 = 50.<br />
				<m>Measure Barlines</m>: set by the symbol "barline", it represents a barline, and expects no content.
				For instance, a message to add such a marker could be <b>addmarker 0 foo barline</b>. <br />
				<m>Measure Division</m>: set by the symbol "division", it represents a measure division, and expects no content.
				For instance, a message to add such a marker could be <b>addmarker 0 foo division</b>. <br />
				<m>Measure Subdivision</m>: set by the symbol "subdivision", it represents a measure subdivision, and expects no content.
				For instance, a message to add such a marker could be <b>addmarker 0 foo subdivision</b>. <br />
				All these marker can be parsed by bach.quantize in order to automatically retrieve the measureinfo of the
				entire bach.roll.
				<br /> <br />
			</description>
		</method>
		<method name="bang">
			<arglist />
			<digest>
				Perform the last boxing operation.
			</digest>
			<description>
				Perform the boxing operation on the most recently received input data.
			</description>
		</method>
		<method name="forbid">
			<arg name="forbidden_configurations" optional="1" type="llll" />
			<digest>
				Forbid some rhythmic configurations
			</digest>
			<description>
				Syntax: <b>forbid <m>[&lt;llll: forbidden_configurations&gt;]</m> </b><br />
				Examples:<br />
				• <b>forbid [1/16 1/16 1/8] [1/8 1/16 1/16] [1/4]</b>   <i>→ forbid some patterns</i><br />
				• <b>forbid [[1/16 1/16 1/8] [1/8 1/16 1/16] [1/4]] [[1/16 1/8 1/16] [1/8 1/8]]</b>   <i>→ forbid differen patterns for different voices</i><br />
				<br />
				Via a <m>forbid</m> message one can force a box NOT to have some rhythmic configurations.
				For instance <b>forbid [1/16 1/8 1/16] [1/16 1/16 1/8]</b> denies the two given possibilities (one for each sublist).
				Just use <b>forbid</b> with no further arguments in order to revert to the default behaviour of no configurations denied.
				If an <m>forbid</m> list has one more level of parenthesis, such as <b>forbid [[1/16 1/8 1/16]] [[1/16 3/16]]</b>
				bach considers that different <m>forbid</m> specification will apply to the different voices (possibly looping the last one, if needed).
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Function depends on inlet
			</digest>
			<description>
				In first inlet: Sets the measureinfo and performs the quantization (outputting the result). <br />
				In second inlet: Receives the result of bach.roll's "quantize" message (from bach.roll's or bach.score's first outlet). In "separate" mode: Sets the Cents to be quantized. <br />
				In third inlet: Sets the regularity boxes for the quantization. In "separate" mode: Sets the absolute Durations (in milliseconds) to be quantized. <br />
				In fourth inlet ("separate" mode only): Sets the Velocities to be quantized. <br />
				In fifth inlet ("separate" mode only): Sets the Ties to be quantized. <br />
				In sixth inlet ("separate" mode only): Sets the Extras to be quantized. <br />
				In seventh inlet ("separate" mode only): Sets the regularity boxes for the quantization. <br /> <br />
				All parameters must be given voice-wise: a list for each voice, then an element or list for each chord. (Durations are expected to have just a single element for each chord,
				and you should use the ties to have polyphonies. All the other separate parameters can be chord-wise, i.e. the parameter is assigned to the whole chord, or note-wise, thus each
				chord is a list of elements, one for each note).  <br /> <br />
				Measureinfo is the information about time signature and tempo, plus some other optional specifications concerning the measure itself.
				This can be a single <b><m>TIME_SIGNATURE</m> <m>TEMPO</m></b> valid for all voices and all measures, or a llll containing for each measure and each voice
				an llll in the form <b>[<m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				All elements except for the <m>TIME_SIGNATURE</m> are optional. <br /> <br />
				The <m>TIME_SIGNATURE</m> is an llll containing the measure time signature, in one of the following forms: <br />
				- <b>[<m>numerator</m> <m>denominator</m>]</b> for standard time signatures. For instance, <b>[4 4]</b> corresponds to a 4/4 time signature. <br />
				- <b>[[<m>numerator1</m> <m>numerator2</m> <m>numerator3</m>...] <m>denominator</m>]</b> for time
				signatures where the numerator is a sum of numbers.For instance <b>[[3 2 3] 8]</b>
				corresponds to a (3+2+3)/8 time signature. <br /> <br />
				The <m>TEMPO_OR_LIST_OF_TEMPI</m> represent in its simplest form, a single tempo. <br />
				A tempo, defined for a measure of a <o>bach.score</o> has one of the following syntaxes: <br />
				- <b>[<m>tempo_value</m>]</b> will assign a quarter tempo at the beginning of the measure. For instance <b>[60]</b> will set a 1/4 = 60 tempo. <br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m>]</b> will assign the tempo value to the specified symbolic unit (at the beginning of the measure).
				The <m>tempo_figure</m> is indeed the tempo symbolic unit: for instance <b>[3/8 40]</b> will set a tempo of a dotted quarter = 40.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m>]</b> will assign the tempo value to the specified symbolic unit and will put the
				tempo at the point inside the measure specified by the <m>tempo_sym_onset</m>. For instance <b>[3/8 40 1/4]</b> will set a tempo of a dotted quarter = 40
				but not at the beginning of the measure, rather after 1/4 from the beginning.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m> <m>interpolation_to_next?</m>]</b> will do exactly as the previous case
				but if <m>interpolation_to_next?</m> is non-zero it will also toggle the interpolation from this tempo to the following one,
				yielding an accelerando or rallentando (depending if the next tempo is faster or slower). For instance <b>[3/8 40 1/4 1]</b>
				will set a tempo of a dotted quarter = 40, after 1/4 from the beginning, and will toggle the tempo interpolation to next tempo.<br />
				If more than one tempo need to be assigned to a given measure, one needs to use the general syntax for <m>TEMPO_OR_LIST_OF_TEMPI</m>, which is
				<b>[<m>TEMPO1</m> <m>TEMPO2</m> <m>TEMPO3</m>...]</b>, where each tempo must be in one the forms explained above. As an example, consider
				<b>[[60] [1/4 70 1/16] [1/8 60 1/8 1] [1/8 80 3/8]]</b>, where four tempi have been defined. The order of tempi is irrelevant,
				only their onset is accounted for. <br />
				Also, one might add an integer number at the beginning of each measure llll to indicate that the given measureinfo reference is valid for a
				certain number of measures, such as <b>[<m>how_many_measures</m> <m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				For instance <b>[5 [4 4] [[80] [1/4 160 1/2]]]</b> creates 5 measures of 4/4, each one starting with quarter = 80, and then each one accelerating
				until 1/4 = 160 exactly at half of the measure. For instance
				<b> [[[4 4] [1/8 60]] [[2 4] [1/4 50 1/4 1]] [4 [4 4]] [nil [180]]]</b> means that we start a bar 1 in 4/4 and octave note = 60, then we
				pass at 2/4 and quarter = 50 after 1/4 of measure 2, and at that moment, an accelerando starts. The accelerando lasts during 4 4/4-measures,
				and then ends at the following measure on a new tempo of quarter = 180. <br /> <br />
				Each <m>SPECIFICATION</m> is an optional llll representing a given measure parameter, in the form <b>[<m>parameter_name</m> <m>parameter_value</m>]</b>.
				The <m>parameter_name</m> is a symbol identifying the parameter. The complete list of parameters symbols and their corresponding
				values is the following one: <br />
				- <b>width</b>: assigns a fixed width to a measure. It expects as value a fixed width in pixels that the measure will have (referred to the default
				vertical and horizontal zoom of 100%, and modified accordingly to those). Assigning a <m>width</m> parameter will also lock the measure barline,
				so that the width will remain the same, no matter how many chords and notes the measure does and will contain. Use the "auto" symbol
				instead of the fixed width to revert to the automatic measure width assignment (depending on the measure content). <br />
				- <b>widthfactor</b>: assigns a local factor for the spacing. It expects as value a multiplier factor, which will be applied to the whole measure
				spacing, and which will compress (for values less than 1) or expand (for values
				greater than 1) the width of the measure and the spacing of its chords accordingly. In this case, the measure barline is not locked, only the
				width factor is changed. <br />
				- <b>barline</b>: assigns a specific ending barline to a given measure. It expects a specific letter, representing the barline type. This letter
				can be one of the following ones: 'a' = automatic barline (defaul), 'n' = normal barline, 'd' = dashed barline, 'p' = dotted barline (p = "points"),
				't' = double barline (t = "two"), 's' = solid barline, 'f' = final barline, 'h' = hidden barline, 'k' = tick,
				'i' = intervoice barline only (barline is only between voice staves, not over staves). <br />.
				- <b>shownumber</b>: deals with measure numbers. If an "off" symbol is given as value, it means that the measure number of the current measure will
				not be displayed. If a specific number is given, it will be assigned as a forced measure number to be displayed, for instance <b>[shownumber -4]</b> will
				show -4 as measure number (also see the attribute <m>measurenumberoffset</m>). If an "auto" symbol is given, it will show the measure's automatically
				assigned measure number (default). <br />
				- <b>boxes</b>: assign custom beaming boxes. It expects custom beaming boxes for the measure, as a plain list of rational numbers.
				Custom boxing allows you to handle beam grouping inside the measure differently than beat-wise.
				Each number of the expected list is the symbolic width of each beaming box inside the measure.
				If the given boxes don't fill the whole measure, the last one is padded. For instance, in a 4/4 measure,
				<b>[boxes 1/8]</b> will simply use eight 1/8-wide boxes to beam elements inside the measure, instead of the default 1/4 wide ones (beats).
				This is equivalent to <b>[boxes 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8]</b>.
				Analogously, <b>[boxes 1/2 1/8 1/4 1/8]</b> is a more exotic boxing for the same time signature. <br />
				As a final example, (((4 4) (60) (widthfactor 0.5) (barline h) (shownumber off))) for a given measure sets a 4/4 time signature, a quarter = 60 tempo,
				compresses the measure by a factor of two, hides its final barline and its number.
				<br /> <br />
				Regularity boxes are a concept that helps bach.quantize quantizing properly by preserving untouched important beat positions.
				Indeed, bach.quantize's algorithm is a box-based algorithm: bach.quantize first cuts a measure into different boxes (for instance having widths of 1/4 each, but the default boxes depend
				on the time signature in general), and then performs the quantization in each box. This allows things falling almost exactly on box boundaries to be kept exactly on the box boundaries,
				so that they may not float due to quantization errors. You can assign custom boxes by explicitely saying which boxes you want.
				You have to give a llll for each voice (in our case, just one), containing for each measure: either a rational number, which represents the
				width of each box (e.g. <b>1/8</b>] and which will be repeated; or a list, containing explicitely the box width for each box, e.g. <b>[1/4 3/4]</b>.
				This has to be done for each voice, so that for instance a list like <b>[1/8 2/4] [] [[1/4 3/4] 1/8]</b> sets to 1/8 the boxes for firt measure of first voice,
				to 2/4 the boxes for second measure of first voice (and all the possibly following ones); leaves by default the boxes of second voice; sets explicitely to <b>[1/4 3/4]</b> the boxes for
				the first measure of the third voice and then to 1/8 for all the following ones.
				<br /> <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="algorithm" get="1" set="1" type="int" size="1">
			<digest>
				Algorithm
			</digest>
			<description>
				Choose the algorithm which will be used. The "Exhaustive" algorithm guarantees that the output solution will be the "best" possible solution,
				but it will in general require a lot of time to be computed ("full tree search"). A "Greedy" algorithm (default) will find a reasonably good solution in a more
				reasonable time. An "Exhaustive Greedy First" algorithm will perform full search, but giving priority to the Greedy possibilities (so that if a "best match" is
				found, the search is immediately stopped, the "best match" being when each chord is individually approximated with the best possible approximation among the
				possible choices depending on the <m>minimalunits</m>).
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Algorithm" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="approxwidth" get="1" set="1" type="int" size="1">
			<digest>
				Width Of The Approximation Search
			</digest>
			<description>
				bach.quantize builds a tree of possible approximations for each duration. Take a note of a given duration, for each minimal unit,
				there will always be a "best approximation" for the note, which not necessarily will fit in the "best rhythm approximation".
				In other words, for every note r and for each minimal unit u, there will always be a k such that k*u is "as near as possible" to r.
				The width of the approximation search is the number of approximations that we want to consider at "every side" of k. For instance, if k = 3, we will try to approximate
				r with k*u, but also with (k+1)*u, (k+2)*u, (k+3)*u, (k-1)*u, (k-2)*u, (k-3)*u.
				The higher the <m>approxwidth</m> is, the higher will be the number of possible approximations and solutions - the slower the algorithm will be.
				The default width of the approximation is is 2.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Width Of The Approximation Search" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="autoceil" get="1" set="1" type="int" size="1">
			<digest>
				Force All Voices To End Together
			</digest>
			<description>
				Force all voices to have the same number of measures (in case voices have different durations).
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Force All Voices To End Together" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="autoclear" get="1" set="1" type="int" size="1">
			<digest>
				Autoclear
			</digest>
			<description>
				Automatically clear the score before outputting the new data.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Autoclear" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="boxedgetiedurthresh" get="1" set="1" type="float" size="1">
			<digest>
				Box Edge Tied Notes Threshold
			</digest>
			<description>
				This threshold is the same as <m>durthresh</m>, but this one applies only for notes at the beginning or at the end of a quantization box, which are
				rests or which are completely tied to (respectively) the previous or the following one. This threshold is also given as a percentage of the smallest minimal unit
				(by default, this is 20%). Typically this should be greater than the <m>durthresh</m>.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Box Edge Tied Notes Threshold" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="discardgrace" get="1" set="1" type="int" size="1">
			<digest>
				Discard Grace Chords When
			</digest>
			<description>
				This attribute tells in which cases grace chords have to be immediately discarded, depending on the ties starting or ending on them.
				This might be useful, since you might want to prevent grace tied chords from being created. (This is taken into account only if <m>smalleventshandling</m> is set to "Make Grace Chords").
				<m>Never</m>: never discard any grace chord<br />
				<m>Tied To Next Chord</m>: discard a grace chord when it is completely tied to the next one<br />
				<m>Tied To Previous Chord</m>: discard a grace chord when it is completely tied to the previous one<br />
				<m>Tied To Next And Previous Chord</m>: discard a grace chord when it is completely tied to the previous AND the next one<br />
				<m>Tied To Next Or Previous Chord</m>: discard a grace chord when it is completely tied to the previous OR the next one<br />
				<m>Each Note Has Tie</m> (default): discard a grace chord when each note in the chord has a tie (starting or ending)<br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Grace Chords" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Discard Grace Chords When" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="discardgracerests" get="1" set="1" type="int" size="1">
			<digest>
				Always Discard Grace Rests
			</digest>
			<description>
				If this is set, bach.quantize always delete grace rests. (This is taken into account only if <m>smalleventshandling</m> is set to "Make Grace Chords").
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Grace Chords" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Always Discard Grace Rests" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="durthresh" get="1" set="1" type="float" size="1">
			<digest>
				Small Notes Duration Threshold
			</digest>
			<description>
				Threshold to determine which chords are "so small" that we have to discard them (what will happen to them depends on the <m>smalleventshandling</m> attribute).
				This threshold is given as a percentage of the smallest minimal unit (by default, this is 5%).
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Small Notes Duration Threshold" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="gracedeletethresh" get="1" set="1" type="float" size="1">
			<digest>
				Grace Chords Deletion Duration Threshold
			</digest>
			<description>
				Threshold to determine which grace chords are "so small" that we have to immediately discard them.
				All grace chords whose duration is less than this percentage of the smallest minimal unit will be in ANY case deleted.
				The default is 2.5%. (This is taken into account only if <m>smalleventshandling</m> is set to "Make Grace Chords")
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Grace Chords" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Grace Chords Deletion Duration Threshold" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="incoherentsubdivisions" get="1" set="1" type="int" size="1">
			<digest>
				Incoherent Subdivision
			</digest>
			<description>
				Determines what to do when incoherent subdivision markers are found: <br />
				<m>Drop</m>: Incoherent subdivision markers are dropped. <br />
				<m>Change Time Signature</m>: Time signature is modified according to the subdivision marker, to restore coherence. <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Quantization From Markers" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Incoherent Subdivision" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="maxiterations" get="1" set="1" type="int" size="1">
			<digest>
				Max Iterations For Single Box
			</digest>
			<description>
				Upper bound on the number of possible iterations for each box. After this number is reached, the best found solution is output
				(or no solution is output if no solution has been found). Leave 0 to search inside the whole tree (default).
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Max Iterations For Single Box" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="mergingpolicy" get="1" set="1" type="int" size="1">
			<digest>
				Small Events Merging Policy
			</digest>
			<description>
				If the <m>smalleventshandling</m> requires some merging, this attributes tells how the content should be merged: <br />
				<m>Merge To Next</m>: merges the chord to be deleted to the next chord (if any) <br />
				<m>Merge To Previous</m>: merges the chord to be deleted to the previous chord (if any) <br />
				<m>Merge To Smallest</m> (default): merges the chord to be deleted to the smallest between the previous and the next chord <br />
				<m>Merge To Biggest</m>: merges the chord to be deleted to the biggest between the previous and the next chord <br />
				<m>Merge To Both</m>: split the chord to be deleted between the previous chord and the next chord <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Small Events Merging Policy" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="minimalunits" get="1" set="1" type="llll" size="1">
			<digest>
				Minimal Units
			</digest>
			<description>
				Minimal units are the standard bricks with which the quantized rhythm of each box will be formed. More specifically, the final rhythm will be allowed to have as
				durations only linear combinations of the given minimal units. For instance, if minimal units are [1/8 1/12],
				the resulting rhythm will have as durations only multiple of the eighth note, multiples of the eighth-triplet note, and (but only if <m>mixingmode</m> is allowed)
				combinations of the two, such as 5/24 (by default weird combination possibilities are not allowed, keeping the rhythm more natural and straightforward to read,
				see <m>mixingmode</m> for more information).
				Minimal units can also be defined depending on the "amount of events" happening in a box. The idea behind this is: if we have very few events, we might want to use looser
				approximations and thus relatively "big" minimal units (such as 1/8 or 1/12) whereas if we have a lot of quick notes, we might want to increase (locally!) the finesse of
				the quantization, by choosing smaller minimal units (such as 1/32 or 1/24). This is achieved by putting "dynamic" as a first symbol in the minimal unit list.
				For instance: [dynamic ( 1/8 1/12 ) 10 ( 1/32 1/24 )] does what we wanted, and "10" is a threshold between the two regions (the one with "big" minimal units and the one
				with "small" minimal units), measured in event density. The event density is simply the number of events per whole note (1/1), so for instance in a measure with a long
				sequence of sixteenth notes, the density will be 16/1 = 1 (since there are 16 notes in a 1/1). Putting 10 as threshold means: in boxes where there are less than 10 notes
				per 1/1, use (1/8 1/12); otherwise use (1/32 1/24). The threshold must be an integer number.
				More than one threshold is also possible: for instance [dynamic ( 1/16 1/12 ) 10 ( 1/16 1/24 ) 15 ( 1/32 1/24 )] are the default minimal units when bach.quantize is created.
				Minimal units can also be a list of lists, such as [(1/8 1/12) (1/64 1/40)] in this case: each list applies to the corresponding voice (and the last one is looped, if needed).
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Minimal Units" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="mixingmode" get="1" set="1" type="int" size="1">
			<digest>
				Minimal Units Mixing In A Box
			</digest>
			<description>
				The <m>mixingmode</m> attribute deals with the fact that inside a box one might want just multiples of a single minimal unit.
				This is typically the most common case (and the fastest case as well!), which assure not to have tuplet-numbers greater than the one related
				to the minimal units: if one chooses 1/12 and 1/10 as minimal units, one will just have triplets or or 5-plets, but no 15-plet (for instance).
				If one wants this behavior, one should choose "Forbid" (default).
				If one chooses "Allow", mixed combination of units will be possible inside a box: this will make the algorithm slower and might produce cases where,
				by having 1/12's and 1/10's together in the same box, a 15-plet is produced.
				The "Smart Mix" possibility is somewhere in the middle: it hallows having different minimal units within the same, box but each chord has to have a
				single minimal unit, and all the tuplets must be completely achieved before changing minimal unit
				For instance, (1/24 1/24 1/24 1/8 1/8) is a perfectly allowed solution for smart mixing in a 1/4-wide-box, but (1/24 1/24 1/8 1/24 1/8) is NOT.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Minimal Units Mixing In A Box" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="multimeasure" get="1" set="1" type="int" size="1">
			<digest>
				Allow Multiple Measures Within Barline Markers
			</digest>
			<description>
				Allow the creation of more than one measure inside two barline markers, in case they are so far apart that more
				than one measure will fit, depending on the current tempo.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Quantization From Markers" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Allow Multiple Measures Within Barline Markers" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the "t" specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="quantizationpriority" get="1" set="1" type="int" size="1">
			<digest>
				Quantization Priority
			</digest>
			<description>
				Quantization is by default performed linearly, which means that quantization errors are tried to be fixed chord by chord,
				from the first chord to the last. One might want to change this priority, and decide to quantize the chords in a different order.
				This parameter is irrelevant if the <m>algorithm</m> is the exhaustive search. <br />
				<m>Linear</m> (default): quantization is performed linearly on the introduced events <br />
				<m>Backwards</m>: quantization is performed in reversed order with respect to the introduced events <br />
				<m>Notes First Decreasing</m>: quantization is performed first on non-rest chords, in decreasing order of duration (biggest to smallest), then on rests <br />
				<m>Notes First Increasing</m>: quantization is performed first on non-rest chords, in increasing order of duration (smallest to biggest), then on rests <br />
				<m>Rests First Decreasing</m>: quantization is performed first on rests, in decreasing order of duration (biggest to smallest), then on non-rest chords <br />
				<m>Rests First Increasing</m>: quantization is performed first on rests, in increasing order of duration (smallest to biggest), then on non-rest chords <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Quantization Priority" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="smalleventshandling" get="1" set="1" type="int" size="1">
			<digest>
				Small Notes Policy
			</digest>
			<description>
				Sometimes a quantization might require to drop some of the input events (either because they are too many with respect to the
				grid given by the minimal units, or - but only if <m>trytoavoidgrace</m> is not set, because the approximation will gain in precision). In this
				case there are a certain number of possibilities of dealing with the "small events" to discard. The "Small Notes Policy" deals exactly with this: <br />
				<m>Delete</m>: small events are simply deleted <br />
				<m>Merge</m>: small events are merged (see the attribute <m>mergingpolicy</m> to define how this is performed) <br />
				<m>Merge With Repetitions</m>: as the previous one, but notes are present with their multiplicity: if two chords are merged having the same note, this note will appear as doubled <br />
				<m>Make Grace Chords</m> (default): small events are turned into grace chords.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Small Notes Policy" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="sync" get="1" set="1" type="int" size="1">
			<digest>
				Preserve Synchronicities
			</digest>
			<description>
				Force all voices to maintain the synchronicities they had before the quantization.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Preserve Synchronicities" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="tempocompensation" get="1" set="1" type="int" size="1">
			<digest>
				Compensate For Tempo Sync
			</digest>
			<description>
				Determines when tempi should be changed, in order to keep sync with the score. Indeed tempo approximation
				might cause slight drifts with rispect to the non-quantized score; the drift amount is in general inversely proportional
				to the <m>tempodigits</m> attribute. The more often the tempo changes, the more often compensations are made, hence
				the better synchronicity one will achieve. Three values are available: <br />
				<m>At Tempo Change</m>: Change tempi only when they actually change. <br />
				<m>At Each Measure</m>: Compensate tempi at each measure beginning, if needed. <br />
				<m>At Each Division</m>: Compensate tempi at each measure division, if needed. <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Quantization From Markers" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Compensate For Tempo Sync" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="tempodigits" get="1" set="1" type="int" size="1">
			<digest>
				Number Of Digits For Tempo Approximation
			</digest>
			<description>
				Sets the number of digits for tempo approximation. Defaults to 2 for 64-bit mode, to 1 for 32-bit mode.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Number Of Digits For Tempo Approximation" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="tempohandling" get="1" set="1" type="int" size="1">
			<digest>
				Tempi Creation Policy
			</digest>
			<description>
				Sets the policy for creating tempi in the new score:
				<m>Ignore</m>: No tempi are created <br />
				<m>Set From Tempo Markers</m>: Tempi are only created when tempo markers are found. <br />
				<m>Set From Barlines</m>: Tempi are created for each measure, in sync with the defined barlines. <br />
				<m>Set From Divisions</m>: Tempi are created for each division, in sync with the defined barlines and division markers.
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Quantization From Markers" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Tempi Creation Policy" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="trytoavoidgrace" get="1" set="1" type="int" size="1">
			<digest>
				Try To Avoid Grace Chords When Possible
			</digest>
			<description>
				If this is set, bach.quantize always tries to accomplish the quantization in each box with the minimum possible number of grace chords,
				even if the result will be "less precise" than a solution with more grace chords. (This is taken into account only if <m>smalleventshandling</m> is set to "Make Grace Chords")
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Grace Chords" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Try To Avoid Grace Chords When Possible" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="verbose" get="1" set="1" type="int" size="1">
			<digest>
				Verbose Output
			</digest>
			<description>
				Amount of "verbosity" of bach.quantize: bach.quantize can post in the Max window the steps of its algorithm (this could be needed, for instance, for debug).
				By default this verbosity is 0 (no output), but it can get to 3 (most talkative: it almost mirrors the entire process in the Max window).
				Choose any number in between to have the corresponding amount of verbosity
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Settings" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Verbose Output" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		<o>bach.quantize</o> typically performs the task of converting a <o>bach.roll</o> object into a <o>bach.score</o> object.
		Yet, it can be used for a much wider range of purposes (e.g. for performing a score-to-score quantization).
		Generally speaking, it approximates a list of durations with combinations of a given set of so-called "minimal-units".
		To accomplish this, bach.quantize implements a box-wise algorithm: it performs an initial subdivision of the original
		rhythm into "boxes" where the quantization has to be achieved; then it quantizes each box separately;
		finally the boxes are merged into the requested measures. The criterion to decide the bounty of an approximation
		is simply the euclidean distance of quantized durations with the original durations, but a lot of attributes
		can partially modify this behaviour.
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.roll" />
		<seealso name="bach.score" />
		<seealso name="bach.beatbox" />
		<seealso name="bach.beatunbox" />
		<seealso name="bach.score2roll" />
		<seealso name="bach.mono" />
		<seealso name="pG" module="bach" type="tutorial" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll/bang)">
			<description>
				Measureinfo or bang.
				Measureinfo is the information about time signature and tempo, plus some other optional specifications concerning the measure itself.
				This can be a single <b><m>TIME_SIGNATURE</m> <m>TEMPO</m></b> valid for all voices and all measures, or a llll containing for each measure and each voice
				an llll in the form <b>[<m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				All elements except for the <m>TIME_SIGNATURE</m> are optional. <br /> <br />
				The <m>TIME_SIGNATURE</m> is an llll containing the measure time signature, in one of the following forms: <br />
				- <b>[<m>numerator</m> <m>denominator</m>]</b> for standard time signatures. For instance, <b>[4 4]</b> corresponds to a 4/4 time signature. <br />
				- <b>[[<m>numerator1</m> <m>numerator2</m> <m>numerator3</m>...] <m>denominator</m>]</b> for time
				signatures where the numerator is a sum of numbers.For instance <b>[[3 2 3] 8]</b>
				corresponds to a (3+2+3)/8 time signature. <br /> <br />
				The <m>TEMPO_OR_LIST_OF_TEMPI</m> represent in its simplest form, a single tempo. <br />
				A tempo, defined for a measure of a <o>bach.score</o> has one of the following syntaxes: <br />
				- <b>[<m>tempo_value</m>]</b> will assign a quarter tempo at the beginning of the measure. For instance <b>[60]</b> will set a 1/4 = 60 tempo. <br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m>]</b> will assign the tempo value to the specified symbolic unit (at the beginning of the measure).
				The <m>tempo_figure</m> is indeed the tempo symbolic unit: for instance <b>[3/8 40]</b> will set a tempo of a dotted quarter = 40.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m>]</b> will assign the tempo value to the specified symbolic unit and will put the
				tempo at the point inside the measure specified by the <m>tempo_sym_onset</m>. For instance <b>[3/8 40 1/4]</b> will set a tempo of a dotted quarter = 40
				but not at the beginning of the measure, rather after 1/4 from the beginning.<br />
				- <b>[<m>tempo_figure</m> <m>tempo_value</m> <m>tempo_sym_onset</m> <m>interpolation_to_next?</m>]</b> will do exactly as the previous case
				but if <m>interpolation_to_next?</m> is non-zero it will also toggle the interpolation from this tempo to the following one,
				yielding an accelerando or rallentando (depending if the next tempo is faster or slower). For instance <b>[3/8 40 1/4 1]</b>
				will set a tempo of a dotted quarter = 40, after 1/4 from the beginning, and will toggle the tempo interpolation to next tempo.<br />
				If more than one tempo need to be assigned to a given measure, one needs to use the general syntax for <m>TEMPO_OR_LIST_OF_TEMPI</m>, which is
				<b>[<m>TEMPO1</m> <m>TEMPO2</m> <m>TEMPO3</m>...]</b>, where each tempo must be in one the forms explained above. As an example, consider
				<b>[[60] [1/4 70 1/16] [1/8 60 1/8 1] [1/8 80 3/8]]</b>, where four tempi have been defined. The order of tempi is irrelevant,
				only their onset is accounted for. <br />
				Also, one might add an integer number at the beginning of each measure llll to indicate that the given measureinfo reference is valid for a
				certain number of measures, such as <b>[<m>how_many_measures</m> <m>TIME_SIGNATURE</m> <m>TEMPO_OR_LIST_OF_TEMPI</m> <m>SPECIFICATION1</m> <m>SPECIFICATION2</m>...]</b>.
				For instance <b>[5 [4 4] [[80] [1/4 160 1/2]]]</b> creates 5 measures of 4/4, each one starting with quarter = 80, and then each one accelerating
				until 1/4 = 160 exactly at half of the measure. For instance
				<b> [[[4 4] [1/8 60]] [[2 4] [1/4 50 1/4 1]] [4 [4 4]] [nil [180]]]</b> means that we start a bar 1 in 4/4 and octave note = 60, then we
				pass at 2/4 and quarter = 50 after 1/4 of measure 2, and at that moment, an accelerando starts. The accelerando lasts during 4 4/4-measures,
				and then ends at the following measure on a new tempo of quarter = 180. <br /> <br />
				Each <m>SPECIFICATION</m> is an optional llll representing a given measure parameter, in the form <b>[<m>parameter_name</m> <m>parameter_value</m>]</b>.
				The <m>parameter_name</m> is a symbol identifying the parameter. The complete list of parameters symbols and their corresponding
				values is the following one: <br />
				- <b>width</b>: assigns a fixed width to a measure. It expects as value a fixed width in pixels that the measure will have (referred to the default
				vertical and horizontal zoom of 100%, and modified accordingly to those). Assigning a <m>width</m> parameter will also lock the measure barline,
				so that the width will remain the same, no matter how many chords and notes the measure does and will contain. Use the "auto" symbol
				instead of the fixed width to revert to the automatic measure width assignment (depending on the measure content). <br />
				- <b>widthfactor</b>: assigns a local factor for the spacing. It expects as value a multiplier factor, which will be applied to the whole measure
				spacing, and which will compress (for values less than 1) or expand (for values
				greater than 1) the width of the measure and the spacing of its chords accordingly. In this case, the measure barline is not locked, only the
				width factor is changed. <br />
				- <b>barline</b>: assigns a specific ending barline to a given measure. It expects a specific letter, representing the barline type. This letter
				can be one of the following ones: 'a' = automatic barline (defaul), 'n' = normal barline, 'd' = dashed barline, 'p' = dotted barline (p = "points"),
				't' = double barline (t = "two"), 's' = solid barline, 'f' = final barline, 'h' = hidden barline, 'k' = tick,
				'i' = intervoice barline only (barline is only between voice staves, not over staves). <br />.
				- <b>shownumber</b>: deals with measure numbers. If an "off" symbol is given as value, it means that the measure number of the current measure will
				not be displayed. If a specific number is given, it will be assigned as a forced measure number to be displayed, for instance <b>[shownumber -4]</b> will
				show -4 as measure number (also see the attribute <m>measurenumberoffset</m>). If an "auto" symbol is given, it will show the measure's automatically
				assigned measure number (default). <br />
				- <b>boxes</b>: assign custom beaming boxes. It expects custom beaming boxes for the measure, as a plain list of rational numbers.
				Custom boxing allows you to handle beam grouping inside the measure differently than beat-wise.
				Each number of the expected list is the symbolic width of each beaming box inside the measure.
				If the given boxes don't fill the whole measure, the last one is padded. For instance, in a 4/4 measure,
				<b>[boxes 1/8]</b> will simply use eight 1/8-wide boxes to beam elements inside the measure, instead of the default 1/4 wide ones (beats).
				This is equivalent to <b>[boxes 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8]</b>.
				Analogously, <b>[boxes 1/2 1/8 1/4 1/8]</b> is a more exotic boxing for the same time signature. <br />
				As a final example, (((4 4) (60) (widthfactor 0.5) (barline h) (shownumber off))) for a given measure sets a 4/4 time signature, a quarter = 60 tempo,
				compresses the measure by a factor of two, hides its final barline and its number.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Inlet 2 (llll)">
			<description>
				The llll output by bach.roll's or bach.score's first outlet after a <m>quantize</m> message – or in <m>separate</m> mode: Pitches or MIDIcents.
			</description>
		</entry>
		<entry name ="Inlet 3 (llll)">
			<description>
				The Regularity Boxes for the quantization – or in <m>separate</m> mode: Durations.
				Regularity boxes are a concept that helps bach.quantize quantizing properly by preserving untouched important beat positions.
				Indeed, bach.quantize's algorithm is a box-based algorithm: bach.quantize first cuts a measure into different boxes (for instance having widths of 1/4 each, but the default boxes depend
				on the time signature in general), and then performs the quantization in each box. This allows things falling almost exactly on box boundaries to be kept exactly on the box boundaries,
				so that they may not float due to quantization errors. You can assign custom boxes by explicitely saying which boxes you want.
				You have to give a llll for each voice (in our case, just one), containing for each measure: either a rational number, which represents the
				width of each box (e.g. <b>1/8</b>] and which will be repeated; or a list, containing explicitely the box width for each box, e.g. <b>[1/4 3/4]</b>.
				This has to be done for each voice, so that for instance a list like <b>[1/8 2/4] [] [[1/4 3/4] 1/8]</b> sets to 1/8 the boxes for firt measure of first voice,
				to 2/4 the boxes for second measure of first voice (and all the possibly following ones); leaves by default the boxes of second voice; sets explicitely to <b>[1/4 3/4]</b> the boxes for
				the first measure of the third voice and then to 1/8 for all the following ones.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Inlet 4 (llll)">
			<description>
				Velocities (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Inlet 5 (llll)">
			<description>
				Ties (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Inlet 6 (llll)">
			<description>
				Extras (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Inlet 7 (llll)">
			<description>
				Regularity Boxes (in <m>separate</m> mode only).
				Regularity boxes are a concept that helps bach.quantize quantizing properly by preserving untouched important beat positions.
				Indeed, bach.quantize's algorithm is a box-based algorithm: bach.quantize first cuts a measure into different boxes (for instance having widths of 1/4 each, but the default boxes depend
				on the time signature in general), and then performs the quantization in each box. This allows things falling almost exactly on box boundaries to be kept exactly on the box boundaries,
				so that they may not float due to quantization errors. You can assign custom boxes by explicitely saying which boxes you want.
				You have to give a llll for each voice (in our case, just one), containing for each measure: either a rational number, which represents the
				width of each box (e.g. <b>1/8</b>] and which will be repeated; or a list, containing explicitely the box width for each box, e.g. <b>[1/4 3/4]</b>.
				This has to be done for each voice, so that for instance a list like <b>[1/8 2/4] [] [[1/4 3/4] 1/8]</b> sets to 1/8 the boxes for firt measure of first voice,
				to 2/4 the boxes for second measure of first voice (and all the possibly following ones); leaves by default the boxes of second voice; sets explicitely to <b>[1/4 3/4]</b> the boxes for
				the first measure of the third voice and then to 1/8 for all the following ones.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (anything)">
			<description>
				Messages for bach.score.
				Unless the <m>separate</m> argument is set, this sends
				the score gathered-syntax which construct the quantized score.
				If the <m>separate</m> attribute is set, this sends messages to score (such as "clear"
				if <m>autoclear</m> is active) and a bang to properly build the score from
				the separate parameters
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Notifications (in standard mode), or Measureinfo (in <m>separate</m> mode).
				Unless the <m>separate</m> attribute is set, this sends out the notifications obtained
				from marker quantization (such as the pickup added time).
				If the <m>separate</m> argument is set, this sends out the Measureinfo (in <m>separate</m> mode only)
			</description>
		</entry>
		<entry name ="Outlet 3 (llll)">
			<description>
				The quantized Pitches or cents (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Outlet 4 (llll)">
			<description>
				The quantized Durations (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Outlet 5 (llll)">
			<description>
				The quantized Velocities (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Outlet 6 (llll)">
			<description>
				The quantized Ties (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Outlet 7 (llll)">
			<description>
				The quantized Extras (in <m>separate</m> mode only).
			</description>
		</entry>
		<entry name ="Outlet 8 (llll)">
			<description>
				Notifications (in <m>separate</m> mode only).
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		<o>bach.quantize</o> typically performs the task of converting a <o>bach.roll</o> object into a <o>bach.score</o> object.
		Yet, it can be used for a much wider range of purposes (e.g. for performing a score-to-score quantization).
		Generally speaking, it approximates a list of durations with combinations of a given set of so-called "minimal-units".
		To accomplish this, bach.quantize implements a box-wise algorithm: it performs an initial subdivision of the original
		rhythm into "boxes" where the quantization has to be achieved; then it quantizes each box separately;
		finally the boxes are merged into the requested measures. The criterion to decide the bounty of an approximation
		is simply the euclidean distance of quantized durations with the original durations, but a lot of attributes
		can partially modify this behaviour.
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
quantize, measureinfo, convert, measured, proportional, marker, minimal units, grace notes, box, approximate, distance, time signature, tempo, barline.
			</description>
		</entry>
	</misc>

</c74object>