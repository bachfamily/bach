<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.belong" module="bach" kind="patcher">

	<digest>
		Tell if some elements belong to a llll
	</digest>

	<description>
		Tells if one or more elements belong to a given llll.
		The condition for which an element belongs to the llll can be customized via
		a lambda loop.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach abstractions</metadata>
		<metadata name="tag">bach llll</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				The elements to be found
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				The llll possibly containing the elements
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the two elements
				output via the lambda outlet are equal (according to your custom meaning of the word "equality"),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				1 if all elements belong to the llll container, 0 otherwise
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				First lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from each one of the two lambda outlets have to be tested for "equality":
				you should tell whether they are "equal" (according to your custom meaning of the word "equality") or not.
				In the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				Second lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from each one of the two lambda outlets have to be tested for "equality":
				you should tell whether they are "equal" (according to your custom meaning of the word "equality") or not.
				In the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="possible_container" optional="1" type="llll">
			<digest>
				Possible container
			</digest>
			<description>
				The argument is an llll which might be the possible container
				of the elements expected in the first inlet (this llll can also be set via second inlet).
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Tell if elements belong to the llll
			</digest>
			<description>
				Outputs the answer obtained from the most recently received input data.
			</description>
		</method>
		<method name="int">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				Third inlet is a lambda inlet. <br />
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the two elements
				output via the lambda outlet are equal (according to your custom meaning of the word "equality"),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Function depends on inlet
			</digest>
			<description>
				In the first inlet, an llll will set the collection of elements to be matched,
				and will trigger the output of the answer, whether all these elements belong to the
				contained defined in the middle inlet.<br />
				In the second inlet, an llll will set the possible container of such elements. <br />
				In the third inlet, an llll is converted into an <m>int</m>.
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		The lambda behavior work like for <o>bach.intersection</o>, of which
		this abstraction is a small wrapper.
		An element of the first collection is said to be equal to an element
		of the second llll according the a custom operator.	<br /> <br />
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.find" />
		<seealso name="bach.intersection" />
		<seealso name="bach.thin" />
		<seealso name="bach.union" />
		<seealso name="bach.filter" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				The elements to be found.
			</description>
		</entry>
		<entry name ="Inlet 2 (llll)">
			<description>
				The llll possibly containing the elements.
			</description>
		</entry>
		<entry name ="Inlet 3 (int/llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the two elements
				output via the lambda outlet are equal (according to your custom meaning of the word "equality"),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (int)">
			<description>
				1 if all elements belong to the llll container, 0 otherwise.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				First lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from each one of the two lambda outlets have to be tested for "equality":
				you should tell whether they are "equal" (according to your custom meaning of the word "equality") or not.
				In the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Outlet 3 (llll)">
			<description>
				Second lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from each one of the two lambda outlets have to be tested for "equality":
				you should tell whether they are "equal" (according to your custom meaning of the word "equality") or not.
				In the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		The lambda behavior work like for <o>bach.intersection</o>, of which
		this abstraction is a small wrapper.
		An element of the first collection is said to be equal to an element
		of the second llll according the a custom operator.	<br /> <br />
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
belong, lambda loop, equal, include.
			</description>
		</entry>
	</misc>

</c74object>