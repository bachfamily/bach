<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.split" module="bach" kind="patcher">

	<digest>
		Add parentheses depending on a separator
	</digest>

	<description>
		Splits the incoming llll into chunks, depending on a
		given separator, and wraps each chunk inside a level of parentheses.
		The separators can also be specified via a lambda loop.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach abstractions</metadata>
		<metadata name="tag">bach llll</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				The llll
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				The lambda inlet expects a 1 if the currently output element is a separator,
				a 0 otherwise. <br />
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the element output from the lambda outlet is a match
				(according to your custom matching function, defined in the lambda loop),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				The split llll
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda outlet
			</digest>
			<description>
				Elements are output through the lambda outlet in order to let the user decide
				whether they are separators (in which case 1 must returned in the lambda inlet, as for
				a found match) or not (0 should be returned in the lambda inlet). <br />
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet have to be tested in order to know if they are a match:
				in the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="separator" optional="1" type="llll">
			<digest>
				Separator
			</digest>
			<description>
				The optional argument sets the element used as separator
				for splitting the llll into wrapped chunks. It is expected to be a single element
				or an llll of length 1.
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Output result
			</digest>
			<description>
				Outputs the result of the process performed on the most received input llll.
			</description>
		</method>
		<method name="int">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				Second inlet is a lambda inlet, and is expected to receive 1 if the
				currently output element is a separator, 0 otherwise. <br />
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the element output from the lambda outlet is a match
				(according to your custom matching function, defined in the lambda loop),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Split llll
			</digest>
			<description>
				An llll in the first inlet will be split into chunks depending on the
				given separator element; each chunk is then wrapped in a level of parenthesis, and
				the resulting list is output. The separator can be kept or discarded depending
				on the <m>keep</m> attribute; the separator itself is set via the <m>separator</m> attribute. <br />
				In the second inlet, an llll is converted into an <m>int</m>
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="keep" get="1" set="1" type="int" size="1">
			<digest>
				Keep Separator
			</digest>
			<description>
				Toggles the possibility to keep the separator element in the
				output llll. By default it is set to 0 (<b>Never</b>: separator is discarded),
				but this can be set to 1 (<b>Before Parentheses</b>: separator is kept before
				the newly placed parentheses) or 2 (<b>After Parentheses</b>: separator is kept
				after the newly placed parentheses).
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Keep Separator" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="mode" get="1" set="1" type="" size="1">
			<digest>
				
			</digest>
			<description>
				Element used as separator for splitting the llll into wrapped chunks.
			</description>
			<attributelist>
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message. To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format, e
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="separator" get="1" set="1" type="llll" size="1">
			<digest>
				Separator
			</digest>
			<description>
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Separator" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		The lambda loop will return 1 if a given element is a separator, 0
		otherwise. In this case, the introduced separator (if any) is ignored. <br /> <br />
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.slice" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				The llll.
			</description>
		</entry>
		<entry name ="Inlet 2 (int/llll)">
			<description>
				Lambda inlet.
				The lambda inlet expects a 1 if the currently output element is a separator,
				a 0 otherwise. <br />
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is in a 0/1 form: if the element output from the lambda outlet is a match
				(according to your custom matching function, defined in the lambda loop),
				this inlet should receive a 1; otherwise it should receive a 0. <br />
				The lambda inlet also accepts the 0/1 result in a native llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				The split llll.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda outlet.
				Elements are output through the lambda outlet in order to let the user decide
				whether they are separators (in which case 1 must returned in the lambda inlet, as for
				a found match) or not (0 should be returned in the lambda inlet). <br />
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet have to be tested in order to know if they are a match:
				in the first case, you should return a 1 into the lambda inlet, in the second case you should return a 0. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		The lambda loop will return 1 if a given element is a separator, 0
		otherwise. In this case, the introduced separator (if any) is ignored. <br /> <br />
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
split, separate, chunk, separator, wrap, lambda loop, keep, change, repetition.
			</description>
		</entry>
	</misc>

</c74object>