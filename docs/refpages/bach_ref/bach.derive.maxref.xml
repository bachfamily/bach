<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.derive" module="bach" category="Math">

	<digest>
		Derive functions
	</digest>

	<description>
		Computes the derivative of a breakpoint function or of a general function defined via a lambda loop.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach objects</metadata>
		<metadata name="tag">bach math</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Breakpoint function llll or sampling parameters
			</digest>
			<description>
				In auto mode, an <m>llll</m> in the first inlet is the breakpoint function to be derived.
				In lambda mode, a flat <m>llll</m> contains an explicit sampling, whereas an <m>llll</m> in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b> sets an uniform sampling.
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is supposed to be the Y value of the function at the X point which has been sent out.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Derived breakpoint function llll
			</digest>
			<description>
				The llll with the derived breakpoint function, as a list of points, where each
				point is in the form <b>[<m>x</m> <m>y</m> 0]</b>. Notice that the slope is always 0, since the
				output function is always piecewise linear.
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda Outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, domain X values are output one by one, and expect to be mapped to the corresponding Y values,
				to be plugged in the lambda inlet.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="mode" optional="1" type="symbol">
			<digest>
				Mode
			</digest>
			<description>
				If there is no argument or if the argument is the <b>auto</b> symbol,
				the operation mode is the automatic mode: the object has just one inlet and one outlet,
				and expects as input an incoming breakpoint function, which will be derived.
				If the argument is the <b>lambda</b> symbol, the object is instantiated in lambda mode:
				the function is now defined via a lambda loop: X values are output through the lambda
				outlet and expect to be mapped on the desired Y values, to be plugged in the lambda inlet.
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Output result
			</digest>
			<description>
				Output the derivative function, based on the most recently received input data.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Derive breakpoint function or lambda-defined function
			</digest>
			<description>
				In auto mode (see arguments), an <m>llll</m> in the first inlet is considered to be a breakpoint function
				defined as a sequence of points in the form <b>[<m>x</m> <m>y</m> <m>slope</m>]</b>. Such function
				is derived exactly if the function is piecewise linear, i.e. all slopes are negligible; otherwise
				the derivation is performed via a sampling process (the original function is sampled in a certain number
				of points, defined by the <m>numsamples</m> attribute).
				The resulting derivative is output in the same breakpoint function form from the left outlet
				(all slopes will be 0: output function is always piecewise linear). <br />
				In lambda mode (see arguments), an <m>llll</m> in the first inlet must be either in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b>, or must be a plain list of
				explicit sampling points (points in which derivative function should be sampled). The domain points are output one by one
				from the lamdba outlet, and values of the function to derive are collected in the lambda inlet.
				After deriving, the resulting derivative function is output in the breakpoint function form
				explained above from the left outlet. <br />
				An <m>llll</m> in the second inlet is converted into a <m>float</m>.
			</description>
		</method>
		<method name="number">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				Second inlet is a lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case the answer is expected to be a the value of the function to be derived,
				corresponding to the output domain value.
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="discrete" get="1" set="1" type="int" size="1">
			<digest>
				Output Discrete Derivative
			</digest>
			<description>
				Toggles the ability to choose between discrete derivative and continuous derivative.
				If this attribute is active, for each couple of incoming points a derivative point is computed
				and placed at the mean point of their X coordinates. However, if this attribute is set to 0 (default), for each incoming segment
				two values are output: one at the beginning of the segment, and one at the end of the segment, with the same Y coordinate,
				retaining the original X coordinates of the segment. As a result, a piecewise linear function is mapped to a
				piecewise constant function. The number of points, thus, in this case essentially doubles the original number (up to
				a final sieving of useless function points).
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Output Discrete Derivative" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="numsamples" get="1" set="1" type="int" size="1">
			<digest>
				Number of Sampling Points
			</digest>
			<description>
				In the automatic mode (with no arguments) sets the number of samples for the incoming
				breakpoint function. If the breakpoint function is purely piecewise linear (no slopes), this
				number is ignored, and the actual points are used for precise derivative.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Number of Sampling Points" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="order" get="1" set="1" type="int" size="1">
			<digest>
				Order
			</digest>
			<description>
				Sets the order of the derivative, i.e. the number of times the derivative should be subsequently performed.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Order" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the "t" specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="pad" get="1" set="1" type="int" size="1">
			<digest>
				Discreted Derivative Pad
			</digest>
			<description>
				If <m>discrete</m> is set to 1, the output discrete derivative is output.
				Such derivative, by construction, has one point less than the original number of data. This <m>pad</m> attribute handles the
				possible padding behavior: <br />
				- No Pad: output number of points will be the original number of points minus one. All output X coordinates are mean points
				of each incoming segment. <br />
				- Pad At Right (Default): output number of points will be the same as the original number of points. All output X coordinates are ending points
				of each incoming segment, and a starting point is added. <br />
				- Pad At Left: output number of points will be the same as the original number of points. All output X coordinates are starting points
				of each incoming segment, and a final point is added. <br />
				- Pad At Left And Right: output number of points will be the original number of points plus one. All output X coordinates are mean points
				of each incoming segment, and a starting and final points are added. <br />
				The padding, in all cases, is done by preserving the derivative, i.e. by constant extrapolation of the derivative.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Discreted Derivative Pad" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.integrate" />
		<seealso name="bach.expr" />
		<seealso name="bach.slot" />
		<seealso name="bach.reducefunction" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (bang/llll)">
			<description>
				Breakpoint function llll or sampling parameters.
				In auto mode, an <m>llll</m> in the first inlet is the breakpoint function to be derived.
				In lambda mode, a flat <m>llll</m> contains an explicit sampling, whereas an <m>llll</m> in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b> sets an uniform sampling.
			</description>
		</entry>
		<entry name ="Inlet 2 (number/llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is supposed to be the Y value of the function at the X point which has been sent out.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Derived breakpoint function llll.
				The llll with the derived breakpoint function, as a list of points, where each
				point is in the form <b>[<m>x</m> <m>y</m> 0]</b>. Notice that the slope is always 0, since the
				output function is always piecewise linear.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda Outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, domain X values are output one by one, and expect to be mapped to the corresponding Y values,
				to be plugged in the lambda inlet.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

</c74object>