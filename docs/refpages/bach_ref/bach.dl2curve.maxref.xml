<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.dl2curve" module="bach" kind="patcher">

	<digest>
		Convert a duration line into pitch and velocity curve~ messages
	</digest>

	<description>
		Converts the information about the duration line of a note
		into messages to drive a pitch curve~ and a velocity curve~.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach abstractions</metadata>
		<metadata name="tag">bach notation</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				The base pitch (midicents)
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				The base velocity
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				The note duration (milliseconds)
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="3" type="INLET_TYPE">
			<digest>
				The pitch breakpoints as llll
			</digest>
			<description>
				Breakpoints are expected
				as an llll in the form <b><m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...</b>,
				as in the note pitch breakpoint syntax (see below), but without
				the routing <b>breakpoint</b> symbol, and without the outer level
				of parenthesis. <br />
				The <m>breakpoint</m> specification informs about possible pitch breakpoints that a note duration line has. This is useful to represent glissandi.
				It is given by an llll in the form <b>[<m>breakpoints</m> <m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...]</b>,
				where each <m>BPT</m> is an llll in the form <b>[<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m>]</b>, where
				<m>relative_x_position</m> is a double precision number from 0 to 1 representing the point where the breakpoint is, 0 corresponding to
				the notehead and 1 corresponding to the note tail; <m>delta_midicents</m> is the pitch difference (in midicents) between the breakpoint pitch and the base note pitch;
				<m>slope</m> is a value from -1 to 1 corresponding to the curvature of the segment of duration line preceding the breakpoint (this implies that the slope of the first breakpoint
				is always ignored), as for Max <o>curve</o> object (thus 0 being linear). <br />
				Two breakpoints are always present: the first breakpoint corresponds always to (0 0 0), and can never
				be different than this; the last breakpoint corresponds always to the note tail, and must always be in the form <b>[1 <m>delta_midicents</m> <m>slope</m>]</b>.
				If all breakpoints are trivial (thus if there are just two breakpoints: notehead and tail, and the notetail has <m>delta_midicents</m> = 0), the breakpoint
				specification is never given as output. For instance, a note making a glissando upwards and then downwards of 200cents, linear while ascending and exponential in the descent,
				will have the breakpoint specification of the form <b>[breakpoints [0 0 0] [0.5 200 0] [1 0 0.5]]</b>. <br />
				If the <m>breakpointshavevelocity</m> attribute is set to 1, pitch breakpoints also have velocities, thus the complete <m>BPT</m> specification is in the form
				(<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m> <m>velocity</m>),
				where <m>velocity</m> is a number from 1 to 127 corresponding to the pitch breakpoint dynamic. If different breapoints have different dynamics, the behavior of
				the velocity between them is considered to be interpolatory, for instance by abstractions like <o>bach.dl2line</o> or <o>bach.dl2curve</o>.
				<br /> <br />
			</description>
		</inlet>
		<inlet id="4" type="INLET_TYPE">
			<digest>
				The pitch lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
		<inlet id="5" type="INLET_TYPE">
			<digest>
				The velocity lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Messages for the curve~ controlling the pitch
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Messages for the curve~ controlling the velocity
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				The pitch lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
		<outlet id="3" type="INLET_TYPE">
			<digest>
				The velocity lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Perform last operation
			</digest>
			<description>
				Performs and outputs the messages for the curve~ objects, based on the most recently received input data.
			</description>
		</method>
		<method name="float">
			<arglist />
			<digest>
				Function depends on inlet
			</digest>
			<description>
			</description>
		</method>
		<method name="int">
			<arglist />
			<digest>
				Set base velocity
			</digest>
			<description>
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Set pitch breakpoints
			</digest>
			<description>
				An llll in the fourth inlet sets the breakpoint
				function of the duration line. Breakpoints are expected
				as an llll in the form <b><m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...</b>,
				as in the note pitch breakpoint syntax (see below), but without
				the routing <b>breakpoint</b> symbol, and without the outer level
				of parenthesis. <br />
				An llll in any other inlet is converted into a number (see <m>float</m> and <m>int</m>). <br />
				The <m>breakpoint</m> specification informs about possible pitch breakpoints that a note duration line has. This is useful to represent glissandi.
				It is given by an llll in the form <b>[<m>breakpoints</m> <m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...]</b>,
				where each <m>BPT</m> is an llll in the form <b>[<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m>]</b>, where
				<m>relative_x_position</m> is a double precision number from 0 to 1 representing the point where the breakpoint is, 0 corresponding to
				the notehead and 1 corresponding to the note tail; <m>delta_midicents</m> is the pitch difference (in midicents) between the breakpoint pitch and the base note pitch;
				<m>slope</m> is a value from -1 to 1 corresponding to the curvature of the segment of duration line preceding the breakpoint (this implies that the slope of the first breakpoint
				is always ignored), as for Max <o>curve</o> object (thus 0 being linear). <br />
				Two breakpoints are always present: the first breakpoint corresponds always to (0 0 0), and can never
				be different than this; the last breakpoint corresponds always to the note tail, and must always be in the form <b>[1 <m>delta_midicents</m> <m>slope</m>]</b>.
				If all breakpoints are trivial (thus if there are just two breakpoints: notehead and tail, and the notetail has <m>delta_midicents</m> = 0), the breakpoint
				specification is never given as output. For instance, a note making a glissando upwards and then downwards of 200cents, linear while ascending and exponential in the descent,
				will have the breakpoint specification of the form <b>[breakpoints [0 0 0] [0.5 200 0] [1 0 0.5]]</b>. <br />
				If the <m>breakpointshavevelocity</m> attribute is set to 1, pitch breakpoints also have velocities, thus the complete <m>BPT</m> specification is in the form
				(<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m> <m>velocity</m>),
				where <m>velocity</m> is a number from 1 to 127 corresponding to the pitch breakpoint dynamic. If different breapoints have different dynamics, the behavior of
				the velocity between them is considered to be interpolatory, for instance by abstractions like <o>bach.dl2line</o> or <o>bach.dl2curve</o>.
				<br /> <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the "t" specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.dl2line" />
		<seealso name="bach.roll" />
		<seealso name="bach.score" />
		<seealso name="bach.slot2line" />
		<seealso name="bach.slot2curve" />
		<seealso name="bach.playkeys" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (float)">
			<description>
				The base pitch (midicents).
			</description>
		</entry>
		<entry name ="Inlet 2 (int)">
			<description>
				The base velocity.
			</description>
		</entry>
		<entry name ="Inlet 3 (float)">
			<description>
				The note duration (milliseconds).
			</description>
		</entry>
		<entry name ="Inlet 4 (llll)">
			<description>
				The pitch breakpoints as llll.
				Breakpoints are expected
				as an llll in the form <b><m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...</b>,
				as in the note pitch breakpoint syntax (see below), but without
				the routing <b>breakpoint</b> symbol, and without the outer level
				of parenthesis. <br />
				The <m>breakpoint</m> specification informs about possible pitch breakpoints that a note duration line has. This is useful to represent glissandi.
				It is given by an llll in the form <b>[<m>breakpoints</m> <m>BPT1</m> <m>BPT2</m> <m>BPT3</m>...]</b>,
				where each <m>BPT</m> is an llll in the form <b>[<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m>]</b>, where
				<m>relative_x_position</m> is a double precision number from 0 to 1 representing the point where the breakpoint is, 0 corresponding to
				the notehead and 1 corresponding to the note tail; <m>delta_midicents</m> is the pitch difference (in midicents) between the breakpoint pitch and the base note pitch;
				<m>slope</m> is a value from -1 to 1 corresponding to the curvature of the segment of duration line preceding the breakpoint (this implies that the slope of the first breakpoint
				is always ignored), as for Max <o>curve</o> object (thus 0 being linear). <br />
				Two breakpoints are always present: the first breakpoint corresponds always to (0 0 0), and can never
				be different than this; the last breakpoint corresponds always to the note tail, and must always be in the form <b>[1 <m>delta_midicents</m> <m>slope</m>]</b>.
				If all breakpoints are trivial (thus if there are just two breakpoints: notehead and tail, and the notetail has <m>delta_midicents</m> = 0), the breakpoint
				specification is never given as output. For instance, a note making a glissando upwards and then downwards of 200cents, linear while ascending and exponential in the descent,
				will have the breakpoint specification of the form <b>[breakpoints [0 0 0] [0.5 200 0] [1 0 0.5]]</b>. <br />
				If the <m>breakpointshavevelocity</m> attribute is set to 1, pitch breakpoints also have velocities, thus the complete <m>BPT</m> specification is in the form
				(<m>relative_x_position</m> <m>delta_midicents</m> <m>slope</m> <m>velocity</m>),
				where <m>velocity</m> is a number from 1 to 127 corresponding to the pitch breakpoint dynamic. If different breapoints have different dynamics, the behavior of
				the velocity between them is considered to be interpolatory, for instance by abstractions like <o>bach.dl2line</o> or <o>bach.dl2curve</o>.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Inlet 5 (float/llll)">
			<description>
				The pitch lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Inlet 6 (float/llll)">
			<description>
				The velocity lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Messages for the curve~ controlling the pitch.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Messages for the curve~ controlling the velocity.
			</description>
		</entry>
		<entry name ="Outlet 3 (llll)">
			<description>
				The pitch lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Outlet 4 (llll)">
			<description>
				The velocity lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

</c74object>