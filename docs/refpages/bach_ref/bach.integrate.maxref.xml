<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.integrate" module="bach" category="Math">

	<digest>
		Integrate functions
	</digest>

	<description>
		Computes the integral of a breakpoint function or of a general function defined via a lambda loop.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach objects</metadata>
		<metadata name="tag">bach math</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Breakpoint function llll or sampling parameters
			</digest>
			<description>
				In auto mode, an <m>llll</m> in the first inlet is the breakpoint function to be integrated.
				In lambda mode, a flat <m>llll</m> contains an explicit sampling, whereas an <m>llll</m> in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b> sets an uniform sampling.
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is supposed to be the Y value of the function at the X point which has been sent out.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Integrated breakpoint function llll
			</digest>
			<description>
				The llll with the integrated breakpoint function, as a list of points, where each
				point is in the form <b>[<m>x</m> <m>y</m> 0]</b>. Notice that the slope is always 0, since the
				output function is always piecewise linear.
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda Outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, domain X values are output one by one, and expect to be mapped to the corresponding Y values,
				to be plugged in the lambda inlet.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="mode" optional="1" type="symbol">
			<digest>
				Mode
			</digest>
			<description>
				If there is no argument or if the argument is the <b>auto</b> symbol,
				the operation mode is the automatic mode: the object has just one inlet and one outlet,
				and expects as input an incoming breakpoint function, which will be integrated.
				If the argument is the <b>lambda</b> symbol, the object is instantiated in lambda mode:
				the function is now defined via a lambda loop: X values are output through the lambda
				outlet and expect to be mapped on the desired Y values, to be plugged in the lambda inlet.
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Output result
			</digest>
			<description>
				Output the integrated function, based on the most recently received input data.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Integrate breakpoint function or lambda-defined function
			</digest>
			<description>
				In auto mode (see arguments), an <m>llll</m> in the first inlet is considered to be a breakpoint function
				defined as a sequence of points in the form <b>[<m>x</m> <m>y</m> <m>slope</m>]</b>. Such function
				is integrated exactly if the function is piecewise linear, i.e. all slopes are negligible; otherwise
				the integration is performed via a sampling process (the original function is sampled in a certain number
				of points, defined by the <m>numsamples</m> attribute).
				The resulting integral function is output in the same breakpoint function form from the left outlet
				(all slopes will be 0: output function is always piecewise linear). <br />
				In lambda mode (see arguments), an <m>llll</m> in the first inlet must be either in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b>, or must be a plain list of
				explicit sampling points (points in which integral function should be sampled). The domain points are output one by one
				from the lamdba outlet, and values of the function to integrate are collected in the lambda inlet.
				After the integration, the resulting integral function is output in the breakpoint function form
				explained above from the left outlet. <br />
				An <m>llll</m> in the second inlet is converted into a <m>float</m>.
			</description>
		</method>
		<method name="number">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				Second inlet is a lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case the answer is expected to be a the value of the function to be integrated,
				corresponding to the output domain value.
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="numsamples" get="1" set="1" type="int" size="1">
			<digest>
				Number of Sampling Points
			</digest>
			<description>
				In the automatic mode (with no arguments) sets the number of samples for the incoming
				breakpoint function. If the breakpoint function is purely piecewise linear (no slopes), this
				number is ignored, and the actual points are used for precise integration.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Number of Sampling Points" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="order" get="1" set="1" type="int" size="1">
			<digest>
				Order
			</digest>
			<description>
				Sets the order of the integration, i.e. the number of times the integration should be subsequently performed.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Order" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="origin" get="1" set="1" type="float_array" size="0">
			<digest>
				Initial Value For Integration
			</digest>
			<description>
				Sets the initial value of the integral function. If the <m>order</m> of the integration is
				greater than one, one origin for each different integration step can be defined.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Initial Value For Integration" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the "t" specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="slopemapping" get="1" set="1" type="int" size="1">
			<digest>
				Slope Mapping
			</digest>
			<description>
				Sets the function to be used for slope mapping: either bach (default) or Max.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Slope Mapping" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.derive" />
		<seealso name="bach.expr" />
		<seealso name="bach.slot" />
		<seealso name="bach.reducefunction" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (bang/llll)">
			<description>
				Breakpoint function llll or sampling parameters.
				In auto mode, an <m>llll</m> in the first inlet is the breakpoint function to be integrated.
				In lambda mode, a flat <m>llll</m> contains an explicit sampling, whereas an <m>llll</m> in the form
				<b>[<m>domain_start</m> <m>domain_end</m>] <m>num_sampling_points</m></b> sets an uniform sampling.
			</description>
		</entry>
		<entry name ="Inlet 2 (number/llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is supposed to be the Y value of the function at the X point which has been sent out.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Integrated breakpoint function llll.
				The llll with the integrated breakpoint function, as a list of points, where each
				point is in the form <b>[<m>x</m> <m>y</m> 0]</b>. Notice that the slope is always 0, since the
				output function is always piecewise linear.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda Outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, domain X values are output one by one, and expect to be mapped to the corresponding Y values,
				to be plugged in the lambda inlet.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

</c74object>