<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.constraints" module="bach">

	<digest>
		Solve constraints satisfaction problems
	</digest>

	<description>
		Solves constraints satisfaction problems.
		The rules for the evaluation of each constraint must be provided in the object's lambda loop, each associated to a unique arbitrary name.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach objects</metadata>
		<metadata name="tag">bach llll</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Domains
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Associations
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				Lambda inlet: validity or score
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				If the strong solver is active, the expected value is 0 (or <m>reject</m>) or 1 (or no return value),
				meaning respectively that a given partial label violates one or more constraints, or is acceptable. <br />
				If the heuristic or hungry solver is active, the expected value is any integer, to be added to the score of the solution being currently examined,
				or the <m>reject</m> symbol, meaning that the solution is not acceptable.
				If no return value is provided, it will be considered a score of 1 by strong solver,
				a score of 0 by the heuristic and hungry solver. <br />
				If the strong or hungry solver is active and the <m>provisionals</m> attribute is on,
				the <m>getdomains</m> and <m>setdomains</m> message can be sent to the lambda inlet
				in response to the <m>provisional</m> message from the lambda outlet,
				and the <m>setdomains</m> message can be sent in response to the <m>domains</m> message.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Found solutions
			</digest>
			<description>
				Solutions are output as an llll whose sublists contain one solution each.
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Search advancement
			</digest>
			<description>
				With the deterministic search engine, the middle outlet returns the current search position in the problem tree, expressed in percentage.
				With the heuristic and hungry search engines, it returns the current achieved score. In both cases, the value is updated "live" during the search.
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				Lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, assignments of values to one or more variables of the problem are output from the lambda outlet,
				each preceded by the name of the relative constraint
				according to the constraint definitions received in the second inlet. <br />
				Immediately before any proposed assignment, the special keyword <m>vars</m> can be output if requested,
				followed by the indices of the variables associated to the next proposed assignment. <br />
				After the evaluation value for an assignment has been returned,
				the <m>provisional</m> message can be output, followed by a partial solution.
				After that, if requested through the <m>getdomains</m> message,
				the <m>domains</m> message can be output, followed by the current values taken by one or more domains. <br />
				For more details, please refer to the description of the <m>llll</m> method. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Perform last operation
			</digest>
			<description>
				In first inlet: return the solution for the most recently received domains and constraints. <br />
				<br /> N.B.: The object is not aware of changes you make in the lambda loop.
				If you change the lambda loop, you might want to re-input the most recent llll rather than just sending a <m>bang</m>.
			</description>
		</method>
		<method name="int">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				<o>bach.constraints</o> outputs from its lambda outlet combinations of values (partial labels, in techical jargon) to be evaluated,
				each with respect to one specific constraint.
				Each partial label is preceded by the name of the relevant constraint, so that the partial label itself can be routed to the appropriate part of the patch.
				The result of the evaluation is expected in the third inlet.
				The deterministic solver will consider a 0 or 1 respectively as "reject" or "accept".
				The heuristic solver will sum together all the values received for one solution, thus determining the solution's score.
				If no value is re-injected in the lambda inlet, the result of the evaluation will be considered to be 0 by the heuristic and hungry solvers,
				and 1 by the strong solver: this means that, in any case, the proposed assignation will be accepted.
				Notice that the <m>reject</m> keyword (see description of <m>anything</m>) is also accepted in place of a 0 by the strong solver.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Function depends on inlet
			</digest>
			<description>
				An llll in the first inlet sets the problem domains and starts the search.
				Each sublist of the domains llll is the domain for one variable of the problem. <br />
				An llll in the second inlet sets the associations between constraints and domains.
				Each sublist of the associations llll represents one constraint as follows:
				the first element of the sublist is the constraint name, which should be matched by a corresponding branch of the lambda loop;
				then one or more sublists follow, each containing the indices of the variables to which the given constraint applies
				(technically we are defining as many constraints as sublists);
				finally, one or more optional keywords can be specified: <m>low</m>, <m>vars</m>, <m>required</m>.
				If the <m>low</m> keyword is present, the constraint is considered a low-priority one:
				even if the solver is allowed changing the order of evaluation of the constraints
				(which in general is strongly suggested for efficiency reasons),
				low-priority constraints are always evaluated last.
				This can be useful in some exotic cases in which high-priority constraints set the evaluation criteria for low-priority ones.
				If the <m>vars</m> keyword is present,
				an llll containing the <m>vars</m> symbol followed by the indices of the concerned variables is output immediately before evaluating the constraint.
				This can be useful when the same constraint name applies to different variable sets,
				and the actual variable numbers define the evaluation rules.
				If the <m>required</m> keyword is present, the heuristic and hungry engines knows that the evaluation of this constraint
				can yield a <m>reject</m> result (see below), causing the proposed solution to be immediately discarded.
				It is advisable, although not mandatory, adding the <m>required</m> keyword to such constraints, as it will allow some specific search optimizations. <br />
				A single-element llll in the third inlet is treated as the return value from the lambda loop: <br />
				<o>bach.constraints</o> outputs from its lambda outlet combinations of values (partial labels, in techical jargon) to be evaluated,
				each with respect to one specific constraint.
				Each partial label is preceded by the name of the relevant constraint, so that the partial label itself can be routed to the appropriate part of the patch.
				The result of the evaluation is expected in the third inlet.
				It must be 0 or 1 (respectively "reject" or "accept") for the deterministic solver.
				For the heuristic and hungry solvers, all the results (which have to be integers) for one solution will be summed together to concour to the solution's score.
				If the <m>reject</m> keyword is received by the heuristic solver the proposed solution being currently evaluated is immediately rejected. <br />
				Moreover, if the <m>provisionals</m> attribute is set for the strong and hungry solvers, each time a partial solution is found
				(that is, each time all the variables evaluated so far have a set consistent assignments)
				it is output from the third outlet, preceded by the keyword <m>provisional</m>.
				In response to it, a <m>getdomains</m> or <m>setdomains</m> message can be sent to the lambda inlet. <br />
				The <m>getdomains</m> message, followed by a one or more variable indices, will cause the current domains corresponding to said indices
				to be output as sublists of an llll preceded by the <m>domains</m> keyword. At this point, a <m>setdomains</m> message can be sent to the lambda inlet. <br />
				The <m>setdomains</m> message allows to change "on the fly" the domain of one or more variable yet to be assigned.
				It is composed of the <m>setdomains</m> keyword, followed by one or more sublists, each of which is composed of an optional domain index (defaulting to 1 if not present),
				and one or more sublists each containing a domain to substitute the current one. The first sublist will replace the domain for the specified index,
				or the first domain if not specified; the second sublist will replace the domain for the following domain index; and so on.
				For example, the llll <m>setdomains ((a b c) (d e f))</m> will cause the first domain to be set to <m>a b c</m>, and the second to be set to <m>d e f</m>;
				the llll <m>setdomains (10 (g h i) (j k l))</m> will cause the tenth domain to be set to <m>g h i</m>, and the eleventh to be set to <m>j k l</m>;
				the llll <m>setdomains (4 (m n)) (8 (o p) (q))</m> will cause the fourth domain to be set to <m>m n</m>, the eighth to be set to <m>o p</m>,
				and the ninth to be set to <m>q</m>. This is not equivalent to assigning the variable, as its consistency with the problem rules has still to be checked.<br />
				Only domains of variables which have not been assigned yet will actually be replaced:
				if a domain is specified for an already assigned variable, it will be ignored.
				A history of all the domains assignment for a variable is maintained internally,
				so as to be able to retrieve a previously assigned domain in case of backtracking.
				Notice that the <m>setdomains</m> message can sent only once for each provisional output from the third outlet,
				in response to either the <m>provisional</m> or the <m>domains</m> message.
				The latter case is useful for the typical case of progressively filtering out elements of a domain.<br />
				As a final note, if the <m>provisionals</m> attribute is set, immediately after the <m>provisional</m> message is output from the lambda outlet,
				and the optional <m>getdomains</m> and <m>setdomains</m> are received,
				the current partial solution is output from the leftmost outlet as well, preceded by the <m>provisional</m> keyword.
				This allows viewing or processing otherwise said partial solution in the main or scheduler thread,
				even if the <m>parallel</m> attribute is on. <br />
				As a final note, the <m>provisionals</m> attribute for the heuristic solver has a different result:
				as the heuristic solver is not chronological, it does not output partial assignments,
				but rather global assignments that can still be improved.
				For the same reason, this does not happen through the lambda outlet, as it would not make sense to change the domains "on the fly",
				but only through the first outlet, with the syntax described above.
			</description>
		</method>
		<method name="stop">
			<arglist />
			<digest>
				Stop search
			</digest>
			<description>
				A <m>stop</m> message will cause the search to stop immediately.
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="engine" get="1" set="1" type="int" size="1">
			<digest>
				Engine
			</digest>
			<description>
				The <m>engine</m> attribute allows choosing which search engine will be used. <br />
				The strong engine, based upon a chronological backtracking algorithm,
				will look for solutions satisfying all the constraints of the problem.
				The fact that the engine is chronological is crucial:
				as variables are assigned one after another,
				it is possible to view their assignment and possibly change the domains of those yet to be assigned. <br />
				The heuristic engine, based upon a hill-climbing algorithm,
				will look for solutions achieving maximal score, the score being defined as the sum of the evaluation results for every constraint.
				Notice that "maximal score" doesn't necessarily mean "maximum score":
				the heuristic solver will try to find what it considers a good solution for the problem,
				but in most cases this might not be the best possible solution.
				The usefulness of the heuristic solver lies in the fact
				that in many occasions finding the best possible solution would require an enormous amount of time,
				whereas a reasonably good solution can be found quickly.
				It also happens that a "best possible solution" cannot actually be defined,
				but quality scores for different features of the solution can.
				On the other hand, by appropriately setting the <m>minscore</m> and <m>maxscore</m> attributes,
				the heuristic engine can be employed for solving deterministic problems:
				this can indeed be a very efficient approach for large problems. <br />
				The hungry engine adopts a somewhat hybrid approach:
				it builds chronologically a solution, but accepts scores in response to evaluations.
				Namely, it sorts the constraints so as to be able to process and assign the lowest-indexed variables first.
				Then, it evaluates the first constraint for every possible combination of assignments to the variables it concerns,
				and chooses the highest-scored assignment. After that, it repeats the process for the second constraint, and so on.
				As assignment can be rejected, it is possible that a constraint can not be satisfied by any possible assignment of its variables,
				because of the values taken by previously assigned variables are not compatible with it.
				In this case, the solver backtracks and picks the second-best solution for the previously assigned constraint.
				This can happen recursively, picking decreasingly well-scored assignments for the previous constraint,
				and going back to previously evaluated constraints, until an acceptable solution is found, or no solution is proved to exist.
				As such, it is a deterministic solver, which can be useful for large optimization problems
				in which each variable assigned is directly influenced mostly or solely by recent ones.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Engine" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="goalscore" get="1" set="1" type="atom" size="1">
			<digest>
				Goal Score
			</digest>
			<description>
				Heuristic solver only:
				as long as this score is not met, new solutions will be searched for within maxtime.
				Nonetheless, solution with a lower score will still be considered acceptable, and therefore returned.
				The value of the attribute can be any integer, or <m>&lt;none&gt;</m> (default). <br />
				N.B.: if no time limit is set and solutions with sufficient score are rare or non existing,
				<o>bach.constraints</o> can be stuck in an infinite loop.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Goal Score" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="maxscore" get="1" set="1" type="atom" size="1">
			<digest>
				Maximum Score
			</digest>
			<description>
				Heuristic solver only:
				when a solution whose score is greater or equal is found, it is output and no better solution is searched for.
				The value of the attribute can be any integer, or <m>&lt;none&gt;</m> (default). <br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Maximum Score" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="maxtime" get="1" set="1" type="int" size="1">
			<digest>
				Maximum Running Time
			</digest>
			<description>
				Stops the search after the specified time (in ms).
				The default is 60000; when set to 0 no time limit is defined.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Maximum Running Time" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="minscore" get="1" set="1" type="atom" size="1">
			<digest>
				Minimum Score
			</digest>
			<description>
				Heuristic solver only: minimum required score.
				Only solutions whose score is greater or equal will be returned.
				The value of the attribute can be any integer, or <m>&lt;none&gt;</m> (default). <br />
				N.B.: if no time limit is set and solutions with sufficient score are rare or non existing,
				<o>bach.constraints</o> can be stuck in an infinite loop.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Minimum Score" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="nodeconsistency" get="1" set="1" type="int" size="1">
			<digest>
				Node Consistency
			</digest>
			<description>
				Strong and hungry solvers: when set to 1 (as by default),
				node consistency is enforced before starting the backtracking search.
				This means that constraints affecting single variables are processed first,
				so as to reduce the domain sizes and optimize the search process.
				No provisionals are output during the node consistency enforcement,
				and for this reason it may be necessary to set the attribute to 0 in some situations, if the <m>provisionals</m> attribute is on.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Node Consistency" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message. To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format, e
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="parallel" get="1" set="1" type="int" size="1">
			<digest>
				Parallel
			</digest>
			<description>
				When set to 1, the search is performed in a separate thread.
				This means that the normal Max operation is not interrupted.
				The <m>parallel</m> attribute is highly experimental and can lead to serious problems,
				including data corruption and crashes.
				In general, it is essential that the lambda loop is not modified and the patch is not saved or closed
				as long as the search is going on. Such operations are more than likely to crash Max.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Parallel" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="provisionals" get="1" set="1" type="int" size="1">
			<digest>
				Output Provisional Solutions
			</digest>
			<description>
				Heuristic solver: <br />
				When set to 0, no provisional solutions are output during the search. <br />
				When set to 1, only provisional solutions that improve the score are output. <br />
				When set to 2, provisional solution with the same score as the previous ones are output. <br />
				Strong and hungry solvers: <br />
				Partial solutions are output from the third and first outlets when set to 1 or 2.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Output Provisional Solutions" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="random" get="1" set="1" type="int" size="1">
			<digest>
				Random
			</digest>
			<description>
				Deterministic and hungry solvers only:
				when set to 1 the domains are randomized.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Random" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
		<attribute name="solutions" get="1" set="1" type="int" size="1">
			<digest>
				Number of Solutions
			</digest>
			<description>
				Strong solver only: number of solutions to find.
				When set to 0, all the solutions are found.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Number of Solutions" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="sortconstraints" get="1" set="1" type="int" size="1">
			<digest>
				Sort Constraints
			</digest>
			<description>
				Strong and hungry solvers:
				When set to 1 (as by default), the constraints might not be evaluated in the order they are provided by the user,
				but according to a different ordering allowing the search to be performed more efficiently.
				If the <m>provisionals</m> attribute is on, this may interfere with the dynamic reassignment of domains.
				For this reason, it is generally advisable to set the attribute to 0 if the domains will be reassigned during the search.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Sort Constraints" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="onoff" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.comb" />
		<seealso name="bach.perm" />
		<seealso name="bach.cartesianprod" />
		<seealso name="03-Iterations" module="bach" type="tutorial" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				Domains.
			</description>
		</entry>
		<entry name ="Inlet 2 (llll)">
			<description>
				Associations.
			</description>
		</entry>
		<entry name ="Inlet 3 (int/llll)">
			<description>
				Lambda inlet: validity or score.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				If the strong solver is active, the expected value is 0 (or <m>reject</m>) or 1 (or no return value),
				meaning respectively that a given partial label violates one or more constraints, or is acceptable. <br />
				If the heuristic or hungry solver is active, the expected value is any integer, to be added to the score of the solution being currently examined,
				or the <m>reject</m> symbol, meaning that the solution is not acceptable.
				If no return value is provided, it will be considered a score of 1 by strong solver,
				a score of 0 by the heuristic and hungry solver. <br />
				If the strong or hungry solver is active and the <m>provisionals</m> attribute is on,
				the <m>getdomains</m> and <m>setdomains</m> message can be sent to the lambda inlet
				in response to the <m>provisional</m> message from the lambda outlet,
				and the <m>setdomains</m> message can be sent in response to the <m>domains</m> message.
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Found solutions.
				Solutions are output as an llll whose sublists contain one solution each.
			</description>
		</entry>
		<entry name ="Outlet 2 (int/float)">
			<description>
				Search advancement.
				With the deterministic search engine, the middle outlet returns the current search position in the problem tree, expressed in percentage.
				With the heuristic and hungry search engines, it returns the current achieved score. In both cases, the value is updated "live" during the search.
			</description>
		</entry>
		<entry name ="Outlet 3 (llll)">
			<description>
				Lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, assignments of values to one or more variables of the problem are output from the lambda outlet,
				each preceded by the name of the relative constraint
				according to the constraint definitions received in the second inlet. <br />
				Immediately before any proposed assignment, the special keyword <m>vars</m> can be output if requested,
				followed by the indices of the variables associated to the next proposed assignment. <br />
				After the evaluation value for an assignment has been returned,
				the <m>provisional</m> message can be output, followed by a partial solution.
				After that, if requested through the <m>getdomains</m> message,
				the <m>domains</m> message can be output, followed by the current values taken by one or more domains. <br />
				For more details, please refer to the description of the <m>llll</m> method. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
			</description>
		</entry>
	</misc>

</c74object>