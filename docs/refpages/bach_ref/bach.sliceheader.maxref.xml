<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.sliceheader" module="bach" kind="patcher">

	<digest>
		Separate header and body of a gathered syntax
	</digest>

	<description>
		Takes the gathered syntax of a notation object and separates the
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach abstractions</metadata>
		<metadata name="tag">bach notation</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				The llll containing the gathered syntax of the notation object
			</digest>
			<description>
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				The llll containing the header of the notation object (and routing symbol, if any)
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				The llll containing the body of the notation object
			</digest>
			<description>
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Separate header and body
			</digest>
			<description>
				Separates header and body of the most recently received input llll.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Separate header and body of gathered syntax
			</digest>
			<description>
				An llll in the first inlet is considered as the
				gathered syntax of a notation object: its header and body parts are separated, and output
				respectively from the first and second outlets (in right-to-left order, as usual).
				The header part also incorporates the notation object routing symbol (such as <b>roll</b> or
				<b>score</b>), which is a slight abuse, since strictly speaking it is not part of the header.
				<br /> <br />
				The gathered syntax of any notation object is in the form <b><m>notation_object_name</m> <m>HEADER</m> <m>BODY</m></b>, where
				where the first symbol is optional as input (but always given as output) and identifies the notation object
				(e.g.: <b>roll</b> or <b>score</b>). The <m>HEADER</m> is an llll containing all the
				meta-information about the object (such as key signatures, clefs, markers...), while <m>BODY</m> is the llll
				containing the actual content of the notation object (i.e. the content of each voice, or measure, or chord,
				or note: the form varies depending on the notation object). <br /> <br />
				The header contains meta-information about the score. Such information is given in the form <b>[<m>HEADER_LLLL1</m> <m>HEADER_LLLL2</m>...]</b>
				where each <m>HEADER_LLLL</m> is in the form <b>[<m>header_element_name</m> <m>CONTENT</m>]</b>. The complete list of header element names
				and the expected content is the following one: <br />
				– <b>clefs</b>: introduces the used clefs; one clef symbol for each voice is expected. The number of voices is automatically
				updated to the number of clef symbols inserted.
				Since clefs can be set both as header element and as attribute, also see the <m>clefs</m> attribute.
				Each clef symbol can be one of the following: "G", "F", "FG", "FGG", "FFG", "FFGG", "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb",
				"Soprano", "Mezzo", "Alto", "Tenor", "Soprano", "Mezzo", "Tenor", "Alto", "Barytone", "Percussion", "None". <br />
				Clefs such as "FGG" correspond to multiple-staff voices: for instance, in this case, we have a standard piano staff ("FG") with an additional
				G clef superposed (transposed a 15ma above). The "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb" symbols correspond to
				octave-transposed clefs. For instance, "G8va" is the G clef, transposed one octave above, whereas "F15mb" is the F clef transposed two octaves below.
				<br /> <br />
				– <b>keys</b>: introduces the used key signatures; one key signature symbol for each voice is expected. If less are given, last one is padded.
				Since key signatures can be set both as header element and as attribute, also see the <m>keys</m> attribute.
				The syntax for the single key signature must be an unique symbol (no spaces) with:
				<b><m>notename</m>-<m>optional:accidental</m>-<m>optional:mode</m></b>.
				Dashes are only set in order to separate parts of the symbol, but must not be included in the symbol. <br /> <br />
				Note names are allowed both in anglo-saxon (C, D, E...) and in latin (Do, Re, Mi) format. In both ways,
				they are case insensitive ("c" or "C", "do" or "DO" is the same). <br /> <br />
				Accidentals are defined as string of ASCII characters, each identifying one accidental.
				The list of allowed characters is the following one: <br />
				"n" = natural <br />
				"#" = sharp (+1/2 tone) <br />
				"x" = double sharp (+ 1 tone) <br />
				"+" = monesis = quarter sharp (+1/4 tone) <br />
				"^" = +1/8 tone <br />
				"b" = flat (-1/2 tone) <br />
				"d" or "-" = mobemol = quarter flat (-1/4 tone) <br />
				"v" = -1/8 tone <br />
				If no accidental is defined, the natural is used by default.
				<br /> <br />
				The mode can be either "M" (major) or "m" minor. If no mode is defined, the major is used by default.
				<br /> <br />
				– <b>voicenames</b>: introduces the voice names specification, one name (atom) for each voice is expected.
				If a voice have more than one name, an llll with the list of names must be introduced. To skip names for a voice use <b>nil</b> or <b>[]</b>.
				Since voice names can be set both as header element and as attribute, also see the <m>voicenames</m> attribute.
				<br /> <br />
				– <b>midichannels</b>: introduces the MIDI channels specification, one integer for each voice is expected.
				Since MIDI channels can be set both as header element and as attribute, also see the <m>midichannels</m> attribute.
				<br /> <br />
				– <b>stafflines</b>: set the staff lines configurations. A list of elements (one for each voice) is expected. Since staff lines can be set both as header element and
				as attribute, also see the <m>stafflines</m> attribute. Each element can be in one of the following forms:
				either <b><m>number_of_stafflines</m></b>, setting the number of stafflines for the voice, which will be distributed evenly around
				the middle line of the default staff, or a wrapped llll in the form <b>[<m>index_staff_line1</m> <m>index_staff_line2</m>...]</b>
				where each index is the position of a line to be drawn. Line 1 correspond to the bottommost staffline of a standard staff;
				line 5 correspond to the topmost staffline of a standard staff. Integers need not be positive: indices like -2 or 7 will be
				extrapolated from the standard staff. The total number of lines is thus the length of such llll.
				<br /> <br />
				– <b>markers</b>: specifies the markers. A list of elements (one for each marker) is expected. For <o>bach.roll</o> markers, or for
				<o>bach.score</o> markers attached to milliseconds position, each element
				must be in the form <b>[<m>position_ms</m> <m>marker_name[s]</m> <m>role</m> <m>content</m>]</b> where the two last parameters
				are optional and only supported by <o>bach.roll</o> (ignore them in <o>bach.score</o>). The <m>position_ms</m> is a floating number
				specifying the marker position in milliseconds; the <m>marker_name(s)</m> is either a single symbol, or a wrapped llll, or
				<b>nil</b> or <b>[]</b> if marker has no name. For <o>bach.score</o> measure-attached markers the syntax is: <b>[<m>TIMEPOINT</m> <m>marker_name[s]</m>]</b>
				where <m>TIMEPOINT</m> identifies a time point.
				A timepoint represents a given instant inside <o>bach.score</o>, as a measure-attached position.
				It identifies such point according to a measure, a position inside such measure,
				and possibly a voice (in case tempi and time signatures are not synchronous for all voices).
				Differently from absolute millisecond positions,
				timepoints are represented by lllls, in one of the following syntaxes: <br />
				- <b>[<m>measure_number</m>]</b>: represents the point is at the beginning of the measure identified by the introduced measure number, in the first voice.
				For instance, <b>[4]</b> represents the point at the very beginning of measure 4, voice 1. <br />
				- <b>[<m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number (in the first voice),
				but not necessarily at the beginning, rather at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
				For instance, <b>[4 1/4]</b> represents the point at measure 4, voice 1, after 1/4 from the beginning of the measure. <br />
				- <b>[<m>voice_number</m> <m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number,
				in the voice identified, by the introduced voice number, at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
				For instance, <b>[2 4 1/4]</b> represents the point at measure 4, voice 2, after 1/4 from the beginning of the measure. Specifying voice numbers explicitly is especially
				important if voices don't have the same tempi or time signatures.
				<br />
				A timepoint can also  be specified via a <b>[<m>float_measure_number</m>]</b>, representing the point in a floating
				point position between two measures (referred to the first voice). For instance, <b>[4.2]</b> represents the point at the 20% of measure 4, voice 1.
				Furthermore, the <m>sym_onset_in_measure</m> can be replaced by a float between 0 and 1 to represent a point between the beginning (0) and the end
				of the measure (1); for instance <b>[1 4 0.2]</b> represents the point after 20% of measure 4, voice 1.
				<br />
				If the measure number is replaced by the <b>any</b> symbol, then the following rational is interpreted as a global symbolic onset inside the score.
				For instance, <b>[any 27/4]</b> represents the point at 27/4 after the beginning of the score, referred to the measureinfo of voice 1;
				<b>[3 any 27/4]</b> does the same for voice 3.
				<br /> <br />
				– <b>slotinfo</b>: specifies the information about the types and the global characteristics of each slot.
				The general syntax for a slotinfo llll in a notation object header is: <b>[slotinfo [<m>slot_num1</m> <m>SPECIFICATIONS1</m>] [<m>slot_num2</m> <m>SPECIFICATIONS2</m>]...]</b>,
				where the <m>slot_num</m> are the slot numbers (1 to 30), followed by their corresponding slotinfo specification. You don't need to give the information about all slots
				at input (only the one that you will use), nor the slot numbers have to be sorted in any way. On the other hand, at output, the slotinfo
				is always output for all slots, sorted in ascending order.
				Each <m>SPECIFICATIONS</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
				each <m>parameter</m> is a symbol followed by some content specifying a field of the slotinfo.
				The complete list of parameters symbols and their corresponding expected content is the following one: <br />
				– <b>name</b>: expects the name you want to give to the slot (given as a unique symbol). <br />
				– <b>type</b>: expects one of the following symbols, defining the slot type: "function", "int", "float", "intlist", "floatlist", "text",
				"filelist", "llll", "spat", "togglematrix", "intmatrix", "floatmatrix", "filter, "dynfilter", "color", "3dfunction",
				"articulations", "notehead, "dynamics", "none".  <br />
				- <b>access</b>: sets the slot accessibility, and expects a symbol. Default is "readandwrite" (slot is readable and writable);
				you can also use "readonly" (slot is only readable, not writable via interface), or "none" (slot window can't even be opened, slot
				content cannot be accessed).<br />
				- <b>temporalmode</b>: sets whether the slot contains temporal information, and if so in which form.
				It expects one of the following symbols: "none" (the information is not temporal), "relative" (the information is temporal, and the X value
				of each slot item is a relative position inside the note duration, usually between 0 and 1), "milliseconds" (the information is temporal, and the X
				value of each slot item is defined as a position milliseconds with respect to the note onset). <br />
				- <b>extend</b>: toggles the ability for temporal slots to extend their content beyond the end of each corresponding note (might be also useful,
				in combination with the "milliseconds" temporalmode, in order to define continuous parameters, independently from a note duration). <br />
				– <b>range</b>: followed by two numbers, sets the minimum and maximum values the slot range (vertical axis for function and 3dfunction slots, or number
				range for number slots) may assume. <br />
				– <b>key</b>: expects the character or the ASCII value of a key to be mapped as a hotkey for the slot. <br />
				– <b>slope</b>: expects a parameter (-1 to 1, 0 = linear) to exponentially represent the displayed range values of the slot. <br />
				– <b>width</b>: expects a value determining the width of the slot window (scaled according to the object's vertical zoom). <br />
				– <b>height</b>: a value determining the height of the slot window (scaled according to the object's vertical zoom). You can also put "auto"
				if you want to leave an automatically calculated height (default). <br />
				– <b>ysnap</b>: sets, for function or 3dfunction slots, some privileged Y points to which the points will be snapped
				upon Shift+Alt+mousedrag. <br />
				– <b>zsnap</b>: sets, for 3function slots, some privileged Z points to which the points will be snapped
				upon Shift+Ctrl+Alt+mousedrag (mac). <br />
				– <b>domain</b>: followed by two numbers, for function and 3dfunction slots, replaces the standard 0 to 1 domain with any input domain (input numbers
				are minimum and maximum). <br />
				– <b>domainslope</b>: a slope (-1 to 1, 0 = linear) to exponentially rescale the domain display. <br />
				– <b>default</b>: a numeric value (for numeric slots) determining the slot default value. <br />
				– <b>representation</b>: it could expect one of the following things. 1: Symbols defining units of measurement (e.g. "Hz", "ms"...), for numeric
				slots one symbol is expected, for function slots if one symbol is given, it is applied to the Y axis, if two symbols are given they are
				applied to the X and Y axis, for 3dfunction slots up to three symbols can be given, the third one referring to the Z axis, use <b>nil</b> or
				<b>[]</b> to skip assignment for an axis. For filter and dynfilter slots, you can assign "Hz" or "cents" as unit of measurement
				and it will be used to display the cutoff frequency accordingly. 2: An enumeration list (only for int
				and intlist slots), mapping each integer to an element of this enumeration list (e.g. in an int slot from 1 to 3, a
				slot_representation "(one two three)" will display "one" at the place of 1, "two" at the place of 2, "three" at the place of 3).
				These symbols will never be output upon dump or play, they will be just displayed. 3:
				For matrix-typed slots, it can be either a llll containing the number of rows and columns, such as (3 4), or a llll containing
				the names of the rows and columns, such as ((or fee foo) (col1 col2 col3)). To give units to different axes, just list them, such as: Hz dB.
				– <b>zrange</b>: as "range", but for the Z spatial dimension (used by the 3dfunction slot: the Z dimension is the one "coming out" from the screen). <br />
				– <b>zslope</b>: as "slope", but for the Z spatial dimention (used by the 3dfunction slot). <br />
				– <b>singleslotfortiednotes</b>: (for bach.score only) tells whether tied sequences of notes have just one slot, the one corresponding
				to the first note of the sequence. <br />
				– <b>copywhensplit</b>: tells whether this slot should be copied when a note is split into a sequence of multiple notes (e.g. via quantization). <br />
				- <b>follownotehead</b>: forces to automatically modify the value of the slot depending on the notehead trimming (useful if the slot
				value is something associated to the notehead, such as the starting point for reading a sample).<br />
				<br />
				You are not obliged to input all the fields: you can give as input only the required fields.
				Also at output, only the needed fields are given (e.g. the "zrange" is only output for 3dfunction slots, and so on).
				Setting an individual field for a given will not change any other field, unless the type is changed, in which case
				a conversion on all the slots is performed (if possible, i.e. if slots are compatible) otherwise the slot data of the given slot is lost.
				While converting slots, also some other fields may be changed to default values for the new slot type. <br />
				Some more fields can be set via the slotinfo. These fields are never retrieved when the slotinfo is queried via a
				<m>dump</m> message, since they correspond to standard attribute values of the notation object: <br />
				- <b>background</b>: this should be set to 1 if one needs the slot to be constantly painted in the background or 0 otherwise.
				This information is constantly synchronized with the <m>bgslots</m> attribute. <br />
				- <b>popup</b> (except bach.slot): this should be set to 1 if one needs the slot to show up in the note+popup+menu, or to 0 otherwise.
				This information is constantly synchronized with the <m>popupmenuslots</m> attribute. <br />
				- <b>rightclick</b> (except bach.slot): this should be set to 1 if one wants that the right click (or two-fingers tap) on a note head directly
				pops up the slot window of the current slot, or to 0 otherwise.
				This information is constantly synchronized with the <m>rightclickslot</m> attribute. <br />
				- <b>linkto</b> (except bach.slot): this field defines the possible slot linkage. Slot linkage is a way to entangle some notation or
				display features to the content of a given slot. You can specify here to which feature the slot should be linked,
				via one of the following symbols: "none", "lyrics", "color", "noteheadadjust", "noteheadchar", "noteheadfont", "notesize". <br />
				<br />
				– <b>commands</b>: specifies the information about the commands. A list of elements (one for each command) is expected.
				The general syntax for an llll defining commands in a notation object header is:
				<b>[commands [<m>command_num1</m> <m>SPECIFICATIONS1</m>] [<m>command_num2</m> <m>SPECIFICATIONS2</m>]...]</b>
				where the <m>command_num1</m> are the command numbers (1 to 30), followed by their corresponding command specification. You don't need to give the information about all slots
				at input (only the one that you will use), nor the command numbers have to be sorted in any way. On the other hand, at output, the commands
				are always output for all commands, sorted in ascending order.
				Each <m>SPECIFICATIONS</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
				each <m>parameter</m> is a symbol followed by some content specifying a field of the commands.
				The list of parameters symbols and their corresponding expected content is the following one: <br />
				– <b>note</b>: expects the symbol which will replace the "note" symbol in the playout (given as a unique symbol). <br />
				– <b>chord</b>: expects the symbol which will replace the "chord" symbol in the playout (given as a unique symbol). <br />
				– <b>rest</b>: expects the symbol which will replace the "rest" symbol in the playout (given as a unique symbol). <br />
				– <b>key</b>: expects the character or the ASCII value of a key to be mapped as a hotkey for the slot. <br />
				<br /> <br />
				– <b>groups</b>: (<o>bach.roll</o> only) specifies the information about the grouped chords.
				Although bach.roll syntax, as everything in bach, is transparent (and you are thus allowed to modify any element),
				there are extremely few cases where you might need to set manually the group information in llll form.
				Usually, such information is only dealt with via the interface (i.e. by grouping and ungrouping things),
				and the group header element is only a way to embed or save such information with the object.
				Nevertheless, nothing in principle prevents you from setting groups via message. The syntax is the following one:
				<b>[groups <m>GROUP1</m> <m>GROUP2</m>...]</b>, where each <m>GROUP</m> is an llll having the syntax
				<b>[<m>ADDRESS_CHORD1</m> <m>ADDRESS_CHORD2</m> <m>ADDRESS_CHORD3</m>...]</b>, where each address llll identifies one of the
				chord inside the groups, via the following syntax: <b>[<m>voice_number</m> <m>chord_index</m>]</b>,
				where the chord index is the position of the chord inside the sequence of chords of the voice (ordered by onsets).
				– <b>articulationinfo</b>: specifies the information about custom defined articulation.
				The general syntax for the articulationinfo llll in a notation object header is: <b>[articulationinfo <m>CUSTOMARTICULATION1</m> <m>CUSTOMARTICULATION2</m>...]</b>.
				Each <m>CUSTOMARTICULATION</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
				each <m>parameter</m> is some propriety of the custom articulation to be defined, followed by its value.
				The complete list of parameters symbols and their corresponding expected content is the following one: <br />
				– <b>fullname</b>: a symbol defining the articulation full name (e.g. "myfermata"). <br />
				– <b>shortname</b>: a symbol defining the articulation short name (e.g. "myf"). <br />
				– <b>alias</b>: up to 5 other names which will be mapped on the articulation when found in articulation slots. <br />
				– <b>font</b>: a symbol containing the font name, or "default" (in order to use the defined "articulationsfont"). <br />
				– <b>basept</b>: the basic font size (corresponding to a no-vzoom situation). <br />
				– <b>position</b>: one of the following symbols: "abovenote", "belownote", "noteside", "stemsidenearnotehead", "stemsidenearflag", "manual", determining the position of the articulation. <br />
				– <b>position</b>: one of the following symbols: "abovenote", "belownote", "noteside", "stemsidenearnotehead", "stemsidenearflag", "manual", determining the position of the articulation. <br />
				<br />
				The following specifications determine the characters used:
				– <b>mainchar</b>: symbol or unicode value determining the main articulation character (above notes). <br />
				– <b>flippedchar</b>: symbol or unicode value determining the flipped articulation character (below notes). <br />
				– <b>extchar</b>: symbol or unicode value of the articulation extension, if any (e.g.: the tilde in a trill line). <br />
				<br />
				The following specifications will refer to unzoomed situations, and will be scaled according to the zoom:
				– <b>mainxshift</b>, <b>mainyshift</b>: x and y shift of positioning for the main character (positive y shift moves up). <br />
				– <b>flippedxshift</b>, <b>flippedyshift</b>: x and y shift of positioning for the flipped character. <br />
				– <b>mainheight</b>, <b>flippedheight</b>: height of the main and flipped characters. <br />
				– <b>mainycenter</b>, <b>flippedycenter</b>: position of the vertical center of the articulation for main and flipped char. <br />
				– <b>outsidestaffynudge</b>: additional y shift to push articulation farther from staff. <br />
				– <b>extyshift</b>: horizontal offset for the beginning of the articulation extensions. <br />
				<br />
				The following specifications will set the markings used when exporting articulations to MusicXML format:
				– <b>xmlornament</b>: text to be exported as MusicXML ornament whenever the articulation is found, or "none" if no export needed (default). <br />
				– <b>xmltechnical</b>: text to be exported as MusicXML technical tag whenever the articulation is found,
				or "none" if no export needed (default), or "custom" if export must be of "other-technical" type, defining a custom technical tag.<br />
				– <b>xmlarticulations</b>: text to be exported as MusicXML articulation tag whenever the articulation is found,
				or "none" if no export needed (default), or "custom" if export must be of "other-articulation" type, defining a custom articulation tag.<br />
				<br />
				Finally, one can assign an option specification, possibly followed by a list of symbols, to set some flags.
				Symbols must be among the following ones:<br />
				· <b>avoidlines</b>: avoid staff lines.<br />
				· <b>outsidestaff</b>: always place outside staff.<br />
				· <b>centerovernote</b>: center over the notehead.<br />
				· <b>centeroverstem</b>: center over the stem.<br />
				· <b>spanties</b>: articulation extension spans sequences of tied notes.<br />
				· copywhencloned: copy articulation while copying notes.<br />
				· copywhenclonedtosamechord: copy articulation while copying notes, and also when copying notes into the same chord.<br />
				· copywhensplit: copy articulation to all notes when notes are split, or retranscribed as tied sequences.<br />
				· shiftwithbeams: shift vertically according to beams.<br />
				<br />
				– <b>noteheadinfo</b>: specifies the information about custom defined noteheads.
				The general syntax for the articulationinfo llll in a notation object header is: <b>[articulationinfo <m>CUSTOMNOTEHEAD1</m> <m>CUSTOMNOTEHEAD2</m>...]</b>.
				Each <m>CUSTOMNOTEHEAD</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
				each <m>parameter</m> is some propriety of the custom notehead to be defined, followed by its value.
				The complete list of parameters symbols and their corresponding expected content is the following one: <br />
				– <b>fullname</b>: a symbol defining the articulation full name (e.g. "curly").<br />
				– <b>shortname</b>: a symbol defining the articulation short name (e.g. "cr").<br />
				– <b>alias</b>: up to 5 other names which will be mapped on the articulation when found in articulation slots.<br />
				– <b>font</b>: a symbol containing the font name, or "default" (in order to use the defined "notationfont").<br />
				– <b>basept</b>: the basic font size (corresponding to a no-vzoom situation).<br />
				– <b>char</b>: symbol or unicode value determining the notehead character. If two values are input, they refer respectively to the "black" and "white" flavours
				(assigned <o>bach.score</o> to black and white notes). If three values are input, they refer respectively to "black", "white" and "whole note" flavours.
				If four values are input they refer respectively to "black", "white", "whole note" and "double whole note". <br />
				<br />
				The following specifications will refer to unzoomed situations, and will be scaled according to the zoom: <br />
				– <b>xshift</b>: horizontal shift (positive values move right). <br />
				– <b>yshift</b>: vertical shift (positive values move up). <br />
				– <b>width</b>: the width of the notehead. <br />
				– <b>xshiftsmall</b>: same as xshift, but for grace notes. <br />
				– <b>yshiftsmall</b>: same as yshift, but for grace notes. <br />
				– <b>dlstartxshift</b>: horizontal offset for the beginning of the duration line. <br />
				<br />
				– <b>numparts</b>: specifies the information about the part assignment (see <m>numparts</m> attribute).
				– <b>loop</b>: specifies the information about the loop, as for the <m>loop</m> attribute, as a starting and ending point (in milliseconds, or as timepoints).
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the "t" specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		The gathered syntax of any notation object is in the form <b><m>notation_object_name</m> <m>HEADER</m> <m>BODY</m></b>, where
		where the first symbol is optional as input (but always given as output) and identifies the notation object
		(e.g.: <b>roll</b> or <b>score</b>). The <m>HEADER</m> is an llll containing all the
		meta-information about the object (such as key signatures, clefs, markers...), while <m>BODY</m> is the llll
		containing the actual content of the notation object (i.e. the content of each voice, or measure, or chord,
		or note: the form varies depending on the notation object). <br /> <br />
		The header contains meta-information about the score. Such information is given in the form <b>[<m>HEADER_LLLL1</m> <m>HEADER_LLLL2</m>...]</b>
		where each <m>HEADER_LLLL</m> is in the form <b>[<m>header_element_name</m> <m>CONTENT</m>]</b>. The complete list of header element names
		and the expected content is the following one: <br />
		– <b>clefs</b>: introduces the used clefs; one clef symbol for each voice is expected. The number of voices is automatically
		updated to the number of clef symbols inserted.
		Since clefs can be set both as header element and as attribute, also see the <m>clefs</m> attribute.
		Each clef symbol can be one of the following: "G", "F", "FG", "FGG", "FFG", "FFGG", "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb",
		"Soprano", "Mezzo", "Alto", "Tenor", "Soprano", "Mezzo", "Tenor", "Alto", "Barytone", "Percussion", "None". <br />
		Clefs such as "FGG" correspond to multiple-staff voices: for instance, in this case, we have a standard piano staff ("FG") with an additional
		G clef superposed (transposed a 15ma above). The "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb" symbols correspond to
		octave-transposed clefs. For instance, "G8va" is the G clef, transposed one octave above, whereas "F15mb" is the F clef transposed two octaves below.
		<br /> <br />
		– <b>keys</b>: introduces the used key signatures; one key signature symbol for each voice is expected. If less are given, last one is padded.
		Since key signatures can be set both as header element and as attribute, also see the <m>keys</m> attribute.
		The syntax for the single key signature must be an unique symbol (no spaces) with:
		<b><m>notename</m>-<m>optional:accidental</m>-<m>optional:mode</m></b>.
		Dashes are only set in order to separate parts of the symbol, but must not be included in the symbol. <br /> <br />
		Note names are allowed both in anglo-saxon (C, D, E...) and in latin (Do, Re, Mi) format. In both ways,
		they are case insensitive ("c" or "C", "do" or "DO" is the same). <br /> <br />
		Accidentals are defined as string of ASCII characters, each identifying one accidental.
		The list of allowed characters is the following one: <br />
		"n" = natural <br />
		"#" = sharp (+1/2 tone) <br />
		"x" = double sharp (+ 1 tone) <br />
		"+" = monesis = quarter sharp (+1/4 tone) <br />
		"^" = +1/8 tone <br />
		"b" = flat (-1/2 tone) <br />
		"d" or "-" = mobemol = quarter flat (-1/4 tone) <br />
		"v" = -1/8 tone <br />
		If no accidental is defined, the natural is used by default.
		<br /> <br />
		The mode can be either "M" (major) or "m" minor. If no mode is defined, the major is used by default.
		<br /> <br />
		– <b>voicenames</b>: introduces the voice names specification, one name (atom) for each voice is expected.
		If a voice have more than one name, an llll with the list of names must be introduced. To skip names for a voice use <b>nil</b> or <b>[]</b>.
		Since voice names can be set both as header element and as attribute, also see the <m>voicenames</m> attribute.
		<br /> <br />
		– <b>midichannels</b>: introduces the MIDI channels specification, one integer for each voice is expected.
		Since MIDI channels can be set both as header element and as attribute, also see the <m>midichannels</m> attribute.
		<br /> <br />
		– <b>stafflines</b>: set the staff lines configurations. A list of elements (one for each voice) is expected. Since staff lines can be set both as header element and
		as attribute, also see the <m>stafflines</m> attribute. Each element can be in one of the following forms:
		either <b><m>number_of_stafflines</m></b>, setting the number of stafflines for the voice, which will be distributed evenly around
		the middle line of the default staff, or a wrapped llll in the form <b>[<m>index_staff_line1</m> <m>index_staff_line2</m>...]</b>
		where each index is the position of a line to be drawn. Line 1 correspond to the bottommost staffline of a standard staff;
		line 5 correspond to the topmost staffline of a standard staff. Integers need not be positive: indices like -2 or 7 will be
		extrapolated from the standard staff. The total number of lines is thus the length of such llll.
		<br /> <br />
		– <b>markers</b>: specifies the markers. A list of elements (one for each marker) is expected. For <o>bach.roll</o> markers, or for
		<o>bach.score</o> markers attached to milliseconds position, each element
		must be in the form <b>[<m>position_ms</m> <m>marker_name[s]</m> <m>role</m> <m>content</m>]</b> where the two last parameters
		are optional and only supported by <o>bach.roll</o> (ignore them in <o>bach.score</o>). The <m>position_ms</m> is a floating number
		specifying the marker position in milliseconds; the <m>marker_name(s)</m> is either a single symbol, or a wrapped llll, or
		<b>nil</b> or <b>[]</b> if marker has no name. For <o>bach.score</o> measure-attached markers the syntax is: <b>[<m>TIMEPOINT</m> <m>marker_name[s]</m>]</b>
		where <m>TIMEPOINT</m> identifies a time point.
		A timepoint represents a given instant inside <o>bach.score</o>, as a measure-attached position.
		It identifies such point according to a measure, a position inside such measure,
		and possibly a voice (in case tempi and time signatures are not synchronous for all voices).
		Differently from absolute millisecond positions,
		timepoints are represented by lllls, in one of the following syntaxes: <br />
		- <b>[<m>measure_number</m>]</b>: represents the point is at the beginning of the measure identified by the introduced measure number, in the first voice.
		For instance, <b>[4]</b> represents the point at the very beginning of measure 4, voice 1. <br />
		- <b>[<m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number (in the first voice),
		but not necessarily at the beginning, rather at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
		For instance, <b>[4 1/4]</b> represents the point at measure 4, voice 1, after 1/4 from the beginning of the measure. <br />
		- <b>[<m>voice_number</m> <m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number,
		in the voice identified, by the introduced voice number, at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
		For instance, <b>[2 4 1/4]</b> represents the point at measure 4, voice 2, after 1/4 from the beginning of the measure. Specifying voice numbers explicitly is especially
		important if voices don't have the same tempi or time signatures.
		<br />
		A timepoint can also  be specified via a <b>[<m>float_measure_number</m>]</b>, representing the point in a floating
		point position between two measures (referred to the first voice). For instance, <b>[4.2]</b> represents the point at the 20% of measure 4, voice 1.
		Furthermore, the <m>sym_onset_in_measure</m> can be replaced by a float between 0 and 1 to represent a point between the beginning (0) and the end
		of the measure (1); for instance <b>[1 4 0.2]</b> represents the point after 20% of measure 4, voice 1.
		<br />
		If the measure number is replaced by the <b>any</b> symbol, then the following rational is interpreted as a global symbolic onset inside the score.
		For instance, <b>[any 27/4]</b> represents the point at 27/4 after the beginning of the score, referred to the measureinfo of voice 1;
		<b>[3 any 27/4]</b> does the same for voice 3.
		<br /> <br />
		– <b>slotinfo</b>: specifies the information about the types and the global characteristics of each slot.
		The general syntax for a slotinfo llll in a notation object header is: <b>[slotinfo [<m>slot_num1</m> <m>SPECIFICATIONS1</m>] [<m>slot_num2</m> <m>SPECIFICATIONS2</m>]...]</b>,
		where the <m>slot_num</m> are the slot numbers (1 to 30), followed by their corresponding slotinfo specification. You don't need to give the information about all slots
		at input (only the one that you will use), nor the slot numbers have to be sorted in any way. On the other hand, at output, the slotinfo
		is always output for all slots, sorted in ascending order.
		Each <m>SPECIFICATIONS</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
		each <m>parameter</m> is a symbol followed by some content specifying a field of the slotinfo.
		The complete list of parameters symbols and their corresponding expected content is the following one: <br />
		– <b>name</b>: expects the name you want to give to the slot (given as a unique symbol). <br />
		– <b>type</b>: expects one of the following symbols, defining the slot type: "function", "int", "float", "intlist", "floatlist", "text",
		"filelist", "llll", "spat", "togglematrix", "intmatrix", "floatmatrix", "filter, "dynfilter", "color", "3dfunction",
		"articulations", "notehead, "dynamics", "none".  <br />
		- <b>access</b>: sets the slot accessibility, and expects a symbol. Default is "readandwrite" (slot is readable and writable);
		you can also use "readonly" (slot is only readable, not writable via interface), or "none" (slot window can't even be opened, slot
		content cannot be accessed).<br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.roll" />
		<seealso name="bach.score" />
		<seealso name="bach.slice" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				The llll containing the gathered syntax of the notation object.
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				The llll containing the header of the notation object (and routing symbol, if any).
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				The llll containing the body of the notation object.
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		The gathered syntax of any notation object is in the form <b><m>notation_object_name</m> <m>HEADER</m> <m>BODY</m></b>, where
		where the first symbol is optional as input (but always given as output) and identifies the notation object
		(e.g.: <b>roll</b> or <b>score</b>). The <m>HEADER</m> is an llll containing all the
		meta-information about the object (such as key signatures, clefs, markers...), while <m>BODY</m> is the llll
		containing the actual content of the notation object (i.e. the content of each voice, or measure, or chord,
		or note: the form varies depending on the notation object). <br /> <br />
		The header contains meta-information about the score. Such information is given in the form <b>[<m>HEADER_LLLL1</m> <m>HEADER_LLLL2</m>...]</b>
		where each <m>HEADER_LLLL</m> is in the form <b>[<m>header_element_name</m> <m>CONTENT</m>]</b>. The complete list of header element names
		and the expected content is the following one: <br />
		– <b>clefs</b>: introduces the used clefs; one clef symbol for each voice is expected. The number of voices is automatically
		updated to the number of clef symbols inserted.
		Since clefs can be set both as header element and as attribute, also see the <m>clefs</m> attribute.
		Each clef symbol can be one of the following: "G", "F", "FG", "FGG", "FFG", "FFGG", "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb",
		"Soprano", "Mezzo", "Alto", "Tenor", "Soprano", "Mezzo", "Tenor", "Alto", "Barytone", "Percussion", "None". <br />
		Clefs such as "FGG" correspond to multiple-staff voices: for instance, in this case, we have a standard piano staff ("FG") with an additional
		G clef superposed (transposed a 15ma above). The "G8va", "G15ma", "G8vb", "G15mb", "F8va", "F15ma", "F8vb", "F15mb" symbols correspond to
		octave-transposed clefs. For instance, "G8va" is the G clef, transposed one octave above, whereas "F15mb" is the F clef transposed two octaves below.
		<br /> <br />
		– <b>keys</b>: introduces the used key signatures; one key signature symbol for each voice is expected. If less are given, last one is padded.
		Since key signatures can be set both as header element and as attribute, also see the <m>keys</m> attribute.
		The syntax for the single key signature must be an unique symbol (no spaces) with:
		<b><m>notename</m>-<m>optional:accidental</m>-<m>optional:mode</m></b>.
		Dashes are only set in order to separate parts of the symbol, but must not be included in the symbol. <br /> <br />
		Note names are allowed both in anglo-saxon (C, D, E...) and in latin (Do, Re, Mi) format. In both ways,
		they are case insensitive ("c" or "C", "do" or "DO" is the same). <br /> <br />
		Accidentals are defined as string of ASCII characters, each identifying one accidental.
		The list of allowed characters is the following one: <br />
		"n" = natural <br />
		"#" = sharp (+1/2 tone) <br />
		"x" = double sharp (+ 1 tone) <br />
		"+" = monesis = quarter sharp (+1/4 tone) <br />
		"^" = +1/8 tone <br />
		"b" = flat (-1/2 tone) <br />
		"d" or "-" = mobemol = quarter flat (-1/4 tone) <br />
		"v" = -1/8 tone <br />
		If no accidental is defined, the natural is used by default.
		<br /> <br />
		The mode can be either "M" (major) or "m" minor. If no mode is defined, the major is used by default.
		<br /> <br />
		– <b>voicenames</b>: introduces the voice names specification, one name (atom) for each voice is expected.
		If a voice have more than one name, an llll with the list of names must be introduced. To skip names for a voice use <b>nil</b> or <b>[]</b>.
		Since voice names can be set both as header element and as attribute, also see the <m>voicenames</m> attribute.
		<br /> <br />
		– <b>midichannels</b>: introduces the MIDI channels specification, one integer for each voice is expected.
		Since MIDI channels can be set both as header element and as attribute, also see the <m>midichannels</m> attribute.
		<br /> <br />
		– <b>stafflines</b>: set the staff lines configurations. A list of elements (one for each voice) is expected. Since staff lines can be set both as header element and
		as attribute, also see the <m>stafflines</m> attribute. Each element can be in one of the following forms:
		either <b><m>number_of_stafflines</m></b>, setting the number of stafflines for the voice, which will be distributed evenly around
		the middle line of the default staff, or a wrapped llll in the form <b>[<m>index_staff_line1</m> <m>index_staff_line2</m>...]</b>
		where each index is the position of a line to be drawn. Line 1 correspond to the bottommost staffline of a standard staff;
		line 5 correspond to the topmost staffline of a standard staff. Integers need not be positive: indices like -2 or 7 will be
		extrapolated from the standard staff. The total number of lines is thus the length of such llll.
		<br /> <br />
		– <b>markers</b>: specifies the markers. A list of elements (one for each marker) is expected. For <o>bach.roll</o> markers, or for
		<o>bach.score</o> markers attached to milliseconds position, each element
		must be in the form <b>[<m>position_ms</m> <m>marker_name[s]</m> <m>role</m> <m>content</m>]</b> where the two last parameters
		are optional and only supported by <o>bach.roll</o> (ignore them in <o>bach.score</o>). The <m>position_ms</m> is a floating number
		specifying the marker position in milliseconds; the <m>marker_name(s)</m> is either a single symbol, or a wrapped llll, or
		<b>nil</b> or <b>[]</b> if marker has no name. For <o>bach.score</o> measure-attached markers the syntax is: <b>[<m>TIMEPOINT</m> <m>marker_name[s]</m>]</b>
		where <m>TIMEPOINT</m> identifies a time point.
		A timepoint represents a given instant inside <o>bach.score</o>, as a measure-attached position.
		It identifies such point according to a measure, a position inside such measure,
		and possibly a voice (in case tempi and time signatures are not synchronous for all voices).
		Differently from absolute millisecond positions,
		timepoints are represented by lllls, in one of the following syntaxes: <br />
		- <b>[<m>measure_number</m>]</b>: represents the point is at the beginning of the measure identified by the introduced measure number, in the first voice.
		For instance, <b>[4]</b> represents the point at the very beginning of measure 4, voice 1. <br />
		- <b>[<m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number (in the first voice),
		but not necessarily at the beginning, rather at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
		For instance, <b>[4 1/4]</b> represents the point at measure 4, voice 1, after 1/4 from the beginning of the measure. <br />
		- <b>[<m>voice_number</m> <m>measure_number</m> <m>sym_onset_in_measure</m>]</b>: represents the point inside the measure identified by the introduced measure number,
		in the voice identified, by the introduced voice number, at the generic position in measure identified by the symbolic onset <m>sym_onset_in_measure</m>.
		For instance, <b>[2 4 1/4]</b> represents the point at measure 4, voice 2, after 1/4 from the beginning of the measure. Specifying voice numbers explicitly is especially
		important if voices don't have the same tempi or time signatures.
		<br />
		A timepoint can also  be specified via a <b>[<m>float_measure_number</m>]</b>, representing the point in a floating
		point position between two measures (referred to the first voice). For instance, <b>[4.2]</b> represents the point at the 20% of measure 4, voice 1.
		Furthermore, the <m>sym_onset_in_measure</m> can be replaced by a float between 0 and 1 to represent a point between the beginning (0) and the end
		of the measure (1); for instance <b>[1 4 0.2]</b> represents the point after 20% of measure 4, voice 1.
		<br />
		If the measure number is replaced by the <b>any</b> symbol, then the following rational is interpreted as a global symbolic onset inside the score.
		For instance, <b>[any 27/4]</b> represents the point at 27/4 after the beginning of the score, referred to the measureinfo of voice 1;
		<b>[3 any 27/4]</b> does the same for voice 3.
		<br /> <br />
		– <b>slotinfo</b>: specifies the information about the types and the global characteristics of each slot.
		The general syntax for a slotinfo llll in a notation object header is: <b>[slotinfo [<m>slot_num1</m> <m>SPECIFICATIONS1</m>] [<m>slot_num2</m> <m>SPECIFICATIONS2</m>]...]</b>,
		where the <m>slot_num</m> are the slot numbers (1 to 30), followed by their corresponding slotinfo specification. You don't need to give the information about all slots
		at input (only the one that you will use), nor the slot numbers have to be sorted in any way. On the other hand, at output, the slotinfo
		is always output for all slots, sorted in ascending order.
		Each <m>SPECIFICATIONS</m> llll has the form <b>[<m>parameter1</m> <m>content1</m>] [<m>parameter2</m> <m>content2</m>]...</b>, where
		each <m>parameter</m> is a symbol followed by some content specifying a field of the slotinfo.
		The complete list of parameters symbols and their corresponding expected content is the following one: <br />
		– <b>name</b>: expects the name you want to give to the slot (given as a unique symbol). <br />
		– <b>type</b>: expects one of the following symbols, defining the slot type: "function", "int", "float", "intlist", "floatlist", "text",
		"filelist", "llll", "spat", "togglematrix", "intmatrix", "floatmatrix", "filter, "dynfilter", "color", "3dfunction",
		"articulations", "notehead, "dynamics", "none".  <br />
		- <b>access</b>: sets the slot accessibility, and expects a symbol. Default is "readandwrite" (slot is readable and writable);
		you can also use "readonly" (slot is only readable, not writable via interface), or "none" (slot window can't even be opened, slot
		content cannot be accessed).<br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
header, information, slice, separate, body, gathered syntax, content, split, retrieve.
			</description>
		</entry>
	</misc>

</c74object>